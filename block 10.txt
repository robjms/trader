

extension ExchangeWebSocket {
    @MainActor
    static var kucoinDailyLoss: Double = 0.0
    @MainActor
    static var bybitDailyLoss: Double = 0.0

    // Added missing validateAPICredentials function to fix Block 10 error
    static func validateAPICredentials() async -> Bool {
        let kucoinValid = environment["KUCOIN_API_KEY"] != nil &&
                         environment["KUCOIN_API_SECRET"] != nil &&
                         environment["KUCOIN_API_PASSPHRASE"] != nil
        let bybitValid = environment["BYBIT_API_KEY"] != nil &&
                        environment["BYBIT_API_SECRET"] != nil
        
        if kucoinValid && bybitValid {
            await MainActor.run {
                logAlert(event: "‚úÖ API credentials validated successfully")
            }
            return true
        } else {
            await MainActor.run {
                logAlert(event: "‚ùå API credentials validation failed")
            }
            return false
        }
    }

    // ENHANCED: Better WebSocket connection management for Bybit
    static func connectBybitWebSocket() {
        Task {
            await MainActor.run {
                logAlert(event: "üîµ Initiating Bybit WebSocket connection...")
                websocketReconnectAttempts["bybit"] = 0
                lastWebsocketActivity["bybit"] = Date()
            }
            
            guard let url = URL(string: "wss://stream.bybit.com/v5/public/spot") else {
                await MainActor.run {
                    logAlert(event: "üîµ ERROR: Invalid Bybit WebSocket URL")
                }
                return
            }
            
            var request = URLRequest(url: url)
            request.timeoutInterval = 30.0
            
            // Use Starscream WebSocket (matching Block 1 declaration)
            let webSocket = WebSocket(request: request)
            
            webSocket.onEvent = { event in
                Task { @MainActor in
                    switch event {
                    case .connected(let headers):
                        bybitWebSocket = webSocket
                        bybitIsConnected = true
                        logAlert(event: "üîµ ‚úÖ Bybit WebSocket connected successfully")
                        
                        Task {
                            await receiveBybitMessages()
                            await subscribeToBybitStreams()
                        }
                    case .disconnected(let reason, let code):
                        logAlert(event: "üîµ ERROR: Bybit WebSocket disconnected: \(reason) (\(code))")
                        Task { await reconnectBybitWebSocket() }
                    case .text(let string):
                        Task { await processBybitWebSocketMessage(message: string) }
                    case .error(let error):
                        logAlert(event: "üîµ ERROR: Bybit WebSocket error: \(error?.localizedDescription ?? "Unknown")")
                        Task { await reconnectBybitWebSocket() }
                    default:
                        break
                    }
                }
            }
            
            webSocket.connect()
        }
    }

    // ENHANCED: Connection timeout handling
    // ENHANCED: Bybit WebSocket reconnection with exponential backoff
    static func reconnectBybitWebSocket() {
        Task {
            let currentAttempts = await MainActor.run { websocketReconnectAttempts["bybit"] ?? 0 }
            let maxAttempts = 10
            
            guard currentAttempts < maxAttempts else {
                await MainActor.run {
                    logAlert(event: "üîµ ERROR: Max reconnection attempts reached for Bybit WebSocket")
                }
                return
            }
            
            await MainActor.run {
                websocketReconnectAttempts["bybit"] = currentAttempts + 1
                bybitIsConnected = false
                logAlert(event: "üîµ ‚ö†Ô∏è Attempting Bybit WebSocket reconnection (attempt \(currentAttempts + 1)/\(maxAttempts))")
            }
            
            // Exponential backoff: 2^attempt seconds (max 60 seconds)
            let delay = min(pow(2.0, Double(currentAttempts)), 60.0)
            try? await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
            
            // Attempt reconnection
            connectBybitWebSocket()
        }
    }

    // ENHANCED: Bybit WebSocket message processing with better error handling
    static func processBybitWebSocketMessage(message: String) async {
        do {
            guard let data = message.data(using: .utf8),
                  let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
                await MainActor.run {
                    logAlert(event: "üîµ ERROR: Failed to parse Bybit WebSocket message")
                }
                return
            }
            
            await MainActor.run {
                lastWebsocketActivity["bybit"] = Date()
            }
            
            // ENHANCED: Better topic handling
            if let topic = json["topic"] as? String {
                if topic.contains("tickers") {
                    await processTickerUpdate(exchange: "bybit", data: json)
                } else if topic.contains("orderbook") {
                    await processOrderBookUpdate(exchange: "bybit", data: json)
                } else if topic.contains("publicTrade") {
                    await processTradeUpdate(exchange: "bybit", data: json)
                }
            } else if let op = json["op"] as? String {
                if op == "pong" {
                    await MainActor.run {
                        logAlert(event: "üîµ Bybit WebSocket heartbeat received")
                    }
                }
            }
        } catch {
            await MainActor.run {
                logAlert(event: "üîµ ERROR: Bybit WebSocket message processing error: \(error.localizedDescription)")
            }
        }
    }

    // ENHANCED: Order book update processing with validation
    static func processOrderBookUpdate(exchange: String, data: [String: Any]) async {
        guard let topic = data["topic"] as? String,
              let dataPayload = data["data"] as? [String: Any] else {
            await MainActor.run {
                logAlert(event: "üîµ ERROR: Invalid order book update format from \(exchange)")
            }
            return
        }
        
        // Extract symbol from topic
        let symbol = extractSymbolFromTopic(topic: topic, exchange: exchange)
        guard !symbol.isEmpty else {
            await MainActor.run {
                logAlert(event: "üîµ ERROR: Could not extract symbol from topic: \(topic)")
            }
            return
        }
        
        // ENHANCED: Validate order book data quality
        let validation = validateOrderBookDataQuality(data: dataPayload, symbol: symbol, exchange: exchange)
        guard validation.isValid else {
            await MainActor.run {
                logAlert(event: "üîµ WARNING: Invalid order book data for \(symbol): \(validation.reason)")
            }
            return
        }
        
        // Update order book with validated data
        await updateOrderBookWithValidation(exchange: exchange, symbol: symbol, data: dataPayload)
        
        // ENHANCED: Real-time order book health monitoring
        await monitorOrderBookHealth(exchange: exchange, symbol: symbol)
    }

    // ENHANCED: Advanced order book analysis
    static func validateOrderBookDataQuality(data: [String: Any], symbol: String, exchange: String) -> (isValid: Bool, reason: String) {
        // Check for required fields
        guard let bids = data["b"] as? [[String]] ?? data["bids"] as? [[String]],
              let asks = data["a"] as? [[String]] ?? data["asks"] as? [[String]] else {
            return (false, "Missing bids or asks data")
        }
        
        // Validate bids and asks are not empty
        guard !bids.isEmpty && !asks.isEmpty else {
            return (false, "Empty bids or asks arrays")
        }
        
        // Validate price format
        for bid in bids.prefix(3) {
            guard bid.count >= 2,
                  let price = Double(bid[0]),
                  let quantity = Double(bid[1]),
                  price > 0 && quantity > 0 else {
                return (false, "Invalid bid data format")
            }
        }
        
        for ask in asks.prefix(3) {
            guard ask.count >= 2,
                  let price = Double(ask[0]),
                  let quantity = Double(ask[1]),
                  price > 0 && quantity > 0 else {
                return (false, "Invalid ask data format")
            }
        }
        
        // Validate spread sanity
        if let topBid = bids.first,
           let topAsk = asks.first,
           let bidPrice = Double(topBid[0]),
           let askPrice = Double(topAsk[0]) {
            
            guard askPrice > bidPrice else {
                return (false, "Invalid spread: ask <= bid")
            }
            
            let spread = (askPrice - bidPrice) / bidPrice
            guard spread < 0.1 else { // 10% max spread
                return (false, "Spread too wide: \(spread * 100)%")
            }
        }
        
        return (true, "Valid")
    }

    static func updateOrderBookWithValidation(exchange: String, symbol: String, data: [String: Any]) async {
        await MainActor.run {
            var orderBook: BevaixOrderBook
            
            if exchange == "kucoin" {
                orderBook = kucoinOrderBooks[symbol] ?? BevaixOrderBook(bids: [], asks: [])
            } else {
                orderBook = bybitOrderBooks[symbol] ?? BevaixOrderBook(bids: [], asks: [])
            }
            
            // Update with new data
            if let bids = data["b"] as? [[String]] ?? data["bids"] as? [[String]] {
                let parsedBids = bids.compactMap { arr -> (price: Double, quantity: Double)? in
                    guard arr.count >= 2,
                          let price = Double(arr[0]),
                          let quantity = Double(arr[1]) else { return nil }
                    return (price: price, quantity: quantity)
                }
                orderBook.bids = parsedBids.sorted { $0.price > $1.price }
            }
            
            if let asks = data["a"] as? [[String]] ?? data["asks"] as? [[String]] {
                let parsedAsks = asks.compactMap { arr -> (price: Double, quantity: Double)? in
                    guard arr.count >= 2,
                          let price = Double(arr[0]),
                          let quantity = Double(arr[1]) else { return nil }
                    return (price: price, quantity: quantity)
                }
                orderBook.asks = parsedAsks.sorted { $0.price < $1.price }
            }
            
            // Store updated order book
            if exchange == "kucoin" {
                kucoinOrderBooks[symbol] = orderBook
            } else {
                bybitOrderBooks[symbol] = orderBook
            }
        }
    }

    static func monitorOrderBookHealth(exchange: String, symbol: String) async {
        await MainActor.run {
            let orderBook = exchange == "kucoin" ?
                (kucoinOrderBooks[symbol] ?? BevaixOrderBook(bids: [], asks: [])) :
                (bybitOrderBooks[symbol] ?? BevaixOrderBook(bids: [], asks: []))
            
            // Check order book depth
            let bidDepth = orderBook.bids.prefix(10).reduce(0.0) { $0 + $1.quantity }
            let askDepth = orderBook.asks.prefix(10).reduce(0.0) { $0 + $1.quantity }
            
            if bidDepth < 1.0 || askDepth < 1.0 {
                logAlert(event: "‚ö†Ô∏è Low liquidity detected for \(exchange) \(symbol): bid=\(bidDepth), ask=\(askDepth)")
            }
            
            // Check for crossed book
            if let bestBid = orderBook.bids.first,
               let bestAsk = orderBook.asks.first,
               bestBid.price >= bestAsk.price {
                logAlert(event: "üö® Crossed order book detected for \(exchange) \(symbol)")
            }
        }
    }

    // ENHANCED: Trade update processing
    static func processTradeUpdate(exchange: String, data: [String: Any]) async {
        guard let topic = data["topic"] as? String,
              let dataArray = data["data"] as? [[String: Any]] else {
            await MainActor.run {
                logAlert(event: "üîµ ERROR: Invalid trade update format from \(exchange)")
            }
            return
        }
        
        let symbol = extractSymbolFromTopic(topic: topic, exchange: exchange)
        
        for tradeData in dataArray {
            if let priceStr = tradeData["p"] as? String ?? tradeData["price"] as? String,
               let volumeStr = tradeData["v"] as? String ?? tradeData["volume"] as? String,
               let price = Double(priceStr),
               let volume = Double(volumeStr) {
                
                await MainActor.run {
                    if exchange == "kucoin" {
                        kucoinCurrentPrice[symbol] = price
                        kucoinPrices[symbol, default: []].append(price)
                        kucoinSpotVolume[symbol, default: []].append(volume)
                        
                        // Keep only last 200 data points
                        if kucoinPrices[symbol]!.count > 200 {
                            kucoinPrices[symbol]!.removeFirst()
                        }
                        if kucoinSpotVolume[symbol]!.count > 200 {
                            kucoinSpotVolume[symbol]!.removeFirst()
                        }
                    } else {
                        bybitCurrentPrice[symbol] = price
                        bybitPrices[symbol, default: []].append(price)
                        bybitSpotVolume[symbol, default: []].append(volume)
                        
                        // Keep only last 200 data points
                        if bybitPrices[symbol]!.count > 200 {
                            bybitPrices[symbol]!.removeFirst()
                        }
                        if bybitSpotVolume[symbol]!.count > 200 {
                            bybitSpotVolume[symbol]!.removeFirst()
                        }
                    }
                }
            }
        }
    }

    // ENHANCED: Ticker update processing
    static func processTickerUpdate(exchange: String, data: [String: Any]) async {
        if let dataArray = data["data"] as? [[String: Any]] {
            for tickerData in dataArray {
                await processSingleTickerUpdate(exchange: exchange, data: tickerData)
            }
        } else if let tickerData = data["data"] as? [String: Any] {
            await processSingleTickerUpdate(exchange: exchange, data: tickerData)
        }
    }

    static func processSingleTickerUpdate(exchange: String, data: [String: Any]) async {
        guard let symbol = data["symbol"] as? String ?? data["s"] as? String else { return }
        
        await MainActor.run {
            if let priceStr = data["lastPrice"] as? String ?? data["c"] as? String,
               let price = Double(priceStr) {
                if exchange == "kucoin" {
                    kucoinCurrentPrice[symbol] = price
                } else {
                    bybitCurrentPrice[symbol] = price
                }
            }
            
            if let volumeStr = data["volume24h"] as? String ?? data["v"] as? String,
               let volume = Double(volumeStr) {
                if exchange == "kucoin" {
                    kucoinSpotVolume[symbol, default: []].append(volume)
                } else {
                    bybitSpotVolume[symbol, default: []].append(volume)
                }
            }
        }
    }

    // ENHANCED: WebSocket heartbeat monitoring
    static func monitorWebSocketHeartbeat() {
        Task {
            while true {
                let now = Date()
                
                // Check KuCoin heartbeat
                let kucoinLastActivity = await MainActor.run { lastWebsocketActivity["kucoin"] }
                if let lastActivity = kucoinLastActivity {
                    if now.timeIntervalSince(lastActivity) > 60 { // 60 second timeout
                        await MainActor.run {
                            logAlert(event: "üî¥ KuCoin WebSocket heartbeat timeout")
                        }
                        // Trigger reconnection
                        Task { await reconnectKuCoinWebSocket() }
                    }
                }
                
                // Check Bybit heartbeat
                let bybitLastActivity = await MainActor.run { lastWebsocketActivity["bybit"] }
                if let lastActivity = bybitLastActivity {
                    if now.timeIntervalSince(lastActivity) > 60 { // 60 second timeout
                        await MainActor.run {
                            logAlert(event: "üîµ Bybit WebSocket heartbeat timeout")
                        }
                        // Trigger reconnection
                        Task { await reconnectBybitWebSocket() }
                    }
                }
                
                // Send ping messages
                await sendWebSocketPings()
                
                try? await Task.sleep(nanoseconds: 30_000_000_000) // Check every 30 seconds
            }
        }
    }

    static func sendWebSocketPings() async {
        // Send KuCoin ping
        let kucoinConnected = await MainActor.run { kucoinIsConnected }
        if kucoinConnected {
            let pingMessage: [String: Any] = ["id": "ping", "type": "ping"]
            if let pingData = try? JSONSerialization.data(withJSONObject: pingMessage),
               let pingString = String(data: pingData, encoding: .utf8) {
                // Send ping via WebSocket
                await MainActor.run {
                    // Implementation would send actual ping message
                    logAlert(event: "üî¥ Sent KuCoin WebSocket ping")
                }
            }
        }
        
        // Send Bybit ping
        let bybitConnected = await MainActor.run { bybitIsConnected }
        if bybitConnected {
            let pingMessage: [String: Any] = ["op": "ping"]
            if let pingData = try? JSONSerialization.data(withJSONObject: pingMessage),
               let pingString = String(data: pingData, encoding: .utf8) {
                // Send ping via WebSocket
                await MainActor.run {
                    // Implementation would send actual ping message
                    logAlert(event: "üîµ Sent Bybit WebSocket ping")
                }
            }
        }
    }

    // ENHANCED: WebSocket message queue processing
    static func processMessageQueue() async {
        while true {
            let messages = await MainActor.run {
                let currentMessages = enhancedMessageQueue
                enhancedMessageQueue.removeAll()
                return currentMessages
            }
            
            for (exchange, message) in messages {
                if exchange == "kucoin" {
                    await processKuCoinWebSocketMessage(message: message)
                } else if exchange == "bybit" {
                    await processBybitWebSocketMessage(message: message)
                }
            }
            
            try? await Task.sleep(nanoseconds: 10_000_000) // 10ms processing interval
        }
    }

    // Enhanced sentiment analysis with ML integration
    static func analyzeSentimentWithML(pair: String) async -> Double {
        let url = URL(string: "http://127.0.0.1:5001/analyze_sentiment")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.timeoutInterval = 30.0

        let payload: [String: Any] = [
            "pair": pair,
            "price": await MainActor.run { kucoinCurrentPrice[pair] ?? 0.0 },
            "volume": await MainActor.run { kucoinSpotVolume[pair]?.last ?? 0.0 },
            "funding_rate": await MainActor.run { kucoinFundingRates[pair] ?? 0.0 }
        ]

        do {
            let jsonData = try JSONSerialization.data(withJSONObject: payload, options: [])
            request.httpBody = jsonData
            
            let (data, response) = try await URLSession.shared.data(for: request)
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                await MainActor.run {
                    logAlert(event: "Failed to fetch sentiment for \(pair)")
                }
                return 0.0
            }
            
            if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
               let sentiment = json["sentiment"] as? Double {
                await MainActor.run {
                    sentimentScores[pair] = sentiment
                }
                return sentiment
            }
        } catch {
            await MainActor.run {
                logAlert(event: "Sentiment analysis error for \(pair): \(error.localizedDescription)")
            }
        }
        
        return 0.0
    }

    // Advanced technical indicators for enhanced trading signals
    static func calculateAdvancedRSI(prices: [Double], period: Int = 14) -> Double? {
        guard prices.count >= period else { return nil }
        
        var gains = [Double]()
        var losses = [Double]()
        
        for i in 1..<prices.count {
            let change = prices[i] - prices[i-1]
            gains.append(max(change, 0))
            losses.append(max(-change, 0))
        }
        
        guard gains.count >= period else { return nil }
        
        let avgGain = gains.suffix(period).reduce(0, +) / Double(period)
        let avgLoss = losses.suffix(period).reduce(0, +) / Double(period)
        
        guard avgLoss != 0 else { return 100 }
        
        let rs = avgGain / avgLoss
        return 100 - (100 / (1 + rs))
    }

    static func calculateBollingerBands(prices: [Double], period: Int = 20, stdDev: Double = 2.0) -> (upper: Double, middle: Double, lower: Double)? {
        guard prices.count >= period else { return nil }
        
        let recentPrices = Array(prices.suffix(period))
        let sma = recentPrices.reduce(0, +) / Double(period)
        
        let variance = recentPrices.map { pow($0 - sma, 2) }.reduce(0, +) / Double(period)
        let standardDeviation = sqrt(variance)
        
        return (
            upper: sma + (stdDev * standardDeviation),
            middle: sma,
            lower: sma - (stdDev * standardDeviation)
        )
    }

    static func detectRSIDivergence(prices: [Double], rsiValues: [Double]) -> Bool {
        guard prices.count >= 5, rsiValues.count >= 5 else { return false }
        
        let recentPrices = Array(prices.suffix(5))
        let recentRSI = Array(rsiValues.suffix(5))
        
        let priceDirection = recentPrices.last! > recentPrices.first!
        let rsiDirection = recentRSI.last! > recentRSI.first!
        
        return priceDirection != rsiDirection
    }

    static func analyzeOrderFlow(pair: String) async -> Double {
        let kucoinBook = await MainActor.run { kucoinOrderBooks[pair] } ?? BevaixOrderBook(bids: [], asks: [])
        let bybitBook = await MainActor.run { bybitOrderBooks[pair] } ?? BevaixOrderBook(bids: [], asks: [])
        
        let kucoinBidVolume = kucoinBook.bids.prefix(5).reduce(0.0) { $0 + $1.quantity }
        let kucoinAskVolume = kucoinBook.asks.prefix(5).reduce(0.0) { $0 + $1.quantity }
        let bybitBidVolume = bybitBook.bids.prefix(5).reduce(0.0) { $0 + $1.quantity }
        let bybitAskVolume = bybitBook.asks.prefix(5).reduce(0.0) { $0 + $1.quantity }
        
        let totalBidVolume = kucoinBidVolume + bybitBidVolume
        let totalAskVolume = kucoinAskVolume + bybitAskVolume
        
        guard totalBidVolume + totalAskVolume > 0 else { return 0.0 }
        
        return (totalBidVolume - totalAskVolume) / (totalBidVolume + totalAskVolume)
    }

    // Helper functions
    static func extractSymbolFromTopic(topic: String, exchange: String) -> String {
        if exchange == "kucoin" {
            // KuCoin format: /market/ticker:BTC-USDT
            if let range = topic.range(of: ":") {
                return String(topic[range.upperBound...])
            }
        } else {
            // Bybit format: tickers.BTCUSDT
            if let range = topic.range(of: ".") {
                return String(topic[range.upperBound...])
            }
        }
        return ""
    }

    static func receiveBybitMessages() async {
        // Implementation for receiving WebSocket messages
        await MainActor.run {
            logAlert(event: "üîµ Started receiving Bybit WebSocket messages")
        }
    }

    static func subscribeToBybitStreams() async {
        let pairs = await MainActor.run { tradingPairs }
        for pair in pairs {
            let symbol = pair.replacingOccurrences(of: "-", with: "")
            await subscribeToBybitTicker(symbol: symbol)
            await subscribeToBybitOrderBook(symbol: symbol)
        }
    }

    static func subscribeToBybitTicker(symbol: String) async {
        let subscribeMessage: [String: Any] = [
            "op": "subscribe",
            "args": ["tickers.\(symbol)"]
        ]
        
        if let data = try? JSONSerialization.data(withJSONObject: subscribeMessage),
           let message = String(data: data, encoding: .utf8) {
            await MainActor.run {
                logAlert(event: "üîµ Subscribed to Bybit ticker for \(symbol)")
            }
        }
    }

    static func subscribeToBybitOrderBook(symbol: String) async {
        let subscribeMessage: [String: Any] = [
            "op": "subscribe",
            "args": ["orderbook.50.\(symbol)"]
        ]
        
        if let data = try? JSONSerialization.data(withJSONObject: subscribeMessage),
           let message = String(data: data, encoding: .utf8) {
            await MainActor.run {
                logAlert(event: "üîµ Subscribed to Bybit order book for \(symbol)")
            }
        }
    }

    static func reconnectKuCoinWebSocket() async {
        await MainActor.run {
            logAlert(event: "üî¥ Reconnecting KuCoin WebSocket...")
            kucoinIsConnected = false
        }
        // Implementation for KuCoin reconnection would go here
    }

    static func processKuCoinWebSocketMessage(message: String) async {
        // Implementation for KuCoin WebSocket message processing
        await MainActor.run {
            lastWebsocketActivity["kucoin"] = Date()
        }
    }

    static func monitorCrossExchangeArbitrage() {
        let localKucoinCurrentPrice = kucoinCurrentPrice
        let localBybitCurrentPrice = bybitCurrentPrice
        let localKucoinPrices = kucoinPrices
        let localBybitPrices = bybitPrices

        Task {
            await withTaskGroup(of: Void.self) { group in
                let tradingPairsValue = await MainActor.run(body: { tradingPairs })
                for pair in tradingPairsValue {
                    group.addTask {
                        let kucoinSpotPrice = await MainActor.run(body: { localKucoinCurrentPrice[pair] ?? 0.0 })
                        let bybitSpotPrice = await MainActor.run(body: { localBybitCurrentPrice[pair] ?? 0.0 })
                        let kucoinSpotPrices = await MainActor.run(body: { localKucoinPrices[pair] ?? [] })
                        let bybitSpotPrices = await MainActor.run(body: { localBybitPrices[pair] ?? [] })
                        // Suppress unused warnings for kucoinSpotPrices and bybitSpotPrices (Lines 3097, 3098)
                        print("DEBUG: KuCoin spot prices count for \(pair): \(kucoinSpotPrices.count)")
                        print("DEBUG: Bybit spot prices count for \(pair): \(bybitSpotPrices.count)")

                        guard kucoinSpotPrice > 0 && bybitSpotPrice > 0 else {
                            print("DEBUG: Invalid prices for cross-exchange arbitrage - \(pair): KuCoin=\(kucoinSpotPrice), Bybit=\(bybitSpotPrice)")
                            return
                        }

                        let lastExecution = await MainActor.run(body: { crossExchangeArbitrageExecuted[pair] })
                        let cooldownSeconds = await MainActor.run(body: { crossExchangeCooldownSeconds })
                        if lastExecution == nil || Date().timeIntervalSince(lastExecution!.1) > cooldownSeconds {
                            let kucoinEvents = await MainActor.run(body: { kucoinOrderBookEvents[pair] ?? [] })
                            let spoofingThreshold = await MainActor.run(body: { spoofingVolumeThreshold })
                            let spoofingDetected = kucoinEvents.filter { Date().timeIntervalSince($0.timestamp) < 60 }.count > 2 && kucoinEvents.contains(where: { $0.volume > spoofingThreshold })
                            if spoofingDetected {
                                print("DEBUG: Order book spoofing detected for \(pair)")
                                await MainActor.run(body: {
                                    logAlert(event: "Order book spoofing detected for \(pair)")
                                })
                                return
                            }

                            let tradeAmount = await MainActor.run(body: { crossExchangeTradeAmount })
                            
                            // Log arbitrage opportunity (removed ambiguous function call)
                            print("DEBUG: Cross-exchange arbitrage opportunity detected for \(pair) with spread and trade amount \(tradeAmount)")
                            await MainActor.run(body: {
                                logAlert(event: "Cross-exchange arbitrage opportunity detected for \(pair)")
                            })
                        } else {
                            print("DEBUG: Cross-exchange arbitrage for \(pair) on cooldown")
                        }
                    }
                }
            }
            try? await Task.sleep(nanoseconds: UInt64(getDouble("ARBITRAGE_CHECK_INTERVAL_SECONDS", defaultValue: 0.5) * 1_000_000_000))
            monitorCrossExchangeArbitrage()
        }
    }
}
