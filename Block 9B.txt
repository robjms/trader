  
//--------------------------------------------------------------------------------------------------------------------------------Block 9B - Enhanced KuCoin WebSocket Processing with Spot Price Support
    
    
    
// FIXED: Use ObjectIdentifier to compare WebSocket instances
@MainActor
static func handleWebSocketConnected(client: WebSocketClient, headers: [String: String]) {
    let clientId = ObjectIdentifier(client)
    let kucoinId = kucoinSocket.map { ObjectIdentifier($0) }
    let kucoinFuturesId = kucoinFuturesSocket.map { ObjectIdentifier($0) }
    let bybitId = bybitSocket.map { ObjectIdentifier($0) }
    
    if clientId == kucoinId {
        kucoinIsConnected = true
        kucoinReconnectAttempts = 0
        print("‚úÖ KuCoin Spot WebSocket connected successfully")
        logAlert(event: "‚úÖ KuCoin Spot WebSocket connected successfully")
        
        // Subscribe to spot tickers for all trading pairs
        subscribeToKuCoinSpotTickers()
    } else if clientId == kucoinFuturesId {
        kucoinFuturesIsConnected = true
        kucoinFuturesReconnectAttempts = 0
        print("‚úÖ KuCoin Futures WebSocket connected successfully")
        logAlert(event: "‚úÖ KuCoin Futures WebSocket connected successfully")
    } else if clientId == bybitId {
        bybitIsConnected = true
        bybitReconnectAttempts = 0
        print("‚úÖ Bybit WebSocket connected successfully")
        logAlert(event: "‚úÖ Bybit WebSocket connected successfully")
    }
    
    updateDashboardData()
}

@MainActor
static func handleWebSocketDisconnected(client: WebSocketClient, reason: String, code: UInt16) {
    let clientId = ObjectIdentifier(client)
    let kucoinId = kucoinSocket.map { ObjectIdentifier($0) }
    let kucoinFuturesId = kucoinFuturesSocket.map { ObjectIdentifier($0) }
    let bybitId = bybitSocket.map { ObjectIdentifier($0) }
    
    if clientId == kucoinId {
        kucoinIsConnected = false
        print("‚ùå KuCoin Spot WebSocket disconnected: \(reason) (code: \(code))")
        logAlert(event: "‚ùå KuCoin Spot WebSocket disconnected: \(reason) (code: \(code))")
        scheduleKuCoinReconnection()
    } else if clientId == kucoinFuturesId {
        kucoinFuturesIsConnected = false
        print("‚ùå KuCoin Futures WebSocket disconnected: \(reason) (code: \(code))")
        logAlert(event: "‚ùå KuCoin Futures WebSocket disconnected: \(reason) (code: \(code))")
        scheduleKuCoinFuturesReconnection()
    } else if clientId == bybitId {
        bybitIsConnected = false
        print("‚ùå Bybit WebSocket disconnected: \(reason) (code: \(code))")
        logAlert(event: "‚ùå Bybit WebSocket disconnected: \(reason) (code: \(code))")
        scheduleBybitReconnection()
    }
    
    updateDashboardData()
}

@MainActor
static func handleWebSocketTextMessage(client: WebSocketClient, text: String) {
    let clientId = ObjectIdentifier(client)
    let kucoinId = kucoinSocket.map { ObjectIdentifier($0) }
    let kucoinFuturesId = kucoinFuturesSocket.map { ObjectIdentifier($0) }
    let bybitId = bybitSocket.map { ObjectIdentifier($0) }
    
    // Route to appropriate exchange handler using existing string-based functions
    if clientId == kucoinId {
        Task {
            await handleKuCoinSpotMessage(text)
        }
    } else if clientId == kucoinFuturesId {
        Task {
            await handleKuCoinFuturesMessage(text)
        }
    } else if clientId == bybitId {
        Task {
            await handleBybitSpotMessage(text)
        }
    }
}

@MainActor
static func handleWebSocketBinaryMessage(client: WebSocketClient, data: Data) {
    print("üì¶ Received binary WebSocket message (length: \(data.count))")
}

@MainActor
static func handleWebSocketError(client: WebSocketClient, error: Error?) {
    let errorMessage = error?.localizedDescription ?? "Unknown WebSocket error"
    print("‚ùå WebSocket error: \(errorMessage)")
    logAlert(event: "‚ùå WebSocket error: \(errorMessage)")
    
    let clientId = ObjectIdentifier(client)
    let kucoinId = kucoinSocket.map { ObjectIdentifier($0) }
    let kucoinFuturesId = kucoinFuturesSocket.map { ObjectIdentifier($0) }
    let bybitId = bybitSocket.map { ObjectIdentifier($0) }
    
    // Trigger reconnection for the specific socket
    if clientId == kucoinId {
        scheduleKuCoinReconnection()
    } else if clientId == kucoinFuturesId {
        scheduleKuCoinFuturesReconnection()
    } else if clientId == bybitId {
        scheduleBybitReconnection()
    }
}

// ENHANCED: Subscribe to KuCoin Spot Tickers with CRITICAL FIX for price updates
@MainActor
static func subscribeToKuCoinSpotTickers() {
    guard kucoinIsConnected, let socket = kucoinSocket else {
        print("‚ùå Cannot subscribe to KuCoin spot tickers - not connected")
        return
    }
    
    // CRITICAL FIX: Subscribe to individual ticker topics for better reliability
    for pair in tradingPairs {
        // CRITICAL FIX: Convert BTC-USDT to BTCUSDT for KuCoin API
        let symbol = pair.replacingOccurrences(of: "-", with: "")
        let subscriptionMessage: [String: Any] = [
            "id": UUID().uuidString,
            "type": "subscribe",
            "topic": "/market/ticker:\(symbol)",  // FIXED: Use BTCUSDT format for KuCoin API
            "privateChannel": false,
            "response": true
        ]
        
        do {
            let jsonData = try JSONSerialization.data(withJSONObject: subscriptionMessage)
            if let jsonString = String(data: jsonData, encoding: .utf8) {
                socket.write(string: jsonString)
                print("üì° FIXED: Subscribed to KuCoin SPOT ticker for \(pair) (API symbol: \(symbol))")
                logAlert(event: "üì° FIXED: Subscribed to KuCoin SPOT ticker for \(pair)")
            }
        } catch {
            print("‚ùå Failed to subscribe to KuCoin spot ticker for \(pair): \(error)")
            logAlert(event: "‚ùå Failed to subscribe to KuCoin spot ticker for \(pair): \(error)")
        }
    }
    
    // Also subscribe to order book updates for better liquidity analysis
    for pair in tradingPairs {
        // CRITICAL FIX: Convert BTC-USDT to BTCUSDT for KuCoin order book too
        let symbol = pair.replacingOccurrences(of: "-", with: "")
        let orderBookSubscription: [String: Any] = [
            "id": UUID().uuidString,
            "type": "subscribe",
            "topic": "/market/level2:\(symbol)",  // FIXED: Use BTCUSDT format
            "privateChannel": false,
            "response": true
        ]
        
        do {
            let jsonData = try JSONSerialization.data(withJSONObject: orderBookSubscription)
            if let jsonString = String(data: jsonData, encoding: .utf8) {
                socket.write(string: jsonString)
                print("üìä FIXED: Subscribed to KuCoin SPOT order book for \(pair) (API symbol: \(symbol))")
            }
        } catch {
            print("‚ùå Failed to subscribe to KuCoin spot order book for \(pair): \(error)")
        }
    }
    
    logAlert(event: "‚úÖ FIXED: Subscribed to KuCoin SPOT tickers for \(tradingPairs.count) pairs")
}

// EXISTING FUNCTIONS FROM YOUR CODE - PRESERVED COMPLETELY WITH CRITICAL ENHANCEMENTS

static func handleKuCoinSpotMessage(_ message: String) async {
    do {
        guard let data = message.data(using: .utf8),
              let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            await MainActor.run {
                logAlert(event: "üü°‚ùå Failed to parse KuCoin Spot message: \(message)")
            }
            return
        }
        
        await MainActor.run {
            lastWebsocketActivity["kucoin-spot"] = Date()
        }
        
        // Handle different message types
        if let type = json["type"] as? String {
            switch type {
            case "welcome":
                await MainActor.run {
                    logAlert(event: "üü°‚úÖ KuCoin Spot welcome message received")
                }
                
            case "ack":
                await MainActor.run {
                    logAlert(event: "üü°‚úÖ KuCoin Spot subscription acknowledged")
                }
                
            case "message":
                await handleKuCoinSpotDataMessage(json)
                
            case "pong":
                print("üü°üíì KuCoin Spot pong received")
                
            case "error":
                let errorMsg = json["data"] as? String ?? "Unknown error"
                await MainActor.run {
                    logAlert(event: "üü°‚ùå KuCoin Spot error: \(errorMsg)")
                }
                
            default:
                print("üü°‚ùì Unknown KuCoin Spot message type: \(type)")
            }
        }
    } catch {
        await MainActor.run {
            logAlert(event: "üü°‚ùå Error processing KuCoin Spot message: \(error.localizedDescription)")
        }
    }
}

// CRITICAL ENHANCEMENT: Fixed price parsing to resolve $0.000000 issue
// CRITICAL DIAGNOSTIC FIX: Replace your handleKuCoinSpotDataMessage function with this enhanced version

static func handleKuCoinSpotDataMessage(_ json: [String: Any]) async {
    // STEP 1: Enhanced message validation with detailed logging
    print("üîç DIAGNOSTIC: Received KuCoin message: \(json)")
    
    guard let topic = json["topic"] as? String else {
        print("‚ùå DIAGNOSTIC: Missing topic in KuCoin message")
        await MainActor.run {
            logAlert(event: "‚ùå DIAGNOSTIC: Missing topic in KuCoin message")
        }
        return
    }
    
    guard let data = json["data"] as? [String: Any] else {
        print("‚ùå DIAGNOSTIC: Missing data in KuCoin message for topic: \(topic)")
        await MainActor.run {
            logAlert(event: "‚ùå DIAGNOSTIC: Missing data in KuCoin message for topic: \(topic)")
        }
        return
    }
    
    print("üîç DIAGNOSTIC: Topic = \(topic)")
    print("üîç DIAGNOSTIC: Data keys = \(Array(data.keys))")
    print("üîç DIAGNOSTIC: Full data = \(data)")
    
    await MainActor.run {
        // STEP 2: Handle ticker messages with comprehensive validation
        if topic.contains("/market/ticker:") {
            print("üîç DIAGNOSTIC: Processing ticker message for topic: \(topic)")
            
            // STEP 3: Extract symbol using multiple approaches
            var symbol: String = ""
            
            // Method 1: Extract from topic
            if let symbolStart = topic.range(of: ":")?.upperBound {
                symbol = String(topic[symbolStart...])
                print("üîç DIAGNOSTIC: Extracted symbol from topic: '\(symbol)'")
            }
            
            // Method 2: Try to get symbol from data
            if symbol.isEmpty, let dataSymbol = data["symbol"] as? String {
                symbol = dataSymbol
                print("üîç DIAGNOSTIC: Extracted symbol from data: '\(symbol)'")
            }
            
            guard !symbol.isEmpty else {
                print("‚ùå DIAGNOSTIC: Failed to extract symbol from topic: \(topic)")
                logAlert(event: "‚ùå DIAGNOSTIC: Failed to extract symbol from topic: \(topic)")
                return
            }
            
            // STEP 4: Convert symbol to pair with enhanced validation
            let pair: String
            if symbol.hasSuffix("USDT") && symbol.count > 4 {
                let baseAsset = symbol.replacingOccurrences(of: "USDT", with: "")
                pair = "\(baseAsset)-USDT"
                print("üîç DIAGNOSTIC: Converted symbol '\(symbol)' to pair '\(pair)'")
            } else {
                pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
                print("üîç DIAGNOSTIC: Fallback conversion of symbol '\(symbol)' to pair '\(pair)'")
            }
            
            // STEP 5: Validate pair against trading pairs
            guard tradingPairs.contains(pair) else {
                print("‚ö†Ô∏è DIAGNOSTIC: Pair '\(pair)' not found in trading pairs list")
                print("‚ö†Ô∏è DIAGNOSTIC: Available trading pairs: \(tradingPairs)")
                return
            }
            
            print("‚úÖ DIAGNOSTIC: Pair '\(pair)' validated successfully")
            
            // STEP 6: Enhanced price extraction with ALL possible keys
            let allPriceKeys = [
                "price", "last", "lastPrice", "lastTradePrice",
                "bestAsk", "bestAskPrice", "bestBid", "bestBidPrice",
                "close", "mark", "index", "c", "p"
            ]
            
            var extractedPrice: Double?
            var usedKey: String = ""
            
            // Try string values first
            for key in allPriceKeys {
                if let priceStr = data[key] as? String, !priceStr.isEmpty {
                    if let price = Double(priceStr), price > 0 {
                        extractedPrice = price
                        usedKey = key
                        print("‚úÖ DIAGNOSTIC: Found price using STRING key '\(key)': '\(priceStr)' = $\(price)")
                        break
                    } else {
                        print("‚ö†Ô∏è DIAGNOSTIC: Failed to parse STRING price from key '\(key)': '\(priceStr)'")
                    }
                }
            }
            
            // If no string value worked, try numeric values
            if extractedPrice == nil {
                for key in allPriceKeys {
                    if let priceNum = data[key] as? Double, priceNum > 0 {
                        extractedPrice = priceNum
                        usedKey = key
                        print("‚úÖ DIAGNOSTIC: Found price using NUMERIC key '\(key)': $\(priceNum)")
                        break
                    } else if let priceInt = data[key] as? Int, priceInt > 0 {
                        extractedPrice = Double(priceInt)
                        usedKey = key
                        print("‚úÖ DIAGNOSTIC: Found price using INTEGER key '\(key)': \(priceInt)")
                        break
                    }
                }
            }
            
            // STEP 7: Final price validation
            guard let finalPrice = extractedPrice, finalPrice > 0 else {
                print("‚ùå CRITICAL DIAGNOSTIC: NO VALID PRICE FOUND for \(pair)")
                print("‚ùå Searched keys: \(allPriceKeys)")
                print("‚ùå Available data: \(data)")
                logAlert(event: "‚ùå CRITICAL: NO VALID PRICE FOUND for \(pair) - searched \(allPriceKeys.count) keys")
                
                // Log all available data for debugging
                for (key, value) in data {
                    print("‚ùå DEBUG: data[\(key)] = \(value) (type: \(type(of: value)))")
                }
                return
            }
            
            // STEP 8: Store the price with enhanced logging
            let oldPrice = kucoinCurrentPrice[pair] ?? 0.0
            kucoinCurrentPrice[pair] = finalPrice
            kucoinPrices[pair, default: []].append(finalPrice)
            
            // Maintain price history
            if kucoinPrices[pair]!.count > priceHistoryRetention {
                kucoinPrices[pair]?.removeFirst()
            }
            
            // Update timestamp
            lastDataUpdate[pair] = Date()
            
            // STEP 9: Success logging with full details
            print("üéâ SUCCESS: KuCoin price updated for \(pair)")
            print("   Old Price: $\(String(format: "%.6f", oldPrice))")
            print("   New Price: $\(String(format: "%.6f", finalPrice))")
            print("   Used Key: '\(usedKey)'")
            print("   Topic: \(topic)")
            print("   Symbol: \(symbol)")
            
            logAlert(event: "üéâ KuCoin SUCCESS: \(pair) = $\(finalPrice) (key: \(usedKey))")
            
            // Trigger arbitrage check
            triggerCrossExchangeArbitrageCheck(pair: pair)
            
            // Update dashboard
            updateDashboardData()
            
            // STEP 10: Extract volume data if available
            let volumeKeys = ["vol", "volume", "size", "volume24h", "volValue", "v"]
            for key in volumeKeys {
                if let volumeStr = data[key] as? String, let volume = Double(volumeStr), volume > 0 {
                    kucoinSpotVolume[pair, default: []].append(volume)
                    if kucoinSpotVolume[pair]!.count > priceHistoryRetention {
                        kucoinSpotVolume[pair]?.removeFirst()
                    }
                    print("‚úÖ DIAGNOSTIC: Volume updated for \(pair): \(volume) (key: \(key))")
                    break
                } else if let volumeNum = data[key] as? Double, volumeNum > 0 {
                    kucoinSpotVolume[pair, default: []].append(volumeNum)
                    if kucoinSpotVolume[pair]!.count > priceHistoryRetention {
                        kucoinSpotVolume[pair]?.removeFirst()
                    }
                    print("‚úÖ DIAGNOSTIC: Volume updated for \(pair): \(volumeNum) (key: \(key))")
                    break
                }
            }
            
        } else if topic.contains("/market/level2:") {
            // Handle order book updates
            print("üîç DIAGNOSTIC: Processing order book message for topic: \(topic)")
            let symbolStart = topic.range(of: ":")?.upperBound
            if let start = symbolStart {
                let symbol = String(topic[start...])
                let pair = symbol // Use the symbol directly since it's already in BTC-USDT format
                
                if let changes = data["changes"] as? [String: [[String]]] {
                    updateKuCoinOrderBook(pair: pair, changes: changes)
                    print("‚úÖ DIAGNOSTIC: Order book updated for \(pair)")
                }
            }
        } else {
            print("‚ö†Ô∏è DIAGNOSTIC: Unknown topic type: \(topic)")
        }
    }
}

// ADDITIONAL DIAGNOSTIC: Enhanced subscription function with better logging
@MainActor
static func subscribeToKuCoinSpotTickersEnhanced() {
    guard kucoinIsConnected, let socket = kucoinSocket else {
        print("‚ùå Cannot subscribe to KuCoin spot tickers - not connected")
        return
    }
    
    print("üîç DIAGNOSTIC: Starting KuCoin spot ticker subscriptions...")
    print("üîç DIAGNOSTIC: Trading pairs to subscribe: \(tradingPairs)")
    
    // Subscribe with enhanced validation
    for (index, pair) in tradingPairs.enumerated() {
        // CRITICAL FIX: Convert BTC-USDT to BTCUSDT for KuCoin API
        let symbol = pair.replacingOccurrences(of: "-", with: "")
        
        let subscriptionMessage: [String: Any] = [
            "id": "\(UUID().uuidString)-\(index)",
            "type": "subscribe",
            "topic": "/market/ticker:\(symbol)",  // FIXED: Use BTCUSDT format for KuCoin API
            "privateChannel": false,
            "response": true
        ]
        
        do {
            let jsonData = try JSONSerialization.data(withJSONObject: subscriptionMessage)
            if let jsonString = String(data: jsonData, encoding: .utf8) {
                socket.write(string: jsonString)
                print("üì° DIAGNOSTIC: Subscribed to pair \(pair) (symbol: \(symbol))")
                print("   Subscription message: \(jsonString)")
            }
        } catch {
            print("‚ùå DIAGNOSTIC: Failed to subscribe to \(pair): \(error)")
            logAlert(event: "‚ùå Failed to subscribe to KuCoin spot ticker for \(pair): \(error)")
        }
    }
    
    logAlert(event: "üîç DIAGNOSTIC: Attempted KuCoin subscriptions for \(tradingPairs.count) pairs")
}

// DIAGNOSTIC HELPER: Add this function to test message parsing
@MainActor
static func testKuCoinMessageParsing() {
    // Test with sample KuCoin message format
    let sampleMessage: [String: Any] = [
        "type": "message",
        "topic": "/market/ticker:BTCUSDT",
        "subject": "trade.ticker",
        "data": [
            "symbol": "BTC-USDT",
            "symbolName": "BTCUSDT",
            "buy": "65000.1",
            "sell": "65000.2",
            "changeRate": "-0.0055",
            "changePrice": "-357.6",
            "high": "65400.0",
            "low": "64800.0",
            "vol": "1234.567",
            "volValue": "80000000.123",
            "last": "65000.15",
            "averagePrice": "65100.0",
            "takerFeeRate": "0.001",
            "makerFeeRate": "0.001",
            "takerCoefficient": "1.0",
            "makerCoefficient": "1.0"
        ]
    ]
    
    print("üß™ TESTING: Parsing sample KuCoin message...")
    Task {
        await handleKuCoinSpotDataMessage(sampleMessage)
    }
}
static func handleKuCoinFuturesMessage(_ message: String) async {
    do {
        guard let data = message.data(using: .utf8),
              let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            await MainActor.run {
                logAlert(event: "üü°‚ùå Failed to parse KuCoin Futures message: \(message)")
            }
            return
        }
        
        await MainActor.run {
            lastWebsocketActivity["kucoin-futures"] = Date()
        }
        
        // Handle different message types
        if let type = json["type"] as? String {
            switch type {
            case "welcome":
                await MainActor.run {
                    logAlert(event: "üü°‚úÖ KuCoin Futures welcome message received")
                }
                
            case "ack":
                await MainActor.run {
                    logAlert(event: "üü°‚úÖ KuCoin Futures subscription acknowledged")
                }
                
            case "message":
                await handleKuCoinFuturesDataMessage(json)
                
            case "pong":
                print("üü°üíì KuCoin Futures pong received")
                
            case "error":
                let errorMsg = json["data"] as? String ?? "Unknown error"
                await MainActor.run {
                    logAlert(event: "üü°‚ùå KuCoin Futures error: \(errorMsg)")
                }
                
            default:
                print("üü°‚ùì Unknown KuCoin Futures message type: \(type)")
            }
        }
    } catch {
        await MainActor.run {
            logAlert(event: "üü°‚ùå Error processing KuCoin Futures message: \(error.localizedDescription)")
        }
    }
}

static func handleKuCoinFuturesDataMessage(_ json: [String: Any]) async {
    guard let topic = json["topic"] as? String,
          let data = json["data"] as? [String: Any] else {
        return
    }
    
    await MainActor.run {
        if topic.contains("/contractMarket/ticker:") {
            // Extract symbol from topic: /contractMarket/ticker:XBTUSDTM
            let symbolStart = topic.range(of: ":")?.upperBound
            if let start = symbolStart {
                let symbol = String(topic[start...])
                let pair = convertSymbolToPair(symbol: symbol, isFutures: true)
                
                // Extract price data
                if let priceStr = data["price"] as? String,
                   let price = Double(priceStr), price > 0 {
                    
                    kucoinCurrentFuturesPrice[pair] = price
                    kucoinFuturesPrices[pair, default: []].append(price)
                    
                    // Maintain price history
                    if kucoinFuturesPrices[pair]!.count > priceHistoryRetention {
                        kucoinFuturesPrices[pair]?.removeFirst()
                    }
                    
                    print("‚úÖ [KuCoin Futures] Updated price for \(pair): $\(price)")
                    logAlert(event: "‚úÖ [KuCoin Futures] Updated price for \(pair): $\(price)")
                    
                    // Update dashboard
                    updateDashboardData()
                }
                
                // Extract volume if available
                if let volumeStr = data["vol"] as? String,
                   let volume = Double(volumeStr) {
                    kucoinFuturesVolume[pair, default: []].append(volume)
                    if kucoinFuturesVolume[pair]!.count > priceHistoryRetention {
                        kucoinFuturesVolume[pair]?.removeFirst()
                    }
                }
                
                // Extract funding rate if available
                if let fundingRateStr = data["fundingRate"] as? String,
                   let fundingRate = Double(fundingRateStr) {
                    kucoinFundingRates[pair] = fundingRate
                    kucoinFundingRateHistory[pair, default: []].append(fundingRate)
                    if kucoinFundingRateHistory[pair]!.count > priceHistoryRetention {
                        kucoinFundingRateHistory[pair]?.removeFirst()
                    }
                }
            }
        }
    }
}

static func handleBybitSpotMessage(_ message: String) async {
    do {
        guard let data = message.data(using: .utf8),
              let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            await MainActor.run {
                logAlert(event: "üîµ‚ùå Failed to parse Bybit Spot message: \(message)")
            }
            return
        }
        
        await MainActor.run {
            lastWebsocketActivity["bybit-spot"] = Date()
        }
        
        // Handle subscription success
        if let success = json["success"] as? Bool, success == true {
            await MainActor.run {
                logAlert(event: "üîµ‚úÖ Bybit Spot subscription successful")
            }
            return
        }
        
        // Handle data messages
        if let topic = json["topic"] as? String,
           let data = json["data"] as? [String: Any],
           topic.contains("tickers.") {
            
            await handleBybitSpotDataMessage(topic: topic, data: data)
        }
        
    } catch {
        await MainActor.run {
            logAlert(event: "üîµ‚ùå Error processing Bybit Spot message: \(error.localizedDescription)")
        }
    }
}

static func handleBybitSpotDataMessage(topic: String, data: [String: Any]) async {
    // Extract symbol from topic: tickers.BTCUSDT
    let symbolStart = topic.range(of: ".")?.upperBound
    guard let start = symbolStart else { return }
    
    let symbol = String(topic[start...])
    let pair = convertSymbolToPair(symbol: symbol, isFutures: false)
    
    await MainActor.run {
        // Extract price data
        if let priceStr = data["lastPrice"] as? String,
           let price = Double(priceStr), price > 0 {
            
            bybitCurrentPrice[pair] = price
            bybitPrices[pair, default: []].append(price)
            
            // Maintain price history
            if bybitPrices[pair]!.count > priceHistoryRetention {
                bybitPrices[pair]?.removeFirst()
            }
            
            print("‚úÖ [Bybit Spot] Updated price for \(pair): $\(price)")
            logAlert(event: "‚úÖ [Bybit Spot] Updated price for \(pair): $\(price)")
            
            // CRITICAL FIX: Trigger arbitrage check when price updates
            triggerCrossExchangeArbitrageCheck(pair: pair)
            
            // Update dashboard
            updateDashboardData()
        }
        
        // Extract volume if available
        if let volumeStr = data["volume24h"] as? String,
           let volume = Double(volumeStr) {
            bybitSpotVolume[pair, default: []].append(volume)
            if bybitSpotVolume[pair]!.count > priceHistoryRetention {
                bybitSpotVolume[pair]?.removeFirst()
            }
        }
    }
}

static func handleBybitFuturesMessage(_ message: String) async {
    do {
        guard let data = message.data(using: .utf8),
              let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            await MainActor.run {
                logAlert(event: "üîµ‚ùå Failed to parse Bybit Futures message: \(message)")
            }
            return
        }
        
        await MainActor.run {
            lastWebsocketActivity["bybit-futures"] = Date()
        }
        
        // Handle subscription success
        if let success = json["success"] as? Bool, success == true {
            await MainActor.run {
                logAlert(event: "üîµ‚úÖ Bybit Futures subscription successful")
            }
            return
        }
        
        // Handle data messages
        if let topic = json["topic"] as? String,
           let data = json["data"] as? [String: Any],
           topic.contains("tickers.") {
            
            await handleBybitFuturesDataMessage(topic: topic, data: data)
        }
        
    } catch {
        await MainActor.run {
            logAlert(event: "üîµ‚ùå Error processing Bybit Futures message: \(error.localizedDescription)")
        }
    }
}

static func handleBybitFuturesDataMessage(topic: String, data: [String: Any]) async {
    // Extract symbol from topic: tickers.BTCUSDT
    let symbolStart = topic.range(of: ".")?.upperBound
    guard let start = symbolStart else { return }
    
    let symbol = String(topic[start...])
    let pair = convertSymbolToPair(symbol: symbol, isFutures: false)
    
    await MainActor.run {
        // Extract price data
        if let priceStr = data["lastPrice"] as? String,
           let price = Double(priceStr), price > 0 {
            
            bybitCurrentFuturesPrice[pair] = price
            bybitFuturesPrices[pair, default: []].append(price)
            
            // Maintain price history
            if bybitFuturesPrices[pair]!.count > priceHistoryRetention {
                bybitFuturesPrices[pair]?.removeFirst()
            }
            
            print("‚úÖ [Bybit Futures] Updated price for \(pair): $\(price)")
            logAlert(event: "‚úÖ [Bybit Futures] Updated price for \(pair): $\(price)")
            
            // Update dashboard
            updateDashboardData()
        }
        
        // Extract volume if available
        if let volumeStr = data["volume24h"] as? String,
           let volume = Double(volumeStr) {
            bybitFuturesVolume[pair, default: []].append(volume)
            if bybitFuturesVolume[pair]!.count > priceHistoryRetention {
                bybitFuturesVolume[pair]?.removeFirst()
            }
        }
        
        // Extract funding rate if available
        if let fundingRateStr = data["fundingRate"] as? String,
           let fundingRate = Double(fundingRateStr) {
            bybitFundingRates[pair] = fundingRate
            bybitFundingRateHistory[pair, default: []].append(fundingRate)
            if bybitFundingRateHistory[pair]!.count > priceHistoryRetention {
                bybitFuturesPrices[pair]?.removeFirst()
            }
        }
    }
}

// ENHANCED: KuCoin Spot Message Processing
@MainActor
static func processKuCoinSpotMessage(_ json: [String: Any]) {
    guard let type = json["type"] as? String, type == "message",
          let topic = json["topic"] as? String,
          topic.hasPrefix("/market/ticker:"),
          let dataDict = json["data"] as? [String: Any] else {
        print("DEBUG: Invalid KuCoin Spot message format")
        return
    }
    
    let priceKeys = ["price", "last", "bestAsk", "bestBid"]
    var priceStr: String?
    for key in priceKeys {
        if let value = dataDict[key] as? String {
            priceStr = value
            break
        }
    }
    
    guard let priceStr = priceStr else {
        print("Failed to find price in KuCoin Spot message. Available keys: \(dataDict.keys)")
        return
    }
    
    // Fix ambiguous type expression by being explicit
    guard let price: Double = Double(priceStr) else {
        print("Failed to parse price '\(priceStr)' from KuCoin Spot message")
        return
    }
    
  //  let spotSymbol = topic.components(separatedBy: ":").last ?? ""
   // let pair = convertSymbolToPair(symbol: spotSymbol, isFutures: false)
    
    let spotSymbol = topic.components(separatedBy: ":").last ?? ""
    let pair = spotSymbol  // Use as-is since KuCoin sends PEPE-USDT format
    
   
    
    kucoinCurrentPrice[pair] = price
    kucoinPrices[pair, default: []].append(price)
    
    if kucoinPrices[pair]!.count > priceHistoryRetention {
        kucoinPrices[pair]!.removeFirst()
    }
    
    // Process volume if available
    if let volStr = dataDict["size"] as? String ?? dataDict["volume"] as? String,
       let vol: Double = Double(volStr) {
        kucoinSpotVolume[pair, default: []].append(vol)
        if kucoinSpotVolume[pair]!.count > priceHistoryRetention {
            kucoinSpotVolume[pair]!.removeFirst()
        }
    }
    
    print("‚úÖ [KuCoin Spot] Updated price for \(pair): $\(price)")
    logAlert(event: "‚úÖ KuCoin Spot price update: \(pair) = $\(price)")
}

// ENHANCED: KuCoin Futures Message Processing
@MainActor
static func processKuCoinFuturesMessage(_ json: [String: Any]) {
    guard let type = json["type"] as? String, type == "message",
          let topic = json["topic"] as? String,
          let dataDict = json["data"] as? [String: Any] else {
        print("DEBUG: Invalid KuCoin Futures message format")
        return
    }
    
    if topic.hasPrefix("/contractMarket/tickerV2:") {
        processKuCoinFuturesTicker(topic: topic, data: dataDict)
    } else if topic.hasPrefix("/contractMarket/level2:") {
        processKuCoinFuturesOrderBook(topic: topic, data: dataDict)
    } else if topic.hasPrefix("/contract/instrument:") {
        processKuCoinFuturesFunding(topic: topic, data: dataDict)
    }
}

@MainActor
private static func processKuCoinFuturesTicker(topic: String, data: [String: Any]) {
    let priceKeys = ["bestAskPrice", "bestBidPrice", "lastPrice", "indexPrice"]
    var priceStr: String?
    for key in priceKeys {
        if let value = data[key] as? String {
            priceStr = value
            break
        }
    }
    
    guard let priceStr = priceStr,
          let price: Double = Double(priceStr) else {
        print("Failed to find/parse price in KuCoin Futures message")
        return
    }
    
    let futuresSymbol = topic.components(separatedBy: ":").last ?? ""
    guard let pair = kucoinFuturesSymbols.first(where: { $0.value == futuresSymbol })?.key else {
        print("No pair found for futures symbol: \(futuresSymbol)")
        return
    }
    
    kucoinCurrentFuturesPrice[pair] = price
    kucoinFuturesPrices[pair, default: []].append(price)
    
    if kucoinFuturesPrices[pair]!.count > priceHistoryRetention {
        kucoinFuturesPrices[pair]!.removeFirst()
    }
    
    // Process volume
    if let volStr = data["volume"] as? String ?? data["size"] as? String,
       let vol: Double = Double(volStr) {
        kucoinFuturesVolume[pair, default: []].append(vol)
        if kucoinFuturesVolume[pair]!.count > priceHistoryRetention {
            kucoinFuturesVolume[pair]!.removeFirst()
        }
    }
    
    print("‚úÖ [KuCoin Futures] Updated price for \(pair): $\(price)")
    logAlert(event: "‚úÖ KuCoin Futures price update: \(pair) = $\(price)")
}

@MainActor
private static func processKuCoinFuturesOrderBook(topic: String, data: [String: Any]) {
    let futuresSymbol = topic.components(separatedBy: ":").last ?? ""
    guard let pair = kucoinFuturesSymbols.first(where: { $0.value == futuresSymbol })?.key else {
        print("No pair found for futures symbol: \(futuresSymbol)")
        return
    }
    
    var orderBook: [(price: Double, volume: Double, side: String)] = []
    
    if let bids = data["bids"] as? [[String]],
       let asks = data["asks"] as? [[String]] {
        // Snapshot
        for bid in bids {
            if let priceStr = bid.first, let qtyStr = bid.last,
               let price: Double = Double(priceStr),
               let qty: Double = Double(qtyStr), qty > 0 {
                orderBook.append((price: price, volume: qty, side: "buy"))
            }
        }
        for ask in asks {
            if let priceStr = ask.first, let qtyStr = ask.last,
               let price: Double = Double(priceStr),
               let qty: Double = Double(qtyStr), qty > 0 {
                orderBook.append((price: price, volume: qty, side: "sell"))
            }
        }
    } else if let change = data["change"] as? String {
        // Incremental update
        orderBook = kucoinFuturesOrderBook[pair] ?? []
        let components = change.components(separatedBy: ",")
        if components.count == 3,
           let price: Double = Double(components[0]),
           let size: Double = Double(components[2]) {
            let side = components[1].lowercased() == "buy" ? "buy" : "sell"
            orderBook.removeAll { $0.price == price && $0.side == side }
            if size > 0 {
                orderBook.append((price: price, volume: size, side: side))
            }
        }
    }
    
    kucoinFuturesOrderBook[pair] = orderBook
    print("DEBUG: Updated KuCoin futures order book for \(pair): \(orderBook.count) entries")
}

@MainActor
private static func processKuCoinFuturesFunding(topic: String, data: [String: Any]) {
    guard let fundingRateStr = data["fundingRate"] as? String,
          let fundingRate: Double = Double(fundingRateStr),
          let futuresSymbol = topic.components(separatedBy: ":").last,
          let pair = kucoinFuturesSymbols.first(where: { $0.value == futuresSymbol })?.key else {
        return
    }
    
    kucoinFundingRates[pair] = fundingRate
    kucoinFundingRateHistory[pair, default: []].append(fundingRate)
    
    if kucoinFundingRateHistory[pair]!.count > 24 { // Keep 24 hours of history
        kucoinFundingRateHistory[pair]!.removeFirst()
    }
    
    print("‚úÖ [KuCoin Futures] Updated funding rate for \(pair): \(fundingRate)")
    logAlert(event: "‚úÖ KuCoin Funding rate update: \(pair) = \(fundingRate * 100)%")
}
    
    
