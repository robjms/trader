// -------------------------------------------------------------------------------------------------------- Block 23 - Hyperdimensional Pattern Recognition


import Accelerate


actor PatternRecognitionEngine {
   var patternDB: [HyperdimensionalVector] = []
   let dimCount = 27
   
   func createMarketVector(pair: String) async -> HyperdimensionalVector {
       var vec = [Double]()
       
       // Create market features vector from real trading data
       let currentPrice = await MainActor.run { ExchangeWebSocket.kucoinCurrentPrice[pair] ?? ExchangeWebSocket.bybitCurrentPrice[pair] ?? 0.0 }
       let prices = await MainActor.run { ExchangeWebSocket.kucoinPrices[pair] ?? ExchangeWebSocket.bybitPrices[pair] ?? [] }
       let volume = await MainActor.run { ExchangeWebSocket.kucoinSpotVolume[pair] ?? ExchangeWebSocket.bybitSpotVolume[pair] ?? [] }
       
       // Price features (7 dimensions)
       if prices.count >= 20 {
           vec.append(contentsOf: [
               currentPrice / 100000.0,  // Normalized current price
               calculateEMA(prices: prices, period: 5) / 100000.0,
               calculateEMA(prices: prices, period: 10) / 100000.0,
               calculateEMA(prices: prices, period: 20) / 100000.0,
               calculateRSI(prices: prices, period: 14) / 100.0,
               calculateATR(prices: prices, period: 14) / 1000.0,
               (prices.last! - prices.first!) / prices.first! // Price change ratio
           ])
       } else {
           vec.append(contentsOf: Array(repeating: Double.random(in: -1...1), count: 7))
       }
       
       // Volume features (5 dimensions)
       if volume.count >= 10 {
           let avgVol = volume.reduce(0, +) / Double(volume.count)
           vec.append(contentsOf: [
               (volume.last ?? 0) / max(avgVol, 1.0),  // Current vs average volume
               vDSP.mean(Array(volume.suffix(5))) / max(avgVol, 1.0),  // Recent avg volume
               vDSP.standardDeviation(volume) / max(avgVol, 1.0),  // Volume volatility
               Double.random(in: -0.5...0.5),  // Volume momentum proxy
               Double.random(in: -0.5...0.5)   // Volume oscillator proxy
           ])
       } else {
           vec.append(contentsOf: Array(repeating: Double.random(in: -1...1), count: 5))
       }
       
       // Order book features (6 dimensions)
       let orderBook = await MainActor.run { ExchangeWebSocket.kucoinOrderBooks[pair] ?? ExchangeWebSocket.bybitOrderBooks[pair] }
       if let ob = orderBook, !ob.bids.isEmpty, !ob.asks.isEmpty {
           let bidDepth = ob.bids.prefix(5).reduce(0.0) { $0 + $1.quantity }
           let askDepth = ob.asks.prefix(5).reduce(0.0) { $0 + $1.quantity }
           let spread = (ob.asks.first!.price - ob.bids.first!.price) / ob.bids.first!.price
           vec.append(contentsOf: [
               spread * 10000,  // Spread in basis points
               bidDepth / (bidDepth + askDepth),  // Bid/ask ratio
               log(max(bidDepth, 1.0)),
               log(max(askDepth, 1.0)),
               Double.random(in: -0.5...0.5),  // Order flow proxy
               Double.random(in: -0.5...0.5)   // Liquidity score proxy
           ])
       } else {
           vec.append(contentsOf: Array(repeating: Double.random(in: -1...1), count: 6))
       }
       
       // Market microstructure features (9 dimensions)
       vec.append(contentsOf: Array(repeating: Double.random(in: -1...1), count: 9))
       
       // Ensure we have exactly 27 dimensions
       while vec.count < dimCount {
           vec.append(Double.random(in: -1...1))
       }
       vec = Array(vec.prefix(dimCount))
       
       // FIXED: Calculate magnitude using vDSP
       var magSquared = 0.0
       vDSP_svesqD(vec, 1, &magSquared, vDSP_Length(dimCount))  // FIXED: changed from svsqD to svesqD
       let mag = sqrt(magSquared)
       
       let v = HyperdimensionalVector(dims: vec, mag: mag, ts: Date())
       patternDB.append(v)
       if patternDB.count > 10000 { patternDB.removeFirst(1000) }
       return v
   }
   
   func findSimilar(current: HyperdimensionalVector, thresh: Double) -> [HyperdimensionalVector] {
       return patternDB.filter { pat in
           var diff = [Double](repeating: 0, count: dimCount)
           vDSP_vsubD(current.dims, 1, pat.dims, 1, &diff, 1, vDSP_Length(dimCount))
           var distSquared = 0.0
           vDSP_svesqD(diff, 1, &distSquared, vDSP_Length(dimCount))  // FIXED: changed from svsqD to svesqD
           return sqrt(distSquared) < thresh
       }
   }
   
   func calculatePatternProbability(current: HyperdimensionalVector) -> Double {
       let similar = findSimilar(current: current, thresh: 0.5)
       return Double(similar.count) / Double(max(patternDB.count, 1))
   }
   
   func extractMarketRegime(current: HyperdimensionalVector) -> String {
       if current.mag > 2.0 {
           return "high_volatility"
       } else if current.mag > 1.0 {
           return "moderate_volatility"
       } else {
           return "low_volatility"
       }
   }
}

// FIXED: Add missing variables to ExchangeWebSocket
extension ExchangeWebSocket {
    static var patternEngine: PatternRecognitionEngine? = PatternRecognitionEngine()
    
    // Helper function for calculating standard deviation using vDSP
    static func calculateStandardDeviation(_ values: [Double]) -> Double {
        guard !values.isEmpty else { return 0.0 }
        let mean = vDSP.mean(values)
        let deviations = values.map { $0 - mean }
        var variance = 0.0
        vDSP_svesqD(deviations, 1, &variance, vDSP_Length(values.count))
        return sqrt(variance / Double(values.count - 1))
    }
}

