// --------------------------------------------------------- Block 24 - Temporal Prediction Engine




actor TemporalOracle {
    var preds: [String: [TemporalPrediction]] = [:]
    let horizons: [TimeInterval] = [0.05, 0.1, 0.2, 0.5, 1.0, 5.0, 30.0, 60.0, 300.0]
    var modelWeights: [[Double]] = []
    
    init() {
        // Initialize simple prediction model weights
        modelWeights = (0..<horizons.count).map { _ in
            (0..<10).map { _ in Double.random(in: -0.1...0.1) }
        }
    }
    
    func predictFuture(pair: String) async -> [TemporalPrediction] {
        let currentPrice = await MainActor.run {
            ExchangeWebSocket.kucoinCurrentPrice[pair] ?? ExchangeWebSocket.bybitCurrentPrice[pair] ?? 0.0
        }
        let prices = await MainActor.run {
            ExchangeWebSocket.kucoinPrices[pair] ?? ExchangeWebSocket.bybitPrices[pair] ?? []
        }
        
        var predictions: [TemporalPrediction] = []
        
        for (index, horizon) in horizons.enumerated() {
            let features = extractFeatures(prices: prices, currentPrice: currentPrice)
            let prediction = generatePrediction(features: features, weights: modelWeights[index], horizon: horizon, currentPrice: currentPrice)
            predictions.append(prediction)
        }
        
        // Sort by confidence (highest first)
        predictions.sort { $0.conf > $1.conf }
        preds[pair] = predictions
        return predictions
    }
    
    private func extractFeatures(prices: [Double], currentPrice: Double) -> [Double] {
        guard prices.count >= 10 else {
            return Array(repeating: 0.5, count: 10)
        }
        
        var features: [Double] = []
        
        // Price momentum features
        let recent5 = Array(prices.suffix(5))
        let recent10 = Array(prices.suffix(10))
        features.append(vDSP.mean(recent5) / max(vDSP.mean(recent10), 1.0))
        
        // Volatility features
        let returns = zip(prices.dropFirst(), prices).map { ($0 - $1) / $1 }
        features.append(vDSP.standardDeviation(Array(returns.suffix(10))))
        
        // Trend features
        features.append((currentPrice - prices.first!) / prices.first!)
        
        // RSI-like feature
        let rsi = calculateRSI(prices: prices, period: 14)
        features.append(rsi / 100.0)
        
        // Price position features
        let maxPrice = prices.max() ?? currentPrice
        let minPrice = prices.min() ?? currentPrice
        features.append((currentPrice - minPrice) / max(maxPrice - minPrice, 1.0))
        
        // Volume proxy (using price variance as proxy)
        features.append(vDSP.standardDeviation(Array(prices.suffix(5))))
        
        // Add more features to reach 10
        features.append(contentsOf: Array(repeating: Double.random(in: 0...1), count: max(0, 10 - features.count)))
        
        return Array(features.prefix(10))
    }
    
    private func generatePrediction(features: [Double], weights: [Double], horizon: TimeInterval, currentPrice: Double) -> TemporalPrediction {
        // Simple linear prediction model
        var prediction = 0.0
        for (feature, weight) in zip(features, weights) {
            prediction += feature * weight
        }
        
        // Convert to price prediction
        let pricePrediction = currentPrice * (1.0 + tanh(prediction) * 0.05)  // Max 5% change
        
        // Calculate confidence based on feature stability
        let featureVariance = vDSP.standardDeviation(features)
        let confidence = max(0.1, min(0.95, 1.0 - featureVariance))
        
        // Calculate probability based on historical accuracy (simplified)
        let probability = max(0.4, min(0.9, confidence * Double.random(in: 0.8...1.2)))
        
        return TemporalPrediction(
            predPrice: max(0.1, pricePrediction),  // Ensure positive price
            conf: confidence,
            horizon: horizon,
            prob: probability
        )
    }
    
    func updateModel(pair: String, actualPrice: Double, horizon: TimeInterval) async {
        // Simple model update (learning rate = 0.01)
        guard let predictions = preds[pair],
              let targetPrediction = predictions.first(where: { $0.horizon == horizon }) else { return }
        
        let error = actualPrice - targetPrediction.predPrice
        let learningRate = 0.01
        
        // Update weights based on prediction error
        if let horizonIndex = horizons.firstIndex(of: horizon) {
            for i in modelWeights[horizonIndex].indices {
                modelWeights[horizonIndex][i] -= learningRate * error * Double.random(in: -0.1...0.1)
            }
        }
    }
    
    func getBestPrediction(pair: String, maxHorizon: TimeInterval = 300.0) -> TemporalPrediction? {
        return preds[pair]?.first { $0.horizon <= maxHorizon }
    }
    
    func getAveragePrediction(pair: String, maxHorizon: TimeInterval = 300.0) -> TemporalPrediction? {
        let validPredictions = preds[pair]?.filter { $0.horizon <= maxHorizon } ?? []
        guard !validPredictions.isEmpty else { return nil }
        
        let avgPrice = validPredictions.map { $0.predPrice }.reduce(0, +) / Double(validPredictions.count)
        let avgConf = validPredictions.map { $0.conf }.reduce(0, +) / Double(validPredictions.count)
        let avgProb = validPredictions.map { $0.prob }.reduce(0, +) / Double(validPredictions.count)
        let avgHorizon = validPredictions.map { $0.horizon }.reduce(0, +) / Double(validPredictions.count)
        
        return TemporalPrediction(
            predPrice: avgPrice,
            conf: avgConf,
            horizon: avgHorizon,
            prob: avgProb
        )
    }
}

// FIXED: Add missing variables to ExchangeWebSocket
extension ExchangeWebSocket {
    static var temporalOracle: TemporalOracle? = TemporalOracle()
}
