
extension ExchangeWebSocket {
    static func checkLiquidity(exchange: String, pair: String, completion: @escaping @Sendable (Double?) -> Void) {
        let tradeAmount = getDouble("SPOT_TRADE_AMOUNT", defaultValue: 50.0)
        let currentPrice = exchange == "bybit" ? (bybitCurrentPrice[pair] ?? lastPriceUpdate[pair]?.price ?? 1.0) : (kucoinCurrentPrice[pair] ?? lastPriceUpdate[pair]?.price ?? 1.0)
        let requiredLiquidity = tradeAmount * currentPrice * liquidityDepthMultiplier
        let minLiquidityThresholdValue = minLiquidityThreshold
        
        Task { @MainActor in
            // Fix: Use async/await to handle MainActor-isolated fetchOrderBookDepth
            let spotDepth = await withCheckedContinuation { continuation in
                fetchOrderBookDepthFixed(exchange: exchange, pair: pair, marketType: "spot") { depth in
                    continuation.resume(returning: depth)
                }
            }
            let futuresDepth = await withCheckedContinuation { continuation in
                fetchOrderBookDepthFixed(exchange: exchange, pair: pair, marketType: "futures") { depth in
                    continuation.resume(returning: depth)
                }
            }
            
            let spotDepthValue = spotDepth ?? minLiquidityThresholdValue
            let futuresDepthValue = futuresDepth ?? minLiquidityThresholdValue
            let totalLiquidity = spotDepthValue + futuresDepthValue
            
            // ENHANCED: Basic liquidity analysis using existing variables
            let liquidityScore = calculateBasicLiquidityScore(totalLiquidity: totalLiquidity)
            print("DEBUG: Liquidity score for \(exchange)-\(pair): \(liquidityScore)")
            
            if totalLiquidity < requiredLiquidity {
                print("Insufficient liquidity for \(exchange)-\(pair): Depth \(totalLiquidity), Required \(requiredLiquidity)")
                logAlert(event: "Insufficient liquidity for \(exchange)-\(pair): Depth \(totalLiquidity), Required \(requiredLiquidity), Score: \(liquidityScore)")
                completion(nil)
            } else {
                print("DEBUG: Liquidity check passed for \(exchange)-\(pair): Depth \(totalLiquidity), Score: \(liquidityScore)")
                completion(totalLiquidity)
            }
        }
    }

    // FIXED: Enhanced order book processing with better error handling
    static func fetchOrderBookDepthFixed(exchange: String, pair: String, marketType: String, retryCount: Int = 0, completion: @escaping @Sendable (Double?) -> Void) {
        let maxRetries = getInt("API_MAX_RETRIES", defaultValue: 3)
        guard retryCount < maxRetries else {
            print("Max retries reached for order book fetch: \(exchange)-\(pair)-\(marketType)")
            Task { @MainActor in
                logAlert(event: "Max retries reached for order book fetch: \(exchange)-\(pair)-\(marketType)")
            }
            // Use fallback depth calculation
            let fallbackDepth = minLiquidityThreshold * 2.0
            print("DEBUG: Using fallback depth for \(exchange)-\(pair)-\(marketType): \(fallbackDepth)")
            completion(fallbackDepth)
            return
        }
        
        // FIXED: Improved URL building with proper symbol formatting
        var url: URL?
        let symbol = pair.replacingOccurrences(of: "-USDT", with: "USDT")
        
        if exchange == "bybit" {
            let category = marketType == "spot" ? "spot" : "linear"
            url = URL(string: "https://api.bybit.com/v5/market/orderbook?category=\(category)&symbol=\(symbol)&limit=25")
        } else if exchange == "kucoin" {
            if marketType == "spot" {
                url = URL(string: "https://api.kucoin.com/api/v1/market/orderbook/level2_20?symbol=\(symbol)")
            } else {
                let futuresSymbol = kucoinFuturesSymbols[pair] ?? "\(symbol)M"
                url = URL(string: "https://api-futures.kucoin.com/api/v1/level2/snapshot?symbol=\(futuresSymbol)")
            }
        }

        guard let requestUrl = url else {
            print("Invalid order book URL for \(exchange)-\(pair)-\(marketType)")
            Task { @MainActor in
                logAlert(event: "Invalid order book URL for \(exchange)-\(pair)-\(marketType)")
            }
            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                fetchOrderBookDepthFixed(exchange: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1, completion: completion)
            }
            return
        }

        var request = URLRequest(url: requestUrl)
        request.httpMethod = "GET"
        request.timeoutInterval = 8.0  // Reduced timeout
        request.setValue("application/json", forHTTPHeaderField: "Accept")

        let startTime = Date()
        URLSession.shared.dataTask(with: request) { data, response, error in
            let latency = Date().timeIntervalSince(startTime) * 1000
            Task { @MainActor in
                lastLatency[pair] = latency
                if latency > 1000 {  // 1 second threshold
                    print("High latency detected for order book fetch: \(latency)ms")
                    logAlert(event: "High latency detected for order book fetch: \(latency)ms")
                }
            }

            if let error = error {
                print("Failed to fetch order book for \(exchange)-\(pair)-\(marketType): \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to fetch order book for \(exchange)-\(pair)-\(marketType): \(error.localizedDescription)")
                }
                DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                    fetchOrderBookDepthFixed(exchange: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1, completion: completion)
                }
                return
            }

            guard let httpResponse = response as? HTTPURLResponse else {
                print("Invalid HTTP response for \(exchange)-\(pair)-\(marketType)")
                Task { @MainActor in
                    logAlert(event: "Invalid HTTP response for \(exchange)-\(pair)-\(marketType)")
                }
                DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                    fetchOrderBookDepthFixed(exchange: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1, completion: completion)
                }
                return
            }

            // FIXED: Better HTTP status code handling
            guard httpResponse.statusCode == 200 else {
                print("HTTP error \(httpResponse.statusCode) for \(exchange)-\(pair)-\(marketType)")
                Task { @MainActor in
                    logAlert(event: "HTTP error \(httpResponse.statusCode) for \(exchange)-\(pair)-\(marketType)")
                }
                if httpResponse.statusCode == 429 {
                    // Rate limited, wait longer
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5.0) {
                        fetchOrderBookDepthFixed(exchange: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1, completion: completion)
                    }
                } else {
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                        fetchOrderBookDepthFixed(exchange: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1, completion: completion)
                    }
                }
                return
            }

            guard let data = data, !data.isEmpty else {
                print("Empty response data for \(exchange)-\(pair)-\(marketType)")
                Task { @MainActor in
                    logAlert(event: "Empty response data for \(exchange)-\(pair)-\(marketType)")
                }
                DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                    fetchOrderBookDepthFixed(exchange: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1, completion: completion)
                }
                return
            }

            do {
                guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
                    print("Failed to parse JSON for \(exchange)-\(pair)-\(marketType)")
                    Task { @MainActor in
                        logAlert(event: "Failed to parse JSON for \(exchange)-\(pair)-\(marketType)")
                    }
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                        fetchOrderBookDepthFixed(exchange: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1, completion: completion)
                    }
                    return
                }

                // FIXED: Enhanced parsing for different exchange formats
                var totalDepth: Double = 0.0
                
                if exchange == "bybit" {
                    if let result = json["result"] as? [String: Any],
                       let bids = result["b"] as? [[String]],
                       let asks = result["a"] as? [[String]] {
                        totalDepth = calculateDepthFromArrays(bids: bids, asks: asks)
                        Task { @MainActor in
                            updateOrderBookCache(exchange: exchange, pair: pair, marketType: marketType, bids: bids, asks: asks)
                        }
                    } else {
                        throw NSError(domain: "ParseError", code: 1, userInfo: [NSLocalizedDescriptionKey: "Failed to parse Bybit response"])
                    }
                } else if exchange == "kucoin" {
                    if let data = json["data"] as? [String: Any] {
                        if marketType == "spot" {
                            if let bids = data["bids"] as? [[String]],
                               let asks = data["asks"] as? [[String]] {
                                totalDepth = calculateDepthFromArrays(bids: bids, asks: asks)
                                Task { @MainActor in
                                    updateOrderBookCache(exchange: exchange, pair: pair, marketType: marketType, bids: bids, asks: asks)
                                }
                            } else {
                                throw NSError(domain: "ParseError", code: 2, userInfo: [NSLocalizedDescriptionKey: "Failed to parse KuCoin spot response"])
                            }
                        } else {
                            // KuCoin futures format
                            if let bids = data["bids"] as? [[Double]],
                               let asks = data["asks"] as? [[Double]] {
                                totalDepth = calculateDepthFromDoubleArrays(bids: bids, asks: asks)
                            } else {
                                throw NSError(domain: "ParseError", code: 3, userInfo: [NSLocalizedDescriptionKey: "Failed to parse KuCoin futures response"])
                            }
                        }
                    } else {
                        throw NSError(domain: "ParseError", code: 4, userInfo: [NSLocalizedDescriptionKey: "No data field in KuCoin response"])
                    }
                }

                print("DEBUG: Successfully fetched order book depth for \(exchange)-\(pair)-\(marketType): \(totalDepth)")
                Task { @MainActor in
                    logAlert(event: "Updated order book for \(exchange)-\(pair)-\(marketType)")
                }
                completion(totalDepth)

            } catch {
                print("Error parsing order book data for \(exchange)-\(pair)-\(marketType): \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Error parsing order book data for \(exchange)-\(pair)-\(marketType): \(error.localizedDescription)")
                }
                DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                    fetchOrderBookDepthFixed(exchange: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1, completion: completion)
                }
            }
        }.resume()
    }
    
    // FIXED: Helper function to calculate depth from string arrays
    private static func calculateDepthFromArrays(bids: [[String]], asks: [[String]]) -> Double {
        var bidDepth: Double = 0.0
        var askDepth: Double = 0.0
        
        for bid in bids.prefix(10) {
            if bid.count >= 2, let price = Double(bid[0]), let quantity = Double(bid[1]), price > 0, quantity > 0 {
                bidDepth += price * quantity
            }
        }
        
        for ask in asks.prefix(10) {
            if ask.count >= 2, let price = Double(ask[0]), let quantity = Double(ask[1]), price > 0, quantity > 0 {
                askDepth += price * quantity
            }
        }
        
        return bidDepth + askDepth
    }
    
    // FIXED: Helper function to calculate depth from double arrays
    private static func calculateDepthFromDoubleArrays(bids: [[Double]], asks: [[Double]]) -> Double {
        var bidDepth: Double = 0.0
        var askDepth: Double = 0.0
        
        for bid in bids.prefix(10) {
            if bid.count >= 2, bid[0] > 0, bid[1] > 0 {
                bidDepth += bid[0] * bid[1]
            }
        }
        
        for ask in asks.prefix(10) {
            if ask.count >= 2, ask[0] > 0, ask[1] > 0 {
                askDepth += ask[0] * ask[1]
            }
        }
        
        return bidDepth + askDepth
    }
    
    // FIXED: Update order book cache with validation
    @MainActor
    private static func updateOrderBookCache(exchange: String, pair: String, marketType: String, bids: [[String]], asks: [[String]]) {
        guard !bids.isEmpty, !asks.isEmpty else { return }
        
        let parsedBids: [(price: Double, quantity: Double)] = bids.prefix(10).compactMap { bid in
            if bid.count >= 2, let price = Double(bid[0]), let quantity = Double(bid[1]), price > 0, quantity > 0 {
                return (price: price, quantity: quantity)
            }
            return nil
        }
        
        let parsedAsks: [(price: Double, quantity: Double)] = asks.prefix(10).compactMap { ask in
            if ask.count >= 2, let price = Double(ask[0]), let quantity = Double(ask[1]), price > 0, quantity > 0 {
                return (price: price, quantity: quantity)
            }
            return nil
        }
        
        guard !parsedBids.isEmpty, !parsedAsks.isEmpty else { return }
        
        let orderBook = BevaixOrderBook(bids: parsedBids, asks: parsedAsks)
        
        if exchange == "kucoin" {
            kucoinOrderBooks[pair] = orderBook
        } else {
            bybitOrderBooks[pair] = orderBook
        }
        
        // Analyze order book health
        let imbalance = calculateOrderBookImbalance(book: orderBook)
        if imbalance > maxOrderBookImbalance {
            logAlert(event: "Order book imbalance detected for \(exchange)-\(pair): \(String(format: "%.2f", imbalance))")
        }
    }

    static func checkLiquidityAsync(exchange: String, pair: String, marketType: String, tradeAmount: Double, price: Double) async -> Double? {
        await withCheckedContinuation { continuation in
            checkLiquidity(exchange: exchange, pair: pair) { liquidity in
                continuation.resume(returning: liquidity)
            }
        }
    }
    
    // ENHANCED FEATURES: Using only existing variables
    
    static func calculateBasicLiquidityScore(totalLiquidity: Double) -> Double {
        let baseThreshold = minLiquidityThreshold
        let ratio = totalLiquidity / baseThreshold
        
        if ratio >= 10 { return 100 }
        else if ratio >= 5 { return 85 }
        else if ratio >= 3 { return 70 }
        else if ratio >= 2 { return 55 }
        else if ratio >= 1 { return 40 }
        else { return 20 }
    }
    
    @MainActor
    static func analyzeOrderBookBasic(exchange: String, pair: String, marketType: String) {
        let orderBook = exchange == "bybit" ?
            bybitOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: []) :
            kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
        
        guard !orderBook.bids.isEmpty && !orderBook.asks.isEmpty else { return }
        
        // Calculate basic spread metrics
        let bestBid = orderBook.bids.first?.price ?? 0
        let bestAsk = orderBook.asks.first?.price ?? 0
        let spread = bestAsk - bestBid
        let midPrice = (bestBid + bestAsk) / 2
        let spreadPercent = midPrice > 0 ? (spread / midPrice) * 100 : 0
        
        // Analyze basic order book imbalance
        let bidVolume = orderBook.bids.prefix(5).reduce(0) { $0 + $1.quantity }
        let askVolume = orderBook.asks.prefix(5).reduce(0) { $0 + $1.quantity }
        let totalVolume = bidVolume + askVolume
        let imbalance = totalVolume > 0 ? abs(bidVolume - askVolume) / totalVolume : 0
        
        // Log significant findings using existing logging
        if spreadPercent > 0.2 {
            logAlert(event: "Wide spread detected for \(exchange)-\(pair): \(String(format: "%.3f", spreadPercent))%")
        }
        
        if imbalance > 0.4 {
            logAlert(event: "Order book imbalance detected for \(exchange)-\(pair): \(String(format: "%.1f", imbalance * 100))%")
        }
        
        // Basic large order detection
        detectBasicLargeOrders(exchange: exchange, pair: pair, orderBook: orderBook)
    }
    
    @MainActor
    static func detectBasicLargeOrders(exchange: String, pair: String, orderBook: BevaixOrderBook) {
        guard !orderBook.bids.isEmpty && !orderBook.asks.isEmpty else { return }
        
        let avgBidSize = orderBook.bids.reduce(0) { $0 + $1.quantity } / Double(orderBook.bids.count)
        let avgAskSize = orderBook.asks.reduce(0) { $0 + $1.quantity } / Double(orderBook.asks.count)
        let avgSize = (avgBidSize + avgAskSize) / 2
        let largeOrderThreshold = avgSize * 5 // 5x average size
        
        var largeOrderCount = 0
        
        // Count large bids
        for bid in orderBook.bids {
            if bid.quantity > largeOrderThreshold {
                largeOrderCount += 1
            }
        }
        
        // Count large asks
        for ask in orderBook.asks {
            if ask.quantity > largeOrderThreshold {
                largeOrderCount += 1
            }
        }
        
        // Log if significant large orders found
        if largeOrderCount >= 3 {
            logAlert(event: "Multiple large orders detected in \(exchange)-\(pair): \(largeOrderCount) orders > \(String(format: "%.1f", largeOrderThreshold))")
        }
    }
    
    // Helper function for order book depth calculation
    static func calculateOrderBookDepth(_ orderBook: BevaixOrderBook) -> Double {
        let bidDepth = orderBook.bids.prefix(10).reduce(0) { $0 + ($1.price * $1.quantity) }
        let askDepth = orderBook.asks.prefix(10).reduce(0) { $0 + ($1.price * $1.quantity) }
        return bidDepth + askDepth
    }
    
    // ENHANCED: Cross-exchange liquidity comparison using existing variables
    @MainActor
    static func compareExchangeLiquidity(pair: String) -> String {
        let bybitBook = bybitOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
        let kucoinBook = kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
        
        let bybitDepth = calculateOrderBookDepth(bybitBook)
        let kucoinDepth = calculateOrderBookDepth(kucoinBook)
        
        let result = bybitDepth > kucoinDepth ? "bybit" : "kucoin"
        let diff = abs(bybitDepth - kucoinDepth)
        
        print("DEBUG: Liquidity comparison for \(pair) - Bybit: \(bybitDepth), KuCoin: \(kucoinDepth), Best: \(result)")
        
        if diff > 1000 { // Significant difference
            logAlert(event: "Significant liquidity difference for \(pair): \(result) has \(String(format: "%.0f", diff)) more depth")
        }
        
        return result
    }
    
    // ENHANCED: Real-time order book health check
    @MainActor
    static func checkOrderBookHealth(exchange: String, pair: String) -> Bool {
        let orderBook = exchange == "bybit" ?
            bybitOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: []) :
            kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
        
        // Basic health checks
        let hasSufficientLevels = orderBook.bids.count >= 5 && orderBook.asks.count >= 5
        let hasValidSpread = orderBook.bids.first?.price ?? 0 < (orderBook.asks.first?.price ?? Double.infinity)
        
        if !hasSufficientLevels {
            logAlert(event: "Insufficient order book levels for \(exchange)-\(pair): bids=\(orderBook.bids.count), asks=\(orderBook.asks.count)")
        }
        
        if !hasValidSpread {
            logAlert(event: "Invalid spread detected for \(exchange)-\(pair) - possible data issue")
        }
        
        return hasSufficientLevels && hasValidSpread
    }
}


