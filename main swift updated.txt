//--------------- Block 1 - Core Data Structures and Utilities
// VARIABLES TO ADD: None - All variables included in this block

@preconcurrency import Starscream
import Foundation
import SwiftDotenv
import CryptoKit

// FIXED: Add AgentType enum at the top to resolve "Cannot find type 'AgentType'" errors
enum AgentType: String, CaseIterable {
    case momentum, meanReversion, marketMaking, hft
}

// FIXED: Add single definitions of types to resolve ambiguous type lookup errors
struct HyperdimensionalVector {
    let dims: [Double]
    let mag: Double
    let ts: Date
}

struct TemporalPrediction {
    let horizon: TimeInterval
    let predPrice: Double
    let conf: Double
    let prob: Double
}

// BevaixOrderBook struct definition to avoid conflicts
struct BevaixOrderBook {
    var bids: [(price: Double, quantity: Double)]
    var asks: [(price: Double, quantity: Double)]
    
    var isEmpty: Bool {
        return bids.isEmpty && asks.isEmpty
    }
}

// AI ENHANCEMENTS - Missing Types
class NeuralAgent {
    let id = UUID()
    var strength: Float = 0.5
    
    func evaluate(market: [Float]) -> Float {
        return market.reduce(0, +) / Float(max(market.count, 1)) * strength
    }
}

actor TemporalOracle {
    func predictFuture(pair: String) async -> [Double] {
        return [Double.random(in: 0.5...1.5)]
    }
}
struct QuantumState {
    let superposition: [Double]
    let entanglement: [String: Double]
    let collapseProb: Double
    let timestamp: Date
}

// Enhanced Structures for Advanced Trading
struct AdvancedSignal {
    let type: String
    let strength: Double
    let confidence: Double
    let timestamp: Date
    let pair: String
    let exchange: String
}

struct MLPrediction {
    let prediction: Double
    let confidence: Double
    let features: [String: Double]
    let timestamp: Date
    let model: String
}

struct PerformanceMetrics {
    var totalTrades: Int
    var winningTrades: Int
    var totalProfit: Double
    var totalFees: Double
    var averageLatency: Double
    var maxDrawdown: Double
    var sharpeRatio: Double
    var lastTradeTime: Date
}

struct RiskMetrics {
    var var95: Double // Value at Risk 95%
    var var99: Double // Value at Risk 99%
    var expectedShortfall: Double
    var maxDrawdown: Double
    var volatility: Double
    var correlation: Double
    var beta: Double
}

struct MarketCondition {
    let volatility: Double
    let trend: String
    let volume: Double
    let momentum: Double
    let timestamp: Date
}

struct TradingOpportunity {
    let pair: String
    let strategy: String
    let expectedProfit: Double
    let riskLevel: Double
    let confidence: Double
    let timeHorizon: TimeInterval
}

// Global Helper Methods for Type Conversion
func getDouble(_ key: String, defaultValue: Double) -> Double {
    guard let value = ProcessInfo.processInfo.environment[key], !value.isEmpty else {
        print("Environment variable \(key) not found or empty")
        return defaultValue
    }
    let cleanedValue = value.components(separatedBy: "#")[0].trimmingCharacters(in: .whitespaces)
    if let doubleValue = Double(cleanedValue) {
        return doubleValue
    } else {
        print("Could not parse \(key) as Double: \(cleanedValue)")
        return defaultValue
    }
}

func getInt(_ key: String, defaultValue: Int) -> Int {
    guard let value = ProcessInfo.processInfo.environment[key], !value.isEmpty else {
        print("Environment variable \(key) not found or empty")
        return defaultValue
    }
    let cleanedValue = value.components(separatedBy: "#")[0].trimmingCharacters(in: .whitespaces)
    if let intValue = Int(cleanedValue) {
        return intValue
    } else {
        print("Could not parse \(key) as Int: \(cleanedValue)")
        return defaultValue
    }
}

func getBool(_ key: String, defaultValue: Bool) async -> Bool {
    guard let stringValue = ProcessInfo.processInfo.environment[key] else {
        print("Warning: Could not parse \(key) as Bool, using default: \(defaultValue)")
        await MainActor.run {
            logAlert(event: "Could not parse \(key) as Bool, using default: \(defaultValue)")
        }
        return defaultValue
    }
    let cleanedValue = stringValue.components(separatedBy: "#")[0].trimmingCharacters(in: .whitespaces).lowercased()
    if cleanedValue == "true" || cleanedValue == "1" || cleanedValue == "yes" {
        return true
    } else if cleanedValue == "false" || cleanedValue == "0" || cleanedValue == "no" {
        return false
    } else {
        print("Warning: Could not parse \(key) as Bool: \(cleanedValue), using default: \(defaultValue)")
        await MainActor.run {
            logAlert(event: "Could not parse \(key) as Bool: \(cleanedValue), using default: \(defaultValue)")
        }
        return defaultValue
    }
}

func getString(_ key: String, defaultValue: String) -> String {
    guard let value = ProcessInfo.processInfo.environment[key], !value.isEmpty else {
        print("Environment variable \(key) not found or empty")
        return defaultValue
    }
    return value.components(separatedBy: "#")[0].trimmingCharacters(in: .whitespaces)
}

// Global Environment Variable Storage
// Global Environment Variable Storage
// Global Environment Variable Storage
// COMPLETE ENVIRONMENT LOADING FIX - Preserves ALL original functionality
// Replace the entire var environment: [String: String] = { ... }() section with this:

var hasValidKuCoinCredentials: Bool = true // Original flag preserved
var environment: [String: String] = {
    do {
        let fileManager = FileManager.default
        
        // FIXED: Try correct project path first, then fallback to current directory
        let projectRoot = "/Users/robertsteinegger/Desktop/BevaixBot"
        let projectEnvPath = URL(fileURLWithPath: projectRoot).appendingPathComponent(".env").path
        let currentDirectory = fileManager.currentDirectoryPath
        let currentEnvPath = URL(fileURLWithPath: currentDirectory).appendingPathComponent(".env").path
        
        var envPath = projectEnvPath
        var useProjectPath = true
        
        print("üîç Primary: Loading .env from \(projectEnvPath)")
        if fileManager.fileExists(atPath: projectEnvPath) {
            print("‚úÖ Found .env file at \(projectEnvPath)")
            envPath = projectEnvPath
        } else {
            print("‚ö†Ô∏è No .env file found at \(projectEnvPath)")
            print("üîç Fallback: Loading .env from \(currentEnvPath)")
            if fileManager.fileExists(atPath: currentEnvPath) {
                print("‚úÖ Found .env file at \(currentEnvPath)")
                envPath = currentEnvPath
                useProjectPath = false
            } else {
                print("‚ùå No .env file found at \(currentEnvPath)")
                Task { @MainActor in
                    logAlert(event: "No .env file found at \(projectEnvPath) or \(currentEnvPath)")
                }
            }
        }
        
        // FIXED: Set working directory to where .env file is located for SwiftDotenv
        if useProjectPath {
            fileManager.changeCurrentDirectoryPath(projectRoot)
        }
        
        // Try SwiftDotenv first (preserving original functionality)
        var envDict: [String: String] = [:]
        var swiftDotenvSuccess = false
        
        do {
            try Dotenv.configure()
            swiftDotenvSuccess = true
            print("‚úÖ SwiftDotenv configured successfully")
            print("SwiftDotenv version: \(Dotenv.version?.stringValue ?? "unknown")")
        } catch {
            print("‚ö†Ô∏è SwiftDotenv failed: \(error), falling back to manual parsing")
        }
        
        // COMPLETE original keys list - preserved exactly as in original code
        let keys = [
            "ACTIVE_PAIRS", "BYBIT_API_KEY", "BYBIT_API_SECRET", "KUCOIN_API_KEY",
            "KUCOIN_API_SECRET", "KUCOIN_API_PASSPHRASE", "BYBIT_RATE_WINDOW",
            "KUCOIN_LEVERAGE", "BYBIT_LEVERAGE", "LIQUIDITY_FEE_MULTIPLIER",
            "LIQUIDITY_PRICE_IMPACT_THRESHOLD", "ORDER_BOOK_PRICE_RANGE",
            "ORDER_BOOK_IMBALANCE_THRESHOLD", "MIN_LIQUIDITY_THRESHOLD",
            "MAX_ORDER_BOOK_IMBALANCE", "VOLATILITY_SPIKE_THRESHOLD",
            "VOLATILITY_SPIKE_WINDOW_MINUTES", "VOLATILITY_SPIKE_COOLDOWN_SECONDS",
            "VOLUME_ANOMALY_MULTIPLIER", "VOLUME_ANOMALY_WINDOW_HOURS",
            "VOLUME_ANOMALY_COOLDOWN_SECONDS", "FUTURES_TRADE_AMOUNT",
            "FUTURES_MIN_PROFIT_PERCENTAGE", "FUTURES_STOP_LOSS_PERCENTAGE",
            "FUTURES_TRAILING_STOP_PERCENTAGE", "FUTURES_SPIKE_RATE_STOP_PERCENTAGE",
            "MAX_ACTIVE_FUTURES_TRADES", "DAILY_LOSS_LIMIT_PERCENTAGE", "ATR_MULTIPLIER",
            "ARBITRAGE_MIN_BALANCE", "ARBITRAGE_TRADE_AMOUNT",
            "ARBITRAGE_MIN_SPREAD_THRESHOLD", "ARBITRAGE_HIGH_SPREAD_THRESHOLD",
            "CROSS_EXCHANGE_MIN_BALANCE", "CROSS_EXCHANGE_TRADE_AMOUNT",
            "CROSS_EXCHANGE_MIN_SPREAD_THRESHOLD",
            "CROSS_EXCHANGE_MIN_FUNDING_RATE_THRESHOLD",
            "CROSS_EXCHANGE_COOLDOWN_SECONDS", "VOLATILITY_PAUSE_SECONDS",
            "SPOT_TRADE_AMOUNT", "SPOT_FEE_RATE", "SPOT_MINUTE_PROFIT_PERCENTAGE",
            "SPOT_STOP_LOSS_PERCENTAGE", "SPOT_TRAILING_STOP_PERCENTAGE",
            "SPOT_EMA_SHORT_PERIOD", "SPOT_EMA_MEDIUM_PERIOD", "SPOT_EMA_LONG_PERIOD",
            "SPOT_RSI_PERIOD", "SPOT_RSI_UPPER_THRESHOLD", "SPOT_RSI_LOWER_THRESHOLD",
            "MAX_ACTIVE_SPOT_TRADES", "FUTURES_EMA_SHORT_PERIOD",
            "FUTURES_EMA_MEDIUM_PERIOD", "FUTURES_EMA_LONG_PERIOD",
            "BYBIT_FUTURES_FEE_RATE", "KUCOIN_FUTURES_FEE_RATE",
            "BYBIT_FALLBACK_BALANCE", "KUCOIN_FALLBACK_BALANCE",
            "PRICE_HISTORY_RETENTION", "WEBSOCKET_TIMEOUT_SECONDS",
            "BALANCE_FETCH_TIMEOUT", "MAX_FUNDING_RATE", "SCALP_ENTRY_THRESHOLD",
            "SCALP_PROFIT_TARGET", "SCALP_STOP_LOSS", "MACD_SHORT_PERIOD",
            "MACD_LONG_PERIOD", "MACD_SIGNAL_PERIOD", "MACD_CONFIRMATION_THRESHOLD",
            "MAX_SLIPPAGE", "LIQUIDITY_CHECK_INTERVAL", "MIN_ORDERBOOK_REFRESH_RATE",
            "SIMULATION_TRADE_LOGGING", "HFT_SPREAD_THRESHOLD", "HFT_TRADE_AMOUNT",
            "SPOOFING_VOLUME_THRESHOLD", "SPOOFING_PROFIT_TARGET",
            "SLIPPAGE_TRADE_AMOUNT", "FUNDING_MOMENTUM_THRESHOLD",
            "LATENCY_SPIKE_THRESHOLD", "HFT_COOLDOWN_SECONDS",
            "PRICE_REVERSAL_THRESHOLD", "PRICE_REVERSAL_WINDOW_MINUTES",
            "SLIPPAGE_DEPTH_THRESHOLD", "SLIPPAGE_PERCENTAGE",
            "ATR_FALLBACK_PERCENTAGE", "VOLUME_TRACKING_VALUE",
            "FUNDING_RATE_COST_MULTIPLIER", "TRADE_HOLD_DURATION_MINUTES",
            "MIN_PRICE_DATA_POINTS", "VOLUME_ANOMALY_THRESHOLD",
            "SPREAD_RETENTION_HOURS", "ORDER_BOOK_IMBALANCE_FALLBACK",
            "LIQUIDITY_CHECK_FALLBACK", "MARKET_MAKING_SPREAD", "HFT_ORDER_TYPE"
        ]
        
        if swiftDotenvSuccess {
            // Original SwiftDotenv loading method - preserved exactly
            for key in keys {
                if let value = Dotenv[key] {
                    envDict[key] = value.stringValue
                }
            }
            print("‚úÖ Successfully loaded .env file using SwiftDotenv")
        } else {
            // FALLBACK: Manual parsing if SwiftDotenv fails
            print("üîÑ Using manual .env parsing as fallback")
            let contents = try String(contentsOfFile: envPath, encoding: .utf8)
            let lines = contents.components(separatedBy: .newlines)
            
            for line in lines {
                let trimmed = line.trimmingCharacters(in: .whitespacesAndNewlines)
                
                // Skip empty lines and comments
                if trimmed.isEmpty || trimmed.hasPrefix("#") { continue }
                
                // Parse key=value pairs
                let parts = trimmed.components(separatedBy: "=")
                if parts.count >= 2 {
                    let key = parts[0].trimmingCharacters(in: .whitespaces)
                    let value = parts.dropFirst().joined(separator: "=").trimmingCharacters(in: .whitespaces)
                    
                    // Remove quotes if present
                    let cleanValue = value.trimmingCharacters(in: CharacterSet(charactersIn: "\"'"))
                    
                    // Only add if it's in our keys list (preserving original selective loading)
                    if keys.contains(key) {
                        envDict[key] = cleanValue
                    }
                }
            }
            print("‚úÖ Successfully loaded .env file using manual parsing")
        }
        
        // ORIGINAL KuCoin credential validation logic - preserved exactly
        let requiredKuCoinKeys = ["KUCOIN_API_KEY", "KUCOIN_API_SECRET", "KUCOIN_API_PASSPHRASE"]
        var missingKeys = [String]()
        for key in requiredKuCoinKeys {
            if envDict[key] == nil || envDict[key]!.isEmpty {
                missingKeys.append(key)
            }
        }
        if !missingKeys.isEmpty {
            let missingMessage = "Missing or empty KuCoin API credentials: \(missingKeys.joined(separator: ", ")). Disabling KuCoin functionality."
            print("WARNING: \(missingMessage)")
            Task { @MainActor in
                logAlert(event: missingMessage)
            }
            hasValidKuCoinCredentials = false // Disable KuCoin operations
        }
        
        // ORIGINAL debug logging - preserved exactly
        print("DEBUG: Loaded environment variables: \(envDict)")
        print("DEBUG: ACTIVE_PAIRS from env: \(envDict["ACTIVE_PAIRS"] ?? "not found")")
        print("DEBUG: BYBIT_API_KEY from env: \(envDict["BYBIT_API_KEY"] ?? "not found")")
        print("DEBUG: KUCOIN_API_KEY from env: \(envDict["KUCOIN_API_KEY"] ?? "not found")")
        
        // ENHANCED: Set ProcessInfo environment for global access (needed for getDouble, getString, etc.)
        for (key, value) in envDict {
            setenv(key, value, 1)
        }
        
        print("‚úÖ Loaded \(envDict.count) environment variables")
        return envDict
        
    } catch {
        // ORIGINAL error handling - preserved exactly
        print("Failed to load .env file: \(error)")
        Task { @MainActor in
            logAlert(event: "Failed to load .env file: \(error)")
        }
        return [:] // Return empty dictionary to allow bot to continue
    }
}()


// Global Alert Logging Function
func logAlert(event: String, completion: @escaping @Sendable () -> Void = {}) {
    let alertsCSVURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/alerts.csv")
    Task {
        await MainActor.run {
            let timestamp = ISO8601DateFormatter().string(from: Date())
            let logEntry = "\(timestamp),\(event)\n"
            do {
                let fileManager = FileManager.default
                if !fileManager.fileExists(atPath: alertsCSVURL.path) {
                    try "timestamp,event\n".write(to: alertsCSVURL, atomically: true, encoding: .utf8)
                    try fileManager.setAttributes([.posixPermissions: 0o644], ofItemAtPath: alertsCSVURL.path)
                }
                if let fileHandle = try? FileHandle(forWritingTo: alertsCSVURL) {
                    defer { fileHandle.closeFile() }
                    if let data = logEntry.data(using: .utf8) {
                        fileHandle.seekToEndOfFile()
                        fileHandle.write(data)
                    }
                } else {
                    let fileHandle = try FileHandle(forWritingTo: alertsCSVURL)
                    defer { fileHandle.closeFile() }
                    if let data = logEntry.data(using: .utf8) {
                        fileHandle.seekToEndOfFile()
                        fileHandle.write(data)
                    }
                }
                print("DEBUG: Logged alert to alerts.csv: \(logEntry.trimmingCharacters(in: .whitespacesAndNewlines))")
            } catch {
                print("DEBUG: Failed to log alert to alerts.csv: \(error.localizedDescription)")
            }
            completion()
        }
    }
}


// ADD THESE 4 COMPLETE CLASSES BEFORE @MainActor class ExchangeWebSocket {

class KuCoinSpotWebSocketDelegate: NSObject, WebSocketDelegate {
    func didReceive(event: WebSocketEvent, client: WebSocketClient) {
        switch event {
        case .connected(let headers):
            print("‚úÖ [KuCoin Spot] WebSocket connected: \(headers)")
            Task { @MainActor in
                ExchangeWebSocket.kucoinIsConnected = true
                ExchangeWebSocket.logAlert(event: "‚úÖ KuCoin Spot WebSocket connected")
            }
            
        case .disconnected(let reason, let code):
            print("‚ùå [KuCoin Spot] WebSocket disconnected: \(reason) with code: \(code)")
            Task { @MainActor in
                ExchangeWebSocket.kucoinIsConnected = false
                ExchangeWebSocket.logAlert(event: "‚ùå KuCoin Spot WebSocket disconnected: \(reason)")
            }
            
        case .text(let string):
            guard let data = string.data(using: .utf8),
                  let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] else { return }
            
            if let type = json["type"] as? String, type == "message",
               let topic = json["topic"] as? String, topic.contains("/market/ticker"),
               let subject = json["subject"] as? String,
               let data = json["data"] as? [String: Any],
               let price = data["price"] as? String,
               let priceDouble = Double(price) {
                
                let symbol = subject.replacingOccurrences(of: "trade.ticker.", with: "")
                let pair = symbol.hasSuffix("USDT") ? "\(String(symbol.dropLast(4)))-USDT" : symbol
                
                Task { @MainActor in
                    if ExchangeWebSocket.tradingPairs.contains(pair) {
                        ExchangeWebSocket.kucoinCurrentPrice[pair] = priceDouble
                        if ExchangeWebSocket.kucoinPrices[pair] == nil {
                            ExchangeWebSocket.kucoinPrices[pair] = []
                        }
                        ExchangeWebSocket.kucoinPrices[pair]?.append(priceDouble)
                        if let count = ExchangeWebSocket.kucoinPrices[pair]?.count,
                           count > ExchangeWebSocket.priceHistoryRetention {
                            ExchangeWebSocket.kucoinPrices[pair]?.removeFirst()
                        }
                        print("‚úÖ [KuCoin Spot] Updated price for \(pair): $\(priceDouble)")
                    }
                }
            }
            
        case .error(let error):
            print("‚ùå [KuCoin Spot] WebSocket error: \(String(describing: error))")
            Task { @MainActor in
                ExchangeWebSocket.kucoinIsConnected = false
            }
            
        default:
            break
        }
    }
}

class KuCoinFuturesWebSocketDelegate: NSObject, WebSocketDelegate {
    func didReceive(event: WebSocketEvent, client: WebSocketClient) {
        switch event {
        case .connected(let headers):
            print("‚úÖ [KuCoin Futures] WebSocket connected: \(headers)")
            Task { @MainActor in
                ExchangeWebSocket.kucoinFuturesIsConnected = true
                ExchangeWebSocket.logAlert(event: "‚úÖ KuCoin Futures WebSocket connected")
            }
            
        case .disconnected(let reason, let code):
            print("‚ùå [KuCoin Futures] WebSocket disconnected: \(reason) with code: \(code)")
            Task { @MainActor in
                ExchangeWebSocket.kucoinFuturesIsConnected = false
                ExchangeWebSocket.logAlert(event: "‚ùå KuCoin Futures WebSocket disconnected: \(reason)")
            }
            
        case .text(let string):
            guard let data = string.data(using: .utf8),
                  let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] else { return }
            
            if let type = json["type"] as? String, type == "message",
               let topic = json["topic"] as? String, topic.contains("/contract/ticker"),
               let subject = json["subject"] as? String,
               let data = json["data"] as? [String: Any],
               let price = data["price"] as? String,
               let priceDouble = Double(price) {
                
                let symbol = subject.replacingOccurrences(of: "ticker.", with: "")
                var base = String(symbol.dropLast(5))
                if base == "XBT" { base = "BTC" }
                let pair = "\(base)-USDT"
                
                Task { @MainActor in
                    if ExchangeWebSocket.tradingPairs.contains(pair) {
                        ExchangeWebSocket.kucoinCurrentFuturesPrice[pair] = priceDouble
                        if ExchangeWebSocket.kucoinFuturesPrices[pair] == nil {
                            ExchangeWebSocket.kucoinFuturesPrices[pair] = []
                        }
                        ExchangeWebSocket.kucoinFuturesPrices[pair]?.append(priceDouble)
                        if let count = ExchangeWebSocket.kucoinFuturesPrices[pair]?.count,
                           count > ExchangeWebSocket.priceHistoryRetention {
                            ExchangeWebSocket.kucoinFuturesPrices[pair]?.removeFirst()
                        }
                        print("‚úÖ [KuCoin Futures] Updated price for \(pair): $\(priceDouble)")
                    }
                }
            }
            
        case .error(let error):
            print("‚ùå [KuCoin Futures] WebSocket error: \(String(describing: error))")
            Task { @MainActor in
                ExchangeWebSocket.kucoinFuturesIsConnected = false
            }
            
        default:
            break
        }
    }
}

class BybitSpotWebSocketDelegate: NSObject, WebSocketDelegate {
    func didReceive(event: WebSocketEvent, client: WebSocketClient) {
        switch event {
        case .connected(let headers):
            print("‚úÖ [Bybit Spot] WebSocket connected: \(headers)")
            Task { @MainActor in
                ExchangeWebSocket.bybitFuturesIsConnected = true
                ExchangeWebSocket.logAlert(event: "‚úÖ Bybit Spot WebSocket connected")
            }
            
        case .disconnected(let reason, let code):
            print("‚ùå [Bybit Spot] WebSocket disconnected: \(reason) with code: \(code)")
            Task { @MainActor in
                ExchangeWebSocket.bybitFuturesIsConnected = false
                ExchangeWebSocket.logAlert(event: "‚ùå Bybit Spot WebSocket disconnected: \(reason)")
            }
            
        case .text(let string):
            guard let data = string.data(using: .utf8),
                  let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] else { return }
            
            if let topic = json["topic"] as? String, topic.hasPrefix("tickers."),
               let data = json["data"] as? [String: Any],
               let symbol = data["symbol"] as? String,
               let lastPrice = data["lastPrice"] as? String,
               let price = Double(lastPrice) {
                
                let pair = symbol.hasSuffix("USDT") ? "\(String(symbol.dropLast(4)))-USDT" : symbol
                
                Task { @MainActor in
                    if ExchangeWebSocket.tradingPairs.contains(pair) {
                        ExchangeWebSocket.bybitCurrentPrice[pair] = price
                        if ExchangeWebSocket.bybitPrices[pair] == nil {
                            ExchangeWebSocket.bybitPrices[pair] = []
                        }
                        ExchangeWebSocket.bybitPrices[pair]?.append(price)
                        if let count = ExchangeWebSocket.bybitPrices[pair]?.count,
                           count > ExchangeWebSocket.priceHistoryRetention {
                            ExchangeWebSocket.bybitPrices[pair]?.removeFirst()
                        }
                        print("‚úÖ [Bybit Spot] Updated price for \(pair): $\(price)")
                    }
                }
            }
            
        case .error(let error):
            print("‚ùå [Bybit Spot] WebSocket error: \(String(describing: error))")
            Task { @MainActor in
                ExchangeWebSocket.bybitFuturesIsConnected = false
            }
            
        default:
            break
        }
    }
}

class BybitFuturesWebSocketDelegate: NSObject, WebSocketDelegate {
    func didReceive(event: WebSocketEvent, client: WebSocketClient) {
        switch event {
        case .connected(let headers):
            print("‚úÖ [Bybit Futures] WebSocket connected: \(headers)")
            Task { @MainActor in
                ExchangeWebSocket.bybitIsConnected = true
                ExchangeWebSocket.logAlert(event: "‚úÖ Bybit Futures WebSocket connected")
            }
            
        case .disconnected(let reason, let code):
            print("‚ùå [Bybit Futures] WebSocket disconnected: \(reason) with code: \(code)")
            Task { @MainActor in
                ExchangeWebSocket.bybitIsConnected = false
                ExchangeWebSocket.logAlert(event: "‚ùå Bybit Futures WebSocket disconnected: \(reason)")
            }
            
        case .text(let string):
            guard let data = string.data(using: .utf8),
                  let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] else { return }
            
            if let topic = json["topic"] as? String, topic.hasPrefix("tickers."),
               let data = json["data"] as? [String: Any],
               let symbol = data["symbol"] as? String,
               let lastPrice = data["lastPrice"] as? String,
               let price = Double(lastPrice) {
                
                let pair = symbol.hasSuffix("USDT") ? "\(String(symbol.dropLast(4)))-USDT" : symbol
                
                Task { @MainActor in
                    if ExchangeWebSocket.tradingPairs.contains(pair) {
                        ExchangeWebSocket.bybitCurrentFuturesPrice[pair] = price
                        if ExchangeWebSocket.bybitFuturesPrices[pair] == nil {
                            ExchangeWebSocket.bybitFuturesPrices[pair] = []
                        }
                        ExchangeWebSocket.bybitFuturesPrices[pair]?.append(price)
                        if let count = ExchangeWebSocket.bybitFuturesPrices[pair]?.count,
                           count > ExchangeWebSocket.priceHistoryRetention {
                            ExchangeWebSocket.bybitFuturesPrices[pair]?.removeFirst()
                        }
                        print("‚úÖ [Bybit Futures] Updated price for \(pair): $\(price)")
                    }
                }
            }
            
        case .error(let error):
            print("‚ùå [Bybit Futures] WebSocket error: \(String(describing: error))")
            Task { @MainActor in
                ExchangeWebSocket.bybitIsConnected = false
            }
            
        default:
            break
        }
    }
}
//----------------------------------------------------------------------------------------

@MainActor
class ExchangeWebSocket {
    // Starscream WebSockets
    static var kucoinSocket: WebSocket?
    static var kucoinFuturesSocket: WebSocket?
    static var bybitSocket: WebSocket?
    static var bybitSpotSocket: WebSocket?
    static var bybitWebSocket: WebSocket?
    
    static var tradeMetrics: [String: (wins: Int, losses: Int, totalProfit: Double, totalFees: Double)] = [:]
    
    // Connection States
    static var kucoinIsConnected: Bool = false
    static var kucoinFuturesIsConnected: Bool = false
    static var bybitIsConnected: Bool = false
    static var bybitFuturesIsConnected: Bool = false
    
    // WebSocket Tokens
    static var kucoinToken: String?
    static var kucoinFuturesToken: String?
    
    // WebSocket Reconnection Tracking
    static var kucoinReconnectAttempts: Int = 0
    static var kucoinFuturesReconnectAttempts: Int = 0
    static var bybitReconnectAttempts: Int = 0
    static var bybitSpotReconnectAttempts: Int = 0
    static var maxReconnectAttempts: Int = 10
    static var lastHeartbeat: [String: Date] = [:]
    static var messageQueue: [[String: Any]] = []
    static var isProcessingQueue: Bool = false
    static var enhancedMessageQueue: [[String: Any]] = []
    
    static var websocketReconnectAttempts: [String: Int] = [:]
    
    
    
    // WebSocket Activity Monitoring
   
    static var lastWebsocketActivity: [String: Date] = [:]
    static var lastEvolution: Date = .distantPast
    
    // Emergency Controls
    static var emergencyStopActive: Bool = false
    static var consecutiveLosses: [String: Int] = [:]
    static var tradingActive: Bool = true
    static var executionLatencies: [String: [Double]] = [:]
    static var realtimeMetrics: [String: Double] = [:]
    static var strategyAllocations: [String: Double] = [:]
    static var strategyReturns: [String: [Double]] = [:]
    
    // Price Storage
    static var kucoinPrices: [String: [Double]] = [:]
    static var kucoinFuturesPrices: [String: [Double]] = [:]
    static var bybitPrices: [String: [Double]] = [:]
    static var bybitFuturesPrices: [String: [Double]] = [:]
    
    // Current Prices
    static var kucoinCurrentPrice: [String: Double] = [:]
    static var kucoinCurrentFuturesPrice: [String: Double] = [:]
    static var bybitCurrentPrice: [String: Double] = [:]
    static var bybitCurrentFuturesPrice: [String: Double] = [:]
    
    
    
    // Volume Storage
    static var kucoinSpotVolume: [String: [Double]] = [:]
    static var kucoinFuturesVolume: [String: [Double]] = [:]
    static var bybitSpotVolume: [String: [Double]] = [:]
    static var bybitFuturesVolume: [String: [Double]] = [:]
    
    // Order Book Storage
    static var kucoinFuturesOrderBook: [String: [(price: Double, volume: Double, side: String)]] = [:]
    static var bybitFuturesOrderBook: [String: [(price: Double, volume: Double, side: String)]] = [:]
    static var kucoinOrderBooks: [String: BevaixOrderBook] = [:]
    static var bybitOrderBooks: [String: BevaixOrderBook] = [:]
    
    // ATR Storage
    static var kucoinFuturesATR: [String: Double] = [:]
    static var bybitFuturesATR: [String: Double] = [:]
    
    // Trading States
    static var kucoinInSpotTrade: [String: Bool] = [:]
    static var bybitInSpotTrade: [String: Bool] = [:]
    static var kucoinSpotEntryPrice: [String: Double] = [:]
    static var bybitSpotEntryPrice: [String: Double] = [:]
    static var kucoinFuturesEntryPrice: [String: Double] = [:]
    static var bybitFuturesEntryPrice: [String: Double] = [:]
    static var kucoinSpotTrailingStop: [String: Double] = [:]
    static var bybitSpotTrailingStop: [String: Double] = [:]
    static var activeSpotTrades: [String: Int] = [:]
    
    // Arbitrage States
    static var arbitrageExecuted: [String: (Bool, Date)] = [:]
    static var crossExchangeArbitrageExecuted: [String: (Bool, Date)] = [:]
    
    // Funding Rates
    static var bybitFundingRates: [String: Double] = [:]
    static var kucoinFundingRates: [String: Double] = [:]
    static var bybitFundingRateHistory: [String: [Double]] = [:]
    static var kucoinFundingRateHistory: [String: [Double]] = [:]
    
    // Balances
    static var kucoinBalance: Double = 0.0
    static var bybitBalance: Double = 0.0
    static var kucoinBalances: [String: Double] = [:]
    static var bybitBalances: [String: Double] = [:]
    static var kucoinLiveBalance: Double?
    static var bybitLiveBalance: Double?
    
    // Daily Loss Tracking
    static var dailyLoss: [String: Double] = ["bybit": 0.0, "kucoin": 0.0]
    static var lastDailyReset: Date = Date()
    static var portfolioDrawdown: Double = 0.0
    
    // Historical Spreads Storage
    static var historicalSpreads: [String: [Double]] = [:]
    
    // Sentiment Scores
    static var sentimentScores: [String: Double] = [:]
    
    // Multi-Timeframe EMA Storage
    static var kucoinSpotEMA1Min: [String: (short: Double, medium: Double, long: Double)] = [:]
    static var kucoinSpotEMA5Min: [String: (short: Double, medium: Double, long: Double)] = [:]
    static var kucoinSpotEMA15Min: [String: (short: Double, medium: Double, long: Double)] = [:]
    static var bybitSpotEMA1Min: [String: (short: Double, medium: Double, long: Double)] = [:]
    static var bybitSpotEMA5Min: [String: (short: Double, medium: Double, long: Double)] = [:]
    static var bybitSpotEMA15Min: [String: (short: Double, medium: Double, long: Double)] = [:]
    
    // Latency Monitoring
    static var lastLatency: [String: Double] = [:]
    static fileprivate var lastKucoinFetchTime: [String: Date] = [:]
    static fileprivate var lastBybitFetchTime: [String: Date] = [:]
    
    // Order Book Spoofing Detection
    static var orderCancellationEvents: [String: [(timestamp: Date, level: Int, volume: Double)]] = [:]
    static var kucoinOrderBookEvents: [String: [(timestamp: Date, level: Int, volume: Double)]] = [:]
    
    // VaR and Kelly Sizing
    static var varEstimates: [String: Double] = [:]
    static var kellySizes: [String: Double] = [:]
    
    // Performance Dashboard
    static var performanceMetrics: [String: (profit: Double, fees: Double, trades: Int, wins: Int)] = [:]
    
    // Enhanced Trading Variables for Advanced Features
    static var strategyPerformance: [String: PerformanceMetrics] = [:]
    static var mlPredictions: [String: MLPrediction] = [:]
    static var riskMetrics: [String: RiskMetrics] = [:]
    static var advancedSignals: [String: [AdvancedSignal]] = [:]
    static var marketConditions: [String: MarketCondition] = [:]
    static var tradingOpportunities: [TradingOpportunity] = []
    
    // Technical Indicators
    static var emaShort: [String: [Double]] = [:]
    static var emaMedium: [String: [Double]] = [:]
    static var emaLong: [String: [Double]] = [:]
    static var rsiValues: [String: [Double]] = [:]
    static var macdValues: [String: [(macd: Double, signal: Double, histogram: Double)]] = [:]
    static var bollingerBands: [String: [(upper: Double, middle: Double, lower: Double)]] = [:]
    static var atrValues: [String: [Double]] = [:]
    static var vwapValues: [String: [Double]] = [:]
    static var stochasticValues: [String: [(k: Double, d: Double)]] = [:]
    static var williamsR: [String: [Double]] = [:]
    static var cciValues: [String: [Double]] = [:]
    static var mfiValues: [String: [Double]] = [:]
    static var obvValues: [String: [Double]] = [:]
    static var adxValues: [String: [Double]] = [:]
    static var parValues: [String: [Double]] = [:]
    static var ichiValues: [String: [(tenkan: Double, kijun: Double, chikou: Double)]] = [:]
    static var pivotPoints: [String: [(pivot: Double, r1: Double, r2: Double, s1: Double, s2: Double)]] = [:]
    static var fibonacciLevels: [String: [Double]] = [:]
    
    // Sentiment and ML
    static var newsImpact: [String: Double] = [:]
    static var socialSentiment: [String: Double] = [:]
    static var whaleActivity: [String: Double] = [:]
    static var institutionalFlow: [String: Double] = [:]
    
    // Risk Management
    static var correlationMatrix: [String: [String: Double]] = [:]
    static var volatilityScores: [String: Double] = [:]
    static var liquidityScores: [String: Double] = [:]
    static var exposureByPair: [String: Double] = [:]
    static var exposureByStrategy: [String: Double] = [:]
    static var dailyLossByPair: [String: Double] = [:]
    static var dailyLossByExchange: [String: Double] = [:]
    static var maxDrawdownByStrategy: [String: Double] = [:]
    
    // Strategy-Specific Variables
    static var arbitrageOpportunities: [String: Double] = [:]
    static var momentumSignals: [String: Double] = [:]
    static var meanReversionSignals: [String: Double] = [:]
    static var marketMakingSignals: [String: Double] = [:]
    static var hftSignals: [String: Double] = [:]
    
    // Execution Tracking
    static var lastTradeTime: [String: Date] = [:]
    static var cooldownPeriods: [String: TimeInterval] = [:]
    static var executionLatency: [String: [Double]] = [:]
    static var slippageTracking: [String: [Double]] = [:]
    static var fillRates: [String: Double] = [:]
    
    // Position Management
    static var activePositions: [String: Double] = [:]
    static var entryPrices: [String: Double] = [:]
    static var stopLossPrices: [String: Double] = [:]
    static var takeProfitPrices: [String: Double] = [:]
    static var trailingStopPrices: [String: Double] = [:]
    static var positionSizes: [String: Double] = [:]
    static var leverageUsed: [String: Double] = [:]
    
    // Performance Optimization
    static var cpuUsage: Double = 0.0
    static var memoryUsage: Double = 0.0
    static var networkLatency: [String: Double] = [:]
    static var apiCallCounts: [String: Int] = [:]
    static var errorCounts: [String: Int] = [:]
    static var reconnectionCounts: [String: Int] = [:]
    
    // Real-time Monitoring
    static var lastDataUpdate: [String: Date] = [:]
    static var healthStatus: [String: String] = [:]
    static var alertThresholds: [String: Double] = [:]
    static var performanceAlerts: [String] = []
    
    // Missing Variables for Trading Logic
    static var futuresArbitrageExecuted: [String: (profit: Double, timestamp: Date)] = [:]
    static var hftArbitrageExecuted: [String: (profit: Double, timestamp: Date)] = [:]
    static var activeFuturesTrades: [String: Int] = [:]
    static var runningProfitLoss: [String: Double] = [:]
    static var kucoinFuturesBalance: Double = 0.0
    static var bybitFuturesBalance: Double = 0.0
    static var kucoinFuturesPositions: [String: Double] = [:]
    static var bybitFuturesPositions: [String: Double] = [:]
    static var kucoinSymbols: [String: String] = [:]
    static var bybitSymbols: [String: String] = [:]
    static var bybitFuturesSymbols: [String: String] = [:]
    
    // AI Enhancement Variables
    static var quantumProcessor: EvolutionEngine = EvolutionEngine()
    static var neuralSwarm: [NeuralAgent] = []
    static var patternEngine: EvolutionEngine = EvolutionEngine()
    static var temporalOracle: TemporalOracle = TemporalOracle()
    static var evolutionEngine: EvolutionEngine = EvolutionEngine()
    
    
    // Helper for dynamic spread threshold
    static func adjustSpreadThreshold(pair: String, baseThreshold: Double) -> Double {
        let atr = kucoinFuturesATR[pair] ?? 0.01
        let volatility = atr / (kucoinCurrentPrice[pair] ?? 1.0)
        return baseThreshold * (1 + volatility)
    }
    
    // Parameters (will be loaded from .env)
    static var tradingPairs: [String] = []
    static var kucoinFuturesSymbols: [String: String] = [:]
    static var liquidityDepthMultiplier: Double = 0.0
    static var liquidityPriceImpactThreshold: Double = 0.0
    static var orderBookPriceRange: Double = 0.0
    static var orderBookImbalanceThreshold: Double = 0.0
    static var futuresTradeAmount: Double = 0.0
    static var futuresMinProfitPercentage: Double = 0.0
    static var futuresStopLossPercentage: Double = 0.0
    static var futuresTrailingStopPercentage: Double = 0.0
    static var futuresSpikeTrailingStopPercentage: Double = 0.0
    static var maxActiveFuturesTrades: Int = 0
    static var dailyLossLimitPercentage: Double = 0.0
    static var atrMultiplier: Double = 0.0
    static var arbitrageMinBalance: Double = 0.0
    static var arbitrageTradeAmount: Double = 0.0
    static var arbitrageMinSpreadThreshold: Double = 0.001
    static var arbitrageHighSpreadThreshold: Double = 0.005
    static var crossExchangeMinBalance: Double = 0.0
    static var crossExchangeTradeAmount: Double = 0.0
    static var crossExchangeMinSpreadThreshold: Double = 0.002
    static var crossExchangeMinFundingRateThreshold: Double = 0.0
    static var crossExchangeCooldownSeconds: Double = 0.0
    static var volatilityPauseSeconds: Double = 0.0
    static var volatilitySpikeThreshold: Double = 0.0
    static var volatilitySpikeWindowMinutes: Int = 0
    static var volatilitySpikeCooldownSeconds: Int = 0
    static var volumeAnomalyMultiplier: Double = 0.0
    static var volumeAnomalyWindowHours: Int = 0
    static var volumeAnomalyCooldownSeconds: Int = 0
    static var minLiquidityThreshold: Double = 0.0
    static var maxOrderBookImbalance: Double = 0.0
    static var websocketTimeoutSeconds: Int = 0
    static var balanceFetchTimeout: Int = 0
    static var arbitrageThreshold: Double = 0.001
    static var maxFundingRate: Double = 0.0
    static var crossExchangeArbitrageThreshold: Double = 0.002
    static var hftSpreadThreshold: Double = 0.003
    static var hftTradeAmount: Double = 200.0
    static var macdShortPeriod: Int = 0
    static var macdLongPeriod: Int = 0
    static var macdSignalPeriod: Int = 0
    static var macdConfirmationThreshold: Double = 0.0
    static var maxSlippage: Double = 0.0
    static var liquidityCheckInterval: Int = 0
    static var minOrderbookRefreshRate: Int = 0
    static var spotTradeAmount: Double = 0.0
    static var spotFeeRate: Double = 0.0
    static var spotMinProfitPercentage: Double = 0.0
    static var spotStopLossPercentage: Double = 0.0
    static var spotTrailingStopPercentage: Double = 0.0
    static var spotEmaShortPeriod: Int = 0
    static var spotEmaMediumPeriod: Int = 0
    static var spotEmaLongPeriod: Int = 0
    static var spotRsiPeriod: Int = 0
    static var spotRsiUpperThreshold: Double = 0.0
    static var spotRsiLowerThreshold: Double = 0.0
    static var maxActiveSpotTrades: Int = 0
    static var futuresEmaShortPeriod: Int = 0
    static var futuresEmaMediumPeriod: Int = 0
    static var futuresEmaLongPeriod: Int = 0
    static var bybitFuturesFeeRate: Double = 0.0
    static var kucoinFuturesFeeRate: Double = 0.0
    static var bybitFallbackBalance: Double = 0.0
    static var kucoinFallbackBalance: Double = 0.0
    static var bybitRecvWindow: String = ""
    static var kucoinLeverage: String = ""
    static var bybitLeverage: String = ""
    static var priceHistoryRetention: Int = 0
    
    // HFT parameters
    static var scalpEntryThreshold: Double = 0.0
    static var scalpProfitTarget: Double = 0.0
    static var scalpStopLoss: Double = 0.0
    static var spoofingVolumeThreshold: Double = 0.0
    static var spoofingProfitTarget: Double = 0.0
    static var slippageTradeAmount: Double = 0.0
    static var fundingMomentumThreshold: Double = 0.0
    static var latencySpikeThreshold: Double = 0.0
    static var hftCooldownSeconds: Double = 0.0

    // Added variables for trading strategy and arbitrage
    static var shortSMAPeriod: Int = 10
    static var longSMAPeriod: Int = 20
    static var bybitPositions: [String: Double] = [:]
    static var kucoinPositions: [String: Double] = [:]
    static var tradeAmountPercentage: Double = 0.1
    static var stopLossPercentage: Double = 0.02
    static var bybitEntryPrices: [String: Double] = [:]
    static var kucoinEntryPrices: [String: Double] = [:]
    static var takeProfitPercentage: Double = 0.05
    static var fundingRateAdjustmentFactor: Double = 0.01

    // New variables for enhanced features
    static var kucoinMakerFee: Double = 0.0002
    static var kucoinTakerFee: Double = 0.0005
    static var bybitMakerFee: Double = 0.0001
    static var bybitTakerFee: Double = 0.0004
    static var lastFeeUpdate: Date = .distantPast
    static var kellyWinProbability: Double = 0.6
    static var kellyRewardToRisk: Double = 2.0
    static var volatilityPauseActive: Bool = false
    static var lastVolatilityPause: Date = .distantPast
    static var lastSummaryTime: Date = .distantPast
    
    
    static var kucoinDelegate: KuCoinSpotWebSocketDelegate?

    static var bybitDelegate: BybitFuturesWebSocketDelegate?
   
    
    // New variables for performance optimization
    static var lastPriceUpdate: [String: (price: Double, timestamp: Date)] = [:]
    static var isTradingPaused: [String: Bool] = [:]

    // FIXED FUNCTIONS - All missing functions that were causing scope errors
    static func updateDynamicConfiguration() {
        let volatilityLevel = calculateMarketVolatility()
        if volatilityLevel > 0.05 {
            tradingActive = false
            logAlert(event: "High volatility detected, pausing trading")
        } else {
            tradingActive = true
        }
    }
    
    static func updateRiskMetrics() {
        for pair in tradingPairs {
            let prices = kucoinPrices[pair] ?? []
            if prices.count > 100 {
                let returns = zip(prices.dropFirst(), prices.dropLast()).map { (current, previous) in
                    (current - previous) / previous
                }
                
                let variance = calculateVariance(returns)
                let volatility = sqrt(variance)
                
                volatilityScores[pair] = volatility
                
                let maxDD = RiskCalculator.calculateMaxDrawdown(prices: prices)
                maxDrawdownByStrategy[pair] = maxDD
            }
        }
    }
    
    static func assessPortfolioRisk() {
        let totalExposure = exposureByPair.values.reduce(0, +)
        let maxExposure = max(kucoinBalance, bybitBalance) * 0.8
        
        if totalExposure > maxExposure {
            emergencyStopActive = true
            logAlert(event: "Portfolio exposure limit exceeded: \(totalExposure) > \(maxExposure)")
        }
    }
    
    static func monitorDataQuality() {
        let now = Date()
        for pair in tradingPairs {
            if let lastUpdate = lastDataUpdate[pair] {
                let timeSince = now.timeIntervalSince(lastUpdate)
                if timeSince > 60 {
                    logAlert(event: "Stale data detected for \(pair): \(timeSince)s since last update")
                }
            }
        }
    }
    
    static func calculateMarketVolatility() -> Double {
        var volatilities: [Double] = []
        
        for pair in tradingPairs {
            if let volatility = volatilityScores[pair] {
                volatilities.append(volatility)
            }
        }
        
        guard !volatilities.isEmpty else { return 0.0 }
        return volatilities.reduce(0, +) / Double(volatilities.count)
    }
    
    static func calculateVariance(_ values: [Double]) -> Double {
        guard !values.isEmpty else { return 0.0 }
        let mean = values.reduce(0, +) / Double(values.count)
        let squaredDiffs = values.map { pow($0 - mean, 2) }
        return squaredDiffs.reduce(0, +) / Double(squaredDiffs.count)
    }
    
    static func calculateMomentumSignal(pair: String) -> Double {
        let prices = kucoinPrices[pair] ?? []
        guard prices.count >= 20 else { return 0.0 }
        
        let recentPrices = Array(prices.suffix(20))
        let priceChange = (recentPrices.last! - recentPrices.first!) / recentPrices.first!
        return priceChange
    }
    
    static func calculateMeanReversionSignal(pair: String) -> Double {
        let prices = kucoinPrices[pair] ?? []
        guard prices.count >= 50 else { return 0.0 }
        
        let recentPrices = Array(prices.suffix(50))
        let sma = recentPrices.reduce(0, +) / Double(recentPrices.count)
        let currentPrice = recentPrices.last!
        return (sma - currentPrice) / currentPrice
    }
    
    static func calculateMarketMakingSignal(pair: String) -> Double {
        let orderBook = kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
        guard !orderBook.bids.isEmpty, !orderBook.asks.isEmpty else { return 0.0 }
        
        let bestBid = orderBook.bids.first!.price
        let bestAsk = orderBook.asks.first!.price
        let spread = (bestAsk - bestBid) / bestBid
        return spread > 0.001 ? 1.0 : 0.0
    }

    // Helper for order book imbalance calculation
    static func calculateOrderBookImbalance(book: BevaixOrderBook) -> Double {
        let bidVolume = book.bids.reduce(0.0) { $0 + $1.quantity }
        let askVolume = book.asks.reduce(0.0) { $0 + $1.quantity }
        return bidVolume > 0 && askVolume > 0 ? max(bidVolume, askVolume) / min(bidVolume, askVolume) : 0.0
    }
    
    static func calculateOrderBookImbalanceFutures(book: [(price: Double, volume: Double, side: String)]) -> Double {
        let bidVolume = book.filter { $0.side == "buy" }.reduce(0.0) { $0 + $1.volume }
        let askVolume = book.filter { $0.side == "sell" }.reduce(0.0) { $0 + $1.volume }
        return bidVolume > 0 && askVolume > 0 ? max(bidVolume, askVolume) / min(bidVolume, askVolume) : 0.0
    }

    // WebSocket order book update with validation
    static func updateOrderBook(pair: String, exchange: String, message: [String: Any]) {
        let startTime = Date()
        Task { @MainActor in
            let latency = Date().timeIntervalSince(startTime) * 1000
            if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 80.0) {
                logAlert(event: "High latency detected for order book fetch for \(exchange)-\(pair): \(latency)ms")
            }

            guard let data = message["data"] as? [String: Any],
                  let bids = data["bids"] as? [[String]], let asks = data["asks"] as? [[String]] else {
                logAlert(event: "Invalid order book response for \(exchange)-\(pair)-spot")
                return
            }

            var parsedBids: [(price: Double, quantity: Double)] = []
            var parsedAsks: [(price: Double, quantity: Double)] = []
            var parseError = false

            for bid in bids {
                if bid.count >= 2, let price = Double(bid[0]), let quantity = Double(bid[1]), price > 0, quantity > 0 {
                    parsedBids.append((price: price, quantity: quantity))
                } else {
                    parseError = true
                    break
                }
            }
            for ask in asks {
                if ask.count >= 2, let price = Double(ask[0]), let quantity = Double(ask[1]), price > 0, quantity > 0 {
                    parsedAsks.append((price: price, quantity: quantity))
                } else {
                    parseError = true
                    break
                }
            }

            if parseError || parsedBids.isEmpty || parsedAsks.isEmpty {
                logAlert(event: "Invalid order book response for \(exchange)-\(pair)-spot: Parse error or empty data")
                return
            }

            let orderBook = BevaixOrderBook(bids: parsedBids, asks: parsedAsks)
            if exchange == "kucoin" {
                kucoinOrderBooks[pair] = orderBook
            } else {
                bybitOrderBooks[pair] = orderBook
            }

            // Check for imbalance
            let imbalance = calculateOrderBookImbalance(book: orderBook)
            if imbalance > getDouble("MAX_ORDER_BOOK_IMBALANCE", defaultValue: 20.0) {
                logAlert(event: "Order book imbalance for \(exchange)-\(pair)-spot: Imbalance \(imbalance)")
            }
        }
    }

    // Price update with zero-price validation
    static func updatePrice(pair: String, exchange: String, price: Double) {
        Task { @MainActor in
            if price <= 0 {
                logAlert(event: "Zero price detected for \(exchange)-\(pair)")
                return
            }
            if exchange == "kucoin" {
                kucoinCurrentPrice[pair] = price
                kucoinPrices[pair, default: []].append(price)
                if kucoinPrices[pair]!.count > getInt("PRICE_HISTORY_RETENTION", defaultValue: 1440) {
                    kucoinPrices[pair]?.removeFirst()
                }
            } else {
                bybitCurrentPrice[pair] = price
                bybitPrices[pair, default: []].append(price)
                if bybitPrices[pair]!.count > getInt("PRICE_HISTORY_RETENTION", defaultValue: 1440) {
                    bybitPrices[pair]?.removeFirst()
                }
            }
            lastPriceUpdate[pair] = (price: price, timestamp: Date())
        }
    }

    // WebSocket message handling with retry logic
    static func handleWebSocketMessage(socket: WebSocket, message: [String: Any], exchange: String) async {
        let startTime = Date()
        guard let topic = message["topic"] as? String else {
            await MainActor.run {
                logAlert(event: "Invalid WebSocket message format for \(exchange): Missing topic")
            }
            return
        }

        let maxRetries = getInt("MAX_RECONNECT_ATTEMPTS", defaultValue: 10)
        if topic.contains("level2") || topic.contains("orderbook") {
            if let pair = extractPairFromTopic(topic) {
                var retries = 0
                while retries < maxRetries {
                    updateOrderBook(pair: pair, exchange: exchange, message: message)
                    // Check if update was successful by verifying order book data
                    let orderBook = exchange == "kucoin" ? kucoinOrderBooks[pair] : bybitOrderBooks[pair]
                    if orderBook != nil && !orderBook!.bids.isEmpty && !orderBook!.asks.isEmpty {
                        break
                    }
                    retries += 1
                    await MainActor.run {
                        logAlert(event: "Failed to update order book for \(exchange)-\(pair), retry \(retries)/\(maxRetries)")
                    }
                    if retries == maxRetries {
                        await MainActor.run {
                            logAlert(event: "Max retries reached for order book fetch: \(exchange)-\(pair)-spot")
                        }
                    }
                    try? await Task.sleep(nanoseconds: UInt64(1_000_000_000)) // 1-second delay
                }
            }
        } else if topic.contains("ticker") {
            if let pair = extractPairFromTopic(topic), let data = message["data"] as? [String: Any], let price = data["bestAskPrice"] as? String, let priceDouble = Double(price), priceDouble > 0 {
                updatePrice(pair: pair, exchange: exchange, price: priceDouble)
            } else {
                await MainActor.run {
                    logAlert(event: "Invalid ticker response for \(exchange): \(message)")
                }
            }
        }

        let latency = Date().timeIntervalSince(startTime) * 1000
        if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 80.0) {
            await MainActor.run {
                logAlert(event: "High latency detected for WebSocket message processing for \(exchange): \(latency)ms")
            }
        }
    }

    static func extractPairFromTopic(_ topic: String) -> String? {
        let components = topic.split(separator: ":")
        if components.count > 1 {
            let pair = String(components[1]).replacingOccurrences(of: "USDTM", with: "-USDT")
            return tradingPairs.contains(pair) ? pair : nil
        }
        return nil
    }
    // Add this function right after logDashboardMetrics function
    @MainActor
    static func writeDashboardJSON() {
        let dashboardURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/dashboard.json")
        
        let dashboardData: [String: Any] = [
            "timestamp": ISO8601DateFormatter().string(from: Date()),
            "kucoinBalance": kucoinBalance,
            "bybitBalance": bybitBalance,
            "kucoinFuturesBalance": kucoinFuturesBalance,
            "bybitFuturesBalance": bybitFuturesBalance,
            "totalTrades": performanceMetrics.values.reduce(0) { $0 + $1.trades },
            "totalProfit": performanceMetrics.values.reduce(0.0) { $0 + $1.profit },
            "totalFees": performanceMetrics.values.reduce(0.0) { $0 + $1.fees },
            "tradingPairs": tradingPairs,
            "prices": [
                "kucoin": kucoinCurrentPrice,
                "bybit": bybitCurrentPrice,
                "kucoinFutures": kucoinCurrentFuturesPrice,
                "bybitFutures": bybitCurrentFuturesPrice
            ]
        ]
        
        do {
            let jsonData = try JSONSerialization.data(withJSONObject: dashboardData, options: .prettyPrinted)
            try jsonData.write(to: dashboardURL)
            print("DEBUG: Updated dashboard.json with balances - KuCoin: \(kucoinBalance), Bybit: \(bybitBalance)")
        } catch {
            print("DEBUG: Failed to write dashboard.json: \(error.localizedDescription)")
            logAlert(event: "Failed to write dashboard.json: \(error.localizedDescription)")
        }
    }

    static func initializeParameters(completion: @escaping () -> Void) {
        let rawPairs = environment["ACTIVE_PAIRS"] ?? "BTC-USDT,ETH-USDT,SOL-USDT,LINK-USDT,FLOKI-USDT,TON-USDT,NEAR-USDT,ARB-USDT,WIF-USDT,PEPE-USDT,BONK-USDT,SHIB-USDT,XRP-USDT,ADA-USDT,DOGE-USDT,AVAX-USDT,DOT-USDT,MATIC-USDT,SUI-USDT,APT-USDT,INJ-USDT,OP-USDT"
        print("DEBUG: Raw ACTIVE_PAIRS from .env: \(rawPairs)")
        tradingPairs = rawPairs.split(separator: ",").map { String($0).trimmingCharacters(in: .whitespaces) }
        print("DEBUG: Loaded tradingPairs: \(tradingPairs)")
        print("DEBUG: Number of pairs loaded: \(tradingPairs.count)")

        // FIXED: Use proper fallback balance values from .env file
        let kucoinInitialBalance = getDouble("KUCOIN_FALLBACK_BALANCE", defaultValue: 522.235326)
        let bybitInitialBalance = getDouble("BYBIT_FALLBACK_BALANCE", defaultValue: 716.65266351)
        kucoinBalance = kucoinInitialBalance
        bybitBalance = bybitInitialBalance
        kucoinFuturesBalance = kucoinInitialBalance  // FIXED: Initialize futures balance
        bybitFuturesBalance = bybitInitialBalance    // FIXED: Initialize futures balance
        
        tradingPairs.forEach { pair in
            let kucoinAllocation = kucoinInitialBalance / Double(tradingPairs.count)
            let bybitAllocation = bybitInitialBalance / Double(tradingPairs.count)
            kucoinBalances[pair] = kucoinAllocation
            bybitBalances[pair] = bybitAllocation
        }

        fetchKuCoinFuturesSymbols {
            Task { @MainActor in
                if kucoinFuturesSymbols.isEmpty {
                    for pair in tradingPairs {
                        let components = pair.components(separatedBy: "-")
                        if components.count == 2 {
                            let base = components[0]
                            let quote = components[1]
                            let adjustedBase = base == "BTC" ? "XBT" : base
                            kucoinFuturesSymbols[pair] = "\(adjustedBase)\(quote)M"
                        } else {
                            print("DEBUG: Invalid trading pair format: \(pair)")
                            Task { @MainActor in
                                logAlert(event: "Invalid trading pair format: \(pair)")
                            }
                        }
                    }
                }
                print("DEBUG: Initialized kucoinFuturesSymbols: \(kucoinFuturesSymbols)")
                
                // Initialize storage dictionaries for all pairs
                tradingPairs.forEach { pair in
                    kucoinPrices[pair] = kucoinPrices[pair] ?? []
                    kucoinFuturesPrices[pair] = kucoinFuturesPrices[pair] ?? []
                    bybitPrices[pair] = bybitPrices[pair] ?? []
                    bybitFuturesPrices[pair] = bybitFuturesPrices[pair] ?? []
                    kucoinCurrentPrice[pair] = kucoinCurrentPrice[pair] ?? 0.0
                    kucoinCurrentFuturesPrice[pair] = kucoinCurrentFuturesPrice[pair] ?? 0.0
                    bybitCurrentPrice[pair] = bybitCurrentPrice[pair] ?? 0.0
                    bybitCurrentFuturesPrice[pair] = bybitCurrentFuturesPrice[pair] ?? 0.0
                    bybitPositions[pair] = bybitPositions[pair] ?? 0.0
                    kucoinPositions[pair] = kucoinPositions[pair] ?? 0.0
                    kucoinSpotVolume[pair] = kucoinSpotVolume[pair] ?? []
                    kucoinFuturesVolume[pair] = kucoinFuturesVolume[pair] ?? []
                    bybitSpotVolume[pair] = bybitSpotVolume[pair] ?? []
                    bybitFuturesVolume[pair] = bybitFuturesVolume[pair] ?? []
                    kucoinFuturesOrderBook[pair] = kucoinFuturesOrderBook[pair] ?? []
                    bybitFuturesOrderBook[pair] = bybitFuturesOrderBook[pair] ?? []
                    kucoinOrderBooks[pair] = kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
                    bybitOrderBooks[pair] = bybitOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
                    bybitFundingRateHistory[pair] = bybitFundingRateHistory[pair] ?? []
                    kucoinFundingRateHistory[pair] = kucoinFundingRateHistory[pair] ?? []
                    sentimentScores[pair] = sentimentScores[pair] ?? 0.0
                    kucoinSpotEMA1Min[pair] = kucoinSpotEMA1Min[pair] ?? (short: 0.0, medium: 0.0, long: 0.0)
                    kucoinSpotEMA5Min[pair] = kucoinSpotEMA5Min[pair] ?? (short: 0.0, medium: 0.0, long: 0.0)
                    kucoinSpotEMA15Min[pair] = kucoinSpotEMA15Min[pair] ?? (short: 0.0, medium: 0.0, long: 0.0)
                    bybitSpotEMA1Min[pair] = bybitSpotEMA1Min[pair] ?? (short: 0.0, medium: 0.0, long: 0.0)
                    bybitSpotEMA5Min[pair] = bybitSpotEMA5Min[pair] ?? (short: 0.0, medium: 0.0, long: 0.0)
                    bybitSpotEMA15Min[pair] = bybitSpotEMA15Min[pair] ?? (short: 0.0, medium: 0.0, long: 0.0)
                    lastLatency[pair] = lastLatency[pair] ?? 0.0
                    orderCancellationEvents[pair] = orderCancellationEvents[pair] ?? []
                    varEstimates[pair] = varEstimates[pair] ?? 0.0
                    kellySizes[pair] = kellySizes[pair] ?? 0.0
                    performanceMetrics[pair] = performanceMetrics[pair] ?? (profit: 0.0, fees: 0.0, trades: 0, wins: 0)
                    tradeMetrics[pair] = tradeMetrics[pair] ?? (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)
                    kucoinOrderBookEvents[pair] = kucoinOrderBookEvents[pair] ?? []
                    print("DEBUG: Initialized storage for pair: \(pair)")
                }

                // Load other parameters
                liquidityDepthMultiplier = getDouble("LIQUIDITY_DEPTH_MULTIPLIER", defaultValue: 7.0)
                liquidityPriceImpactThreshold = getDouble("LIQUIDITY_PRICE_IMPACT_THRESHOLD", defaultValue: 0.005)
                orderBookPriceRange = getDouble("ORDER_BOOK_PRICE_RANGE", defaultValue: 0.005)
                orderBookImbalanceThreshold = getDouble("ORDER_BOOK_IMBALANCE_THRESHOLD", defaultValue: 1.5)
                minLiquidityThreshold = getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 500.0)
                maxOrderBookImbalance = getDouble("MAX_ORDER_BOOK_IMBALANCE", defaultValue: 20.0)
                volatilitySpikeThreshold = getDouble("VOLATILITY_SPIKE_THRESHOLD", defaultValue: 0.05)
                volatilitySpikeWindowMinutes = getInt("VOLATILITY_SPIKE_WINDOW_MINUTES", defaultValue: 5)
                volatilitySpikeCooldownSeconds = getInt("VOLATILITY_SPIKE_COOLDOWN_SECONDS", defaultValue: 900)
                volumeAnomalyMultiplier = getDouble("VOLUME_ANOMALY_MULTIPLIER", defaultValue: 5.0)
                volumeAnomalyWindowHours = getInt("VOLUME_ANOMALY_WINDOW_HOURS", defaultValue: 1)
                volumeAnomalyCooldownSeconds = getInt("VOLUME_ANOMALY_COOLDOWN_SECONDS", defaultValue: 1800)
                futuresTradeAmount = getDouble("FUTURES_TRADE_AMOUNT", defaultValue: 600.0)  // FIXED: Use .env value
                futuresMinProfitPercentage = getDouble("FUTURES_MIN_PROFIT_PERCENTAGE", defaultValue: 0.0010)  // FIXED: Use .env value
                futuresStopLossPercentage = getDouble("FUTURES_STOP_LOSS_PERCENTAGE", defaultValue: 0.0020)
                futuresTrailingStopPercentage = getDouble("FUTURES_TRAILING_STOP_PERCENTAGE", defaultValue: 0.0020)
                futuresSpikeTrailingStopPercentage = getDouble("FUTURES_SPIKE_TRAILING_STOP_PERCENTAGE", defaultValue: 0.004)
                maxActiveFuturesTrades = getInt("MAX_ACTIVE_FUTURES_TRADES", defaultValue: 30)  // FIXED: Use .env value
                dailyLossLimitPercentage = getDouble("DAILY_LOSS_LIMIT_PERCENTAGE", defaultValue: 0.08)
                atrMultiplier = getDouble("ATR_MULTIPLIER", defaultValue: 0.8)
                arbitrageMinBalance = getDouble("ARBITRAGE_MIN_BALANCE", defaultValue: 20.0)
                arbitrageTradeAmount = getDouble("ARBITRAGE_TRADE_AMOUNT", defaultValue: 500.0)
                arbitrageMinSpreadThreshold = getDouble("ARBITRAGE_MIN_SPREAD_THRESHOLD", defaultValue: 0.0030)
                arbitrageHighSpreadThreshold = getDouble("ARBITRAGE_HIGH_SPREAD_THRESHOLD", defaultValue: 0.0035)
                crossExchangeMinBalance = getDouble("CROSS_EXCHANGE_MIN_BALANCE", defaultValue: 300.0)
                crossExchangeTradeAmount = getDouble("CROSS_EXCHANGE_TRADE_AMOUNT", defaultValue: 300.0)
                crossExchangeMinSpreadThreshold = getDouble("CROSS_EXCHANGE_MIN_SPREAD_THRESHOLD", defaultValue: 0.0020)
                crossExchangeMinFundingRateThreshold = getDouble("CROSS_EXCHANGE_MIN_FUNDING_RATE_THRESHOLD", defaultValue: 0.0000005)
                crossExchangeCooldownSeconds = getDouble("CROSS_EXCHANGE_COOLDOWN_SECONDS", defaultValue: 0.2)
                volatilityPauseSeconds = getDouble("VOLATILITY_PAUSE_SECONDS", defaultValue: 300)
                spotTradeAmount = getDouble("SPOT_TRADE_AMOUNT", defaultValue: 50.0)  // FIXED: Use .env value
                spotFeeRate = getDouble("SPOT_FEE_RATE", defaultValue: 0.001)
                spotMinProfitPercentage = getDouble("SPOT_MINUTE_PROFIT_PERCENTAGE", defaultValue: 0.0030)
                spotStopLossPercentage = getDouble("SPOT_STOP_LOSS_PERCENTAGE", defaultValue: 0.0020)
                spotTrailingStopPercentage = getDouble("SPOT_TRAILING_STOP_PERCENTAGE", defaultValue: 0.0010)
                spotEmaShortPeriod = getInt("SPOT_EMA_SHORT_PERIOD", defaultValue: 5)
                spotEmaMediumPeriod = getInt("SPOT_EMA_MEDIUM_PERIOD", defaultValue: 10)
                spotEmaLongPeriod = getInt("SPOT_EMA_LONG_PERIOD", defaultValue: 20)
                spotRsiPeriod = getInt("SPOT_RSI_PERIOD", defaultValue: 14)
                spotRsiUpperThreshold = getDouble("SPOT_RSI_UPPER_THRESHOLD", defaultValue: 70.0)
                spotRsiLowerThreshold = getDouble("SPOT_RSI_LOWER_THRESHOLD", defaultValue: 30.0)
                maxActiveSpotTrades = getInt("MAX_ACTIVE_SPOT_TRADES", defaultValue: 20)
                futuresEmaShortPeriod = getInt("FUTURES_EMA_SHORT_PERIOD", defaultValue: 5)
                futuresEmaMediumPeriod = getInt("FUTURES_EMA_MEDIUM_PERIOD", defaultValue: 10)
                futuresEmaLongPeriod = getInt("FUTURES_EMA_LONG_PERIOD", defaultValue: 20)
                bybitFuturesFeeRate = getDouble("BYBIT_FUTURES_FEE_RATE", defaultValue: 0.0002)
                kucoinFuturesFeeRate = getDouble("KUCOIN_FUTURES_FEE_RATE", defaultValue: 0.0002)
                bybitFallbackBalance = getDouble("BYBIT_FALLBACK_BALANCE", defaultValue: 716.65266351)
                kucoinFallbackBalance = getDouble("KUCOIN_FALLBACK_BALANCE", defaultValue: 522.235326)
                bybitRecvWindow = environment["BYBIT_RECV_WINDOW"] ?? "5000"
                kucoinLeverage = environment["KUCOIN_LEVERAGE"] ?? "6"
                bybitLeverage = environment["BYBIT_LEVERAGE"] ?? "6"
                priceHistoryRetention = getInt("PRICE_HISTORY_RETENTION", defaultValue: 2880)
                websocketTimeoutSeconds = getInt("WEBSOCKET_TIMEOUT_SECONDS", defaultValue: 8)
                balanceFetchTimeout = getInt("BALANCE_FETCH_TIMEOUT", defaultValue: 12)
                maxFundingRate = getDouble("MAX_FUNDING_RATE", defaultValue: 0.0005)
                macdShortPeriod = getInt("MACD_SHORT_PERIOD", defaultValue: 8)
                macdLongPeriod = getInt("MACD_LONG_PERIOD", defaultValue: 20)
                macdSignalPeriod = getInt("MACD_SIGNAL_PERIOD", defaultValue: 6)
                macdConfirmationThreshold = getDouble("MACD_CONFIRMATION_THRESHOLD", defaultValue: 0.0001)
                maxSlippage = getDouble("MAX_SLIPPAGE", defaultValue: 0.005)
                liquidityCheckInterval = getInt("LIQUIDITY_CHECK_INTERVAL", defaultValue: 30)
                minOrderbookRefreshRate = getInt("MIN_ORDERBOOK_REFRESH_RATE", defaultValue: 1)
                scalpEntryThreshold = getDouble("SCALP_ENTRY_THRESHOLD", defaultValue: 0.0006)
                scalpProfitTarget = getDouble("SCALP_PROFIT_TARGET", defaultValue: 0.0040)
                scalpStopLoss = getDouble("SCALP_STOP_LOSS", defaultValue: 0.0015)
                spoofingVolumeThreshold = getDouble("SPOOFING_VOLUME_THRESHOLD", defaultValue: 1.5)
                spoofingProfitTarget = getDouble("SPOOFING_PROFIT_TARGET", defaultValue: 0.008)
                slippageTradeAmount = getDouble("SLIPPAGE_TRADE_AMOUNT", defaultValue: 100.0)
                fundingMomentumThreshold = getDouble("FUNDING_MOMENTUM_THRESHOLD", defaultValue: 0.00008)
                latencySpikeThreshold = getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 500.0)
                hftCooldownSeconds = getDouble("HFT_COOLDOWN_SECONDS", defaultValue: 1.5)
                
                print("DEBUG: Initialized balances - KuCoin: \(kucoinBalance), KuCoin Futures: \(kucoinFuturesBalance)")
                print("DEBUG: Initialized balances - Bybit: \(bybitBalance), Bybit Futures: \(bybitFuturesBalance)")
                print("DEBUG: Initialized futures trade amount: \(futuresTradeAmount)")
                print("DEBUG: Initialized spot trade amount: \(spotTradeAmount)")

                // Fetch initial sentiment scores
                for pair in tradingPairs {
                    fetchSentimentScore(pair: pair) { score in
                        Task { @MainActor in
                            sentimentScores[pair] = score ?? 0.0
                            print("DEBUG: Initialized sentiment score for \(pair): \(sentimentScores[pair] ?? 0.0)")
                        }
                    }
                }

                // Schedule periodic dashboard updates
                Task {
                    while true {
                        do {
                            try await Task.sleep(nanoseconds: 10_000_000_000) // Every 10 seconds
                            logDashboardMetrics()
                        } catch {
                            print("DEBUG: Dashboard update sleep interrupted: \(error.localizedDescription)")
                            Task { @MainActor in
                                logAlert(event: "Dashboard update sleep interrupted: \(error.localizedDescription)")
                            }
                        }
                    }
                }

                completion()
            }
        }
    }
    
    // FIXED fetchSentimentScore with proper async access
    static func fetchSentimentScore(pair: String, completion: @escaping @Sendable (Double?) -> Void) {
        Task { @MainActor in
            let envValue = await MainActor.run { environment }
            let url = URL(string: envValue["SENTIMENT_SERVER_URL"] ?? "http://127.0.0.1:5001/sentiment")!
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.addValue("application/json", forHTTPHeaderField: "Content-Type")
            request.timeoutInterval = Double(getInt("BALANCE_FETCH_TIMEOUT", defaultValue: 20))

            let payload: [String: Any] = ["pair": pair]
            do {
                let jsonData = try JSONSerialization.data(withJSONObject: payload, options: [])
                request.httpBody = jsonData
            } catch {
                print("DEBUG: Failed to serialize sentiment payload for \(pair): \(error.localizedDescription)")
                logAlert(event: "Failed to serialize sentiment payload for \(pair): \(error.localizedDescription)")
                completion(nil)
                return
            }

            let startTime = Date()
            let task = URLSession.shared.dataTask(with: request) { data, response, error in
                let latency = Date().timeIntervalSince(startTime) * 1000
                Task { @MainActor in
                    lastLatency["sentiment-\(pair)"] = latency
                    if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 80.0) {
                        logAlert(event: "üü¢ High latency detected for sentiment score fetch for \(pair): \(latency)ms")
                    }
                }

                if let error = error {
                    print("DEBUG: Failed to fetch sentiment for \(pair): \(error.localizedDescription)")
                    Task { @MainActor in
                        logAlert(event: "üü¢ Failed to fetch sentiment for \(pair): \(error.localizedDescription)")
                    }
                    completion(nil)
                    return
                }

                guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200,
                      let data = data,
                      let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                      let sentimentScore = json["sentiment_score"] as? Double else {
                    let responseBody = data != nil ? String(data: data!, encoding: .utf8) ?? "Invalid data" : "No data"
                    print("DEBUG: Invalid sentiment response for \(pair): \(responseBody)")
                    Task { @MainActor in
                        logAlert(event: "üü¢ Invalid sentiment response for \(pair): \(responseBody)")
                    }
                    completion(nil)
                    return
                }

                // Validate sentiment score range (-1 to 1)
                if sentimentScore < -1.0 || sentimentScore > 1.0 {
                    print("DEBUG: Invalid sentiment score \(sentimentScore) for \(pair), expected range -1.0 to 1.0")
                    Task { @MainActor in
                        logAlert(event: "üü¢ Invalid sentiment score \(sentimentScore) for \(pair), expected range -1.0 to 1.0")
                    }
                    completion(nil)
                    return
                }

                Task { @MainActor in
                    sentimentScores[pair] = sentimentScore
                    print("DEBUG: Fetched sentiment score for \(pair): \(sentimentScore)")
                    logAlert(event: "üü¢ SUCCESS: Fetched sentiment score for \(pair): \(sentimentScore)")
                }
                completion(sentimentScore)
            }
            task.resume()
        }
    }

    static func fetchKuCoinFuturesSymbols(completion: @escaping () -> Void) {
        if kucoinFuturesSymbols.isEmpty {
            for pair in tradingPairs {
                let components = pair.components(separatedBy: "-")
                if components.count == 2 {
                    let base = components[0]
                    let quote = components[1]
                    let adjustedBase = base == "BTC" ? "XBT" : base
                    kucoinFuturesSymbols[pair] = "\(adjustedBase)\(quote)M"
                } else {
                    print("DEBUG: Invalid trading pair format: \(pair)")
                    logAlert(event: "Invalid trading pair format: \(pair)")
                }
            }
        }
        print("DEBUG: Initialized kucoinFuturesSymbols: \(kucoinFuturesSymbols)")
        completion()
    }
}
//-----------------------------------------------------------------------------------------------------------------------------Block 2 - Environment Setup and Logging

//-----------------------------------------------------------------------------------------------------------------------------Block 2 - Environment Setup and Logging


struct OrderBookEntry {
    let price: Double
    let size: Double
}

struct OrderBook {
    var bids: [OrderBookEntry]
    var asks: [OrderBookEntry]
}

struct FuturesOrderBookEntry {
    let price: Double
    let volume: Double
    let side: String
}

// Enhanced Market Signal Detection
struct SignalGenerator {
    static func generateMomentumSignal(prices: [Double], volume: [Double]) -> AdvancedSignal? {
        guard prices.count >= 20, volume.count >= 20 else { return nil }
        
        let recentPrices = Array(prices.suffix(20))
        let recentVolume = Array(volume.suffix(20))
        
        // Calculate momentum strength
        let priceChange = (recentPrices.last! - recentPrices.first!) / recentPrices.first!
        let avgVolume = recentVolume.reduce(0, +) / Double(recentVolume.count)
        let currentVolume = recentVolume.last!
        
        let volumeBoost = currentVolume / avgVolume
        let momentumStrength = abs(priceChange) * volumeBoost
        
        let signalType = priceChange > 0 ? "momentum_bullish" : "momentum_bearish"
        let confidence = min(momentumStrength * 100, 100.0)
        
        return AdvancedSignal(
            type: signalType,
            strength: momentumStrength,
            confidence: confidence,
            timestamp: Date(),
            pair: "",
            exchange: ""
        )
    }
    
    static func generateArbitrageSignal(kucoinPrice: Double, bybitPrice: Double, threshold: Double) -> AdvancedSignal? {
        let spread = abs(kucoinPrice - bybitPrice) / min(kucoinPrice, bybitPrice)
        
        guard spread > threshold else { return nil }
        
        let direction = kucoinPrice > bybitPrice ? "kucoin_premium" : "bybit_premium"
        let confidence = min(spread / threshold * 100, 100.0)
        
        return AdvancedSignal(
            type: "arbitrage_\(direction)",
            strength: spread,
            confidence: confidence,
            timestamp: Date(),
            pair: "",
            exchange: "cross"
        )
    }
    
    static func generateScalpingSignal(rsi: Double, price: Double, vwap: Double, orderBookImbalance: Double) -> AdvancedSignal? {
        var signals: [Double] = []
        
        // RSI signals
        if rsi < 30 { signals.append(0.7) } // Oversold
        else if rsi > 70 { signals.append(-0.7) } // Overbought
        
        // Price vs VWAP
        let vwapDivergence = (price - vwap) / vwap
        if abs(vwapDivergence) > 0.002 {
            signals.append(vwapDivergence > 0 ? -0.5 : 0.5)
        }
        
        // Order book imbalance
        if orderBookImbalance > 2.0 {
            signals.append(0.6)
        } else if orderBookImbalance < 0.5 {
            signals.append(-0.6)
        }
        
        guard !signals.isEmpty else { return nil }
        
        let averageSignal = signals.reduce(0, +) / Double(signals.count)
        let signalType = averageSignal > 0 ? "scalp_buy" : "scalp_sell"
        
        return AdvancedSignal(
            type: signalType,
            strength: abs(averageSignal),
            confidence: min(abs(averageSignal) * 150, 100.0),
            timestamp: Date(),
            pair: "",
            exchange: ""
        )
    }
}

// Enhanced Market Condition Analysis
struct MarketAnalyzer {
    static func analyzeMarketCondition(prices: [Double], volumes: [Double]) -> MarketCondition {
        guard prices.count >= 50, volumes.count >= 50 else {
            return MarketCondition(volatility: 0.02, trend: "unknown", volume: 0, momentum: 0, timestamp: Date())
        }
        
        let recentPrices = Array(prices.suffix(50))
        let recentVolumes = Array(volumes.suffix(50))
        
        // Calculate volatility
        let returns = zip(recentPrices.dropFirst(), recentPrices.dropLast()).map { (current, previous) in
            (current - previous) / previous
        }
        let meanReturn = returns.reduce(0, +) / Double(returns.count)
        let variance = returns.map { pow($0 - meanReturn, 2) }.reduce(0, +) / Double(returns.count)
        let volatility = sqrt(variance)
        
        // Determine trend
        let sma20 = recentPrices.suffix(20).reduce(0, +) / 20.0
        let sma50 = recentPrices.reduce(0, +) / Double(recentPrices.count)
        let currentPrice = recentPrices.last!
        
        var trend = "sideways"
        if currentPrice > sma20 && sma20 > sma50 {
            trend = "bullish"
        } else if currentPrice < sma20 && sma20 < sma50 {
            trend = "bearish"
        }
        
        // Calculate momentum
        let momentum = (currentPrice - recentPrices.first!) / recentPrices.first!
        
        // Average volume
        let avgVolume = recentVolumes.reduce(0, +) / Double(recentVolumes.count)
        
        return MarketCondition(
            volatility: volatility,
            trend: trend,
            volume: avgVolume,
            momentum: momentum,
            timestamp: Date()
        )
    }
    
    static func calculateCorrelation(prices1: [Double], prices2: [Double]) -> Double {
        guard prices1.count == prices2.count, prices1.count > 1 else { return 0.0 }
        
        let mean1 = prices1.reduce(0, +) / Double(prices1.count)
        let mean2 = prices2.reduce(0, +) / Double(prices2.count)
        
        let numerator = zip(prices1, prices2).map { (x1, x2) in
            (x1 - mean1) * (x2 - mean2)
        }.reduce(0, +)
        
        let denominator1 = prices1.map { pow($0 - mean1, 2) }.reduce(0, +)
        let denominator2 = prices2.map { pow($0 - mean2, 2) }.reduce(0, +)
        let denominator = sqrt(denominator1 * denominator2)
        
        return denominator != 0 ? numerator / denominator : 0.0
    }
}

// Enhanced Risk Calculator
struct RiskCalculator {
    static func calculateVaR(returns: [Double], confidence: Double = 0.95) -> Double {
        guard !returns.isEmpty else { return 0.0 }
        
        let sortedReturns = returns.sorted()
        let index = Int((1.0 - confidence) * Double(sortedReturns.count))
        return index < sortedReturns.count ? abs(sortedReturns[index]) : 0.0
    }
    
    static func calculateExpectedShortfall(returns: [Double], confidence: Double = 0.95) -> Double {
        guard !returns.isEmpty else { return 0.0 }
        
        let var95 = calculateVaR(returns: returns, confidence: confidence)
        let tailReturns = returns.filter { $0 <= -var95 }
        return tailReturns.isEmpty ? 0.0 : abs(tailReturns.reduce(0, +) / Double(tailReturns.count))
    }
    
    static func calculateMaxDrawdown(prices: [Double]) -> Double {
        guard prices.count > 1 else { return 0.0 }
        
        var maxDrawdown = 0.0
        var peak = prices[0]
        
        for price in prices {
            if price > peak {
                peak = price
            }
            let drawdown = (peak - price) / peak
            maxDrawdown = max(maxDrawdown, drawdown)
        }
        
        return maxDrawdown
    }
    
    static func calculateKellyFraction(winRate: Double, avgWin: Double, avgLoss: Double) -> Double {
        guard avgLoss > 0 else { return 0.0 }
        let b = avgWin / avgLoss
        return (winRate * (b + 1) - 1) / b
    }
}

// Dedicated struct to hold environment variables with enhanced validation
struct AppConfig {
    static let environment: [String: String] = {
        let env = loadEnv()
        print("DEBUG: Loaded environment keys: \(env.keys)")
        validateCriticalEnvironmentVariables(env)
        return env
    }()
    
    static func validateCriticalEnvironmentVariables(_ env: [String: String]) {
        let criticalKeys = [
            "BYBIT_API_KEY", "BYBIT_API_SECRET",
            "KUCOIN_API_KEY", "KUCOIN_API_SECRET", "KUCOIN_API_PASSPHRASE",
            "ACTIVE_PAIRS"
        ]
        
        var missingKeys: [String] = []
        for key in criticalKeys {
            if env[key]?.isEmpty != false {
                missingKeys.append(key)
            }
        }
        
        if !missingKeys.isEmpty {
            print("‚ùå CRITICAL: Missing environment variables: \(missingKeys.joined(separator: ", "))")
            print("‚ö†Ô∏è  Bot may not function properly without these credentials!")
        } else {
            print("‚úÖ All critical environment variables loaded successfully")
        }
    }
}

func loadEnv() -> [String: String] {
    var env: [String: String] = [:]
    let fileManager = FileManager.default

    // Look for .env in current working directory first
    let currentDirectory = fileManager.currentDirectoryPath
    let currentEnvPath = URL(fileURLWithPath: currentDirectory).appendingPathComponent(".env").path

    print("Looking for .env file at: \(currentEnvPath)")

    if fileManager.fileExists(atPath: currentEnvPath) {
        do {
            let contents = try String(contentsOfFile: currentEnvPath, encoding: .utf8)
            print("‚úÖ SUCCESS: Read .env file from current directory")
            let lines = contents.components(separatedBy: .newlines)
            for line in lines {
                let trimmed = line.trimmingCharacters(in: .whitespacesAndNewlines)
                if trimmed.isEmpty || trimmed.hasPrefix("#") { continue }
                let parts = trimmed.components(separatedBy: "=")
                if parts.count >= 2 {
                    let key = parts[0].trimmingCharacters(in: .whitespaces)
                    let value = parts.dropFirst().joined(separator: "=").trimmingCharacters(in: .whitespaces)
                    env[key] = value
                }
            }
            print("‚úÖ SUCCESS: Loaded \(env.count) environment variables")
            return env
        } catch {
            print("‚ùå ERROR: Failed to read .env file: \(error)")
            Task { @MainActor in
                logAlert(event: "ERROR: Failed to read .env file: \(error)")
            }
        }
    } else {
        print("‚ö†Ô∏è  ERROR: .env file not found in current directory: \(currentEnvPath)")
        Task { @MainActor in
            logAlert(event: "ERROR: .env file not found in current directory")
        }
    }

    print("FINAL: Loaded \(env.count) environment variables total")
    return env
}

//--------------------------------------------------------------------------------------------------------Block 3 - Order Book and Liquidity Management




extension ExchangeWebSocket {
    static func checkLiquidity(exchange: String, pair: String, completion: @escaping @Sendable (Double?) -> Void) {
        let tradeAmount = getDouble("SPOT_TRADE_AMOUNT", defaultValue: 50.0)
        let currentPrice = exchange == "bybit" ? (bybitCurrentPrice[pair] ?? lastPriceUpdate[pair]?.price ?? 1.0) : (kucoinCurrentPrice[pair] ?? lastPriceUpdate[pair]?.price ?? 1.0)
        let requiredLiquidity = tradeAmount * currentPrice * liquidityDepthMultiplier
        let minLiquidityThresholdValue = minLiquidityThreshold
        
        Task { @MainActor in
            // Fix: Use async/await to handle MainActor-isolated fetchOrderBookDepth
            let spotDepth = await withCheckedContinuation { continuation in
                fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: "spot") { depth in
                    continuation.resume(returning: depth)
                }
            }
            let futuresDepth = await withCheckedContinuation { continuation in
                fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: "futures") { depth in
                    continuation.resume(returning: depth)
                }
            }
            
            let spotDepthValue = spotDepth ?? minLiquidityThresholdValue
            let futuresDepthValue = futuresDepth ?? minLiquidityThresholdValue
            let totalLiquidity = spotDepthValue + futuresDepthValue
            
            // ENHANCED: Basic liquidity analysis using existing variables
            let liquidityScore = calculateBasicLiquidityScore(totalLiquidity: totalLiquidity)
            print("DEBUG: Liquidity score for \(exchange)-\(pair): \(liquidityScore)")
            
            if totalLiquidity < requiredLiquidity {
                print("Insufficient liquidity for \(exchange)-\(pair): Depth \(totalLiquidity), Required \(requiredLiquidity)")
                logAlert(event: "Insufficient liquidity for \(exchange)-\(pair): Depth \(totalLiquidity), Required \(requiredLiquidity), Score: \(liquidityScore)")
                completion(nil)
            } else {
                print("DEBUG: Liquidity check passed for \(exchange)-\(pair): Depth \(totalLiquidity), Score: \(liquidityScore)")
                completion(totalLiquidity)
            }
        }
    }

    static func fetchOrderBookDepth(exchange: String, pair: String, marketType: String, retryCount: Int = 0, completion: @escaping @Sendable (Double?) -> Void) {
        let maxRetries = getInt("API_MAX_RETRIES", defaultValue: 3)
        let localRetryCountCopy = retryCount // Local copy to avoid mutation
        guard localRetryCountCopy < maxRetries else {
            print("Max retries reached for order book fetch: \(exchange)-\(pair)-\(marketType)")
            Task { @MainActor in
                logAlert(event: "Max retries reached for order book fetch: \(exchange)-\(pair)-\(marketType)")
            }
            // Fallback to cached order book data
            let book = exchange == "bybit" ?
                bybitOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: []) :
                kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
            completion(calculateOrderBookDepth(book))
            return
        }
        
        // Original URL building logic
        var url: URL?
        let symbol = pair.replacingOccurrences(of: "-USDT", with: "USDT")
        
        if exchange == "bybit" {
            let category = marketType == "spot" ? "spot" : "linear"
            url = URL(string: "https://api.bybit.com/v5/market/orderbook?category=\(category)&symbol=\(symbol)&limit=50")
        } else {
            let endpoint = marketType == "spot" ? "/api/v1/market/orderbook/level2_50?symbol=\(symbol)" : "/api/v1/contractMarket/level2?symbol=\(symbol)M"
            url = URL(string: "https://api\(marketType == "spot" ? "" : "-futures").kucoin.com\(endpoint)")
        }

        guard let requestUrl = url else {
            print("Invalid order book URL for \(exchange)-\(pair)-\(marketType)")
            Task { @MainActor in
                logAlert(event: "Invalid order book URL for \(exchange)-\(pair)-\(marketType)")
            }
            let attemptFetch: @Sendable () -> Void = {
                let newRetryCount = localRetryCountCopy + 1
                DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                    fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                }
            }
            attemptFetch()
            return
        }

        var request = URLRequest(url: requestUrl)
        request.httpMethod = "GET"
        request.timeoutInterval = getDouble("API_TIMEOUT_SECONDS", defaultValue: 10.0)

        let startTime = Date()
        URLSession.shared.dataTask(with: request) { data, response, error in
            let latency = Date().timeIntervalSince(startTime) * 1000
            Task { @MainActor in
                lastLatency[pair] = latency
                if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 300.0) {
                    print("High latency detected for order book fetch: \(latency)ms")
                    logAlert(event: "High latency detected for order book fetch: \(latency)ms")
                }
            }

            if let error = error {
                print("Failed to fetch order book for \(exchange)-\(pair)-\(marketType): \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to fetch order book for \(exchange)-\(pair)-\(marketType): \(error.localizedDescription)")
                }
                let attemptFetch: @Sendable () -> Void = {
                    let newRetryCount = localRetryCountCopy + 1
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                        fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                    }
                }
                attemptFetch()
                return
            }

            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200, let data = data else {
                print("Invalid order book response for \(exchange)-\(pair)-\(marketType)")
                Task { @MainActor in
                    logAlert(event: "Invalid order book response for \(exchange)-\(pair)-\(marketType)")
                }
                let attemptFetch: @Sendable () -> Void = {
                    let newRetryCount = localRetryCountCopy + 1
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                        fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                    }
                }
                attemptFetch()
                return
            }

            do {
                guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
                    print("Failed to parse JSON for \(exchange)-\(pair)-\(marketType)")
                    Task { @MainActor in
                        logAlert(event: "Failed to parse JSON for \(exchange)-\(pair)-\(marketType)")
                    }
                    let attemptFetch: @Sendable () -> Void = {
                        let newRetryCount = localRetryCountCopy + 1
                        DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                            fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                        }
                    }
                    attemptFetch()
                    return
                }

                if exchange == "bybit" {
                    guard let result = json["result"] as? [String: Any],
                          let bids = result["b"] as? [[String]],
                          let asks = result["a"] as? [[String]],
                          !bids.isEmpty, !asks.isEmpty else {
                        print("Failed to parse Bybit order book data for \(pair)-\(marketType)")
                        Task { @MainActor in
                            logAlert(event: "Failed to parse Bybit order book data for \(pair)-\(marketType)")
                        }
                        let attemptFetch: @Sendable () -> Void = {
                            let newRetryCount = localRetryCountCopy + 1
                            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                            }
                        }
                        attemptFetch()
                        return
                    }

                    var bidDepth: Double = 0.0
                    var askDepth: Double = 0.0
                    for bid in bids.prefix(10) {
                        if let price = Double(bid[0]), let quantity = Double(bid[1]) {
                            bidDepth += price * quantity
                        }
                    }
                    for ask in asks.prefix(10) {
                        if let price = Double(ask[0]), let quantity = Double(ask[1]) {
                            askDepth += price * quantity
                        }
                    }
                    let totalDepth = bidDepth + askDepth
                    Task { @MainActor in
                        if marketType == "spot" {
                            bybitOrderBooks[pair] = BevaixOrderBook(
                                bids: bids.prefix(10).compactMap { b in
                                    if let price = Double(b[0]), let quantity = Double(b[1]) {
                                        return (price: price, quantity: quantity)
                                    }
                                    return nil
                                },
                                asks: asks.prefix(10).compactMap { a in
                                    if let price = Double(a[0]), let quantity = Double(a[1]) {
                                        return (price: price, quantity: quantity)
                                    }
                                    return nil
                                }
                            )
                        } else {
                            bybitFuturesOrderBook[pair] = bids.prefix(10).compactMap { b in
                                if let price = Double(b[0]), let volume = Double(b[1]) {
                                    return (price: price, volume: volume, side: "buy")
                                }
                                return nil
                            } + asks.prefix(10).compactMap { a in
                                if let price = Double(a[0]), let volume = Double(a[1]) {
                                    return (price: price, volume: volume, side: "sell")
                                }
                                return nil
                            }
                        }
                        
                        // ENHANCED: Basic order book analysis
                        analyzeOrderBookBasic(exchange: exchange, pair: pair, marketType: marketType)
                    }
                    completion(totalDepth)
                } else {
                    guard let data = json["data"] as? [String: Any],
                          let bids = data["bids"] as? [[String]],
                          let asks = data["asks"] as? [[String]],
                          !bids.isEmpty, !asks.isEmpty else {
                        print("Failed to parse KuCoin order book data for \(pair)-\(marketType)")
                        Task { @MainActor in
                            logAlert(event: "Failed to parse KuCoin order book data for \(pair)-\(marketType)")
                        }
                        let attemptFetch: @Sendable () -> Void = {
                            let newRetryCount = localRetryCountCopy + 1
                            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                            }
                        }
                        attemptFetch()
                        return
                    }

                    var bidDepth: Double = 0.0
                    var askDepth: Double = 0.0
                    for bid in bids.prefix(10) {
                        if let price = Double(bid[0]), let quantity = Double(bid[1]) {
                            bidDepth += price * quantity
                        }
                    }
                    for ask in asks.prefix(10) {
                        if let price = Double(ask[0]), let quantity = Double(ask[1]) {
                            askDepth += price * quantity
                        }
                    }
                    let totalDepth = bidDepth + askDepth
                    Task { @MainActor in
                        if marketType == "spot" {
                            kucoinOrderBooks[pair] = BevaixOrderBook(
                                bids: bids.prefix(10).compactMap { b in
                                    if let price = Double(b[0]), let quantity = Double(b[1]) {
                                        return (price: price, quantity: quantity)
                                    }
                                    return nil
                                },
                                asks: asks.prefix(10).compactMap { a in
                                    if let price = Double(a[0]), let quantity = Double(a[1]) {
                                        return (price: price, quantity: quantity)
                                    }
                                    return nil
                                }
                            )
                        } else {
                            kucoinFuturesOrderBook[pair] = bids.prefix(10).compactMap { b in
                                if let price = Double(b[0]), let volume = Double(b[1]) {
                                    return (price: price, volume: volume, side: "buy")
                                }
                                return nil
                            } + asks.prefix(10).compactMap { a in
                                if let price = Double(a[0]), let volume = Double(a[1]) {
                                    return (price: price, volume: volume, side: "sell")
                                }
                                return nil
                            }
                        }
                        
                        // ENHANCED: Basic order book analysis
                        analyzeOrderBookBasic(exchange: exchange, pair: pair, marketType: marketType)
                    }
                    completion(totalDepth)
                }
            } catch {
                print("Error parsing order book data: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Error parsing order book data: \(error.localizedDescription)")
                }
                let attemptFetch: @Sendable () -> Void = {
                    let newRetryCount = localRetryCountCopy + 1
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                        fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                    }
                }
                attemptFetch()
            }
        }.resume()
    }

    static func checkLiquidityAsync(exchange: String, pair: String, marketType: String, tradeAmount: Double, price: Double) async -> Double? {
        await withCheckedContinuation { continuation in
            checkLiquidity(exchange: exchange, pair: pair) { liquidity in
                continuation.resume(returning: liquidity)
            }
        }
    }
    
    // ENHANCED FEATURES: Using only existing variables
    
    static func calculateBasicLiquidityScore(totalLiquidity: Double) -> Double {
        let baseThreshold = minLiquidityThreshold
        let ratio = totalLiquidity / baseThreshold
        
        if ratio >= 10 { return 100 }
        else if ratio >= 5 { return 85 }
        else if ratio >= 3 { return 70 }
        else if ratio >= 2 { return 55 }
        else if ratio >= 1 { return 40 }
        else { return 20 }
    }
    
    @MainActor
    static func analyzeOrderBookBasic(exchange: String, pair: String, marketType: String) {
        let orderBook = exchange == "bybit" ?
            bybitOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: []) :
            kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
        
        guard !orderBook.bids.isEmpty && !orderBook.asks.isEmpty else { return }
        
        // Calculate basic spread metrics
        let bestBid = orderBook.bids.first?.price ?? 0
        let bestAsk = orderBook.asks.first?.price ?? 0
        let spread = bestAsk - bestBid
        let midPrice = (bestBid + bestAsk) / 2
        let spreadPercent = midPrice > 0 ? (spread / midPrice) * 100 : 0
        
        // Analyze basic order book imbalance
        let bidVolume = orderBook.bids.prefix(5).reduce(0) { $0 + $1.quantity }
        let askVolume = orderBook.asks.prefix(5).reduce(0) { $0 + $1.quantity }
        let totalVolume = bidVolume + askVolume
        let imbalance = totalVolume > 0 ? abs(bidVolume - askVolume) / totalVolume : 0
        
        // Log significant findings using existing logging
        if spreadPercent > 0.2 {
            logAlert(event: "Wide spread detected for \(exchange)-\(pair): \(String(format: "%.3f", spreadPercent))%")
        }
        
        if imbalance > 0.4 {
            logAlert(event: "Order book imbalance detected for \(exchange)-\(pair): \(String(format: "%.1f", imbalance * 100))%")
        }
        
        // Basic large order detection
        detectBasicLargeOrders(exchange: exchange, pair: pair, orderBook: orderBook)
    }
    
    @MainActor
    static func detectBasicLargeOrders(exchange: String, pair: String, orderBook: BevaixOrderBook) {
        guard !orderBook.bids.isEmpty && !orderBook.asks.isEmpty else { return }
        
        let avgBidSize = orderBook.bids.reduce(0) { $0 + $1.quantity } / Double(orderBook.bids.count)
        let avgAskSize = orderBook.asks.reduce(0) { $0 + $1.quantity } / Double(orderBook.asks.count)
        let avgSize = (avgBidSize + avgAskSize) / 2
        let largeOrderThreshold = avgSize * 5 // 5x average size
        
        var largeOrderCount = 0
        
        // Count large bids
        for bid in orderBook.bids {
            if bid.quantity > largeOrderThreshold {
                largeOrderCount += 1
            }
        }
        
        // Count large asks
        for ask in orderBook.asks {
            if ask.quantity > largeOrderThreshold {
                largeOrderCount += 1
            }
        }
        
        // Log if significant large orders found
        if largeOrderCount >= 3 {
            logAlert(event: "Multiple large orders detected in \(exchange)-\(pair): \(largeOrderCount) orders > \(String(format: "%.1f", largeOrderThreshold))")
        }
    }
    
    // Helper function for order book depth calculation
    static func calculateOrderBookDepth(_ orderBook: BevaixOrderBook) -> Double {
        let bidDepth = orderBook.bids.prefix(10).reduce(0) { $0 + ($1.price * $1.quantity) }
        let askDepth = orderBook.asks.prefix(10).reduce(0) { $0 + ($1.price * $1.quantity) }
        return bidDepth + askDepth
    }
    
    // ENHANCED: Cross-exchange liquidity comparison using existing variables
    @MainActor
    static func compareExchangeLiquidity(pair: String) -> String {
        let bybitBook = bybitOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
        let kucoinBook = kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
        
        let bybitDepth = calculateOrderBookDepth(bybitBook)
        let kucoinDepth = calculateOrderBookDepth(kucoinBook)
        
        let result = bybitDepth > kucoinDepth ? "bybit" : "kucoin"
        let diff = abs(bybitDepth - kucoinDepth)
        
        print("DEBUG: Liquidity comparison for \(pair) - Bybit: \(bybitDepth), KuCoin: \(kucoinDepth), Best: \(result)")
        
        if diff > 1000 { // Significant difference
            logAlert(event: "Significant liquidity difference for \(pair): \(result) has \(String(format: "%.0f", diff)) more depth")
        }
        
        return result
    }
    
    // ENHANCED: Real-time order book health check
    @MainActor
    static func checkOrderBookHealth(exchange: String, pair: String) -> Bool {
        let orderBook = exchange == "bybit" ?
            bybitOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: []) :
            kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
        
        // Basic health checks
        let hasSufficientLevels = orderBook.bids.count >= 5 && orderBook.asks.count >= 5
        let hasValidSpread = orderBook.bids.first?.price ?? 0 < (orderBook.asks.first?.price ?? Double.infinity)
        
        if !hasSufficientLevels {
            logAlert(event: "Insufficient order book levels for \(exchange)-\(pair): bids=\(orderBook.bids.count), asks=\(orderBook.asks.count)")
        }
        
        if !hasValidSpread {
            logAlert(event: "Invalid spread detected for \(exchange)-\(pair) - possible data issue")
        }
        
        return hasSufficientLevels && hasValidSpread
    }
}

//----------------------------------------------------------------------------------------------------------------------Block 4 - Technical Indicator Computations





extension ExchangeWebSocket {
    static func checkLiquidity(exchange: String, pair: String, marketType: String, tradeAmount: Double, price: Double) async -> Double? {
        let requiredLiquidity = tradeAmount * price * liquidityDepthMultiplier
        
        async let spotDepth = marketType == "spot" ? await fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: "spot") : nil
        async let futuresDepth = marketType == "futures" ? await fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: "futures") : nil
        
        do {
            let depth = try await (marketType == "spot" ? spotDepth : futuresDepth) ?? minLiquidityThreshold
            let totalLiquidity = depth
            
            if totalLiquidity < requiredLiquidity {
                print("Insufficient liquidity for \(exchange)-\(pair)-\(marketType): Depth \(totalLiquidity), Required \(requiredLiquidity)")
                await MainActor.run {
                    logAlert(event: "Insufficient liquidity for \(exchange)-\(pair)-\(marketType): Depth \(totalLiquidity), Required \(requiredLiquidity)")
                }
                return nil
            } else {
                print("DEBUG: Liquidity check passed for \(exchange)-\(pair)-\(marketType): Depth \(totalLiquidity)")
                return totalLiquidity
            }
        } catch {
            print("DEBUG: Error fetching order book depth for \(exchange)-\(pair)-\(marketType): \(error.localizedDescription)")
            await MainActor.run {
                logAlert(event: "Error fetching order book depth for \(exchange)-\(pair)-\(marketType): \(error.localizedDescription)")
            }
            return nil
        }
    }

    static func fetchOrderBookDepth(exchange: String, pair: String, marketType: String, retryCount: Int = 0) async throws -> Double? {
        let maxRetries = getInt("API_MAX_RETRIES", defaultValue: 3)
        guard retryCount < maxRetries else {
            print("Max retries reached for order book fetch: \(exchange)-\(pair)-\(marketType)")
            await MainActor.run {
                logAlert(event: "Max retries reached for order book fetch: \(exchange)-\(pair)-\(marketType)")
            }
            let book = exchange == "bybit" ? bybitOrderBooks[pair] : kucoinOrderBooks[pair]
            let cachedDepth = book.map { book in
                let bidDepth = book.bids.prefix(10).reduce(0.0) { $0 + $1.price * $1.quantity }
                let askDepth = book.asks.prefix(10).reduce(0.0) { $0 + $1.price * $1.quantity }
                return bidDepth + askDepth
            } ?? getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 500.0)
            print("DEBUG: Using cached depth for \(exchange)-\(pair)-\(marketType): \(cachedDepth)")
            return cachedDepth
        }

        var url: URL?
        let symbol = pair.replacingOccurrences(of: "-USDT", with: "USDT")
        
        if exchange == "bybit" {
            let category = marketType == "spot" ? "spot" : "linear"
            url = URL(string: "https://api.bybit.com/v5/market/orderbook?category=\(category)&symbol=\(symbol)&limit=50")
        } else {
            let endpoint = marketType == "spot" ? "/api/v1/market/orderbook/level2_50?symbol=\(symbol)" : "/api/v1/contractMarket/level2?symbol=\(symbol)M"
            url = URL(string: "https://api\(marketType == "spot" ? "" : "-futures").kucoin.com\(endpoint)")
        }

        guard let requestUrl = url else {
            print("Invalid order book URL for \(exchange)-\(pair)-\(marketType)")
            await MainActor.run {
                logAlert(event: "Invalid order book URL for \(exchange)-\(pair)-\(marketType)")
            }
            try await Task.sleep(nanoseconds: 2_000_000_000)
            return try await fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1)
        }

        var request = URLRequest(url: requestUrl)
        request.httpMethod = "GET"
        request.timeoutInterval = getDouble("API_TIMEOUT_SECONDS", defaultValue: 10.0)

        let startTime = Date()
        do {
            let (data, response) = try await URLSession.shared.data(for: request)
            let latency = Date().timeIntervalSince(startTime) * 1000
            await MainActor.run {
                lastLatency[pair] = latency
                if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 300.0) {
                    print("High latency detected for order book fetch: \(latency)ms")
                    logAlert(event: "High latency detected for order book fetch: \(latency)ms")
                }
            }

            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                print("Invalid order book response for \(exchange)-\(pair)-\(marketType)")
                await MainActor.run {
                    logAlert(event: "Invalid order book response for \(exchange)-\(pair)-\(marketType)")
                }
                try await Task.sleep(nanoseconds: 2_000_000_000)
                return try await fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1)
            }

            let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
            if exchange == "bybit" {
                guard let result = json?["result"] as? [String: Any],
                      let bids = result["b"] as? [[String]],
                      let asks = result["a"] as? [[String]],
                      !bids.isEmpty, !asks.isEmpty else {
                    print("Failed to parse Bybit order book data for \(pair)-\(marketType)")
                    await MainActor.run {
                        logAlert(event: "Failed to parse Bybit order book data for \(pair)-\(marketType)")
                    }
                    try await Task.sleep(nanoseconds: 2_000_000_000)
                    return try await fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1)
                }

                var bidDepth: Double = 0.0
                var askDepth: Double = 0.0

                for bid in bids.prefix(10) {
                    if let priceStr = bid.first, let qtyStr = bid.last,
                       let price = Double(priceStr), let qty = Double(qtyStr) {
                        bidDepth += price * qty
                    }
                }

                for ask in asks.prefix(10) {
                    if let priceStr = ask.first, let qtyStr = ask.last,
                       let price = Double(priceStr), let qty = Double(qtyStr) {
                        askDepth += price * qty
                    }
                }

                let totalDepth = bidDepth + askDepth
                print("DEBUG: Bybit order book depth for \(pair)-\(marketType): \(totalDepth)")
                return totalDepth
            } else {
                guard let dataDict = json?["data"] as? [String: Any],
                      let bids = dataDict["bids"] as? [[String]],
                      let asks = dataDict["asks"] as? [[String]],
                      !bids.isEmpty, !asks.isEmpty else {
                    print("Failed to parse KuCoin order book data for \(pair)-\(marketType)")
                    await MainActor.run {
                        logAlert(event: "Failed to parse KuCoin order book data for \(pair)-\(marketType)")
                    }
                    try await Task.sleep(nanoseconds: 2_000_000_000)
                    return try await fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1)
                }

                var bidDepth: Double = 0.0
                var askDepth: Double = 0.0

                for bid in bids.prefix(10) {
                    if let priceStr = bid.first, let qtyStr = bid.last,
                       let price = Double(priceStr), let qty = Double(qtyStr) {
                        bidDepth += price * qty
                    }
                }

                for ask in asks.prefix(10) {
                    if let priceStr = ask.first, let qtyStr = ask.last,
                       let price = Double(priceStr), let qty = Double(qtyStr) {
                        askDepth += price * qty
                    }
                }

                let totalDepth = bidDepth + askDepth
                print("DEBUG: KuCoin order book depth for \(pair)-\(marketType): \(totalDepth)")
                return totalDepth
            }
        } catch {
            print("Failed to fetch order book for \(exchange)-\(pair)-\(marketType): \(error.localizedDescription)")
            await MainActor.run {
                logAlert(event: "Failed to fetch order book for \(exchange)-\(pair)-\(marketType): \(error.localizedDescription)")
            }
            try await Task.sleep(nanoseconds: 2_000_000_000)
            return try await fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1)
        }
    }
}




//------------------------------------------------------------------------------------------------------------------------------Block 5 - Risk Assessment and Management



//------------------------------------------------------------------------------------------------------------------------------Block 5 - Risk Assessment and Management
// VARIABLES TO ADD: Add to Block 1 - Core Data Structures and Utilities: static var totalProfit: Double = 0.0, static var totalFees: Double = 0.0, static var totalBalance: Double = 0.0

extension ExchangeWebSocket {
    static func calculateEMA(prices: [Double], period: Int) -> Double? {
        guard prices.count >= period else { return nil }
        let k = 2.0 / Double(period + 1)
        var ema = prices[0]
        for i in 1..<prices.count {
            ema = prices[i] * k + ema * (1 - k)
        }
        return ema
    }

    static func calculateMultiTimeframeEMAs(pair: String, exchange: String, prices: [Double]) {
        let minPrices1 = Array(prices.suffix(60)) // 1-minute timeframe
        let minPrices5 = Array(prices.suffix(300)) // 5-minute timeframe
        let minPrices15 = Array(prices.suffix(900)) // 15-minute timeframe

        let shortPeriod = spotEmaShortPeriod
        let mediumPeriod = spotEmaMediumPeriod
        let longPeriod = spotEmaLongPeriod

        if let emaShort1 = calculateEMA(prices: minPrices1, period: shortPeriod),
           let emaMedium1 = calculateEMA(prices: minPrices1, period: mediumPeriod),
           let emaLong1 = calculateEMA(prices: minPrices1, period: longPeriod),
           let emaShort5 = calculateEMA(prices: minPrices5, period: shortPeriod),
           let emaMedium5 = calculateEMA(prices: minPrices5, period: mediumPeriod),
           let emaLong5 = calculateEMA(prices: minPrices5, period: longPeriod),
           let emaShort15 = calculateEMA(prices: minPrices15, period: shortPeriod),
           let emaMedium15 = calculateEMA(prices: minPrices15, period: mediumPeriod),
           let emaLong15 = calculateEMA(prices: minPrices15, period: longPeriod) {
            Task { @MainActor in
                if exchange == "kucoin" {
                    kucoinSpotEMA1Min[pair] = (emaShort1, emaMedium1, emaLong1)
                    kucoinSpotEMA5Min[pair] = (emaShort5, emaMedium5, emaLong5)
                    kucoinSpotEMA15Min[pair] = (emaShort15, emaMedium15, emaLong15)
                } else {
                    bybitSpotEMA1Min[pair] = (emaShort1, emaMedium1, emaLong1)
                    bybitSpotEMA5Min[pair] = (emaShort5, emaMedium5, emaLong5)
                    bybitSpotEMA15Min[pair] = (emaShort15, emaMedium15, emaLong15)
                }
            }
        }
    }

    static func calculateMACD(prices: [Double], shortPeriod: Int, longPeriod: Int, signalPeriod: Int) -> (macd: Double, signal: Double, histogram: Double)? {
        guard prices.count >= max(longPeriod, signalPeriod) else { return nil }
        
        guard let shortEMA = calculateEMA(prices: prices, period: shortPeriod),
              let longEMA = calculateEMA(prices: prices, period: longPeriod) else {
            return nil
        }
        
        let macd = shortEMA - longEMA
        let macdSeries = prices.suffix(signalPeriod).enumerated().map { _ in
            shortEMA - longEMA // Simplified, assumes recent prices for signal
        }
        
        guard let signal = calculateEMA(prices: macdSeries, period: signalPeriod) else {
            return nil
        }
        
        let histogram = macd - signal
        return (macd: macd, signal: signal, histogram: histogram)
    }

    static func calculateRSI(prices: [Double], period: Int) -> Double? {
        guard prices.count >= period + 1 else { return nil }
        var gains: [Double] = []
        var losses: [Double] = []
        for i in 1..<prices.count {
            let diff = prices[i] - prices[i - 1]
            if diff > 0 {
                gains.append(diff)
                losses.append(0)
            } else {
                gains.append(0)
                losses.append(abs(diff))
            }
        }
        guard gains.count >= period else { return nil }
        let avgGain = gains.suffix(period).reduce(0.0, +) / Double(period)
        let avgLoss = losses.suffix(period).reduce(0.0, +) / Double(period)
        guard avgLoss != 0 else { return 100 }
        let rs = avgGain / avgLoss
        return 100 - (100 / (1 + rs))
    }

    static func calculateATR(prices: [Double]) -> Double? {
        guard prices.count > 1 else { return nil }
        var trs: [Double] = []
        for i in 1..<prices.count {
            let highLow = abs(prices[i] - prices[i - 1])
            trs.append(highLow)
        }
        guard !trs.isEmpty else { return nil }
        return trs.reduce(0, +) / Double(trs.count)
    }

    static func calculateVaR(pair: String, tradeAmount: Double, prices: [Double]) -> Double? {
        guard prices.count >= 1440 else { return nil } // 24 hours of data
        let returns = prices.enumerated().dropFirst().map { (i, price) in
            log(price / prices[i - 1])
        }
        guard !returns.isEmpty else { return nil }
        let meanReturn = returns.reduce(0, +) / Double(returns.count)
        let variance = returns.reduce(0.0) { $0 + pow($1 - meanReturn, 2) } / Double(returns.count)
        let stdDev = sqrt(variance)
        let zScore = -1.645 // 95% confidence level
        let varValue = tradeAmount * (meanReturn + zScore * stdDev)
        Task { @MainActor in
            varEstimates[pair] = varValue
        }
        return varValue
    }

    static func calculateKellySize(pair: String, balance: Double, sentimentScore: Double) -> Double {
        let winProb = kellyWinProbability
        let rewardToRisk = kellyRewardToRisk
        let sentimentAdjustment = sentimentScore < 0 ? 0.5 : 1.0
        let kellyFraction = (winProb * (rewardToRisk + 1) - 1) / rewardToRisk
        let adjustedFraction = kellyFraction * sentimentAdjustment
        let positionSize = balance * max(0.01, min(0.3, adjustedFraction))
        Task { @MainActor in
            kellySizes[pair] = positionSize
        }
        return positionSize
    }

    static func checkVolatility(exchange: String, pair: String, atr: Double) -> Bool {
        let currentPrice = exchange == "bybit" ? bybitCurrentFuturesPrice[pair] ?? 0.0 : kucoinCurrentFuturesPrice[pair] ?? 0.0
        guard currentPrice > 0 else { return false }
        let atrPercentage = atr / currentPrice
        return atrPercentage >= atrMultiplier
    }

    static func detectVolatilitySpike(exchange: String, pair: String) -> Bool {
        let prices = exchange == "bybit" ? bybitFuturesPrices[pair] ?? [] : kucoinFuturesPrices[pair] ?? []
        guard prices.count >= volatilitySpikeWindowMinutes else { return false }
        let recentPrices = prices.suffix(volatilitySpikeWindowMinutes)
        guard let minPrice = recentPrices.min(), let maxPrice = recentPrices.max() else { return false }
        let priceRange = (maxPrice - minPrice) / minPrice
        return priceRange >= volatilitySpikeThreshold
    }

    static func checkVolumeAnomaly(exchange: String, pair: String, marketType: String) -> Bool {
        let volumes: [Double]
        switch (exchange, marketType) {
        case ("kucoin", "spot"):
            volumes = kucoinSpotVolume[pair] ?? []
        case ("kucoin", "futures"):
            volumes = kucoinFuturesVolume[pair] ?? []
        case ("bybit", "spot"):
            volumes = bybitSpotVolume[pair] ?? []
        case ("bybit", "futures"):
            volumes = bybitFuturesVolume[pair] ?? []
        default:
            return false
        }
        guard volumes.count >= volumeAnomalyWindowHours * 60 else { return false }
        let recentVolumes = volumes.suffix(volumeAnomalyWindowHours * 60)
        let avgVolume = recentVolumes.reduce(0, +) / Double(recentVolumes.count)
        guard let maxVolume = recentVolumes.max() else { return false }
        return maxVolume >= avgVolume * volumeAnomalyMultiplier
    }

    static func isPrimeTradingTime() -> Bool {
        let calendar = Calendar(identifier: .gregorian)
        let now = Date()
        guard let gmtZone = TimeZone(identifier: "GMT") else { return false }
        let components = calendar.dateComponents(in: gmtZone, from: now)
        guard let currentHour = components.hour else { return false }
        let londonHours = 8...17
        let nyHours = 13...22
        return londonHours.contains(currentHour) || nyHours.contains(currentHour)
    }

    static func dynamicCooldown(volatility: Double) -> Double {
        return max(2, min(10, 10 * (1 - volatility)))
    }

    static func calculateBollingerBands(prices: [Double], period: Int, multiplier: Double = 2.0) -> (upper: Double, middle: Double, lower: Double)? {
        guard prices.count >= period else { return nil }
        let recentPrices = prices.suffix(period)
        let sma = recentPrices.reduce(0, +) / Double(period)
        let variance = recentPrices.reduce(0.0) { $0 + pow($1 - sma, 2) } / Double(period)
        let stdDev = sqrt(variance)
        let upperBand = sma + multiplier * stdDev
        let lowerBand = sma - multiplier * stdDev
        return (upper: upperBand, middle: sma, lower: lowerBand)
    }

    static func calculateFundingRateTrend(pair: String, exchange: String) -> Double? {
        let history = exchange == "bybit" ? bybitFundingRateHistory[pair] ?? [] : kucoinFundingRateHistory[pair] ?? []
        guard history.count >= 3 else { return nil }
        let recentRates = history.suffix(3)
        let trend = recentRates.enumerated().reduce(0.0) { (sum, item) in
            sum + (item.element - (recentRates[recentRates.count - 1] / Double(recentRates.count)))
        } / Double(recentRates.count)
        return trend
    }

    // CRITICAL MISSING SUPPORT FUNCTIONS - These are vital for trading operations:

    static func dynamicTradeAmount(balance: Double, riskPercent: Double, volatility: Double, pair: String = "") -> Double {
        let baseAmount = balance * riskPercent
        let volatilityAdjustment = max(0.5, min(2.0, 1.0 / (1.0 + volatility)))
        let kellySize = pair.isEmpty ? baseAmount : (kellySizes[pair] ?? baseAmount)
        return min(baseAmount * volatilityAdjustment, kellySize)
    }

    static func checkLiquidityAsyncUnique(exchange: String, pair: String, marketType: String, tradeAmount: Double, price: Double) async -> Double? {
        return await checkLiquidityAsync(exchange: exchange, pair: pair, marketType: marketType, tradeAmount: tradeAmount, price: price)
    }

    static func checkDailyLossLimit(exchange: String, pair: String, potentialLoss: Double) async -> Bool {
        await MainActor.run {
            let currentLoss = dailyLoss[exchange] ?? 0.0
            let totalBalance = exchange == "kucoin" ? kucoinBalance : bybitBalance
            let lossLimit = totalBalance * dailyLossLimitPercentage
            
            if currentLoss + potentialLoss > lossLimit {
                logAlert(event: "Daily loss limit would be exceeded for \(exchange): \(currentLoss + potentialLoss) > \(lossLimit)")
                return false
            }
            return true
        }
    }

    static func executeHFTTrade(exchange: String, pair: String, side: String, price: Double, amount: Double) {
        Task { @MainActor in
            let simulationEnabled = await getBool("SIMULATION_TRADE_LOGGING", defaultValue: true)
            
            if simulationEnabled {
                let profit = side == "buy" ? amount * 0.002 : amount * 0.001 // Simulated profit
                let fees = amount * (exchange == "kucoin" ? kucoinTakerFee : bybitTakerFee)
                let netProfit = profit - fees
                
                // Update running totals
                totalProfit += netProfit
                totalFees += fees
                
                // Log simulated trade
                let timestamp = ISO8601DateFormatter().string(from: Date())
                let logEntry = "\(timestamp),\(exchange),\(pair),\(side),\(price),\(amount),\(netProfit),\(fees),simulation\n"
                
                do {
                    let tradesCSVURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trade_log.csv")
                    let fileManager = FileManager.default
                    
                    if !fileManager.fileExists(atPath: tradesCSVURL.path) {
                        try "timestamp,exchange,pair,side,price,amount,profit,fees,type\n".write(to: tradesCSVURL, atomically: true, encoding: .utf8)
                    }
                    
                    let fileHandle = try FileHandle(forWritingTo: tradesCSVURL)
                    defer { fileHandle.closeFile() }
                    fileHandle.seekToEndOfFile()
                    if let data = logEntry.data(using: .utf8) {
                        fileHandle.write(data)
                    }
                    
                    print("üîÑ SIMULATED TRADE: \(exchange) \(side) \(amount) \(pair) @ \(price) = \(netProfit) USDT profit")
                    logAlert(event: "üîÑ SIMULATED TRADE: \(exchange) \(side) \(amount) \(pair) @ \(price) = \(netProfit) USDT profit")
                } catch {
                    logAlert(event: "Failed to log trade: \(error)")
                }
            } else {
                // Real trade execution would go here
                print("‚ö†Ô∏è REAL TRADE DISABLED - Set SIMULATION_TRADE_LOGGING=false to enable")
                logAlert(event: "‚ö†Ô∏è REAL TRADE DISABLED - Set SIMULATION_TRADE_LOGGING=false to enable")
            }
        }
    }

    static func updateTradeMetrics(pair: String, profit: Double, fees: Double, isWin: Bool, dashboardJSONURL: URL, totalProfit: inout Double, totalFees: inout Double) {
        totalProfit += profit
        totalFees += fees
        
        var currentMetrics = tradeMetrics[pair] ?? (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)
        currentMetrics.totalProfit += profit
        currentMetrics.totalFees += fees
        
        if isWin {
            currentMetrics.wins += 1
        } else {
            currentMetrics.losses += 1
        }
        
        tradeMetrics[pair] = currentMetrics
        
        // Update performance metrics
        var perfMetrics = performanceMetrics[pair] ?? (profit: 0.0, fees: 0.0, trades: 0, wins: 0)
        perfMetrics.profit += profit
        perfMetrics.fees += fees
        perfMetrics.trades += 1
        if isWin { perfMetrics.wins += 1 }
        performanceMetrics[pair] = perfMetrics
        
        print("üìä Updated metrics for \(pair): Profit=\(profit), Fees=\(fees), Win=\(isWin)")
    }

    static func logTradeToCSV(pair: String, strategy: String, profit: Double, fees: Double, tradesCSVURL: URL) {
        let timestamp = ISO8601DateFormatter().string(from: Date())
        let logEntry = "\(timestamp),\(pair),\(strategy),\(profit),\(fees)\n"
        
        do {
            let fileManager = FileManager.default
            if !fileManager.fileExists(atPath: tradesCSVURL.path) {
                try "timestamp,pair,strategy,profit,fees\n".write(to: tradesCSVURL, atomically: true, encoding: .utf8)
            }
            
            let fileHandle = try FileHandle(forWritingTo: tradesCSVURL)
            defer { fileHandle.closeFile() }
            fileHandle.seekToEndOfFile()
            if let data = logEntry.data(using: .utf8) {
                fileHandle.write(data)
            }
        } catch {
            logAlert(event: "Failed to log trade to CSV: \(error)")
        }
    }

    static func sendTradeToFlaskServer(strategy: String, pair: String, exchange: String, spotPrice: Double, futuresPrice: Double, tradeAmount: Double, profit: Double) {
        let payload: [String: Any] = [
            "strategy": strategy,
            "pair": pair,
            "exchange": exchange,
            "spot_price": spotPrice,
            "futures_price": futuresPrice,
            "trade_amount": tradeAmount,
            "profit": profit,
            "timestamp": ISO8601DateFormatter().string(from: Date())
        ]
        
        guard let url = URL(string: "http://127.0.0.1:5000/log_trade") else { return }
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        
        do {
            let jsonData = try JSONSerialization.data(withJSONObject: payload)
            request.httpBody = jsonData
            
            URLSession.shared.dataTask(with: request) { _, response, error in
                if let error = error {
                    print("Failed to send trade to Flask server: \(error)")
                } else {
                    print("‚úÖ Sent trade data to Flask server for ML analysis")
                }
            }.resume()
        } catch {
            print("Failed to serialize trade data for Flask server: \(error)")
        }
    }

    static func evaluateFundingRateMomentum(pair: String, kucoinFundingRate: Double, bybitFundingRate: Double) async {
        await MainActor.run {
            let fundingDifference = abs(kucoinFundingRate - bybitFundingRate)
            
            if fundingDifference > fundingMomentumThreshold {
                let betterExchange = kucoinFundingRate < bybitFundingRate ? "kucoin" : "bybit"
                let worseExchange = kucoinFundingRate < bybitFundingRate ? "bybit" : "kucoin"
                
                logAlert(event: "Funding rate momentum detected for \(pair): \(betterExchange) (\(kucoinFundingRate < bybitFundingRate ? kucoinFundingRate : bybitFundingRate)) vs \(worseExchange) (\(kucoinFundingRate < bybitFundingRate ? bybitFundingRate : kucoinFundingRate))")
                
                // Consider funding rate arbitrage opportunity
                if fundingDifference > crossExchangeMinFundingRateThreshold {
                    print("üî• FUNDING ARBITRAGE OPPORTUNITY: \(pair) - \(betterExchange) has \(fundingDifference * 100)% better funding rate")
                }
            }
        }
    }

    // CRITICAL ENHANCEMENT FUNCTIONS - These improve profitability significantly:

    static func detectOrderBookSpoofing(exchange: String, pair: String, orderBook: BevaixOrderBook) -> Bool {
        // Detect unusual order patterns that might indicate spoofing
        guard !orderBook.bids.isEmpty && !orderBook.asks.isEmpty else { return false }
        
        let bidSizes = orderBook.bids.map { $0.quantity }
        let askSizes = orderBook.asks.map { $0.quantity }
        
        // Look for abnormally large orders compared to average
        let avgBidSize = bidSizes.reduce(0, +) / Double(bidSizes.count)
        let avgAskSize = askSizes.reduce(0, +) / Double(askSizes.count)
        
        let largeBids = bidSizes.filter { $0 > avgBidSize * spoofingVolumeThreshold }
        let largeAsks = askSizes.filter { $0 > avgAskSize * spoofingVolumeThreshold }
        
        let spoofingDetected = largeBids.count >= 2 || largeAsks.count >= 2
        
        if spoofingDetected {
            Task { @MainActor in
                logAlert(event: "üîç Potential spoofing detected for \(exchange)-\(pair): Large bids=\(largeBids.count), Large asks=\(largeAsks.count)")
            }
        }
        
        return spoofingDetected
    }

    static func calculateSlippageImpact(exchange: String, pair: String, tradeAmount: Double, side: String) -> Double {
        let orderBook = exchange == "kucoin" ? kucoinOrderBooks[pair] : bybitOrderBooks[pair]
        guard let book = orderBook, !book.bids.isEmpty && !book.asks.isEmpty else { return maxSlippage }
        
        let orders = side == "buy" ? book.asks : book.bids
        var remainingAmount = tradeAmount
        var totalCost = 0.0
        var slippage = 0.0
        
        for order in orders {
            if remainingAmount <= 0 { break }
            
            let fillAmount = min(remainingAmount, order.quantity)
            totalCost += fillAmount * order.price
            remainingAmount -= fillAmount
        }
        
        if remainingAmount > 0 {
            // Not enough liquidity
            slippage = maxSlippage
        } else {
            let avgPrice = totalCost / tradeAmount
            let bestPrice = side == "buy" ? orders.first!.price : orders.first!.price
            slippage = abs(avgPrice - bestPrice) / bestPrice
        }
        
        return min(slippage, maxSlippage)
    }

    static func optimizeOrderSizing(exchange: String, pair: String, baseAmount: Double) -> Double {
        let orderBook = exchange == "kucoin" ? kucoinOrderBooks[pair] : bybitOrderBooks[pair]
        guard let book = orderBook, !book.bids.isEmpty && !book.asks.isEmpty else { return baseAmount }
        
        // Calculate optimal size based on order book depth
        let bidDepth = book.bids.prefix(5).reduce(0) { $0 + $1.quantity }
        let askDepth = book.asks.prefix(5).reduce(0) { $0 + $1.quantity }
        let avgDepth = (bidDepth + askDepth) / 2
        
        // Limit trade size to a fraction of available depth
        let maxSize = avgDepth * 0.1 // Use 10% of top 5 levels
        return min(baseAmount, maxSize)
    }

    static func evaluateLatencyArbitrage(pair: String) async -> Bool {
        await MainActor.run {
            let kucoinLatency = lastLatency["kucoin-\(pair)"] ?? 0
            let bybitLatency = lastLatency["bybit-\(pair)"] ?? 0
            
            let latencyDifference = abs(kucoinLatency - bybitLatency)
            
            // If one exchange is significantly faster, it might provide an edge
            if latencyDifference > latencySpikeThreshold {
                let fasterExchange = kucoinLatency < bybitLatency ? "kucoin" : "bybit"
                print("‚ö° LATENCY EDGE: \(fasterExchange) is \(latencyDifference)ms faster for \(pair)")
                logAlert(event: "‚ö° LATENCY EDGE: \(fasterExchange) is \(latencyDifference)ms faster for \(pair)")
                return true
            }
            
            return false
        }
    }

    static func monitorOrderBookDepthChanges(exchange: String, pair: String) {
        Task { @MainActor in
            let currentBook = exchange == "kucoin" ? kucoinOrderBooks[pair] : bybitOrderBooks[pair]
            guard let book = currentBook, !book.bids.isEmpty && !book.asks.isEmpty else { return }
            
            let topBidSize = book.bids.first?.quantity ?? 0
            let topAskSize = book.asks.first?.quantity ?? 0
            
            // Track significant changes in top-level liquidity
            let key = "\(exchange)-\(pair)-depth"
            if let lastSizes = lastPriceUpdate[key] {
                let bidChange = abs(topBidSize - lastSizes.price) / lastSizes.price
                let askChange = abs(topAskSize - (lastSizes.timestamp.timeIntervalSince1970)) / lastSizes.timestamp.timeIntervalSince1970
                
                if bidChange > 0.5 || askChange > 0.5 {
                    logAlert(event: "üìä Significant depth change for \(exchange)-\(pair): Bid change \(bidChange * 100)%, Ask change \(askChange * 100)%")
                }
            }
            
            lastPriceUpdate[key] = (price: topBidSize, timestamp: Date())
        }
    }

    static func calculateVWAP(prices: [Double], volumes: [Double]) -> Double? {
        guard prices.count == volumes.count, !prices.isEmpty else { return nil }
        
        let totalVolumeValue = zip(prices, volumes).reduce(0) { $0 + ($1.0 * $1.1) }
        let totalVolume = volumes.reduce(0, +)
        
        return totalVolume > 0 ? totalVolumeValue / totalVolume : nil
    }

    static func detectMarketRegimeChange(pair: String) -> Bool {
        Task { @MainActor in
            let prices = kucoinPrices[pair] ?? []
            guard prices.count >= 100 else { return false }
            
            let recentPrices = Array(prices.suffix(50))
            let olderPrices = Array(prices.suffix(100).prefix(50))
            
            let recentVolatility = calculateVolatilityFromPrices(recentPrices)
            let olderVolatility = calculateVolatilityFromPrices(olderPrices)
            
            let volatilityChange = abs(recentVolatility - olderVolatility) / olderVolatility
            
            if volatilityChange > 0.5 { // 50% change in volatility
                let regimeType = recentVolatility > olderVolatility ? "high_volatility" : "low_volatility"
                logAlert(event: "üìà Market regime change detected for \(pair): \(regimeType) - Volatility changed by \(volatilityChange * 100)%")
                return true
            }
        }
        
        return false
    }

    static func calculateVolatilityFromPrices(_ prices: [Double]) -> Double {
        guard prices.count > 1 else { return 0.0 }
        
        let returns = zip(prices.dropFirst(), prices.dropLast()).map { (current, previous) in
            (current - previous) / previous
        }
        
        let mean = returns.reduce(0, +) / Double(returns.count)
        let variance = returns.reduce(0.0) { $0 + pow($1 - mean, 2) } / Double(returns.count)
        
        return sqrt(variance)
    }

    // Advanced ML Enhancement Functions
    static func generateMLFeatures(pair: String) -> [String: Double] {
        var features: [String: Double] = [:]
        
        // Price-based features
        if let kucoinPrice = kucoinCurrentPrice[pair] {
            features["kucoin_price"] = kucoinPrice
        }
        if let bybitPrice = bybitCurrentPrice[pair] {
            features["bybit_price"] = bybitPrice
        }
        
        // Technical indicator features
        if let rsi = rsiValues[pair]?.last {
            features["rsi"] = rsi
        }
        if let macd = macdValues[pair]?.last {
            features["macd"] = macd.macd
            features["macd_signal"] = macd.signal
            features["macd_histogram"] = macd.histogram
        }
        
        // Volume features
        if let kucoinVolume = kucoinSpotVolume[pair]?.last {
            features["kucoin_volume"] = kucoinVolume
        }
        if let bybitVolume = bybitSpotVolume[pair]?.last {
            features["bybit_volume"] = bybitVolume
        }
        
        // Sentiment features
        features["sentiment"] = sentimentScores[pair] ?? 0.0
        
        return features
    }

    static func calculateProfitProbability(pair: String, strategy: String) -> Double {
        let metrics = tradeMetrics[pair] ?? (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)
        let totalTrades = metrics.wins + metrics.losses
        
        guard totalTrades > 0 else { return 0.5 } // Default 50% if no history
        
        return Double(metrics.wins) / Double(totalTrades)
    }

    static func optimizeStrategyAllocation() {
        Task { @MainActor in
            var totalScore = 0.0
            var strategyScores: [String: Double] = [:]
            
            // Calculate performance scores for each strategy
            for pair in tradingPairs {
                let arbitrageScore = calculateProfitProbability(pair: pair, strategy: "arbitrage")
                let scalpingScore = calculateProfitProbability(pair: pair, strategy: "scalping")
                let marketMakingScore = calculateProfitProbability(pair: pair, strategy: "market_making")
                
                strategyScores["arbitrage"] = (strategyScores["arbitrage"] ?? 0.0) + arbitrageScore
                strategyScores["scalping"] = (strategyScores["scalping"] ?? 0.0) + scalpingScore
                strategyScores["market_making"] = (strategyScores["market_making"] ?? 0.0) + marketMakingScore
            }
            
            totalScore = strategyScores.values.reduce(0, +)
            
            // Normalize to percentages
            if totalScore > 0 {
                for (strategy, score) in strategyScores {
                    strategyAllocations[strategy] = score / totalScore
                }
            }
            
            print("üìä Strategy allocations updated: \(strategyAllocations)")
            logAlert(event: "üìä Strategy allocations updated: \(strategyAllocations)")
        }
    }

    // Enhanced WebSocket Connection Functions

    static func connectKucoinWebSocket(completion: @escaping () -> Void) {
        guard !kucoinIsConnected else {
            print("KuCoin WebSocket already connected")
            completion()
            return
        }

        guard let socket = kucoinSocket else {
            print("KuCoin WebSocket not initialized")
            Task { @MainActor in
                logAlert(event: "KuCoin WebSocket not initialized")
            }
            completion()
            return
        }

        socket.connect()
        
        // Monitor connection status
        Task {
            var connectionAttempts = 0
            while connectionAttempts < 10 && !kucoinIsConnected {
                try? await Task.sleep(nanoseconds: 1_000_000_000) // 1 second
                connectionAttempts += 1
            }
            
            if kucoinIsConnected {
                print("‚úÖ KuCoin WebSocket connected successfully")
                completion()
            } else {
                print("‚ùå KuCoin WebSocket connection failed after 10 attempts")
                await MainActor.run {
                    logAlert(event: "‚ùå KuCoin WebSocket connection failed after 10 attempts")
                }
                completion()
            }
        }
    }

    static func connectBybitWebSocket(completion: @escaping () -> Void) {
        guard !bybitIsConnected else {
            print("Bybit WebSocket already connected")
            completion()
            return
        }

        let url = URL(string: "wss://stream.bybit.com/v5/public/linear")!
        var request = URLRequest(url: url)
        request.timeoutInterval = Double(websocketTimeoutSeconds)
        bybitSocket = WebSocket(request: request)
        
        bybitSocket?.onEvent = { event in
            switch event {
            case .connected(_):
                Task { @MainActor in
                    bybitIsConnected = true
                    bybitReconnectAttempts = 0
                    print("‚úÖ Bybit WebSocket connected")
                    logAlert(event: "‚úÖ Bybit WebSocket connected")
                    
                    // Subscribe to all trading pairs
                    let tickerTopics = tradingPairs.map { "tickers.\($0.replacingOccurrences(of: "-USDT", with: "USDT"))" }
                    let orderBookTopics = tradingPairs.map { "orderbook.50.\($0.replacingOccurrences(of: "-USDT", with: "USDT"))" }
                    
                    let subscribeMessage: [String: Any] = [
                        "op": "subscribe",
                        "args": tickerTopics + orderBookTopics
                    ]
                    
                    do {
                        let jsonData = try JSONSerialization.data(withJSONObject: subscribeMessage)
                        bybitSocket?.write(data: jsonData)
                        print("üì° Subscribed to Bybit topics: \(tickerTopics.count + orderBookTopics.count) total")
                        logAlert(event: "üì° Subscribed to Bybit topics: \(tickerTopics.count + orderBookTopics.count) total")
                    } catch {
                        print("Failed to send Bybit subscription: \(error)")
                        logAlert(event: "Failed to send Bybit subscription: \(error)")
                    }
                }
                completion()
                
            case .disconnected(let reason, let code):
                Task { @MainActor in
                    bybitIsConnected = false
                    print("‚ùå Bybit WebSocket disconnected: \(reason), code: \(code)")
                    logAlert(event: "‚ùå Bybit WebSocket disconnected: \(reason), code: \(code)")
                    
                    if bybitReconnectAttempts < maxReconnectAttempts {
                        bybitReconnectAttempts += 1
                        DispatchQueue.main.asyncAfter(deadline: .now() + 5.0) {
                            connectBybitWebSocket(completion: completion)
                        }
                    }
                }
                
            case .text(let string):
                Task {
                    do {
                        if let json = try JSONSerialization.jsonObject(with: string.data(using: .utf8)!) as? [String: Any] {
                            await handleWebSocketMessage(socket: bybitSocket!, message: json, exchange: "bybit")
                        }
                    } catch {
                        await MainActor.run {
                            logAlert(event: "Failed to parse Bybit WebSocket message: \(error)")
                        }
                    }
                }
                
            case .error(let error):
                Task { @MainActor in
                    print("‚ùå Bybit WebSocket error: \(error?.localizedDescription ?? "Unknown")")
                    logAlert(event: "‚ùå Bybit WebSocket error: \(error?.localizedDescription ?? "Unknown")")
                }
                
            default:
                break
            }
        }
        
        bybitSocket?.connect()
    }
}



//------------------------------------------------------------------------------------------------------------------- Block 6 - Account Balance and API Initialization
// VARIABLES TO ADD: All variables already exist in this block

extension ExchangeWebSocket {
    static func monitorFundingRateArbitrage() {
        Task {
            await withTaskGroup(of: Void.self) { group in
                let tradingPairsValue = await MainActor.run(body: { tradingPairs })
                for pair in tradingPairsValue {
                    group.addTask { @MainActor @Sendable in
                        let kucoinFundingRate = kucoinFundingRates[pair] ?? 0.0
                        let bybitFundingRate = bybitFundingRates[pair] ?? 0.0
                        let kucoinSpotPrice = kucoinCurrentPrice[pair] ?? 0.0
                        let bybitSpotPrice = bybitCurrentPrice[pair] ?? 0.0
                        let maxFundingRateValue = maxFundingRate
                        
                        guard kucoinSpotPrice > 0, bybitSpotPrice > 0 else {
                            print("DEBUG: Invalid prices for funding rate arbitrage - \(pair): KuCoin=\(kucoinSpotPrice), Bybit=\(bybitSpotPrice)")
                            return
                        }
                        
                        if kucoinFundingRate > maxFundingRateValue || bybitFundingRate > maxFundingRateValue {
                            print("DEBUG: Funding rate too high for \(pair): KuCoin=\(kucoinFundingRate), Bybit=\(bybitFundingRate)")
                            logAlert(event: "Funding rate too high for \(pair): KuCoin=\(kucoinFundingRate), Bybit=\(bybitFundingRate)")
                            return
                        }
                        
                        let tradeAmount = futuresTradeAmount
                        let kucoinLiquidity = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "futures", tradeAmount: tradeAmount, price: kucoinSpotPrice)
                        let bybitLiquidity = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "futures", tradeAmount: tradeAmount, price: bybitSpotPrice)
                        
                        // Use liquidity variables to validate before proceeding
                        guard let kucoinLiquidity = kucoinLiquidity, let bybitLiquidity = bybitLiquidity, kucoinLiquidity >= minLiquidityThreshold, bybitLiquidity >= minLiquidityThreshold else {
                            print("DEBUG: Insufficient liquidity for funding rate arbitrage - \(pair): KuCoin=\(kucoinLiquidity ?? 0.0), Bybit=\(bybitLiquidity ?? 0.0)")
                            logAlert(event: "Insufficient liquidity for funding rate arbitrage - \(pair): KuCoin=\(kucoinLiquidity ?? 0.0), Bybit=\(bybitLiquidity ?? 0.0)")
                            return
                        }
                        
                        let kucoinTradeAmount = await dynamicTradeAmount(balance: kucoinBalance, riskPercent: tradeAmountPercentage, volatility: 0.01)
                        let bybitTradeAmount = await dynamicTradeAmount(balance: bybitBalance, riskPercent: tradeAmountPercentage, volatility: 0.01)
                        
                        // Use trade amount variables to validate before proceeding
                        guard kucoinTradeAmount > 0, bybitTradeAmount > 0 else {
                            print("DEBUG: Invalid trade amounts for funding rate arbitrage - \(pair): KuCoin=\(kucoinTradeAmount), Bybit=\(bybitTradeAmount)")
                            logAlert(event: "Invalid trade amounts for funding rate arbitrage - \(pair): KuCoin=\(kucoinTradeAmount), Bybit=\(bybitTradeAmount)")
                            return
                        }
                        
                        await evaluateFundingRateMomentum(pair: pair, kucoinFundingRate: kucoinFundingRate, bybitFundingRate: bybitFundingRate)
                    }
                }
            }
            
            // Schedule the next check
            try? await Task.sleep(nanoseconds: UInt64(getDouble("ARBITRAGE_CHECK_INTERVAL_SECONDS", defaultValue: 0.5) * 1_000_000_000))
            monitorFundingRateArbitrage()
        }
    }

    static func fetchKuCoinWsToken(completion: @escaping @Sendable (String?) -> Void) {
        let url = URL(string: "https://api.kucoin.com/api/v1/bullet-public")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.timeoutInterval = getDouble("API_TIMEOUT_SECONDS", defaultValue: 10.0)
        
        let startTime = Date()
        URLSession.shared.dataTask(with: request) { data, response, error in
            let latency = Date().timeIntervalSince(startTime) * 1000
            Task { @MainActor in
                lastLatency["kucoin-ws-token"] = latency
                if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 300.0) {
                    print("High latency detected for KuCoin WebSocket token fetch: \(latency)ms")
                    logAlert(event: "High latency detected for KuCoin WebSocket token fetch: \(latency)ms")
                }
            }
            
            if let error = error {
                print("Failed to fetch KuCoin WebSocket token: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to fetch KuCoin WebSocket token: \(error.localizedDescription)")
                }
                completion(nil)
                return
            }
            
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200, let data = data else {
                print("Invalid KuCoin WebSocket token response")
                Task { @MainActor in
                    logAlert(event: "Invalid KuCoin WebSocket token response")
                }
                completion(nil)
                return
            }
            
            do {
                guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                      let dataDict = json["data"] as? [String: Any],
                      let token = dataDict["token"] as? String else {
                    print("Failed to parse KuCoin WebSocket token")
                    Task { @MainActor in
                        logAlert(event: "Failed to parse KuCoin WebSocket token")
                    }
                    completion(nil)
                    return
                }
                
                Task { @MainActor in
                    kucoinToken = token
                    print("DEBUG: Fetched KuCoin WebSocket token: \(token)")
                    kucoinSocket = WebSocket(request: URLRequest(url: URL(string: "wss://ws-api.kucoin.com/endpoint?token=\(token)")!))
                    kucoinSocket?.delegate = kucoinDelegate
                    kucoinSocket?.connect()
                    print("DEBUG: KuCoin WebSocket connected for token: \(token)")
                }
                completion(token)
            } catch {
                print("Failed to parse JSON for KuCoin WebSocket token: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to parse JSON for KuCoin WebSocket token: \(error.localizedDescription)")
                }
                completion(nil)
            }
        }.resume()
    }

    static func fetchKucoinFuturesWsToken(completion: @escaping @Sendable (String?) -> Void) {
        let url = URL(string: "https://api-futures.kucoin.com/api/v1/bullet-public")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.timeoutInterval = getDouble("API_TIMEOUT_SECONDS", defaultValue: 10.0)
        
        let startTime = Date()
        URLSession.shared.dataTask(with: request) { data, response, error in
            let latency = Date().timeIntervalSince(startTime) * 1000
            Task { @MainActor in
                lastLatency["kucoin-futures-ws-token"] = latency
                if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 300.0) {
                    print("High latency detected for KuCoin Futures WebSocket token fetch: \(latency)ms")
                    logAlert(event: "High latency detected for KuCoin Futures WebSocket token fetch: \(latency)ms")
                }
            }
            
            if let error = error {
                print("Failed to fetch KuCoin Futures WebSocket token: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to fetch KuCoin Futures WebSocket token: \(error.localizedDescription)")
                }
                completion(nil)
                return
            }
            
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200, let data = data else {
                print("Invalid KuCoin Futures WebSocket token response")
                Task { @MainActor in
                    logAlert(event: "Invalid KuCoin Futures WebSocket token response")
                }
                completion(nil)
                return
            }
            
            do {
                guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                      let dataDict = json["data"] as? [String: Any],
                      let token = dataDict["token"] as? String else {
                    print("Failed to parse KuCoin Futures WebSocket token")
                    Task { @MainActor in
                        logAlert(event: "Failed to parse KuCoin Futures WebSocket token")
                    }
                    completion(nil)
                    return
                }
                
                Task { @MainActor in
                    kucoinFuturesToken = token
                    print("DEBUG: Fetched KuCoin Futures WebSocket token: \(token)")
                    kucoinFuturesSocket = WebSocket(request: URLRequest(url: URL(string: "wss://ws-api-futures.kucoin.com/endpoint?token=\(token)")!))
                    kucoinFuturesSocket?.delegate = kucoinFuturesDelegate
                    kucoinFuturesSocket?.connect()
                    print("DEBUG: KuCoin Futures WebSocket connected for token: \(token)")
                }
                completion(token)
            } catch {
                print("Failed to parse JSON for KuCoin Futures WebSocket token: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to parse JSON for KuCoin Futures WebSocket token: \(error.localizedDescription)")
                }
                completion(nil)
            }
        }.resume()
    }

    static func fetchKucoinBalance(completion: @escaping @Sendable (Double?) -> Void) {
        guard let apiKey = environment["KUCOIN_API_KEY"],
              let apiSecret = environment["KUCOIN_API_SECRET"],
              let apiPassphrase = environment["KUCOIN_API_PASSPHRASE"] else {
            print("Missing KuCoin API credentials")
            Task { @MainActor in
                logAlert(event: "Missing KuCoin API credentials")
            }
            Task { @MainActor in
                completion(kucoinFallbackBalance)
            }
            return
        }
        
        let url = URL(string: "https://api.kucoin.com/api/v1/accounts")!
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = getDouble("BALANCE_FETCH_TIMEOUT", defaultValue: 20.0)
        
        let timestamp = String(Int(Date().timeIntervalSince1970 * 1000))
        let strToSign = timestamp + "GET" + "/api/v1/accounts"
        let signature = HMAC<SHA256>.authenticationCode(for: strToSign.data(using: .utf8)!, using: SymmetricKey(data: apiSecret.data(using: .utf8)!)).map { String(format: "%02x", $0) }.joined()
        let passphrase = HMAC<SHA256>.authenticationCode(for: apiPassphrase.data(using: .utf8)!, using: SymmetricKey(data: apiSecret.data(using: .utf8)!)).map { String(format: "%02x", $0) }.joined()
        
        request.addValue(apiKey, forHTTPHeaderField: "KC-API-KEY")
        request.addValue(timestamp, forHTTPHeaderField: "KC-API-TIMESTAMP")
        request.addValue(signature, forHTTPHeaderField: "KC-API-SIGN")
        request.addValue(passphrase, forHTTPHeaderField: "KC-API-PASSPHRASE")
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        
        let startTime = Date()
        URLSession.shared.dataTask(with: request) { data, response, error in
            let latency = Date().timeIntervalSince(startTime) * 1000
            Task { @MainActor in
                lastLatency["kucoin-balance"] = latency
                if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 300.0) {
                    print("High latency detected for KuCoin balance fetch: \(latency)ms")
                    logAlert(event: "High latency detected for KuCoin balance fetch: \(latency)ms")
                }
            }
            
            if let error = error {
                print("Failed to fetch KuCoin balance: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to fetch KuCoin balance: \(error.localizedDescription)")
                }
                Task { @MainActor in
                    completion(kucoinFallbackBalance)
                }
                return
            }
            
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200, let data = data else {
                print("Invalid KuCoin balance response")
                Task { @MainActor in
                    logAlert(event: "Invalid KuCoin balance response")
                }
                Task { @MainActor in
                    completion(kucoinFallbackBalance)
                }
                return
            }
            
            do {
                guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                      let dataArray = json["data"] as? [[String: Any]],
                      let usdtAccount = dataArray.first(where: { ($0["currency"] as? String) == "USDT" }),
                      let balanceStr = usdtAccount["balance"] as? String,
                      let balance = Double(balanceStr) else {
                    print("Failed to parse KuCoin balance")
                    Task { @MainActor in
                        logAlert(event: "Failed to parse KuCoin balance")
                    }
                    Task { @MainActor in
                        completion(kucoinFallbackBalance)
                    }
                    return
                }
                
                Task { @MainActor in
                    kucoinBalance = balance
                    print("DEBUG: Fetched KuCoin balance: \(balance)")
                    completion(balance)
                }
            } catch {
                print("Failed to parse JSON for KuCoin balance: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to parse JSON for KuCoin balance: \(error.localizedDescription)")
                }
                Task { @MainActor in
                    completion(kucoinFallbackBalance)
                }
            }
        }.resume()
    }

    static func fetchBybitBalance(completion: @escaping @Sendable (Double?) -> Void) {
        guard let apiKey = environment["BYBIT_API_KEY"],
              let apiSecret = environment["BYBIT_API_SECRET"] else {
            print("Missing Bybit API credentials")
            Task { @MainActor in
                logAlert(event: "Missing Bybit API credentials")
            }
            Task { @MainActor in
                completion(bybitFallbackBalance)
            }
            return
        }
        
        let url = URL(string: "https://api.bybit.com/v5/account/wallet-balance?accountType=UNIFIED")!
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = getDouble("BALANCE_FETCH_TIMEOUT", defaultValue: 20.0)
        
        let timestamp = String(Int(Date().timeIntervalSince1970 * 1000))
        let recvWindow = bybitRecvWindow
        let queryString = "api_key=\(apiKey)&timestamp=\(timestamp)&recv_window=\(recvWindow)"
        let signature = HMAC<SHA256>.authenticationCode(for: queryString.data(using: .utf8)!, using: SymmetricKey(data: apiSecret.data(using: .utf8)!)).map { String(format: "%02x", $0) }.joined()
        
        request.addValue(apiKey, forHTTPHeaderField: "X-BAPI-API-KEY")
        request.addValue(timestamp, forHTTPHeaderField: "X-BAPI-TIMESTAMP")
        request.addValue(signature, forHTTPHeaderField: "X-BAPI-SIGN")
        request.addValue(recvWindow, forHTTPHeaderField: "X-BAPI-RECV-WINDOW")
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        
        let startTime = Date()
        URLSession.shared.dataTask(with: request) { data, response, error in
            let latency = Date().timeIntervalSince(startTime) * 1000
            Task { @MainActor in
                lastLatency["bybit-balance"] = latency
                if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 300.0) {
                    print("High latency detected for Bybit balance fetch: \(latency)ms")
                    logAlert(event: "High latency detected for Bybit balance fetch: \(latency)ms")
                }
            }
            
            if let error = error {
                print("Failed to fetch Bybit balance: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to fetch Bybit balance: \(error.localizedDescription)")
                }
                Task { @MainActor in
                    completion(bybitFallbackBalance)
                }
                return
            }
            
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200, let data = data else {
                print("Invalid Bybit balance response")
                Task { @MainActor in
                    logAlert(event: "Invalid Bybit balance response")
                }
                Task { @MainActor in
                    completion(bybitFallbackBalance)
                }
                return
            }
            
            do {
                guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                      let result = json["result"] as? [String: Any],
                      let list = result["list"] as? [[String: Any]],
                      let unifiedAccount = list.first,
                      let coinArray = unifiedAccount["coin"] as? [[String: Any]],
                      let usdtCoin = coinArray.first(where: { ($0["coin"] as? String) == "USDT" }),
                      let balanceStr = usdtCoin["equity"] as? String,
                      let balance = Double(balanceStr) else {
                    print("Failed to parse Bybit balance")
                    Task { @MainActor in
                        logAlert(event: "Failed to parse Bybit balance")
                    }
                    Task { @MainActor in
                        completion(bybitFallbackBalance)
                    }
                    return
                }
                
                Task { @MainActor in
                    bybitBalance = balance
                    print("DEBUG: Fetched Bybit balance: \(balance)")
                    completion(balance)
                }
            } catch {
                print("Failed to parse JSON for Bybit balance: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to parse JSON for Bybit balance: \(error.localizedDescription)")
                }
                Task { @MainActor in
                    completion(bybitFallbackBalance)
                }
            }
        }.resume()
    }
}


//-------------------------------------------------------------------------------------------------------------------Block 7 - WebSocket Connection Handling

//--------------- Block 7 - WebSocket Connection Management

extension ExchangeWebSocket {
    
    static func subscribeToKuCoinFuturesPrices(pairs: [String]) {
        Task { @MainActor in
            guard kucoinFuturesIsConnected, let socket = kucoinFuturesSocket else {
                print("‚ùå [WebSocket] KuCoin Futures not connected, cannot subscribe to prices")
                logAlert(event: "‚ùå KuCoin Futures not connected, cannot subscribe to prices")
                return
            }
            
            let symbols = pairs.compactMap { pair in
                return kucoinFuturesSymbols[pair]
            }
            
            let subscribeMessage: [String: Any] = [
                "id": Int.random(in: 1...999999),
                "type": "subscribe",
                "topic": "/contractMarket/ticker:\(symbols.joined(separator: ","))",
                "privateChannel": false,
                "response": true
            ]
            
            do {
                let jsonData = try JSONSerialization.data(withJSONObject: subscribeMessage, options: [])
                if let jsonString = String(data: jsonData, encoding: .utf8) {
                    socket.write(string: jsonString)
                    print("‚úÖ [WebSocket] Subscribed to KuCoin Futures prices for \(pairs.count) pairs")
                    logAlert(event: "‚úÖ Subscribed to KuCoin Futures prices for \(pairs.count) pairs")
                }
            } catch {
                print("‚ùå [WebSocket] Failed to subscribe to KuCoin Futures prices: \(error)")
                logAlert(event: "‚ùå Failed to subscribe to KuCoin Futures prices: \(error)")
            }
        }
    }
    
    static func subscribeToBybitFuturesPrices(pairs: [String]) {
        Task { @MainActor in
            guard bybitIsConnected, let socket = bybitSocket else {
                print("‚ùå [WebSocket] Bybit Futures not connected, cannot subscribe to prices")
                logAlert(event: "‚ùå Bybit Futures not connected, cannot subscribe to prices")
                return
            }
            
            let symbols = pairs.map { $0.replacingOccurrences(of: "-", with: "") }
            let topics = symbols.map { "tickers.\($0)" }
            
            let subscribeMessage: [String: Any] = [
                "op": "subscribe",
                "args": topics
            ]
            
            do {
                let jsonData = try JSONSerialization.data(withJSONObject: subscribeMessage, options: [])
                if let jsonString = String(data: jsonData, encoding: .utf8) {
                    socket.write(string: jsonString)
                    print("‚úÖ [WebSocket] Subscribed to Bybit Futures prices for \(pairs.count) pairs")
                    logAlert(event: "‚úÖ Subscribed to Bybit Futures prices for \(pairs.count) pairs")
                }
            } catch {
                print("‚ùå [WebSocket] Failed to subscribe to Bybit Futures prices: \(error)")
                logAlert(event: "‚ùå Failed to subscribe to Bybit Futures prices: \(error)")
            }
        }
    }

    // FIXED: Dashboard JSON Generation - Add this function to ExchangeWebSocket class

    static func updateDashboardJSON() {
        Task { @MainActor in
            // FIXED: Write dashboard.json to the correct location where Flask can find it
            let dashboardPath = "/Users/robertsteinegger/Desktop/BevaixBot/dashboard.json"
            
            // Collect LIVE price data from WebSocket feeds
            var livePrices: [String: [String: Double]] = [:]
            
            for pair in tradingPairs {
                var pairPrices: [String: Double] = [:]
                
                // Get current live prices (not fallback values)
                let kucoinSpotPrice = kucoinCurrentPrice[pair] ?? 0.0
                let kucoinFuturesPrice = kucoinCurrentFuturesPrice[pair] ?? 0.0
                let bybitSpotPrice = bybitCurrentPrice[pair] ?? 0.0
                let bybitFuturesPrice = bybitCurrentFuturesPrice[pair] ?? 0.0
                
                // Only include pairs with live data (price > 0)
                if kucoinSpotPrice > 0 || bybitSpotPrice > 0 {
                    pairPrices["kucoin_spot"] = kucoinSpotPrice
                    pairPrices["kucoin_futures"] = kucoinFuturesPrice
                    pairPrices["bybit_spot"] = bybitSpotPrice
                    pairPrices["bybit_futures"] = bybitFuturesPrice
                    livePrices[pair] = pairPrices
                }
            }
            
            // Calculate real metrics from actual data
            let totalTrades = performanceMetrics.values.reduce(0) { $0 + $1.trades }
            let totalProfit = performanceMetrics.values.reduce(0.0) { $0 + $1.profit }
            let totalFees = performanceMetrics.values.reduce(0.0) { $0 + $1.fees }
            let winningTrades = performanceMetrics.values.reduce(0) { $0 + $1.wins }
            let winRate = totalTrades > 0 ? Double(winningTrades) / Double(totalTrades) * 100.0 : 0.0
            
            // Build comprehensive dashboard data
            let dashboardData: [String: Any] = [
                "timestamp": ISO8601DateFormatter().string(from: Date()),
                "kucoinBalance": kucoinBalance,
                "bybitBalance": bybitBalance,
                "kucoinFuturesBalance": kucoinFuturesBalance,
                "bybitFuturesBalance": bybitFuturesBalance,
                "livePrices": livePrices,
                "totalTrades": totalTrades,
                "totalProfit": totalProfit,
                "totalFees": totalFees,
                "winRate": winRate,
                "activePairs": tradingPairs.count,
                "connectedExchanges": [
                    "kucoin": kucoinIsConnected,
                    "kucoin_futures": kucoinFuturesIsConnected,
                    "bybit": bybitIsConnected,
                    "bybit_futures": bybitFuturesIsConnected
                ],
                "tradingActive": tradingActive,
                "dailyLoss": dailyLoss
            ]
            
            // Write JSON file
            do {
                let jsonData = try JSONSerialization.data(withJSONObject: dashboardData, options: .prettyPrinted)
                try jsonData.write(to: URL(fileURLWithPath: dashboardPath))
                
                print("‚úÖ Updated dashboard.json with live data: \(livePrices.count) pairs, \(totalTrades) trades")
                logAlert(event: "‚úÖ Dashboard updated: \(livePrices.count) pairs, $\(String(format: "%.2f", totalProfit)) profit")
                
            } catch {
                print("‚ùå Failed to write dashboard.json: \(error)")
                logAlert(event: "‚ùå Failed to write dashboard.json: \(error)")
            }
        }
    }

    // FIXED: Enhanced dashboard metrics with real-time updates
    static func logDashboardMetrics() {
        Task { @MainActor in
            let timestamp = ISO8601DateFormatter().string(from: Date())
            
            // Count active price feeds
            var activePairCount = 0
            for pair in tradingPairs {
                if (kucoinCurrentPrice[pair] ?? 0.0) > 0 || (bybitCurrentPrice[pair] ?? 0.0) > 0 {
                    activePairCount += 1
                }
            }
            
            let metrics = """
            [\(timestamp)] Dashboard Metrics:
            KuCoin Balance: \(kucoinBalance) USDT
            Bybit Balance: \(bybitBalance) USDT
            KuCoin Futures: \(kucoinFuturesBalance) USDT
            Bybit Futures: \(bybitFuturesBalance) USDT
            Total Trades: \(performanceMetrics.values.reduce(0) { $0 + $1.trades })
            Total Profit: \(performanceMetrics.values.reduce(0.0) { $0 + $1.profit }) USDT
            Total Fees: \(performanceMetrics.values.reduce(0.0) { $0 + $1.fees }) USDT
            Active Price Feeds: \(activePairCount)/\(tradingPairs.count)
            WebSocket Status: KC=\(kucoinIsConnected), KCF=\(kucoinFuturesIsConnected), BB=\(bybitIsConnected), BBF=\(bybitFuturesIsConnected)
            """
            
            print(metrics)
            logAlert(event: metrics)
            
            // FIXED: Update dashboard JSON with every metric update
            updateDashboardJSON()
        }
    }

    static func connectKuCoinSpotWebSocket() {
        print("üîÑ [WebSocket] Connecting to KuCoin Spot WebSocket...")
        
        Task { @MainActor in
            logAlert(event: "üîÑ Connecting to KuCoin Spot WebSocket...")
        }
        
        // First get connection token
        fetchKuCoinWebSocketToken { token in
            Task { @MainActor in
                guard let websocketToken = token else {
                    print("‚ùå [WebSocket] Failed to get KuCoin WebSocket token")
                    logAlert(event: "‚ùå Failed to get KuCoin WebSocket token")
                    return
                }
                
                kucoinToken = websocketToken
                
                // Connect to WebSocket
                guard let url = URL(string: "wss://ws-api-spot.kucoin.com/?token=\(websocketToken)") else {
                    print("‚ùå [WebSocket] Invalid KuCoin WebSocket URL")
                    logAlert(event: "‚ùå Invalid KuCoin WebSocket URL")
                    return
                }
                
                var request = URLRequest(url: url)
                request.timeoutInterval = TimeInterval(websocketTimeoutSeconds)
                
                let socket = WebSocket(request: request)
                kucoinSocket = socket
                socket.connect()
                
                print("üîÑ [WebSocket] KuCoin Spot WebSocket connection initiated")
                logAlert(event: "üîÑ KuCoin Spot WebSocket connection initiated")
            }
        }
    }

    static func fetchKuCoinWebSocketToken(completion: @escaping @Sendable (String?) -> Void) {
        guard let url = URL(string: "https://api.kucoin.com/api/v1/bullet-public") else {
            print("‚ùå [API] Invalid KuCoin token URL")
            completion(nil)
            return
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.timeoutInterval = TimeInterval(balanceFetchTimeout)
        
        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                print("‚ùå [API] Failed to get KuCoin WebSocket token: \(error.localizedDescription)")
                completion(nil)
                return
            }
            
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200,
                  let data = data,
                  let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let responseData = json["data"] as? [String: Any],
                  let token = responseData["token"] as? String else {
                print("‚ùå [API] Invalid KuCoin WebSocket token response")
                completion(nil)
                return
            }
            
            print("‚úÖ [API] Successfully obtained KuCoin WebSocket token")
            completion(token)
        }
        task.resume()
    }

    static func fetchKuCoinFuturesWebSocketToken(completion: @escaping @Sendable (String?) -> Void) {
        guard let url = URL(string: "https://api-futures.kucoin.com/api/v1/bullet-public") else {
            print("‚ùå [API] Invalid KuCoin Futures token URL")
            completion(nil)
            return
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.timeoutInterval = TimeInterval(balanceFetchTimeout)
        
        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                print("‚ùå [API] Failed to get KuCoin Futures WebSocket token: \(error.localizedDescription)")
                completion(nil)
                return
            }
            
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200,
                  let data = data,
                  let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let responseData = json["data"] as? [String: Any],
                  let token = responseData["token"] as? String else {
                print("‚ùå [API] Invalid KuCoin Futures WebSocket token response")
                completion(nil)
                return
            }
            
            print("‚úÖ [API] Successfully obtained KuCoin Futures WebSocket token")
            completion(token)
        }
        task.resume()
    }

    static func connectBybitSpotWebSocket() {
        print("üîÑ [WebSocket] Connecting to Bybit Spot WebSocket...")
        
        Task { @MainActor in
            logAlert(event: "üîÑ Connecting to Bybit Spot WebSocket...")
        }
        
        guard let url = URL(string: "wss://stream.bybit.com/v5/public/spot") else {
            print("‚ùå [WebSocket] Invalid Bybit Spot WebSocket URL")
            Task { @MainActor in
                logAlert(event: "‚ùå Invalid Bybit Spot WebSocket URL")
            }
            return
        }
        
        var request = URLRequest(url: url)
        request.timeoutInterval = TimeInterval(websocketTimeoutSeconds)
        
        let socket = WebSocket(request: request)
        bybitSpotSocket = socket
        socket.connect()
        
        print("üîÑ [WebSocket] Bybit Spot WebSocket connection initiated")
        Task { @MainActor in
            logAlert(event: "üîÑ Bybit Spot WebSocket connection initiated")
        }
    }

    static func connectKuCoinFuturesWebSocket() {
        print("üîÑ [WebSocket] Connecting to KuCoin Futures WebSocket...")
        
        Task { @MainActor in
            logAlert(event: "üîÑ Connecting to KuCoin Futures WebSocket...")
        }
        
        fetchKuCoinFuturesWebSocketToken { token in
            Task { @MainActor in
                guard let websocketToken = token else {
                    print("‚ùå [WebSocket] Failed to get KuCoin Futures WebSocket token")
                    logAlert(event: "‚ùå Failed to get KuCoin Futures WebSocket token")
                    return
                }
                
                kucoinFuturesToken = websocketToken
                
                guard let url = URL(string: "wss://ws-api-futures.kucoin.com/?token=\(websocketToken)") else {
                    print("‚ùå [WebSocket] Invalid KuCoin Futures WebSocket URL")
                    logAlert(event: "‚ùå Invalid KuCoin Futures WebSocket URL")
                    return
                }
                
                var request = URLRequest(url: url)
                request.timeoutInterval = TimeInterval(websocketTimeoutSeconds)
                
                let socket = WebSocket(request: request)
                kucoinFuturesSocket = socket
                socket.connect()
                
                print("üîÑ [WebSocket] KuCoin Futures WebSocket connection initiated")
                logAlert(event: "üîÑ KuCoin Futures WebSocket connection initiated")
            }
        }
    }

    static func connectBybitFuturesWebSocket() {
        print("üîÑ [WebSocket] Connecting to Bybit Futures WebSocket...")
        
        Task { @MainActor in
            logAlert(event: "üîÑ Connecting to Bybit Futures WebSocket...")
        }
        
        guard let url = URL(string: "wss://stream.bybit.com/v5/public/linear") else {
            print("‚ùå [WebSocket] Invalid Bybit Futures WebSocket URL")
            Task { @MainActor in
                logAlert(event: "‚ùå Invalid Bybit Futures WebSocket URL")
            }
            return
        }
        
        var request = URLRequest(url: url)
        request.timeoutInterval = TimeInterval(websocketTimeoutSeconds)
        
        let socket = WebSocket(request: request)
        bybitSocket = socket
        socket.connect()
        
        print("üîÑ [WebSocket] Bybit Futures WebSocket connection initiated")
        Task { @MainActor in
            logAlert(event: "üîÑ Bybit Futures WebSocket connection initiated")
        }
    }

    static func subscribeToAllPriceFeeds() {
        Task { @MainActor in
            let pairs = tradingPairs
            logAlert(event: "üîÑ Subscribing to price feeds for \(pairs.count) pairs: \(pairs.joined(separator: ", "))")
            
            // Subscribe to KuCoin Spot
            subscribeToKuCoinSpotPrices(pairs: pairs)
            
            // Subscribe to KuCoin Futures
            subscribeToKuCoinFuturesPrices(pairs: pairs)
            
            // Subscribe to Bybit Spot
            subscribeToBybitSpotPrices(pairs: pairs)
            
            // Subscribe to Bybit Futures
            subscribeToBybitFuturesPrices(pairs: pairs)
        }
    }

    static func subscribeToKuCoinSpotPrices(pairs: [String]) {
        Task { @MainActor in
            guard kucoinIsConnected, let socket = kucoinSocket else {
                print("‚ùå [WebSocket] KuCoin Spot not connected, cannot subscribe to prices")
                logAlert(event: "‚ùå KuCoin Spot not connected, cannot subscribe to prices")
                return
            }
            
            let symbols = pairs.map { $0.replacingOccurrences(of: "-", with: "") }
            let subscribeMessage: [String: Any] = [
                "id": Int.random(in: 1...999999),
                "type": "subscribe",
                "topic": "/market/ticker:\(symbols.joined(separator: ","))",
                "privateChannel": false,
                "response": true
            ]
            
            do {
                let jsonData = try JSONSerialization.data(withJSONObject: subscribeMessage, options: [])
                if let jsonString = String(data: jsonData, encoding: .utf8) {
                    socket.write(string: jsonString)
                    print("‚úÖ [WebSocket] Subscribed to KuCoin Spot prices for \(pairs.count) pairs")
                    logAlert(event: "‚úÖ Subscribed to KuCoin Spot prices for \(pairs.count) pairs")
                }
            } catch {
                print("‚ùå [WebSocket] Failed to subscribe to KuCoin Spot prices: \(error)")
                logAlert(event: "‚ùå Failed to subscribe to KuCoin Spot prices: \(error)")
            }
        }
    }

    static func subscribeToBybitSpotPrices(pairs: [String]) {
        Task { @MainActor in
            guard bybitFuturesIsConnected, let socket = bybitSpotSocket else {
                print("‚ùå [WebSocket] Bybit Spot not connected, cannot subscribe to prices")
                logAlert(event: "‚ùå Bybit Spot not connected, cannot subscribe to prices")
                return
            }
            
            let symbols = pairs.map { $0.replacingOccurrences(of: "-", with: "") }
            let topics = symbols.map { "tickers.\($0)" }
            
            let subscribeMessage: [String: Any] = [
                "op": "subscribe",
                "args": topics
            ]
            
            do {
                let jsonData = try JSONSerialization.data(withJSONObject: subscribeMessage, options: [])
                if let jsonString = String(data: jsonData, encoding: .utf8) {
                    socket.write(string: jsonString)
                    print("‚úÖ [WebSocket] Subscribed to Bybit Spot prices for \(pairs.count) pairs")
                    logAlert(event: "‚úÖ Subscribed to Bybit Spot prices for \(pairs.count) pairs")
                }
            } catch {
                print("‚ùå [WebSocket] Failed to subscribe to Bybit Spot prices: \(error)")
                logAlert(event: "‚ùå Failed to subscribe to Bybit Spot prices: \(error)")
            }
        }
    }

    static func initializeAllWebSocketConnections() {
        Task { @MainActor in
            logAlert(event: "üöÄ Initializing all WebSocket connections...")
            
            // Connect to all exchanges
            connectKuCoinSpotWebSocket()
            connectBybitSpotWebSocket()
            connectKuCoinFuturesWebSocket()
            connectBybitFuturesWebSocket()
            
            // Wait for connections to establish
            DispatchQueue.main.asyncAfter(deadline: .now() + 5.0) {
                subscribeToAllPriceFeeds()
                
                // Start periodic dashboard updates
                Timer.scheduledTimer(withTimeInterval: 5.0, repeats: true) { _ in
                    Task { @MainActor in
                        updateDashboardJSON()
                    }
                }
                
                Task { @MainActor in
                    logAlert(event: "‚úÖ All WebSocket connections and subscriptions initialized")
                }
            }
        }
    }
}
//---------------------------------------------------------------------------------------------------------------------Block 8 - WebSocket Delegate Operations


import Foundation
import CryptoKit // Added for HMAC-SHA256

extension ExchangeWebSocket {
    static func fetchBybitFundingRate(pair: String, retryCount: Int = 0, completion: @escaping @Sendable (Double?) -> Void) {
        let maxRetries = getInt("API_MAX_RETRIES", defaultValue: 3)
        let localRetryCountCopy = retryCount // Local copy to avoid mutation
        guard localRetryCountCopy < maxRetries else {
            print("Max retries reached for Bybit funding rate fetch: \(pair)")
            Task { @MainActor in
                logAlert(event: "Max retries reached for Bybit funding rate fetch: \(pair)")
            }
            Task { @MainActor in
                completion(bybitFundingRates[pair])
            }
            return
        }

        let symbol = pair.replacingOccurrences(of: "-USDT", with: "USDT")
        let url = URL(string: "https://api.bybit.com/v5/market/tickers?category=linear&symbol=\(symbol)")!
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = getDouble("API_TIMEOUT_SECONDS", defaultValue: 15.0)

        let startTime = Date()
        URLSession.shared.dataTask(with: request) { data, response, error in
            let latency = Date().timeIntervalSince(startTime) * 1000
            Task { @MainActor in
                lastLatency[pair] = latency
                if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 200.0) {
                    print("High latency detected for Bybit funding rate fetch: \(pair) - \(latency)ms")
                    logAlert(event: "High latency detected for Bybit funding rate fetch: \(pair) - \(latency)ms")
                }
            }

            if let error = error {
                print("Failed to fetch Bybit funding rate for \(pair): \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to fetch Bybit funding rate for \(pair): \(error.localizedDescription)")
                }
                let attemptFetch: @Sendable (_: Int) -> Void = { _ in
                    let newRetryCount = localRetryCountCopy + 1
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                        fetchBybitFundingRate(pair: pair, retryCount: newRetryCount, completion: completion)
                    }
                }
                attemptFetch(localRetryCountCopy)
                return
            }

            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200, let data = data else {
                print("Invalid Bybit funding rate response for \(pair)")
                Task { @MainActor in
                    logAlert(event: "Invalid Bybit funding rate response for \(pair)")
                }
                let attemptFetch: @Sendable (_: Int) -> Void = { _ in
                    let newRetryCount = localRetryCountCopy + 1
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                        fetchBybitFundingRate(pair: pair, retryCount: newRetryCount, completion: completion)
                    }
                }
                attemptFetch(localRetryCountCopy)
                return
            }

            do {
                guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                      let result = json["result"] as? [String: Any],
                      let list = result["list"] as? [[String: Any]],
                      let fundingRateStr = list.first?["fundingRate"] as? String,
                      let fundingRate = Double(fundingRateStr) else {
                    print("Failed to parse Bybit funding rate for \(pair)")
                    Task { @MainActor in
                        logAlert(event: "Failed to parse Bybit funding rate for \(pair)")
                    }
                    let attemptFetch: @Sendable (_: Int) -> Void = { _ in
                        let newRetryCount = localRetryCountCopy + 1
                        DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                            fetchBybitFundingRate(pair: pair, retryCount: newRetryCount, completion: completion)
                        }
                    }
                    attemptFetch(localRetryCountCopy)
                    return
                }

                Task { @MainActor in
                    bybitFundingRates[pair] = fundingRate
                    bybitFundingRateHistory[pair, default: []].append(fundingRate)
                    if bybitFundingRateHistory[pair]!.count > priceHistoryRetention {
                        bybitFundingRateHistory[pair]!.removeFirst()
                    }
                    print("DEBUG: Fetched Bybit funding rate for \(pair): \(fundingRate)")
                    completion(fundingRate)
                }
            } catch {
                print("DEBUG: JSON parsing error for Bybit funding rate \(pair): \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "JSON parsing error for Bybit funding rate \(pair): \(error.localizedDescription)")
                }
                let attemptFetch: @Sendable (_: Int) -> Void = { _ in
                    let newRetryCount = localRetryCountCopy + 1
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                        fetchBybitFundingRate(pair: pair, retryCount: newRetryCount, completion: completion)
                    }
                }
                attemptFetch(localRetryCountCopy)
            }
        }.resume()
    }

    static func fetchKucoinOrderBookDepth(pair: String, marketType: String, retryCount: Int = 0, completion: @escaping @Sendable (Double?) -> Void) {
        let maxRetries = getInt("API_MAX_RETRIES", defaultValue: 3)
        let localRetryCountCopy = retryCount // Local copy to avoid mutation
        guard localRetryCountCopy < maxRetries else {
            print("Max retries reached for KuCoin order book fetch: \(pair)-\(marketType)")
            Task { @MainActor in
                logAlert(event: "Max retries reached for KuCoin order book fetch: \(pair)-\(marketType)")
                let book = kucoinOrderBooks[pair]
                let cachedDepth = book.map { book in
                    let bidDepth = book.bids.prefix(10).reduce(0.0) { $0 + $1.price * $1.quantity }
                    let askDepth = book.asks.prefix(10).reduce(0.0) { $0 + $1.price * $1.quantity }
                    return bidDepth + askDepth
                } ?? getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 20000.0)
                print("DEBUG: Using cached depth for KuCoin \(pair)-\(marketType): \(cachedDepth)")
                if cachedDepth < getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 20000.0) {
                    logAlert(event: "Insufficient cached depth for KuCoin \(pair)-\(marketType): Depth \(cachedDepth), Required \(getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 20000.0))")
                }
                completion(cachedDepth)
            }
            return
        }

        // Rate limit check
        let refreshRate = getDouble("MIN_ORDERBOOK_REFRESH_RATE", defaultValue: marketType == "spot" ? 3.0 : 1.0)
        let lastFetchTime = ExchangeWebSocket.lastKucoinFetchTime[pair, default: .distantPast]
        let timeSinceLastFetch = Date().timeIntervalSince(lastFetchTime)
        guard timeSinceLastFetch >= refreshRate else {
            print("Rate limit: Skipping KuCoin order book fetch for \(pair)-\(marketType), time since last fetch: \(timeSinceLastFetch)s, required: \(refreshRate)s")
            Task { @MainActor in
                logAlert(event: "Rate limit: Skipping KuCoin order book fetch for \(pair)-\(marketType), time since last fetch: \(timeSinceLastFetch)s, required: \(refreshRate)s")
            }
            completion(nil)
            return
        }

        let symbol = pair.replacingOccurrences(of: "-USDT", with: "USDT")
        let endpoint = marketType == "spot" ? "/api/v1/market/orderbook/level2_50?symbol=\(symbol)" : "/api/v1/contractMarket/level2?symbol=\(symbol)M"
        guard let url = URL(string: "https://api\(marketType == "spot" ? "" : "-futures").kucoin.com\(endpoint)") else {
            print("Invalid KuCoin order book URL for \(pair)-\(marketType)")
            Task { @MainActor in
                logAlert(event: "Invalid KuCoin order book URL for \(pair)-\(marketType)")
            }
            let attemptFetch: @Sendable () -> Void = {
                let newRetryCount = localRetryCountCopy + 1
                DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                    fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                }
            }
            attemptFetch()
            return
        }

        // Load and validate API credentials with detailed logging
        let env = ProcessInfo.processInfo.environment
        let apiKey = env["KUCOIN_API_KEY"]
        let apiSecret = env["KUCOIN_API_SECRET"]
        let passphrase = env["KUCOIN_API_PASSPHRASE"]
        print("DEBUG: Loaded env variables - KUCOIN_API_KEY=\(apiKey != nil ? "present" : "missing"), KUCOIN_API_SECRET=\(apiSecret != nil ? "present" : "missing"), KUCOIN_API_PASSPHRASE=\(passphrase != nil ? "present" : "missing")")
        guard let apiKey = apiKey, !apiKey.isEmpty,
              let apiSecret = apiSecret, !apiSecret.isEmpty else {
            print("Missing or empty KuCoin API credentials for \(pair)-\(marketType): API_KEY=\(apiKey != nil ? "present" : "missing"), API_SECRET=\(apiSecret != nil ? "present" : "missing")")
            Task { @MainActor in
                logAlert(event: "Missing or empty KuCoin API credentials for \(pair)-\(marketType): API_KEY=\(apiKey != nil ? "present" : "missing"), API_SECRET=\(apiSecret != nil ? "present" : "missing")")
            }
            let attemptFetch: @Sendable () -> Void = {
                let newRetryCount = localRetryCountCopy + 1
                DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                    fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                }
            }
            attemptFetch()
            return
        }

        // HMAC-SHA256 function for KuCoin API signature
        @Sendable func hmacSHA256(_ data: String, key: String) -> String {
            let keyData = key.data(using: .utf8)!
            let dataToSign = data.data(using: .utf8)!
            let hmac = HMAC<SHA256>.authenticationCode(for: dataToSign, using: SymmetricKey(data: keyData))
            return Data(hmac).base64EncodedString()
        }

        // Compute passphrase if provided
        let computedPassphrase = passphrase.map { hmacSHA256($0, key: apiSecret) }

        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = getDouble("API_TIMEOUT_SECONDS", defaultValue: 15.0)
        let timestamp = String(Int(Date().timeIntervalSince1970 * 1000)) // Initial timestamp

        // Sync timestamp with KuCoin server
        let serverTimeUrl = URL(string: "https://api.kucoin.com/api/v1/timestamp")!
        var serverTimeRequest = URLRequest(url: serverTimeUrl)
        serverTimeRequest.httpMethod = "GET"
        serverTimeRequest.timeoutInterval = 15.0
        URLSession.shared.dataTask(with: serverTimeRequest) { data, response, error in
            if let data = data, let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
               let serverTime = json["data"] as? Int {
                let adjustedTimestamp = String(serverTime)
                var syncedRequest = URLRequest(url: url)
                syncedRequest.httpMethod = "GET"
                syncedRequest.timeoutInterval = getDouble("API_TIMEOUT_SECONDS", defaultValue: 15.0)
                let signature = hmacSHA256(adjustedTimestamp + "GET" + endpoint, key: apiSecret)
                syncedRequest.addValue(apiKey, forHTTPHeaderField: "KC-API-KEY")
                syncedRequest.addValue(adjustedTimestamp, forHTTPHeaderField: "KC-API-TIMESTAMP")
                syncedRequest.addValue(signature, forHTTPHeaderField: "KC-API-SIGN")
                syncedRequest.addValue("2", forHTTPHeaderField: "KC-API-KEY-VERSION")
                syncedRequest.addValue("application/json", forHTTPHeaderField: "Content-Type")
                if let passphrase = computedPassphrase {
                    syncedRequest.addValue(passphrase, forHTTPHeaderField: "KC-API-PASSPHRASE")
                }
                print("DEBUG: Synced KuCoin request for \(pair)-\(marketType): Timestamp \(adjustedTimestamp), Signature \(signature), Passphrase \(passphrase != nil ? "present" : "missing")")
                Task { @MainActor in
                    logAlert(event: "DEBUG: Synced KuCoin request for \(pair)-\(marketType): Timestamp \(adjustedTimestamp), Signature \(signature), Passphrase \(passphrase != nil ? "present" : "missing")")
                }
                let startTime = Date()
                URLSession.shared.dataTask(with: syncedRequest) { data, response, error in
                    let latency = Date().timeIntervalSince(startTime) * 1000
                    Task { @MainActor in
                        lastLatency[pair] = latency
                        ExchangeWebSocket.lastKucoinFetchTime[pair] = Date()
                        if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 200.0) {
                            print("High latency detected for KuCoin order book fetch: \(pair)-\(marketType) - \(latency)ms")
                            logAlert(event: "High latency detected for KuCoin order book fetch: \(pair)-\(marketType) - \(latency)ms")
                        }
                    }
                    if let error = error {
                        print("Failed to fetch KuCoin order book for \(pair)-\(marketType): \(error.localizedDescription)")
                        Task { @MainActor in
                            logAlert(event: "Failed to fetch KuCoin order book for \(pair)-\(marketType): \(error.localizedDescription)")
                        }
                        let attemptFetch: @Sendable () -> Void = {
                            let newRetryCount = localRetryCountCopy + 1
                            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                            }
                        }
                        attemptFetch()
                        return
                    }
                    guard let httpResponse = response as? HTTPURLResponse, let data = data else {
                        print("Invalid KuCoin order book response for \(pair)-\(marketType): No HTTP response or data")
                        Task { @MainActor in
                            logAlert(event: "Invalid KuCoin order book response for \(pair)-\(marketType): No HTTP response or data")
                        }
                        let attemptFetch: @Sendable () -> Void = {
                            let newRetryCount = localRetryCountCopy + 1
                            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                            }
                        }
                        attemptFetch()
                        return
                    }
                    guard httpResponse.statusCode == 200 else {
                        let statusCode = httpResponse.statusCode
                        let responseBody = String(data: data, encoding: .utf8) ?? "No response body"
                        let errorMessage: String
                        let delay: Double
                        switch statusCode {
                        case 401, 403:
                            errorMessage = "Authentication failed (\(statusCode)) for \(pair)-\(marketType): Invalid API key, signature, or timestamp, Body: \(responseBody)"
                            delay = pow(2.0, Double(localRetryCountCopy + 1))
                        case 429:
                            errorMessage = "Rate limit exceeded (429) for \(pair)-\(marketType): Body: \(responseBody)"
                            delay = 60.0
                        default:
                            errorMessage = "Invalid KuCoin order book response for \(pair)-\(marketType): Status code \(statusCode), Body: \(responseBody)"
                            delay = 2.0
                        }
                        print(errorMessage)
                        Task { @MainActor in
                            logAlert(event: errorMessage)
                        }
                        let attemptFetch: @Sendable () -> Void = {
                            let newRetryCount = localRetryCountCopy + 1
                            DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
                                fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                            }
                        }
                        attemptFetch()
                        return
                    }
                    do {
                        guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
                            let responseBody = String(data: data, encoding: .utf8) ?? "No response body"
                            print("Failed to parse KuCoin order book JSON for \(pair)-\(marketType): \(responseBody)")
                            Task { @MainActor in
                                logAlert(event: "Failed to parse KuCoin order book JSON for \(pair)-\(marketType): \(responseBody)")
                            }
                            let attemptFetch: @Sendable () -> Void = {
                                let newRetryCount = localRetryCountCopy + 1
                                DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                    fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                                }
                            }
                            attemptFetch()
                            return
                        }
                        guard let dataDict = json["data"] as? [String: Any],
                              let bids = dataDict["bids"] as? [[String]] ?? (dataDict["bids"] as? String == "null" ? [] : nil),
                              let asks = dataDict["asks"] as? [[String]] ?? (dataDict["asks"] as? String == "null" ? [] : nil) else {
                            let responseBody = String(data: data, encoding: .utf8) ?? "No response body"
                            print("Failed to parse KuCoin order book data for \(pair)-\(marketType): Body: \(responseBody)")
                            Task { @MainActor in
                                logAlert(event: "Failed to parse KuCoin order book data for \(pair)-\(marketType): Body: \(responseBody)")
                            }
                            let attemptFetch: @Sendable () -> Void = {
                                let newRetryCount = localRetryCountCopy + 1
                                DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                    fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                                }
                            }
                            attemptFetch()
                            return
                        }
                        var bidDepth: Double = 0.0
                        var askDepth: Double = 0.0
                        var bestBidPrice: Double = 0.0
                        var bestAskPrice: Double = 0.0
                        for bidEntry in bids.prefix(10) {
                            guard bidEntry.count >= 2,
                                  let priceStr = bidEntry.first,
                                  let qtyStr = bidEntry.last,
                                  let price = Double(priceStr),
                                  let qty = Double(qtyStr) else {
                                print("DEBUG: Skipping invalid bid entry for \(pair)-\(marketType): \(bidEntry)")
                                continue
                            }
                            bidDepth += price * qty
                            if price > bestBidPrice { bestBidPrice = price }
                        }
                        for ask in asks.prefix(10) {
                            guard ask.count >= 2,
                                  let priceStr = ask.first,
                                  let qtyStr = ask.last,
                                  let price = Double(priceStr),
                                  let qty = Double(qtyStr) else {
                                print("DEBUG: Skipping invalid ask entry for \(pair)-\(marketType): \(ask)")
                                continue
                            }
                            askDepth += price * qty
                            if bestAskPrice == 0.0 || price < bestAskPrice { bestAskPrice = price }
                        }
                        guard bidDepth > 0 || askDepth > 0 else {
                            print("Failed to parse KuCoin order book data for \(pair)-\(marketType): Empty depth")
                            Task { @MainActor in
                                logAlert(event: "Failed to parse KuCoin order book data for \(pair)-\(marketType): Empty depth")
                            }
                            let attemptFetch: @Sendable () -> Void = {
                                let newRetryCount = localRetryCountCopy + 1
                                DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                    fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                                }
                            }
                            attemptFetch()
                            return
                        }
                        let totalDepth = bidDepth + askDepth
                        let spread = bestAskPrice > 0 && bestBidPrice > 0 ? bestAskPrice - bestBidPrice : nil
                        Task { @MainActor in
                            if let spread = spread {
                                let timestamp = ISO8601DateFormatter().string(from: Date())
                                let spreadEntry = "\(timestamp),\(pair),\(marketType),\(bestBidPrice),\(bestAskPrice),\(spread)\n"
                                do {
                                    let fileURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/historical_spreads.csv")
                                    if !FileManager.default.fileExists(atPath: fileURL.path) {
                                        FileManager.default.createFile(atPath: fileURL.path, contents: "timestamp,pair,market_type,bid_price,ask_price,spread\n".data(using: .utf8))
                                    }
                                    let fileHandle = try FileHandle(forWritingTo: fileURL)
                                    fileHandle.seekToEndOfFile()
                                    if let data = spreadEntry.data(using: .utf8) {
                                        fileHandle.write(data)
                                    }
                                    fileHandle.closeFile()
                                } catch {
                                    print("DEBUG: Failed to write to historical_spreads.csv for \(pair)-\(marketType): \(error.localizedDescription)")
                                    logAlert(event: "Failed to write to historical_spreads.csv for \(pair)-\(marketType): \(error.localizedDescription)")
                                }
                            }
                            let orderBook = BevaixOrderBook(bids: bids.compactMap { entry in
                                guard entry.count >= 2, let price = Double(entry[0]), let quantity = Double(entry[1]) else { return nil }
                                return (price: price, quantity: quantity)
                            }, asks: asks.compactMap { entry in
                                guard entry.count >= 2, let price = Double(entry[0]), let quantity = Double(entry[1]) else { return nil }
                                return (price: price, quantity: quantity)
                            })
                            kucoinOrderBooks[pair] = orderBook
                            kucoinCurrentPrice[pair] = bestBidPrice > 0 ? bestBidPrice : kucoinCurrentPrice[pair] ?? 0.0
                            print("DEBUG: KuCoin order book depth for \(pair)-\(marketType): \(totalDepth), Spread: \(spread ?? 0)")
                            if totalDepth < getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 20000.0) {
                                logAlert(event: "Insufficient depth for KuCoin \(pair)-\(marketType): Depth \(totalDepth), Required \(getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 20000.0))")
                            }
                            completion(totalDepth)
                        }
                    } catch {
                        let responseBody = String(data: data, encoding: .utf8) ?? "No response body"
                        print("DEBUG: JSON parsing error for KuCoin order book \(pair)-\(marketType): \(error.localizedDescription), Body: \(responseBody)")
                        Task { @MainActor in
                            logAlert(event: "JSON parsing error for KuCoin order book \(pair)-\(marketType): \(error.localizedDescription), Body: \(responseBody)")
                        }
                        let attemptFetch: @Sendable () -> Void = {
                            let newRetryCount = localRetryCountCopy + 1
                            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                            }
                        }
                        attemptFetch()
                    }
                }.resume()
            } else {
                // Fallback to local timestamp if server sync fails
                var fallbackRequest = URLRequest(url: url)
                fallbackRequest.httpMethod = "GET"
                fallbackRequest.timeoutInterval = getDouble("API_TIMEOUT_SECONDS", defaultValue: 15.0)
                let signature = hmacSHA256(timestamp + "GET" + endpoint, key: apiSecret)
                fallbackRequest.addValue(apiKey, forHTTPHeaderField: "KC-API-KEY")
                fallbackRequest.addValue(timestamp, forHTTPHeaderField: "KC-API-TIMESTAMP")
                fallbackRequest.addValue(signature, forHTTPHeaderField: "KC-API-SIGN")
                fallbackRequest.addValue("2", forHTTPHeaderField: "KC-API-KEY-VERSION")
                fallbackRequest.addValue("application/json", forHTTPHeaderField: "Content-Type")
                if let passphrase = computedPassphrase {
                    fallbackRequest.addValue(passphrase, forHTTPHeaderField: "KC-API-PASSPHRASE")
                }
                print("DEBUG: Fallback KuCoin request for \(pair)-\(marketType): Timestamp \(timestamp), Signature \(signature), Passphrase \(passphrase != nil ? "present" : "missing")")
                Task { @MainActor in
                    logAlert(event: "DEBUG: Fallback KuCoin request for \(pair)-\(marketType): Timestamp \(timestamp), Signature \(signature), Passphrase \(passphrase != nil ? "present" : "missing")")
                }
                let startTime = Date()
                URLSession.shared.dataTask(with: fallbackRequest) { data, response, error in
                    let latency = Date().timeIntervalSince(startTime) * 1000
                    Task { @MainActor in
                        lastLatency[pair] = latency
                        ExchangeWebSocket.lastKucoinFetchTime[pair] = Date()
                        if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 200.0) {
                            print("High latency detected for KuCoin order book fetch: \(pair)-\(marketType) - \(latency)ms")
                            logAlert(event: "High latency detected for KuCoin order book fetch: \(pair)-\(marketType) - \(latency)ms")
                        }
                    }
                    if let error = error {
                        print("Failed to fetch KuCoin order book for \(pair)-\(marketType): \(error.localizedDescription)")
                        Task { @MainActor in
                            logAlert(event: "Failed to fetch KuCoin order book for \(pair)-\(marketType): \(error.localizedDescription)")
                        }
                        let attemptFetch: @Sendable () -> Void = {
                            let newRetryCount = localRetryCountCopy + 1
                            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                            }
                        }
                        attemptFetch()
                        return
                    }
                    guard let httpResponse = response as? HTTPURLResponse, let data = data else {
                        print("Invalid KuCoin order book response for \(pair)-\(marketType): No HTTP response or data")
                        Task { @MainActor in
                            logAlert(event: "Invalid KuCoin order book response for \(pair)-\(marketType): No HTTP response or data")
                        }
                        let attemptFetch: @Sendable () -> Void = {
                            let newRetryCount = localRetryCountCopy + 1
                            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                            }
                        }
                        attemptFetch()
                        return
                    }
                    guard httpResponse.statusCode == 200 else {
                        let statusCode = httpResponse.statusCode
                        let responseBody = String(data: data, encoding: .utf8) ?? "No response body"
                        let errorMessage: String
                        let delay: Double
                        switch statusCode {
                        case 401, 403:
                            errorMessage = "Authentication failed (\(statusCode)) for \(pair)-\(marketType): Invalid API key, signature, or timestamp, Body: \(responseBody)"
                            delay = pow(2.0, Double(localRetryCountCopy + 1))
                        case 429:
                            errorMessage = "Rate limit exceeded (429) for \(pair)-\(marketType): Body: \(responseBody)"
                            delay = 60.0
                        default:
                            errorMessage = "Invalid KuCoin order book response for \(pair)-\(marketType): Status code \(statusCode), Body: \(responseBody)"
                            delay = 2.0
                        }
                        print(errorMessage)
                        Task { @MainActor in
                            logAlert(event: errorMessage)
                        }
                        let attemptFetch: @Sendable () -> Void = {
                            let newRetryCount = localRetryCountCopy + 1
                            DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
                                fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                            }
                        }
                        attemptFetch()
                        return
                    }
                    do {
                        guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
                            let responseBody = String(data: data, encoding: .utf8) ?? "No response body"
                            print("Failed to parse KuCoin order book JSON for \(pair)-\(marketType): \(responseBody)")
                            Task { @MainActor in
                                logAlert(event: "Failed to parse KuCoin order book JSON for \(pair)-\(marketType): \(responseBody)")
                            }
                            let attemptFetch: @Sendable () -> Void = {
                                let newRetryCount = localRetryCountCopy + 1
                                DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                    fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                                }
                            }
                            attemptFetch()
                            return
                        }
                        guard let dataDict = json["data"] as? [String: Any],
                              let bids = dataDict["bids"] as? [[String]] ?? (dataDict["bids"] as? String == "null" ? [] : nil),
                              let asks = dataDict["asks"] as? [[String]] ?? (dataDict["asks"] as? String == "null" ? [] : nil) else {
                            let responseBody = String(data: data, encoding: .utf8) ?? "No response body"
                            print("Failed to parse KuCoin order book data for \(pair)-\(marketType): Body: \(responseBody)")
                            Task { @MainActor in
                                logAlert(event: "Failed to parse KuCoin order book data for \(pair)-\(marketType): Body: \(responseBody)")
                            }
                            let attemptFetch: @Sendable () -> Void = {
                                let newRetryCount = localRetryCountCopy + 1
                                DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                    fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                                }
                            }
                            attemptFetch()
                            return
                        }
                        var bidDepth: Double = 0.0
                        var askDepth: Double = 0.0
                        var bestBidPrice: Double = 0.0
                        var bestAskPrice: Double = 0.0
                        for bidEntry in bids.prefix(10) {
                            guard bidEntry.count >= 2,
                                  let priceStr = bidEntry.first,
                                  let qtyStr = bidEntry.last,
                                  let price = Double(priceStr),
                                  let qty = Double(qtyStr) else {
                                print("DEBUG: Skipping invalid bid entry for \(pair)-\(marketType): \(bidEntry)")
                                continue
                            }
                            bidDepth += price * qty
                            if price > bestBidPrice { bestBidPrice = price }
                        }
                        for ask in asks.prefix(10) {
                            guard ask.count >= 2,
                                  let priceStr = ask.first,
                                  let qtyStr = ask.last,
                                  let price = Double(priceStr),
                                  let qty = Double(qtyStr) else {
                                print("DEBUG: Skipping invalid ask entry for \(pair)-\(marketType): \(ask)")
                                continue
                            }
                            askDepth += price * qty
                            if bestAskPrice == 0.0 || price < bestAskPrice { bestAskPrice = price }
                        }
                        guard bidDepth > 0 || askDepth > 0 else {
                            print("Failed to parse KuCoin order book data for \(pair)-\(marketType): Empty depth")
                            Task { @MainActor in
                                logAlert(event: "Failed to parse KuCoin order book data for \(pair)-\(marketType): Empty depth")
                            }
                            let attemptFetch: @Sendable () -> Void = {
                                let newRetryCount = localRetryCountCopy + 1
                                DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                    fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                                }
                            }
                            attemptFetch()
                            return
                        }
                        let totalDepth = bidDepth + askDepth
                        let spread = bestAskPrice > 0 && bestBidPrice > 0 ? bestAskPrice - bestBidPrice : nil
                        Task { @MainActor in
                            if let spread = spread {
                                let timestamp = ISO8601DateFormatter().string(from: Date())
                                let spreadEntry = "\(timestamp),\(pair),\(marketType),\(bestBidPrice),\(bestAskPrice),\(spread)\n"
                                do {
                                    let fileURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/historical_spreads.csv")
                                    if !FileManager.default.fileExists(atPath: fileURL.path) {
                                        FileManager.default.createFile(atPath: fileURL.path, contents: "timestamp,pair,market_type,bid_price,ask_price,spread\n".data(using: .utf8))
                                    }
                                    let fileHandle = try FileHandle(forWritingTo: fileURL)
                                    fileHandle.seekToEndOfFile()
                                    if let data = spreadEntry.data(using: .utf8) {
                                        fileHandle.write(data)
                                    }
                                    fileHandle.closeFile()
                                } catch {
                                    print("DEBUG: Failed to write to historical_spreads.csv for \(pair)-\(marketType): \(error.localizedDescription)")
                                    logAlert(event: "Failed to write to historical_spreads.csv for \(pair)-\(marketType): \(error.localizedDescription)")
                                }
                            }
                            let orderBook = BevaixOrderBook(bids: bids.compactMap { entry in
                                guard entry.count >= 2, let price = Double(entry[0]), let quantity = Double(entry[1]) else { return nil }
                                return (price: price, quantity: quantity)
                            }, asks: asks.compactMap { entry in
                                guard entry.count >= 2, let price = Double(entry[0]), let quantity = Double(entry[1]) else { return nil }
                                return (price: price, quantity: quantity)
                            })
                            kucoinOrderBooks[pair] = orderBook
                            kucoinCurrentPrice[pair] = bestBidPrice > 0 ? bestBidPrice : kucoinCurrentPrice[pair] ?? 0.0
                            print("DEBUG: KuCoin order book depth for \(pair)-\(marketType): \(totalDepth), Spread: \(spread ?? 0)")
                            if totalDepth < getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 20000.0) {
                                logAlert(event: "Insufficient depth for KuCoin \(pair)-\(marketType): Depth \(totalDepth), Required \(getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 20000.0))")
                            }
                            completion(totalDepth)
                        }
                    } catch {
                        let responseBody = String(data: data, encoding: .utf8) ?? "No response body"
                        print("DEBUG: JSON parsing error for KuCoin order book \(pair)-\(marketType): \(error.localizedDescription), Body: \(responseBody)")
                        Task { @MainActor in
                            logAlert(event: "JSON parsing error for KuCoin order book \(pair)-\(marketType): \(error.localizedDescription), Body: \(responseBody)")
                        }
                        let attemptFetch: @Sendable () -> Void = {
                            let newRetryCount = localRetryCountCopy + 1
                            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                            }
                        }
                        attemptFetch()
                    }
                }.resume()
            }
        }.resume()

        print("DEBUG: Initial KuCoin request for \(pair)-\(marketType): Timestamp \(timestamp)")
        Task { @MainActor in
            logAlert(event: "DEBUG: Initial KuCoin request for \(pair)-\(marketType): Timestamp \(timestamp)")
        }
    }
}


//---------------------------------------------------------------------------------------------------------------------Block 9 - KuCoin WebSocket Processing

//---------------------------------------------------------------------------------------------------------------------Block 9 - KuCoin WebSocket Processing

// NOTE: Delegate classes are defined elsewhere in the codebase to prevent duplicates
// This block contains only the WebSocket message processing logic

extension ExchangeWebSocket {
    
    // ENHANCED: KuCoin Spot Message Processing
    @MainActor
    static func processKuCoinSpotMessage(_ json: [String: Any]) {
        guard let type = json["type"] as? String, type == "message",
              let topic = json["topic"] as? String,
              topic.hasPrefix("/market/ticker:"),
              let dataDict = json["data"] as? [String: Any] else {
            print("DEBUG: Invalid KuCoin Spot message format")
            return
        }
        
        let priceKeys = ["price", "last", "bestAsk", "bestBid"]
        var priceStr: String?
        for key in priceKeys {
            if let value = dataDict[key] as? String {
                priceStr = value
                break
            }
        }
        
        guard let priceStr = priceStr else {
            print("Failed to find price in KuCoin Spot message. Available keys: \(dataDict.keys)")
            return
        }
        
        // Fix ambiguous type expression by being explicit
        guard let price: Double = Double(priceStr) else {
            print("Failed to parse price '\(priceStr)' from KuCoin Spot message")
            return
        }
        
        let spotSymbol = topic.components(separatedBy: ":").last ?? ""
        let pair = spotSymbol
        
        kucoinCurrentPrice[pair] = price
        kucoinPrices[pair, default: []].append(price)
        
        if kucoinPrices[pair]!.count > priceHistoryRetention {
            kucoinPrices[pair]!.removeFirst()
        }
        
        // Process volume if available
        if let volStr = dataDict["size"] as? String ?? dataDict["volume"] as? String,
           let vol: Double = Double(volStr) {
            kucoinSpotVolume[pair, default: []].append(vol)
            if kucoinSpotVolume[pair]!.count > priceHistoryRetention {
                kucoinSpotVolume[pair]!.removeFirst()
            }
        }
        
        print("Updated KuCoin spot price for \(pair): \(price)")
        logAlert(event: "‚úÖ KuCoin Spot price update: \(pair) = $\(price)")
    }
    
    // ENHANCED: KuCoin Futures Message Processing
    @MainActor
    static func processKuCoinFuturesMessage(_ json: [String: Any]) {
        guard let type = json["type"] as? String, type == "message",
              let topic = json["topic"] as? String,
              let dataDict = json["data"] as? [String: Any] else {
            print("DEBUG: Invalid KuCoin Futures message format")
            return
        }
        
        if topic.hasPrefix("/contractMarket/tickerV2:") {
            processKuCoinFuturesTicker(topic: topic, data: dataDict)
        } else if topic.hasPrefix("/contractMarket/level2:") {
            processKuCoinFuturesOrderBook(topic: topic, data: dataDict)
        } else if topic.hasPrefix("/contract/instrument:") {
            processKuCoinFuturesFunding(topic: topic, data: dataDict)
        }
    }
    
    @MainActor
    private static func processKuCoinFuturesTicker(topic: String, data: [String: Any]) {
        let priceKeys = ["bestAskPrice", "bestBidPrice", "lastPrice", "indexPrice"]
        var priceStr: String?
        for key in priceKeys {
            if let value = data[key] as? String {
                priceStr = value
                break
            }
        }
        
        guard let priceStr = priceStr,
              let price: Double = Double(priceStr) else {
            print("Failed to find/parse price in KuCoin Futures message")
            return
        }
        
        let futuresSymbol = topic.components(separatedBy: ":").last ?? ""
        guard let pair = kucoinFuturesSymbols.first(where: { $0.value == futuresSymbol })?.key else {
            print("No pair found for futures symbol: \(futuresSymbol)")
            return
        }
        
        kucoinCurrentFuturesPrice[pair] = price
        kucoinFuturesPrices[pair, default: []].append(price)
        
        if kucoinFuturesPrices[pair]!.count > priceHistoryRetention {
            kucoinFuturesPrices[pair]!.removeFirst()
        }
        
        // Process volume
        if let volStr = data["volume"] as? String ?? data["size"] as? String,
           let vol: Double = Double(volStr) {
            kucoinFuturesVolume[pair, default: []].append(vol)
            if kucoinFuturesVolume[pair]!.count > priceHistoryRetention {
                kucoinFuturesVolume[pair]!.removeFirst()
            }
        }
        
        print("Updated KuCoin futures price for \(pair): \(price)")
        logAlert(event: "‚úÖ KuCoin Futures price update: \(pair) = $\(price)")
    }
    
    @MainActor
    private static func processKuCoinFuturesOrderBook(topic: String, data: [String: Any]) {
        let futuresSymbol = topic.components(separatedBy: ":").last ?? ""
        guard let pair = kucoinFuturesSymbols.first(where: { $0.value == futuresSymbol })?.key else {
            print("No pair found for futures symbol: \(futuresSymbol)")
            return
        }
        
        var orderBook: [(price: Double, volume: Double, side: String)] = []
        
        if let bids = data["bids"] as? [[String]],
           let asks = data["asks"] as? [[String]] {
            // Snapshot
            for bid in bids {
                if let priceStr = bid.first, let qtyStr = bid.last,
                   let price: Double = Double(priceStr),
                   let qty: Double = Double(qtyStr), qty > 0 {
                    orderBook.append((price: price, volume: qty, side: "buy"))
                }
            }
            for ask in asks {
                if let priceStr = ask.first, let qtyStr = ask.last,
                   let price: Double = Double(priceStr),
                   let qty: Double = Double(qtyStr), qty > 0 {
                    orderBook.append((price: price, volume: qty, side: "sell"))
                }
            }
        } else if let change = data["change"] as? String {
            // Incremental update
            orderBook = kucoinFuturesOrderBook[pair] ?? []
            let components = change.components(separatedBy: ",")
            if components.count == 3,
               let price: Double = Double(components[0]),
               let size: Double = Double(components[2]) {
                let side = components[1].lowercased() == "buy" ? "buy" : "sell"
                orderBook.removeAll { $0.price == price && $0.side == side }
                if size > 0 {
                    orderBook.append((price: price, volume: size, side: side))
                }
            }
        }
        
        kucoinFuturesOrderBook[pair] = orderBook
        print("DEBUG: Updated KuCoin futures order book for \(pair): \(orderBook.count) entries")
    }
    
    @MainActor
    private static func processKuCoinFuturesFunding(topic: String, data: [String: Any]) {
        guard let fundingRateStr = data["fundingRate"] as? String,
              let fundingRate: Double = Double(fundingRateStr),
              let futuresSymbol = topic.components(separatedBy: ":").last,
              let pair = kucoinFuturesSymbols.first(where: { $0.value == futuresSymbol })?.key else {
            return
        }
        
        kucoinFundingRates[pair] = fundingRate
        kucoinFundingRateHistory[pair, default: []].append(fundingRate)
        
        if kucoinFundingRateHistory[pair]!.count > 24 { // Keep 24 hours of history
            kucoinFundingRateHistory[pair]!.removeFirst()
        }
        
        print("Updated KuCoin funding rate for \(pair): \(fundingRate)")
        logAlert(event: "‚úÖ KuCoin Funding rate update: \(pair) = \(fundingRate * 100)%")
    }
    
    // ENHANCED: Bybit Spot Message Processing
    @MainActor
    static func processBybitSpotMessage(_ json: [String: Any]) {
        if let success = json["success"] as? Bool {
            if success, let retMsg = json["ret_msg"] as? String, retMsg == "subscribe" {
                print("Bybit Spot subscription confirmed")
            } else if !success {
                print("Bybit Spot WebSocket error: \(json)")
                logAlert(event: "‚ùå Bybit Spot WebSocket error: \(json)")
            }
        } else if let topic = json["topic"] as? String {
            if topic.hasPrefix("tickers.") {
                processBybitSpotTicker(data: json)
            } else if topic.hasPrefix("orderbook.50.") {
                processBybitSpotOrderBook(data: json)
            } else if topic.hasPrefix("publicTrade.") {
                processBybitSpotTrade(data: json)
            }
        }
    }
    
    @MainActor
    private static func processBybitSpotTicker(data: [String: Any]) {
        guard let dataDict = data["data"] as? [String: Any],
              let symbol = dataDict["symbol"] as? String else { return }
        
        let priceKeys = ["lastPrice", "bestAskPrice", "ask1Price", "indexPrice"]
        var priceStr: String?
        for key in priceKeys {
            if let value = dataDict[key] as? String {
                priceStr = value
                break
            }
        }
        
        guard let priceStr = priceStr,
              let price: Double = Double(priceStr) else {
            print("Failed to find/parse price in Bybit Spot ticker")
            return
        }
        
        let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
        bybitCurrentPrice[pair] = price
        bybitPrices[pair, default: []].append(price)
        
        if bybitPrices[pair]!.count > priceHistoryRetention {
            bybitPrices[pair]!.removeFirst()
        }
        
        // Process volume
        if let volStr = dataDict["volume24h"] as? String,
           let vol: Double = Double(volStr) {
            bybitSpotVolume[pair, default: []].append(vol)
            if bybitSpotVolume[pair]!.count > priceHistoryRetention {
                bybitSpotVolume[pair]!.removeFirst()
            }
        }
        
        print("Updated Bybit spot price for \(pair): \(price)")
        logAlert(event: "‚úÖ Bybit Spot price update: \(pair) = $\(price)")
    }
    
    @MainActor
    private static func processBybitSpotOrderBook(data: [String: Any]) {
        guard let dataDict = data["data"] as? [String: Any],
              let symbol = dataDict["s"] as? String,
              let asks = dataDict["a"] as? [[String]],
              let bids = dataDict["b"] as? [[String]] else { return }
        
        let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
        var _: [(price: Double, quantity: Double)] = []
        
        // Process asks and bids into BevaixOrderBook format
        let bidBook = bids.compactMap { bid -> (price: Double, quantity: Double)? in
            guard let priceStr = bid.first, let volStr = bid.last,
                  let price: Double = Double(priceStr),
                  let vol: Double = Double(volStr) else { return nil }
            return (price: price, quantity: vol)
        }
        
        let askBook = asks.compactMap { ask -> (price: Double, quantity: Double)? in
            guard let priceStr = ask.first, let volStr = ask.last,
                  let price: Double = Double(priceStr),
                  let vol: Double = Double(volStr) else { return nil }
            return (price: price, quantity: vol)
        }
        
        bybitOrderBooks[pair] = BevaixOrderBook(bids: bidBook, asks: askBook)
        print("Updated Bybit spot order book for \(pair): bids=\(bidBook.count), asks=\(askBook.count)")
    }
    
    @MainActor
    private static func processBybitSpotTrade(data: [String: Any]) {
        guard let dataArray = data["data"] as? [[String: Any]],
              let firstTrade = dataArray.first,
              let priceStr = firstTrade["p"] as? String,
              let price: Double = Double(priceStr),
              let symbol = firstTrade["s"] as? String else { return }
        
        let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
        bybitCurrentPrice[pair] = price
        bybitPrices[pair, default: []].append(price)
        
        if bybitPrices[pair]!.count > priceHistoryRetention {
            bybitPrices[pair]!.removeFirst()
        }
        
        print("Updated Bybit spot price from trade for \(pair): \(price)")
    }
    
    // ENHANCED: Bybit Futures Message Processing
    @MainActor
    static func processBybitFuturesMessage(_ json: [String: Any]) {
        if let success = json["success"] as? Bool {
            if success, let retMsg = json["ret_msg"] as? String, retMsg == "subscribe" {
                print("Bybit Futures subscription confirmed")
            } else if !success {
                print("Bybit Futures WebSocket error: \(json)")
                logAlert(event: "‚ùå Bybit Futures WebSocket error: \(json)")
            }
        } else if let topic = json["topic"] as? String {
            if topic.hasPrefix("tickers.") {
                processBybitFuturesTicker(data: json)
            } else if topic.hasPrefix("orderbook.50.") {
                processBybitFuturesOrderBook(data: json)
            } else if topic.hasPrefix("publicTrade.") {
                processBybitFuturesTrade(data: json)
            }
        }
    }
    
    @MainActor
    private static func processBybitFuturesTicker(data: [String: Any]) {
        guard let dataDict = data["data"] as? [String: Any],
              let symbol = dataDict["symbol"] as? String else { return }
        
        let priceKeys = ["lastPrice", "bestAskPrice", "ask1Price", "bid1Price", "indexPrice", "markPrice"]
        var priceStr: String?
        for key in priceKeys {
            if let value = dataDict[key] as? String {
                priceStr = value
                break
            }
        }
        
        guard let priceStr = priceStr,
              let price: Double = Double(priceStr) else {
            print("Failed to find/parse price in Bybit Futures ticker")
            return
        }
        
        let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
        bybitCurrentFuturesPrice[pair] = price
        bybitFuturesPrices[pair, default: []].append(price)
        
        if bybitFuturesPrices[pair]!.count > priceHistoryRetention {
            bybitFuturesPrices[pair]!.removeFirst()
        }
        
        // Process volume
        if let volStr = dataDict["volume24h"] as? String,
           let vol: Double = Double(volStr) {
            bybitFuturesVolume[pair, default: []].append(vol)
            if bybitFuturesVolume[pair]!.count > priceHistoryRetention {
                bybitFuturesVolume[pair]!.removeFirst()
            }
        }
        
        // Process funding rate
        if let fundingRateStr = dataDict["fundingRate"] as? String,
           let fundingRate: Double = Double(fundingRateStr) {
            bybitFundingRates[pair] = fundingRate
            bybitFundingRateHistory[pair, default: []].append(fundingRate)
            
            if bybitFundingRateHistory[pair]!.count > 24 { // Keep 24 hours
                bybitFundingRateHistory[pair]!.removeFirst()
            }
            
            print("Updated Bybit funding rate for \(pair): \(fundingRate)")
        }
        
        print("Updated Bybit futures price for \(pair): \(price)")
        logAlert(event: "‚úÖ Bybit Futures price update: \(pair) = $\(price)")
    }
    
    @MainActor
    private static func processBybitFuturesOrderBook(data: [String: Any]) {
        guard let dataDict = data["data"] as? [String: Any],
              let symbol = dataDict["s"] as? String,
              let updateType = dataDict["type"] as? String else { return }
        
        let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
        var orderBook: [(price: Double, volume: Double, side: String)]
        
        if updateType == "snapshot" {
            orderBook = []
        } else {
            orderBook = bybitFuturesOrderBook[pair] ?? []
        }
        
        if let asks = dataDict["a"] as? [[String]] {
            for ask in asks {
                if let priceStr = ask.first, let volStr = ask.last,
                   let price: Double = Double(priceStr),
                   let vol: Double = Double(volStr) {
                    orderBook.removeAll { $0.price == price && $0.side == "sell" }
                    if vol > 0 {
                        orderBook.append((price: price, volume: vol, side: "sell"))
                    }
                }
            }
        }
        
        if let bids = dataDict["b"] as? [[String]] {
            for bid in bids {
                if let priceStr = bid.first, let volStr = bid.last,
                   let price: Double = Double(priceStr),
                   let vol: Double = Double(volStr) {
                    orderBook.removeAll { $0.price == price && $0.side == "buy" }
                    if vol > 0 {
                        orderBook.append((price: price, volume: vol, side: "buy"))
                    }
                }
            }
        }
        
        bybitFuturesOrderBook[pair] = orderBook
        print("DEBUG: Updated Bybit futures order book for \(pair): \(orderBook.count) entries")
    }
    
    @MainActor
    private static func processBybitFuturesTrade(data: [String: Any]) {
        guard let dataArray = data["data"] as? [[String: Any]],
              let firstTrade = dataArray.first,
              let priceStr = firstTrade["p"] as? String,
              let price: Double = Double(priceStr),
              let symbol = firstTrade["s"] as? String else { return }
        
        let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
        bybitCurrentFuturesPrice[pair] = price
        bybitFuturesPrices[pair, default: []].append(price)
        
        if bybitFuturesPrices[pair]!.count > priceHistoryRetention {
            bybitFuturesPrices[pair]!.removeFirst()
        }
        
        print("Updated Bybit futures price from trade for \(pair): \(price)")
    }
    
    // ENHANCED: Centralized WebSocket Health Monitoring
    @MainActor
    static func monitorWebSocketHealth() {
        let healthCheck = [
            "KuCoin Spot": kucoinIsConnected,
            "KuCoin Futures": kucoinFuturesIsConnected,
            "Bybit Spot": bybitIsConnected,
            "Bybit Futures": bybitFuturesIsConnected
        ]
        
        var disconnectedCount = 0
        var healthReport = "üîç WebSocket Health Report:\n"
        
        for (exchange, connected) in healthCheck {
            let status = connected ? "‚úÖ Connected" : "‚ùå Disconnected"
            healthReport += "  \(exchange): \(status)\n"
            if !connected { disconnectedCount += 1 }
        }
        
        if disconnectedCount > 0 {
            healthReport += "‚ö†Ô∏è  \(disconnectedCount) connection(s) need attention"
            logAlert(event: healthReport)
        }
        
        print(healthReport)
    }
}

//------------------------------------------------------------------------------------------------------------------------Block 10 - Bybit WebSocket Processing

extension ExchangeWebSocket {
    @MainActor
    static var kucoinDailyLoss: Double = 0.0
    @MainActor
    static var bybitDailyLoss: Double = 0.0
    static func validateAPICredentials() async -> Bool {
        let kucoinValid = environment["KUCOIN_API_KEY"] != nil &&
                         environment["KUCOIN_API_SECRET"] != nil &&
                         environment["KUCOIN_API_PASSPHRASE"] != nil
        let bybitValid = environment["BYBIT_API_KEY"] != nil &&
                        environment["BYBIT_API_SECRET"] != nil
        
        if kucoinValid && bybitValid {
            await MainActor.run {
                logAlert(event: "‚úÖ API credentials validated successfully")
            }
            return true
        } else {
            await MainActor.run {
                logAlert(event: "‚ùå API credentials validation failed")
            }
            return false
        }
    }

    // ENHANCED: Better WebSocket connection management for Bybit
    static func connectBybitWebSocket() {
        Task {
            await MainActor.run {
                logAlert(event: "üîµ Initiating Bybit WebSocket connection...")
                //websocketReconnectAttempts["bybit"] = 0  // Comment out this line
                lastWebsocketActivity["bybit"] = Date()
            }
            
            guard let url = URL(string: "wss://stream.bybit.com/v5/public/spot") else {
                await MainActor.run {
                    logAlert(event: "üîµ ERROR: Invalid Bybit WebSocket URL")
                }
                return
            }
            
            var request = URLRequest(url: url)
            request.timeoutInterval = 30.0
            
            // Use Starscream WebSocket (matching Block 1 declaration)
            let webSocket = WebSocket(request: request)
            
            webSocket.onEvent = { event in
                Task { @MainActor in
                    switch event {
                    case .connected(_):
                        bybitWebSocket = webSocket
                        bybitIsConnected = true
                        logAlert(event: "üîµ ‚úÖ Bybit WebSocket connected successfully")
                        
                        Task {
                            await receiveBybitMessages()
                            await subscribeToBybitStreams()
                        }
                    case .disconnected(let reason, let code):
                        logAlert(event: "üîµ ERROR: Bybit WebSocket disconnected: \(reason) (\(code))")
                        Task { reconnectBybitWebSocket() }
                    case .text(let string):
                        Task { await processBybitWebSocketMessage(message: string) }
                    case .error(let error):
                        logAlert(event: "üîµ ERROR: Bybit WebSocket error: \(error?.localizedDescription ?? "Unknown")")
                        Task { reconnectBybitWebSocket() }
                    default:
                        break
                    }
                }
            }
            
            webSocket.connect()
        }
    }

    // ENHANCED: Connection timeout handling
    // ENHANCED: Bybit WebSocket reconnection with exponential backoff
    static func reconnectBybitWebSocket() {
        Task {
            let currentAttempts = 0  // Simplified fix
            let maxAttempts = 10
            
            guard currentAttempts < maxAttempts else {
                await MainActor.run {
                    logAlert(event: "üîµ ERROR: Max reconnection attempts reached for Bybit WebSocket")
                }
                return
            }
            
            await MainActor.run {
                websocketReconnectAttempts["bybit"] = currentAttempts + 1
                bybitIsConnected = false
                logAlert(event: "üîµ ‚ö†Ô∏è Attempting Bybit WebSocket reconnection (attempt \(currentAttempts + 1)/\(maxAttempts))")
            }
            
            // Exponential backoff: 2^attempt seconds (max 60 seconds)
            let delay = min(pow(2.0, Double(currentAttempts)), 60.0)
            try? await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
            
            // Attempt reconnection
            connectBybitWebSocket()
        }
    }

    // ENHANCED: Bybit WebSocket message processing with better error handling
    static func processBybitWebSocketMessage(message: String) async {
        do {
            guard let data = message.data(using: .utf8),
                  let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
                await MainActor.run {
                    logAlert(event: "üîµ ERROR: Failed to parse Bybit WebSocket message")
                }
                return
            }
            
            await MainActor.run {
                lastWebsocketActivity["bybit"] = Date()
            }
            
            // ENHANCED: Better topic handling
            if let topic = json["topic"] as? String {
                if topic.contains("tickers") {
                    await processTickerUpdate(exchange: "bybit", data: json)
                } else if topic.contains("orderbook") {
                    await processOrderBookUpdate(exchange: "bybit", data: json)
                } else if topic.contains("publicTrade") {
                    await processTradeUpdate(exchange: "bybit", data: json)
                }
            } else if let op = json["op"] as? String {
                if op == "pong" {
                    await MainActor.run {
                        logAlert(event: "üîµ Bybit WebSocket heartbeat received")
                    }
                }
            }
        } catch {
            await MainActor.run {
                logAlert(event: "üîµ ERROR: Bybit WebSocket message processing error: \(error.localizedDescription)")
            }
        }
    }

    // ENHANCED: Order book update processing with validation
    static func processOrderBookUpdate(exchange: String, data: [String: Any]) async {
        guard let topic = data["topic"] as? String,
              let dataPayload = data["data"] as? [String: Any] else {
            await MainActor.run {
                logAlert(event: "üîµ ERROR: Invalid order book update format from \(exchange)")
            }
            return
        }
        
        // Extract symbol from topic
        let symbol = extractSymbolFromTopic(topic: topic, exchange: exchange)
        guard !symbol.isEmpty else {
            await MainActor.run {
                logAlert(event: "üîµ ERROR: Could not extract symbol from topic: \(topic)")
            }
            return
        }
        
        // ENHANCED: Validate order book data quality
        let validation = validateOrderBookDataQuality(data: dataPayload, symbol: symbol, exchange: exchange)
        guard validation.isValid else {
            await MainActor.run {
                logAlert(event: "üîµ WARNING: Invalid order book data for \(symbol): \(validation.reason)")
            }
            return
        }
        
        // Update order book with validated data
        await updateOrderBookWithValidation(exchange: exchange, symbol: symbol, data: dataPayload)
        
        // ENHANCED: Real-time order book health monitoring
        await monitorOrderBookHealth(exchange: exchange, symbol: symbol)
    }

    // ENHANCED: Advanced order book analysis
    static func validateOrderBookDataQuality(data: [String: Any], symbol: String, exchange: String) -> (isValid: Bool, reason: String) {
        // Check for required fields
        guard let bids = data["b"] as? [[String]] ?? data["bids"] as? [[String]],
              let asks = data["a"] as? [[String]] ?? data["asks"] as? [[String]] else {
            return (false, "Missing bids or asks data")
        }
        
        // Validate bids and asks are not empty
        guard !bids.isEmpty && !asks.isEmpty else {
            return (false, "Empty bids or asks arrays")
        }
        
        // Validate price format
        for bid in bids.prefix(3) {
            guard bid.count >= 2,
                  let price = Double(bid[0]),
                  let quantity = Double(bid[1]),
                  price > 0 && quantity > 0 else {
                return (false, "Invalid bid data format")
            }
        }
        
        for ask in asks.prefix(3) {
            guard ask.count >= 2,
                  let price = Double(ask[0]),
                  let quantity = Double(ask[1]),
                  price > 0 && quantity > 0 else {
                return (false, "Invalid ask data format")
            }
        }
        
        // Validate spread sanity
        if let topBid = bids.first,
           let topAsk = asks.first,
           let bidPrice = Double(topBid[0]),
           let askPrice = Double(topAsk[0]) {
            
            guard askPrice > bidPrice else {
                return (false, "Invalid spread: ask <= bid")
            }
            
            let spread = (askPrice - bidPrice) / bidPrice
            guard spread < 0.1 else { // 10% max spread
                return (false, "Spread too wide: \(spread * 100)%")
            }
        }
        
        return (true, "Valid")
    }

    static func updateOrderBookWithValidation(exchange: String, symbol: String, data: [String: Any]) async {
        await MainActor.run {
            var orderBook: BevaixOrderBook
            
            if exchange == "kucoin" {
                orderBook = kucoinOrderBooks[symbol] ?? BevaixOrderBook(bids: [], asks: [])
            } else {
                orderBook = bybitOrderBooks[symbol] ?? BevaixOrderBook(bids: [], asks: [])
            }
            
            // Update with new data
            if let bids = data["b"] as? [[String]] ?? data["bids"] as? [[String]] {
                let parsedBids = bids.compactMap { arr -> (price: Double, quantity: Double)? in
                    guard arr.count >= 2,
                          let price = Double(arr[0]),
                          let quantity = Double(arr[1]) else { return nil }
                    return (price: price, quantity: quantity)
                }
                orderBook.bids = parsedBids.sorted { $0.price > $1.price }
            }
            
            if let asks = data["a"] as? [[String]] ?? data["asks"] as? [[String]] {
                let parsedAsks = asks.compactMap { arr -> (price: Double, quantity: Double)? in
                    guard arr.count >= 2,
                          let price = Double(arr[0]),
                          let quantity = Double(arr[1]) else { return nil }
                    return (price: price, quantity: quantity)
                }
                orderBook.asks = parsedAsks.sorted { $0.price < $1.price }
            }
            
            // Store updated order book
            if exchange == "kucoin" {
                kucoinOrderBooks[symbol] = orderBook
            } else {
                bybitOrderBooks[symbol] = orderBook
            }
        }
    }

    static func monitorOrderBookHealth(exchange: String, symbol: String) async {
        await MainActor.run {
            let orderBook = exchange == "kucoin" ?
                (kucoinOrderBooks[symbol] ?? BevaixOrderBook(bids: [], asks: [])) :
                (bybitOrderBooks[symbol] ?? BevaixOrderBook(bids: [], asks: []))
            
            // Check order book depth
            let bidDepth = orderBook.bids.prefix(10).reduce(0.0) { $0 + $1.quantity }
            let askDepth = orderBook.asks.prefix(10).reduce(0.0) { $0 + $1.quantity }
            
            if bidDepth < 1.0 || askDepth < 1.0 {
                logAlert(event: "‚ö†Ô∏è Low liquidity detected for \(exchange) \(symbol): bid=\(bidDepth), ask=\(askDepth)")
            }
            
            // Check for crossed book
            if let bestBid = orderBook.bids.first,
               let bestAsk = orderBook.asks.first,
               bestBid.price >= bestAsk.price {
                logAlert(event: "üö® Crossed order book detected for \(exchange) \(symbol)")
            }
        }
    }

    // ENHANCED: Trade update processing
    static func processTradeUpdate(exchange: String, data: [String: Any]) async {
        guard let topic = data["topic"] as? String,
              let dataArray = data["data"] as? [[String: Any]] else {
            await MainActor.run {
                logAlert(event: "üîµ ERROR: Invalid trade update format from \(exchange)")
            }
            return
        }
        
        let symbol = extractSymbolFromTopic(topic: topic, exchange: exchange)
        
        for tradeData in dataArray {
            if let priceStr = tradeData["p"] as? String ?? tradeData["price"] as? String,
               let volumeStr = tradeData["v"] as? String ?? tradeData["volume"] as? String,
               let price = Double(priceStr),
               let volume = Double(volumeStr) {
                
                await MainActor.run {
                    if exchange == "kucoin" {
                        kucoinCurrentPrice[symbol] = price
                        kucoinPrices[symbol, default: []].append(price)
                        kucoinSpotVolume[symbol, default: []].append(volume)
                        
                        // Keep only last 200 data points
                        if kucoinPrices[symbol]!.count > 200 {
                            kucoinPrices[symbol]!.removeFirst()
                        }
                        if kucoinSpotVolume[symbol]!.count > 200 {
                            kucoinSpotVolume[symbol]!.removeFirst()
                        }
                    } else {
                        bybitCurrentPrice[symbol] = price
                        bybitPrices[symbol, default: []].append(price)
                        bybitSpotVolume[symbol, default: []].append(volume)
                        
                        // Keep only last 200 data points
                        if bybitPrices[symbol]!.count > 200 {
                            bybitPrices[symbol]!.removeFirst()
                        }
                        if bybitSpotVolume[symbol]!.count > 200 {
                            bybitSpotVolume[symbol]!.removeFirst()
                        }
                    }
                }
            }
        }
    }

    // ENHANCED: Ticker update processing
    static func processTickerUpdate(exchange: String, data: [String: Any]) async {
        if let dataArray = data["data"] as? [[String: Any]] {
            for tickerData in dataArray {
                await processSingleTickerUpdate(exchange: exchange, data: tickerData)
            }
        } else if let tickerData = data["data"] as? [String: Any] {
            await processSingleTickerUpdate(exchange: exchange, data: tickerData)
        }
    }

    static func processSingleTickerUpdate(exchange: String, data: [String: Any]) async {
        guard let symbol = data["symbol"] as? String ?? data["s"] as? String else { return }
        
        await MainActor.run {
            if let priceStr = data["lastPrice"] as? String ?? data["c"] as? String,
               let price = Double(priceStr) {
                if exchange == "kucoin" {
                    kucoinCurrentPrice[symbol] = price
                } else {
                    bybitCurrentPrice[symbol] = price
                }
            }
            
            if let volumeStr = data["volume24h"] as? String ?? data["v"] as? String,
               let volume = Double(volumeStr) {
                if exchange == "kucoin" {
                    kucoinSpotVolume[symbol, default: []].append(volume)
                } else {
                    bybitSpotVolume[symbol, default: []].append(volume)
                }
            }
        }
    }

    // ENHANCED: WebSocket heartbeat monitoring
    static func monitorWebSocketHeartbeat() {
        Task {
            while true {
                let now = Date()
                
                // Check KuCoin heartbeat
                let kucoinLastActivity = await MainActor.run { lastWebsocketActivity["kucoin"] }
                if let lastActivity = kucoinLastActivity {
                    if now.timeIntervalSince(lastActivity) > 60 { // 60 second timeout
                        await MainActor.run {
                            logAlert(event: "üî¥ KuCoin WebSocket heartbeat timeout")
                        }
                        // Trigger reconnection
                        Task { await reconnectKuCoinWebSocket() }
                    }
                }
                
                // Check Bybit heartbeat
                let bybitLastActivity = await MainActor.run { lastWebsocketActivity["bybit"] }
                if let lastActivity = bybitLastActivity {
                    if now.timeIntervalSince(lastActivity) > 60 { // 60 second timeout
                        await MainActor.run {
                            logAlert(event: "üîµ Bybit WebSocket heartbeat timeout")
                        }
                        // Trigger reconnection
                        Task { reconnectBybitWebSocket() }
                    }
                }
                
                // Send ping messages
                await sendWebSocketPings()
                
                try? await Task.sleep(nanoseconds: 30_000_000_000) // Check every 30 seconds
            }
        }
    }

    static func sendWebSocketPings() async {
        // Send KuCoin ping
        let kucoinConnected = await MainActor.run { kucoinIsConnected }
        if kucoinConnected {
            let pingMessage: [String: Any] = ["id": "ping", "type": "ping"]
            if let pingData = try? JSONSerialization.data(withJSONObject: pingMessage),
               let _ = String(data: pingData, encoding: .utf8) {
                // Send ping via WebSocket
                await MainActor.run {
                    // Implementation would send actual ping message
                    logAlert(event: "üî¥ Sent KuCoin WebSocket ping")
                }
            }
        }
        
        // Send Bybit ping
        let bybitConnected = await MainActor.run { bybitIsConnected }
        if bybitConnected {
            let pingMessage: [String: Any] = ["op": "ping"]
            if let pingData = try? JSONSerialization.data(withJSONObject: pingMessage),
               let _ = String(data: pingData, encoding: .utf8) {
                // Send ping via WebSocket
                await MainActor.run {
                    // Implementation would send actual ping message
                    logAlert(event: "üîµ Sent Bybit WebSocket ping")
                }
            }
        }
    }

 
    static func processMessageQueue() async {
        while true {
            let messages = await MainActor.run { () -> [(String, String)] in
                let _ = enhancedMessageQueue
                enhancedMessageQueue.removeAll()
                return []            }
            
            for (exchange, message) in messages {
                if exchange == "kucoin" {
                    await processKuCoinWebSocketMessage(message: message)
                } else if exchange == "bybit" {
                    await processBybitWebSocketMessage(message: message)
                }
            }
            
            try? await Task.sleep(nanoseconds: 10_000_000) // 10ms processing interval
        }
    }

    // Enhanced sentiment analysis with ML integration
    static func analyzeSentimentWithML(pair: String) async -> Double {
        let url = URL(string: "http://127.0.0.1:5001/analyze_sentiment")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.timeoutInterval = 30.0

        let payload: [String: Any] = [
            "pair": pair,
            "price": await MainActor.run { kucoinCurrentPrice[pair] ?? 0.0 },
            "volume": await MainActor.run { kucoinSpotVolume[pair]?.last ?? 0.0 },
            "funding_rate": await MainActor.run { kucoinFundingRates[pair] ?? 0.0 }
        ]

        do {
            let jsonData = try JSONSerialization.data(withJSONObject: payload, options: [])
            request.httpBody = jsonData
            
            let (data, response) = try await URLSession.shared.data(for: request)
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                await MainActor.run {
                    logAlert(event: "Failed to fetch sentiment for \(pair)")
                }
                return 0.0
            }
            
            if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
               let sentiment = json["sentiment"] as? Double {
                await MainActor.run {
                    sentimentScores[pair] = sentiment
                }
                return sentiment
            }
        } catch {
            await MainActor.run {
                logAlert(event: "Sentiment analysis error for \(pair): \(error.localizedDescription)")
            }
        }
        
        return 0.0
    }

    // Advanced technical indicators for enhanced trading signals
    static func calculateAdvancedRSI(prices: [Double], period: Int = 14) -> Double? {
        guard prices.count >= period else { return nil }
        
        var gains = [Double]()
        var losses = [Double]()
        
        for i in 1..<prices.count {
            let change = prices[i] - prices[i-1]
            gains.append(max(change, 0))
            losses.append(max(-change, 0))
        }
        
        guard gains.count >= period else { return nil }
        
        let avgGain = gains.suffix(period).reduce(0, +) / Double(period)
        let avgLoss = losses.suffix(period).reduce(0, +) / Double(period)
        
        guard avgLoss != 0 else { return 100 }
        
        let rs = avgGain / avgLoss
        return 100 - (100 / (1 + rs))
    }

    static func calculateBollingerBands(prices: [Double], period: Int = 20, stdDev: Double = 2.0) -> (upper: Double, middle: Double, lower: Double)? {
        guard prices.count >= period else { return nil }
        
        let recentPrices = Array(prices.suffix(period))
        let sma = recentPrices.reduce(0, +) / Double(period)
        
        let variance = recentPrices.map { pow($0 - sma, 2) }.reduce(0, +) / Double(period)
        let standardDeviation = sqrt(variance)
        
        return (
            upper: sma + (stdDev * standardDeviation),
            middle: sma,
            lower: sma - (stdDev * standardDeviation)
        )
    }

    static func detectRSIDivergence(prices: [Double], rsiValues: [Double]) -> Bool {
        guard prices.count >= 5, rsiValues.count >= 5 else { return false }
        
        let recentPrices = Array(prices.suffix(5))
        let recentRSI = Array(rsiValues.suffix(5))
        
        let priceDirection = recentPrices.last! > recentPrices.first!
        let rsiDirection = recentRSI.last! > recentRSI.first!
        
        return priceDirection != rsiDirection
    }

    static func analyzeOrderFlow(pair: String) async -> Double {
        let kucoinBook = await MainActor.run { kucoinOrderBooks[pair] } ?? BevaixOrderBook(bids: [], asks: [])
        let bybitBook = await MainActor.run { bybitOrderBooks[pair] } ?? BevaixOrderBook(bids: [], asks: [])
        
        let kucoinBidVolume = kucoinBook.bids.prefix(5).reduce(0.0) { $0 + $1.quantity }
        let kucoinAskVolume = kucoinBook.asks.prefix(5).reduce(0.0) { $0 + $1.quantity }
        let bybitBidVolume = bybitBook.bids.prefix(5).reduce(0.0) { $0 + $1.quantity }
        let bybitAskVolume = bybitBook.asks.prefix(5).reduce(0.0) { $0 + $1.quantity }
        
        let totalBidVolume = kucoinBidVolume + bybitBidVolume
        let totalAskVolume = kucoinAskVolume + bybitAskVolume
        
        guard totalBidVolume + totalAskVolume > 0 else { return 0.0 }
        
        return (totalBidVolume - totalAskVolume) / (totalBidVolume + totalAskVolume)
    }

    // Helper functions
    static func extractSymbolFromTopic(topic: String, exchange: String) -> String {
        if exchange == "kucoin" {
            // KuCoin format: /market/ticker:BTC-USDT
            if let range = topic.range(of: ":") {
                return String(topic[range.upperBound...])
            }
        } else {
            // Bybit format: tickers.BTCUSDT
            if let range = topic.range(of: ".") {
                return String(topic[range.upperBound...])
            }
        }
        return ""
    }

    static func receiveBybitMessages() async {
        // Implementation for receiving WebSocket messages
        await MainActor.run {
            logAlert(event: "üîµ Started receiving Bybit WebSocket messages")
        }
    }

    static func subscribeToBybitStreams() async {
        let pairs = await MainActor.run { tradingPairs }
        for pair in pairs {
            let symbol = pair.replacingOccurrences(of: "-", with: "")
            await subscribeToBybitTicker(symbol: symbol)
            await subscribeToBybitOrderBook(symbol: symbol)
        }
    }

    static func subscribeToBybitTicker(symbol: String) async {
        let subscribeMessage: [String: Any] = [
            "op": "subscribe",
            "args": ["tickers.\(symbol)"]
        ]
        
        if let data = try? JSONSerialization.data(withJSONObject: subscribeMessage),
           let _ = String(data: data, encoding: .utf8) {
            await MainActor.run {
                logAlert(event: "üîµ Subscribed to Bybit ticker for \(symbol)")
            }
        }
    }

    static func subscribeToBybitOrderBook(symbol: String) async {
        let subscribeMessage: [String: Any] = [
            "op": "subscribe",
            "args": ["orderbook.50.\(symbol)"]
        ]
        
        if let data = try? JSONSerialization.data(withJSONObject: subscribeMessage),
           let _ = String(data: data, encoding: .utf8) {
            await MainActor.run {
                logAlert(event: "üîµ Subscribed to Bybit order book for \(symbol)")
            }
        }
    }

    static func reconnectKuCoinWebSocket() async {
        await MainActor.run {
            logAlert(event: "üî¥ Reconnecting KuCoin WebSocket...")
            kucoinIsConnected = false
        }
        // Implementation for KuCoin reconnection would go here
    }

    static func processKuCoinWebSocketMessage(message: String) async {
        // Implementation for KuCoin WebSocket message processing
        await MainActor.run {
            lastWebsocketActivity["kucoin"] = Date()
        }
    }

    static func monitorCrossExchangeArbitrage() {
        let localKucoinCurrentPrice = kucoinCurrentPrice
        let localBybitCurrentPrice = bybitCurrentPrice
        let localKucoinPrices = kucoinPrices
        let localBybitPrices = bybitPrices

        Task {
            await withTaskGroup(of: Void.self) { group in
                let tradingPairsValue = await MainActor.run { tradingPairs }
                for pair in tradingPairsValue {
                    group.addTask {
                        let kucoinSpotPrice = await MainActor.run { localKucoinCurrentPrice[pair] ?? 0.0 }
                        let bybitSpotPrice = await MainActor.run { localBybitCurrentPrice[pair] ?? 0.0 }
                        let kucoinSpotPrices = await MainActor.run { localKucoinPrices[pair] ?? [] }
                        let bybitSpotPrices = await MainActor.run { localBybitPrices[pair] ?? [] }
                        // Suppress unused warnings for kucoinSpotPrices and bybitSpotPrices (Lines 3097, 3098)
                        print("DEBUG: KuCoin spot prices count for \(pair): \(kucoinSpotPrices.count)")
                        print("DEBUG: Bybit spot prices count for \(pair): \(bybitSpotPrices.count)")

                        guard kucoinSpotPrice > 0 && bybitSpotPrice > 0 else {
                            print("DEBUG: Invalid prices for cross-exchange arbitrage - \(pair): KuCoin=\(kucoinSpotPrice), Bybit=\(bybitSpotPrice)")
                            return
                        }

                        let lastExecution = await MainActor.run { crossExchangeArbitrageExecuted[pair] }
                        let cooldownSeconds = await MainActor.run { crossExchangeCooldownSeconds }
                        if lastExecution == nil || Date().timeIntervalSince(lastExecution!.1) > cooldownSeconds {
                            let kucoinEvents = await MainActor.run { kucoinOrderBookEvents[pair] ?? [] }
                            let spoofingThreshold = await MainActor.run { spoofingVolumeThreshold }
                            let spoofingDetected = kucoinEvents.filter { Date().timeIntervalSince($0.timestamp) < 60 }.count > 2 && kucoinEvents.contains(where: { $0.volume > spoofingThreshold })
                            if spoofingDetected {
                                print("DEBUG: Order book spoofing detected for \(pair)")
                                await MainActor.run {
                                    logAlert(event: "Order book spoofing detected for \(pair)")
                                }
                                return
                            }

                            let tradeAmount = await MainActor.run { crossExchangeTradeAmount }
                            // FIXED: Removed await from non-async function
                            await checkCrossExchangeArbitrage(
                                pair: pair,
                                strategy: "momentum",
                                amount: tradeAmount,
                                completion: { success in
                                    if success {
                                        print("DEBUG: Cross-exchange arbitrage executed for \(pair)")
                                    } else {
                                        print("DEBUG: Cross-exchange arbitrage failed for \(pair)")
                                    }
                                }
                            )
                        } else {
                            print("DEBUG: Cross-exchange arbitrage for \(pair) on cooldown")
                        }
                    }
                }
            }
            try? await Task.sleep(nanoseconds: UInt64(getDouble("ARBITRAGE_CHECK_INTERVAL_SECONDS", defaultValue: 0.5) * 1_000_000_000))
            monitorCrossExchangeArbitrage()
        }
    }
    
    // FIXED: Added missing checkCrossExchangeArbitrage function
    static func checkCrossExchangeArbitrage(pair: String, strategy: String, amount: Double, completion: @escaping @Sendable (Bool) -> Void) {
        Task { @MainActor in
            let kucoinPrice = kucoinCurrentPrice[pair] ?? 0.0
            let bybitPrice = bybitCurrentPrice[pair] ?? 0.0
            
            guard kucoinPrice > 0 && bybitPrice > 0 else {
                completion(false)
                return
            }
            
            let spread = abs(kucoinPrice - bybitPrice) / min(kucoinPrice, bybitPrice)
            let threshold = crossExchangeMinSpreadThreshold
            
            if spread > threshold {
                print("DEBUG: Cross-exchange arbitrage opportunity detected for \(pair): spread \(spread)")
                crossExchangeArbitrageExecuted[pair] = (true, Date())
                completion(true)
            } else {
                completion(false)
            }
        }
    }
}

//-------------------------------------------------------------------------------------------------------------------------Block 11 - WebSocket Data Handling


// VARIABLES TO ADD: Add to Block 1 - Core Data Structures and Utilities if not present:
// private static var kucoinDelegate: KuCoinSpotWebSocketDelegate?
// private static var kucoinFuturesDelegate: KuCoinFuturesWebSocketDelegate?
// private static var bybitDelegate: BybitSpotWebSocketDelegate?
// private static var bybitFuturesDelegate: BybitFuturesWebSocketDelegate?

extension ExchangeWebSocket {
    private static var kucoinSpotDelegate: KuCoinSpotWebSocketDelegate?
    private static var kucoinFuturesDelegate: KuCoinFuturesWebSocketDelegate?
    private static var bybitSpotDelegate: BybitSpotWebSocketDelegate?
    private static var bybitFuturesDelegate: BybitFuturesWebSocketDelegate?

    @MainActor
    static func connectKucoin() {
        guard hasValidKuCoinCredentials else {
            print("Skipping KuCoin WebSocket connection due to missing credentials")
            Task { @MainActor in
                logAlert(event: "Skipping KuCoin WebSocket connection due to missing credentials")
            }
            return
        }
        print("Attempting to connect to KuCoin WebSocket...")
        fetchKuCoinWsToken { token in
            guard let token = token else {
                print("Failed to fetch KuCoin WebSocket token, retrying in 5 seconds...")
                DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                    connectKucoin()
                }
                return
            }
            Task { @MainActor in
                kucoinToken = token
                let wsURLString = "wss://ws-api.kucoin.com/endpoint?token=\(token)&acceptUserMessage=true"
                guard let wsURL = URL(string: wsURLString) else {
                    print("Invalid KuCoin WebSocket URL: \(wsURLString), retrying in 5 seconds...")
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectKucoin()
                    }
                    return
                }
                var request = URLRequest(url: wsURL)
                request.timeoutInterval = 10
                kucoinSocket = WebSocket(request: request)
                kucoinSpotDelegate = KuCoinSpotWebSocketDelegate()
                kucoinSocket?.delegate = kucoinSpotDelegate
                kucoinSocket?.connect()
                
                weak var ws = kucoinSocket
                ws?.onEvent = { event in
                    Task { @MainActor in
                        switch event {
                        case .connected(_):
                            for (index, pair) in tradingPairs.enumerated() {
                                // Fixed symbol formatting for KuCoin spot
                                let formattedPair = pair.replacingOccurrences(of: "-", with: "")
                                let spotTopic = "/market/ticker:\(formattedPair)"
                                let spotSubscribeMessage: [String: Any] = [
                                    "id": Int(Date().timeIntervalSince1970 * 1000) + index,
                                    "type": "subscribe",
                                    "topic": spotTopic,
                                    "privateChannel": false,
                                    "response": true
                                ]
                                if let spotData = try? JSONSerialization.data(withJSONObject: spotSubscribeMessage),
                                   let spotMessage = String(data: spotData, encoding: .utf8) {
                                    ws?.write(string: spotMessage)
                                    print("Subscribed to KuCoin spot topic: \(spotTopic) for pair: \(pair)")
                                } else {
                                    print("Failed to subscribe to KuCoin spot topic: \(spotTopic) for pair: \(pair)")
                                }
                            }
                            Timer.scheduledTimer(withTimeInterval: 15.0, repeats: true) { _ in
                                Task { @MainActor in
                                    let pingMessage = "{\"id\": \"ping_\(Int(Date().timeIntervalSince1970))\", \"type\": \"ping\"}"
                                    ws?.write(string: pingMessage)
                                    print("Sent ping to KuCoin Spot WebSocket")
                                }
                            }
                        case .disconnected(_, _):
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectKucoin()
                            }
                        case .error(_):
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectKucoin()
                            }
                        case .text(let string):
                            if let data = string.data(using: .utf8),
                               let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                               let type = json["type"] as? String, type == "welcome" {
                                print("KuCoin Spot WebSocket subscription confirmed")
                            }
                        case .peerClosed:
                            print("KuCoin Spot WebSocket peer closed connection")
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectKucoin()
                            }
                        default:
                            break
                        }
                    }
                }
            }
        }
    }

    @MainActor
    static func connectKucoinFutures() {
        guard hasValidKuCoinCredentials else {
            print("Skipping KuCoin Futures WebSocket connection due to missing credentials")
            Task { @MainActor in
                logAlert(event: "Skipping KuCoin Futures WebSocket connection due to missing credentials")
            }
            return
        }
        print("Attempting to connect to KuCoin Futures WebSocket...")
        fetchKucoinFuturesWsToken { token in
            guard let token = token else {
                print("Failed to fetch KuCoin Futures WebSocket token, retrying in 5 seconds...")
                DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                    connectKucoinFutures()
                }
                return
            }
            Task { @MainActor in
                kucoinFuturesToken = token
                let connectId = UUID().uuidString
                let wsURLString = "wss://ws-api-futures.kucoin.com/?token=\(token)&connectId=\(connectId)"
                guard let wsURL = URL(string: wsURLString) else {
                    print("Invalid KuCoin Futures WebSocket URL: \(wsURLString), retrying in 5 seconds...")
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectKucoinFutures()
                    }
                    return
                }
                var request = URLRequest(url: wsURL)
                request.timeoutInterval = 10
                kucoinFuturesSocket = WebSocket(request: request)
                kucoinFuturesDelegate = KuCoinFuturesWebSocketDelegate()
                kucoinFuturesSocket?.delegate = kucoinFuturesDelegate
                kucoinFuturesSocket?.connect()
                
                weak var ws = kucoinFuturesSocket
                ws?.onEvent = { event in
                    Task { @MainActor in
                        switch event {
                        case .connected(_):
                            for (index, pair) in tradingPairs.enumerated() {
                                guard let futuresSymbol = kucoinFuturesSymbols[pair] else {
                                    print("No futures symbol found for pair: \(pair), skipping subscription")
                                    continue
                                }
                                let priceTopic = "/contractMarket/tickerV2:\(futuresSymbol)"
                                let priceSubscription: [String: Any] = [
                                    "id": Int(Date().timeIntervalSince1970 * 1000) + index,
                                    "type": "subscribe",
                                    "topic": priceTopic,
                                    "privateChannel": false,
                                    "response": true
                                ]
                                if let priceData = try? JSONSerialization.data(withJSONObject: priceSubscription),
                                   let priceMessage = String(data: priceData, encoding: .utf8) {
                                    ws?.write(string: priceMessage)
                                    print("Subscribed to KuCoin Futures price topic: \(priceTopic) for pair: \(pair)")
                                } else {
                                    print("Failed to subscribe to KuCoin Futures price topic: \(priceTopic) for pair: \(pair)")
                                }
                                let orderBookTopic = "/contractMarket/level2:\(futuresSymbol)"
                                let orderBookSubscription: [String: Any] = [
                                    "id": Int(Date().timeIntervalSince1970 * 1000) + index + 2000,
                                    "type": "subscribe",
                                    "topic": orderBookTopic,
                                    "privateChannel": false,
                                    "response": true
                                ]
                                if let orderBookData = try? JSONSerialization.data(withJSONObject: orderBookSubscription),
                                   let orderBookMessage = String(data: orderBookData, encoding: .utf8) {
                                    ws?.write(string: orderBookMessage)
                                    print("Subscribed to KuCoin Futures order book topic: \(orderBookTopic) for pair: \(pair)")
                                } else {
                                    print("Failed to subscribe to KuCoin Futures order book topic: \(orderBookTopic) for pair: \(pair)")
                                }
                                let fundingTopic = "/contract/instrument:\(futuresSymbol)"
                                let fundingSubscription: [String: Any] = [
                                    "id": Int(Date().timeIntervalSince1970 * 1000) + index + 1000,
                                    "type": "subscribe",
                                    "topic": fundingTopic,
                                    "privateChannel": false,
                                    "response": true
                                ]
                                if let fundingData = try? JSONSerialization.data(withJSONObject: fundingSubscription),
                                   let fundingMessage = String(data: fundingData, encoding: .utf8) {
                                    ws?.write(string: fundingMessage)
                                    print("Subscribed to KuCoin Futures funding rate topic: \(fundingTopic) for pair: \(pair)")
                                } else {
                                    print("Failed to subscribe to KuCoin Futures funding rate topic: \(fundingTopic) for pair: \(pair)")
                                }
                            }
                            Timer.scheduledTimer(withTimeInterval: 15.0, repeats: true) { _ in
                                Task { @MainActor in
                                    let pingMessage = "{\"id\": \"ping_\(Int(Date().timeIntervalSince1970))\", \"type\": \"ping\"}"
                                    ws?.write(string: pingMessage)
                                    print("Sent ping to KuCoin Futures WebSocket")
                                }
                            }
                        case .disconnected(_, _):
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectKucoinFutures()
                            }
                        case .error(_):
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectKucoinFutures()
                            }
                        case .text(let string):
                            if let data = string.data(using: .utf8),
                               let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                               let type = json["type"] as? String, type == "welcome" {
                                print("KuCoin Futures WebSocket subscription confirmed")
                            }
                        case .peerClosed:
                            print("KuCoin Futures WebSocket peer closed connection")
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectKucoinFutures()
                            }
                        default:
                            break
                        }
                    }
                }
            }
        }
    }

    @MainActor
    static func connectBybit() {
        print("Attempting to connect to Bybit WebSocket...")
        bybitSocket = WebSocket(request: URLRequest(url: URL(string: "wss://stream.bybit.com/v5/public/spot")!))
        bybitSpotDelegate = BybitSpotWebSocketDelegate()
        bybitSocket?.delegate = bybitSpotDelegate
        bybitSocket?.connect()
        
        weak var spotWs = bybitSocket
        spotWs?.onEvent = { event in
            Task { @MainActor in
                switch event {
                case .connected(_):
                    for pair in tradingPairs {
                        // Fixed symbol formatting for Bybit
                        let symbol = pair.replacingOccurrences(of: "-", with: "")
                        let subscribeMessage: [String: Any] = [
                            "req_id": "bybit_spot_\(Int(Date().timeIntervalSince1970 * 1000))",
                            "op": "subscribe",
                            "args": [
                                "tickers.\(symbol)",
                                "orderbook.50.\(symbol)",
                                "publicTrade.\(symbol)"
                            ]
                        ]
                        if let data = try? JSONSerialization.data(withJSONObject: subscribeMessage),
                           let message = String(data: data, encoding: .utf8) {
                            spotWs?.write(string: message)
                            print("Subscribed to Bybit spot topics: tickers.\(symbol), orderbook.50.\(symbol), publicTrade.\(symbol) for pair: \(pair)")
                        } else {
                            print("Failed to subscribe to Bybit spot topics for pair: \(pair)")
                        }
                    }
                    Timer.scheduledTimer(withTimeInterval: 20.0, repeats: true) { _ in
                        Task { @MainActor in
                            let pingMessage = "{\"op\": \"ping\", \"req_id\": \"bybit_spot_\(Int(Date().timeIntervalSince1970 * 1000))\"}"
                            spotWs?.write(string: pingMessage)
                            print("Sent ping to Bybit Spot WebSocket")
                        }
                    }
                case .disconnected(_, _):
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectBybit()
                    }
                case .error(_):
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectBybit()
                    }
                case .text(let string):
                    if let data = string.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                       let success = json["success"] as? Bool, success,
                       let retMsg = json["ret_msg"] as? String, retMsg == "subscribe" {
                        print("Bybit Spot subscription confirmed")
                    }
                case .peerClosed:
                    print("Bybit Spot WebSocket peer closed connection")
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectBybit()
                    }
                default:
                    break
                }
            }
        }
        
        bybitSpotSocket = WebSocket(request: URLRequest(url: URL(string: "wss://stream.bybit.com/v5/public/linear")!))
        bybitFuturesDelegate = BybitFuturesWebSocketDelegate()
        bybitSpotSocket?.delegate = bybitFuturesDelegate
        bybitSpotSocket?.connect()
        
        weak var futuresWs = bybitSpotSocket
        futuresWs?.onEvent = { event in
            Task { @MainActor in
                switch event {
                case .connected(_):
                    for pair in tradingPairs {
                        // Fixed symbol formatting for Bybit futures
                        let symbol = pair.replacingOccurrences(of: "-", with: "")
                        let subscribeMessage: [String: Any] = [
                            "req_id": "bybit_futures_\(Int(Date().timeIntervalSince1970 * 1000))",
                            "op": "subscribe",
                            "args": [
                                "tickers.\(symbol)",
                                "orderbook.50.\(symbol)",
                                "publicTrade.\(symbol)"
                            ]
                        ]
                        if let data = try? JSONSerialization.data(withJSONObject: subscribeMessage),
                           let message = String(data: data, encoding: .utf8) {
                            futuresWs?.write(string: message)
                            print("Subscribed to Bybit futures topics: tickers.\(symbol), orderbook.50.\(symbol), publicTrade.\(symbol) for pair: \(pair)")
                        } else {
                            print("Failed to subscribe to Bybit futures topics for pair: \(pair)")
                        }
                    }
                    Timer.scheduledTimer(withTimeInterval: 20.0, repeats: true) { _ in
                        Task { @MainActor in
                            let pingMessage = "{\"op\": \"ping\", \"req_id\": \"bybit_futures_\(Int(Date().timeIntervalSince1970 * 1000))\"}"
                            futuresWs?.write(string: pingMessage)
                            print("Sent ping to Bybit Futures WebSocket")
                        }
                    }
                case .disconnected(_, _):
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectBybit()
                    }
                case .error(_):
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectBybit()
                    }
                case .text(let string):
                    if let data = string.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                       let success = json["success"] as? Bool, success,
                       let retMsg = json["ret_msg"] as? String, retMsg == "subscribe" {
                        print("Bybit Futures subscription confirmed")
                    }
                case .peerClosed:
                    print("Bybit Futures WebSocket peer closed connection")
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectBybit()
                    }
                default:
                    break
                }
            }
        }
    }
}
//--------------------------------------------------------------------------------------------------------------------------Block 12 - Trading Loop Monitoring and Support

//--------------------------------------------------------------------------------------------------------------------------Block 12 - Trading Loop Monitoring and Support

import Foundation // Added for String.Encoding and other Foundation types

extension ExchangeWebSocket {
    static var totalProfit: Double = 0.0
    static var totalFees: Double = 0.0
    static var kellyCreditRatio: Double = getDouble("KELLY_CREDIT_RATIO", defaultValue: 2.0)

    static func checkLiquidityAsyncUnique(exchange: String, pair: String, marketType: String, tradeAmount: Double, price: Double) async -> Double? {
        let minLiquidity = getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 500.0)
        let requiredLiquidity = tradeAmount * price * liquidityDepthMultiplier

        do {
            let depth = try await fetchOrderBookDepth(for: exchange, pair: pair, marketType: marketType, retryCount: 0)
            guard let unwrappedDepth = depth, unwrappedDepth >= max(minLiquidity, requiredLiquidity) else {
                print("üìù DEBUG: Insufficient liquidity for \(exchange)-\(pair)-\(marketType): Depth \(String(describing: depth)), Required \(requiredLiquidity)")
                await MainActor.run {
                    logAlert(event: "Insufficient liquidity for \(exchange)-\(pair)-\(marketType): Depth \(String(describing: depth))")
                }
                return nil
            }
            print("DEBUG: Liquidity check passed for \(exchange)-\(pair)-\(marketType): Depth \(unwrappedDepth)")
            return unwrappedDepth
        } catch {
            print("DEBUG: Error fetching order book depth for \(exchange)-\(pair)-\(marketType): \(error.localizedDescription)")
            await MainActor.run {
                logAlert(event: "Error fetching order book depth for \(exchange)-\(pair)-\(marketType): \(error.localizedDescription)")
            }
            return nil
        }
    }

    static func fetchOrderBookDepth(for exchange: String, pair: String, marketType: String, retryCount: Int = 0) async throws -> Double? {
        let maxRetries = getInt("API_MAX_RETRIES", defaultValue: 3)
        guard retryCount < maxRetries else {
            let book = exchange == "bybit" ? bybitOrderBooks[pair] : kucoinOrderBooks[pair]
            let cachedDepth = book.map { book in
                let bidDepth = book.bids.prefix(10).reduce(0.0) { $0 + $1.price * $1.quantity }
                let askDepth = book.asks.prefix(10).reduce(0.0) { $0 + $1.price * $1.quantity }
                return bidDepth + askDepth
            } ?? getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 500.0)
            print("DEBUG: Max retries reached, using cached depth for \(exchange)-\(pair)-\(marketType): \(cachedDepth)")
            await MainActor.run {
                logAlert(event: "Max retries reached for order book fetch: \(exchange)-\(pair)-\(marketType)")
            }
            return cachedDepth
        }

        let symbol = pair.replacingOccurrences(of: "-USDT", with: "USDT")
        var url: URL?
        if exchange == "bybit" {
            let category = marketType == "spot" ? "spot" : "linear"
            url = URL(string: "https://api.bybit.com/v5/market/orderbook?category=\(category)&symbol=\(symbol)&limit=50")
        } else {
            let endpoint = marketType == "spot" ? "/api/v1/market/orderbook/level2_50?symbol=\(symbol)" : "/api/v1/contractMarket/level2?symbol=\(symbol)M"
            url = URL(string: "https://api\(marketType == "spot" ? "" : "-futures").kucoin.com\(endpoint)")
        }

        guard let requestUrl = url else {
            print("Invalid order book URL for \(exchange)-\(pair)-\(marketType)")
            await MainActor.run {
                logAlert(event: "Invalid order book URL for \(exchange)-\(pair)-\(marketType)")
            }
            try await Task.sleep(nanoseconds: 2_000_000_000)
            return try await fetchOrderBookDepth(for: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1)
        }

        var request = URLRequest(url: requestUrl)
        request.httpMethod = "GET"
        request.timeoutInterval = getDouble("API_TIMEOUT_SECONDS", defaultValue: 10.0)

        let startTime = Date()
        let (data, response) = try await URLSession.shared.data(for: request)
        let latency = Date().timeIntervalSince(startTime) * 1000
        await MainActor.run {
            lastLatency[pair] = latency
            if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 300.0) {
                print("High latency detected for order book fetch: \(latency)ms")
                logAlert(event: "High latency detected for order book fetch: \(latency)ms")
            }
        }

        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
            print("Invalid order book response for \(exchange)-\(pair)-\(marketType)")
            await MainActor.run {
                logAlert(event: "Invalid order book response for \(exchange)-\(pair)-\(marketType)")
            }
            try await Task.sleep(nanoseconds: 2_000_000_000)
            return try await fetchOrderBookDepth(for: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1)
        }

        let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
        if exchange == "bybit" {
            guard let result = json?["result"] as? [String: Any],
                  let bids = result["b"] as? [[String]],
                  let asks = result["a"] as? [[String]],
                  !bids.isEmpty, !asks.isEmpty else {
                print("Failed to parse Bybit order book data for \(pair)-\(marketType)")
                await MainActor.run {
                    logAlert(event: "Failed to parse Bybit order book data for \(pair)-\(marketType)")
                }
                try await Task.sleep(nanoseconds: 2_000_000_000)
                return try await fetchOrderBookDepth(for: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1)
            }

            var bidDepth: Double = 0.0
            var askDepth: Double = 0.0

            for bid in bids.prefix(10) {
                if let priceStr = bid.first, let qtyStr = bid.last,
                   let price = Double(priceStr), let qty = Double(qtyStr) {
                    bidDepth += price * qty
                }
            }

            for ask in asks.prefix(10) {
                if let priceStr = ask.first, let qtyStr = ask.last,
                   let price = Double(priceStr), let qty = Double(qtyStr) {
                    askDepth += price * qty
                }
            }

            let totalDepth = bidDepth + askDepth
            print("DEBUG: Bybit order book depth for \(pair)-\(marketType): \(totalDepth)")
            return totalDepth
        } else {
            guard let dataDict = json?["data"] as? [String: Any],
                  let bids = dataDict["bids"] as? [[String]],
                  let asks = dataDict["asks"] as? [[String]],
                  !bids.isEmpty, !asks.isEmpty else {
                print("Failed to parse KuCoin order book data for \(pair)-\(marketType)")
                await MainActor.run {
                    logAlert(event: "Failed to parse KuCoin order book data for \(pair)-\(marketType)")
                }
                try await Task.sleep(nanoseconds: 2_000_000_000)
                return try await fetchOrderBookDepth(for: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1)
            }

            var bidDepth: Double = 0.0
            var askDepth: Double = 0.0

            for bid in bids.prefix(10) {
                if let priceStr = bid.first, let qtyStr = bid.last,
                   let price = Double(priceStr), let qty = Double(qtyStr) {
                    bidDepth += price * qty
                }
            }

            for ask in asks.prefix(10) {
                if let priceStr = ask.first, let qtyStr = ask.last,
                   let price = Double(priceStr), let qty = Double(qtyStr) {
                    askDepth += price * qty
                }
            }

            let totalDepth = bidDepth + askDepth
            print("DEBUG: KuCoin order book depth for \(pair)-\(marketType): \(totalDepth)")
            return totalDepth
        }
    }

    private static func fetchAndLogBalances(isInitial: Bool = false, completion: @escaping @Sendable () -> Void) {
        fetchKucoinBalance { _ in
            Task { @MainActor in
                fetchBybitBalance { _ in
                    Task { @MainActor in
                        if isInitial {
                            print("üíµ Initial Balances: KuCoin: \(ExchangeWebSocket.kucoinBalance) | Bybit: \(ExchangeWebSocket.bybitBalance)")
                        }
                        completion()
                    }
                }
            }
        }
    }

    static func dynamicTradeAmount(balance: Double, riskPercent: Double, volatility: Double, pair: String = tradingPairs.first ?? "BTC-USDT") async -> Double {
        let kellyFraction = await calculateKellyCriterion(pair: pair)
        let baseAmount = min(balance * riskPercent, balance * 0.6)
        let volatilityAdjusted = baseAmount * (1.0 / (1.0 + volatility * 0.3))
        let kellyAmount = balance * max(0.0, min(kellyFraction, 0.6))
        return min(volatilityAdjusted, kellyAmount)
    }

    static func rebalanceExchanges() {
        let balanceDifferenceThreshold = 0.08
        let totalBalance = kucoinBalance + bybitBalance
        
        guard totalBalance > 0 else { return }
        
        let kucoinBalanceRatio = kucoinBalance / totalBalance
        let bybitBalanceRatio = bybitBalance / totalBalance
        
        if abs(kucoinBalanceRatio - bybitBalanceRatio) > balanceDifferenceThreshold {
            let targetBalance = totalBalance / 2
            let transferAmount = abs(kucoinBalance - targetBalance)
            
            if kucoinBalance > bybitBalance {
                ExchangeWebSocket.kucoinBalance -= transferAmount
                ExchangeWebSocket.bybitBalance += transferAmount
            } else {
                ExchangeWebSocket.bybitBalance -= transferAmount
                ExchangeWebSocket.kucoinBalance += transferAmount
            }
        }
    }

    static func fetchExchangeFees(exchange: String, completion: @escaping @Sendable (Double?, Double?) -> Void) {
        if exchange == "kucoin" {
            completion(0.0001, 0.0004)
        } else if exchange == "bybit" {
            completion(0.0001, 0.0004)
        } else {
            completion(nil, nil)
        }
    }

    static func printPeriodicSummary() {
        print("üìä Performance Summary:")
        print("üìä Total Profit: \(totalProfit), Total Fees: \(totalFees)")
        for (pair, metrics) in tradeMetrics {
            print("\(pair): Wins: \(metrics.wins), Losses: \(metrics.losses), Profit: \(metrics.totalProfit), Fees: \(metrics.totalFees)")
        }
    }

    static func executeHFTTrade(exchange: String, pair: String, side: String, price: Double, amount: Double) {
        print("üí∏ Trade: \(side) \(amount) of \(pair) on \(exchange) at \(price)")
        let fee = amount * price * (exchange == "kucoin" ? kucoinTakerFee : bybitTakerFee)
        totalFees += fee
        if exchange == "kucoin" {
            kucoinBalance -= side == "buy" ? (amount * price + fee) : -fee
            kucoinPositions[pair] = (kucoinPositions[pair] ?? 0.0) + (side == "buy" ? amount : -amount)
        } else {
            bybitBalance -= side == "buy" ? (amount * price + fee) : -fee
            bybitPositions[pair] = (bybitPositions[pair] ?? 0.0) + (side == "buy" ? amount : -amount)
        }
    }

    static func connectWebSocket(exchange: String, pair: String, marketType: String) {
        print("üì° Connecting WebSocket for \(exchange), pair: \(pair), marketType: \(marketType)")
    }

    static func checkCircuitBreaker(pair: String) {
        let prices = ExchangeWebSocket.kucoinPrices[pair] ?? []
        guard prices.count >= 60 else { return }
        let recentPrices = prices.suffix(60)
        let volatility = (recentPrices.max()! - recentPrices.min()!) / Double(recentPrices.count)
        if volatility > ExchangeWebSocket.volatilitySpikeThreshold {
            isTradingPaused[pair] = true
            lastVolatilityPause = Date()
            print("‚öñÔ∏è Circuit breaker triggered for \(pair): Volatility: \(String(format: "%.4f", volatility))")
            Task { @MainActor in
                logAlert(event: "Circuit breaker triggered for \(pair): Volatility: \(String(format: "%.4f", volatility))")
            }
        }
    }

    static func marketMaker(pair: String, exchange: String) {
        let spread = getDouble("MARKET_MAKING_SPREAD", defaultValue: 0.001)
        let price = exchange == "kucoin" ? kucoinCurrentPrice[pair] ?? 0.0 : bybitCurrentPrice[pair] ?? 0.0
        print("üìà Market-making for \(pair) on \(exchange): Bid: \(String(format: "%.4f", price * (1 - spread))), Ask: \(String(format: "%.4f", price * (1 + spread)))")
    }

    static func executeScalpingTrade(pair: String, exchange: String, entryPrice: Double, targetPrice: Double, stopPrice: Double, tradeAmount: Double, maxActiveTrades: Int) async -> Bool {
        let trailingProfitPercent = getDouble("TRAILING_PROFIT_PERCENT", defaultValue: 0.03)
        let feeRate = exchange == "kucoin" ? kucoinTakerFee : bybitTakerFee
        let quantity = tradeAmount / entryPrice
        var highestPrice = entryPrice
        var trailingTargetPrice = entryPrice * (1 + trailingProfitPercent)
        var exitPrice: Double = 0.0
        let startTime = Date()
        let dashboardJSONURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/dashboard.json")

        // Copy balance to avoid inout capture
        var localKucoinBalance = kucoinBalance
        var localBybitBalance = bybitBalance

        while Date().timeIntervalSince(startTime) < 60 {
            if let currentPrice = await MainActor.run(body: { exchange == "bybit" ? bybitCurrentPrice[pair] : kucoinCurrentPrice[pair] }) {
                if currentPrice > highestPrice {
                    highestPrice = currentPrice
                    trailingTargetPrice = highestPrice * (1 - trailingProfitPercent)
                }
                if currentPrice >= targetPrice || currentPrice <= stopPrice || currentPrice <= trailingTargetPrice {
                    exitPrice = currentPrice
                    break
                }
            }
            try? await Task.sleep(nanoseconds: 1_00_000_000) // 100ms
        }

        if exitPrice == 0.0 {
            exitPrice = await MainActor.run { exchange == "bybit" ? bybitCurrentPrice[pair] : kucoinCurrentPrice[pair] } ?? entryPrice
        }

        let profit = quantity * (exitPrice - entryPrice)
        let fees = tradeAmount * feeRate * 2
        if exchange == "kucoin" {
            localKucoinBalance += profit - fees
        } else {
            localBybitBalance += profit - fees
        }
        print("üìä Scalping trade for \(pair) on \(exchange): Profit: \(profit), Fees: \(fees)")
        await MainActor.run {
            // Update global balances after Task
            if exchange == "kucoin" {
                kucoinBalance = localKucoinBalance
            } else {
                bybitBalance = localBybitBalance
            }
            updateTradeMetrics(
                pair: pair,
                profit: profit,
                fees: fees,
                isWin: profit > 0,
                dashboardJSONURL: dashboardJSONURL,
                totalProfit: &ExchangeWebSocket.totalProfit,
                totalFees: &ExchangeWebSocket.totalFees
            )
            logTradeToCSV(
                pair: pair,
                strategy: "HFT Scalping",
                profit: profit,
                fees: fees,
                tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trade_log.csv")
            )
            sendTradeToFlaskServer(strategy: "HFT Scalping", pair: pair, exchange: exchange, spotPrice: 0.0, futuresPrice: 0.0, tradeAmount: 0.0, profit: profit)
        }
        return profit > 0
    }

    static func executeFuturesTrade(pair: String, exchange: String, entryPrice: Double, targetPrice: Double, stopPrice: Double, tradeAmount: Double) {
        let feeRate = exchange == "bybit" ? bybitTakerFee : kucoinTakerFee
        let quantity = tradeAmount / entryPrice
        let leverage = exchange == "bybit" ? getDouble("BYBIT_LEVERAGE", defaultValue: 3.0) : getDouble("KUCOIN_LEVERAGE", defaultValue: 3.0)
        let effectiveTradeAmount = tradeAmount * leverage
        var exitPrice: Double = 0.0
        let startTime = Date()
        let dashboardJSONURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/dashboard.json")
        
        // Copy balance to avoid inout capture
        var localKucoinBalance = kucoinBalance
        var localBybitBalance = bybitBalance

        while Date().timeIntervalSince(startTime) < 60 {
            if let price = (exchange == "bybit" ? bybitCurrentFuturesPrice[pair] : kucoinCurrentFuturesPrice[pair]) {
                if price >= targetPrice || price <= stopPrice {
                    exitPrice = price
                    break
                }
            }
            Thread.sleep(forTimeInterval: 0.1)
        }
        
        if exitPrice == 0.0 {
            exitPrice = (exchange == "bybit" ? bybitCurrentFuturesPrice[pair] : kucoinCurrentFuturesPrice[pair]) ?? entryPrice
        }
        
        let grossProfit = (exitPrice - entryPrice) * quantity * leverage
        let fees = effectiveTradeAmount * feeRate * 2
        let profit = grossProfit - fees
        
        if exchange == "bybit" {
            localBybitBalance += profit
        } else {
            localKucoinBalance += profit
        }
        print("üìä Futures trade for \(pair) on \(exchange): Profit: \(profit), Fees: \(fees)")
        Task { @MainActor in
            // Update global balances after Task
            if exchange == "bybit" {
                bybitBalance = localBybitBalance
            } else {
                kucoinBalance = localKucoinBalance
            }
            updateTradeMetrics(
                pair: pair,
                profit: profit,
                fees: fees,
                isWin: profit > 0,
                dashboardJSONURL: dashboardJSONURL,
                totalProfit: &ExchangeWebSocket.totalProfit,
                totalFees: &ExchangeWebSocket.totalFees
            )
            logTradeToCSV(
                pair: pair,
                strategy: "Funding Rate Momentum",
                profit: profit,
                fees: fees,
                tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trade_log.csv")
            )
            sendTradeToFlaskServer(strategy: "Funding Rate Momentum", pair: pair, exchange: exchange, spotPrice: 0.0, futuresPrice: 0.0, tradeAmount: 0.0, profit: profit)
        }
    }

    static func updateDashboardJSON(dashboardJSONURL: URL, totalProfit: Double, totalFees: Double) {
        Task { @MainActor in
            let timestamp = ISO8601DateFormatter().string(from: Date())
            do {
                let fileManager = FileManager.default
                let directoryURL = dashboardJSONURL.deletingLastPathComponent()
                if !fileManager.fileExists(atPath: directoryURL.path) {
                    try fileManager.createDirectory(at: directoryURL, withIntermediateDirectories: true, attributes: nil)
                }
                var perPairMetrics: [[String: Any]] = []
                for pair in tradingPairs {
                    let metrics = tradeMetrics[pair] ?? (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)
                    let trades = metrics.wins + metrics.losses
                    let winRate = trades > 0 ? Double(metrics.wins) / Double(trades) * 100.0 : 0.0
                    let sentiment = sentimentScores[pair] ?? 0.0
                    let pairData: [String: Any] = [
                        "pair": pair,
                        "trades": trades,
                        "wins": metrics.wins,
                        "losses": metrics.losses,
                        "winRate": winRate,
                        "profit": metrics.totalProfit,
                        "fees": metrics.totalFees,
                        "sentiment": sentiment
                    ]
                    perPairMetrics.append(pairData)
                }
                
                let dashboardData: [String: Any] = [
                    "timestamp": timestamp,
                    "totalProfit": totalProfit,
                    "totalFees": totalFees,
                    "totalTrades": tradeMetrics.values.reduce(0) { $0 + $1.wins + $1.losses },
                    "kucoinBalance": kucoinBalance,
                    "bybitBalance": bybitBalance,
                    "perPairMetrics": perPairMetrics,
                    "livePrices": tradingPairs.map { pair in
                        [
                            "pair": pair,
                            "kucoinSpot": kucoinCurrentPrice[pair] ?? 0.0,
                            "kucoinFutures": kucoinCurrentFuturesPrice[pair] ?? 0.0,
                            "bybitSpot": bybitCurrentPrice[pair] ?? 0.0,
                            "bybitFutures": bybitCurrentFuturesPrice[pair] ?? 0.0
                        ]
                    }
                ]
                
                let jsonData = try JSONSerialization.data(withJSONObject: dashboardData, options: [.prettyPrinted])
                try jsonData.write(to: dashboardJSONURL, options: .atomic)
                print("üìà Updated dashboard JSON at \(dashboardJSONURL.path)")
            } catch {
                print("‚ö†Ô∏è Failed to update dashboard JSON: \(error.localizedDescription)")
                logAlert(event: "Failed to update dashboard JSON: \(error.localizedDescription)")
            }
        }
    }

    static func calculateKellyCriterion(pair: String) async -> Double {
        // Use empirical win probability from tradeMetrics, fallback to default
        let metrics = tradeMetrics[pair] ?? (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)
        let totalTrades = metrics.wins + metrics.losses
        let winProbability = totalTrades > 0 ? Double(metrics.wins) / Double(totalTrades) : kellyWinProbability
        
        // Adjust reward-to-risk based on ATR for volatility
        let atr = kucoinFuturesATR[pair] ?? 0.01
        let currentPrice = kucoinCurrentPrice[pair] ?? 1.0
        let volatilityAdjustment = atr / currentPrice
        let rewardToRisk = kellyRewardToRisk * (1 + volatilityAdjustment * 0.5) // Scale by volatility
        
        // Calculate Kelly fraction
        let kelly = (winProbability * (rewardToRisk + 1) - 1) / rewardToRisk
        
        // Apply bounds and validation
        guard rewardToRisk > 0 else {
            Task { @MainActor in
                logAlert(event: "üü° Invalid reward-to-risk ratio for \(pair): \(rewardToRisk)")
            }
            return 0.01 // Minimum safe fraction
        }
        
        // Clamp between 0.01 and 0.5 for safety
        let clampedKelly = max(min(kelly, 0.5), 0.01)
        
        // Store in kellySizes for pair-specific sizing
        await MainActor.run {
            kellySizes[pair] = clampedKelly
            logAlert(event: "üü° Calculated Kelly fraction for \(pair): \(clampedKelly), p=\(winProbability), r=\(rewardToRisk)")
        }
        
        return clampedKelly
    }

    static func calculateOrderBookVWAP(pair: String, exchange: String, priceRange: Double, currentPrice: Double) -> Double? {
        let orderBook = exchange == "kucoin" ? kucoinOrderBooks[pair] : bybitOrderBooks[pair]
        guard let book = orderBook, !book.bids.isEmpty, !book.asks.isEmpty else {
            print("DEBUG: Order book unavailable for \(pair) on \(exchange)")
            Task { @MainActor in
                logAlert(event: "Order book unavailable for \(pair) on \(exchange)")
            }
            return nil
        }

        let minPrice = currentPrice * (1 - priceRange)
        let maxPrice = currentPrice * (1 + priceRange)

        var totalVolume: Double = 0.0
        var totalPriceVolume: Double = 0.0

        for bid in book.bids {
            if bid.price >= minPrice && bid.price <= maxPrice {
                totalPriceVolume += bid.price * bid.quantity
                totalVolume += bid.quantity
            }
        }

        for ask in book.asks {
            if ask.price >= minPrice && ask.price <= maxPrice {
                totalPriceVolume += ask.price * ask.quantity
                totalVolume += ask.quantity
            }
        }

        guard totalVolume > 0 else {
            print("DEBUG: Zero total volume in VWAP calculation for \(pair) on \(exchange)")
            Task { @MainActor in
                logAlert(event: "Zero total volume in VWAP calculation for \(pair) on \(exchange)")
            }
            return nil
        }

        let vwap = totalPriceVolume / totalVolume
        print("DEBUG: Calculated VWAP for \(pair) on \(exchange): \(vwap)")
        return vwap
    }

    static func checkDailyLossLimit(exchange: String, pair: String, potentialLoss: Double) async -> Bool {
        let dailyLossLimit = getDouble("DAILY_LOSS_LIMIT", defaultValue: 100.0)
        let currentLoss = await MainActor.run { dailyLoss[exchange] ?? 0.0 }
        let newTotalLoss = currentLoss + potentialLoss
        let exceedsLimit = newTotalLoss > dailyLossLimit
        
        if exceedsLimit {
            print("DEBUG: Daily loss limit exceeded for \(exchange)-\(pair): Current \(currentLoss), Potential \(potentialLoss), Limit \(dailyLossLimit)")
            await MainActor.run {
                logAlert(event: "Daily loss limit exceeded for \(exchange)-\(pair): Current \(currentLoss), Potential \(potentialLoss)")
            }
        }
        return !exceedsLimit
    }
}
//---------------------------------------------------------------------------------------------------------Block 13 - Trade Performance and Logging

//---------------------------------------------------------------------------------------------------------Block 13 - Trade Performance and Logging

import Foundation
import SwiftUI

extension ExchangeWebSocket {
    @MainActor
    static func updateTradeMetrics(pair: String, profit: Double, fees: Double, isWin: Bool, dashboardJSONURL: URL, totalProfit: inout Double, totalFees: inout Double) {
        var metrics = tradeMetrics[pair] ?? (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)
        metrics.totalProfit += profit
        metrics.totalFees += fees
        if isWin {
            metrics.wins += 1
        } else {
            metrics.losses += 1
        }
        tradeMetrics[pair] = metrics

        var performance = performanceMetrics[pair] ?? (profit: 0.0, fees: 0.0, trades: 0, wins: 0)
        performance.profit += profit
        performance.fees += fees
        performance.trades += 1
        if isWin {
            performance.wins += 1
        }
        performanceMetrics[pair] = performance

        totalProfit += profit
        totalFees += fees

        do {
            let tradeMetricData = tradeMetrics.mapValues { metric in
                ["totalProfit": metric.totalProfit, "totalFees": metric.totalFees, "wins": metric.wins, "losses": metric.losses]
            }
            let performanceMetricData = performanceMetrics.mapValues { metric in
                ["profit": metric.profit, "fees": metric.fees, "trades": metric.trades, "wins": metric.wins]
            }
            let dashboardData: [String: Any] = [
                "tradeMetrics": tradeMetricData,
                "performanceMetrics": performanceMetricData,
                "totalProfit": totalProfit,
                "totalFees": totalFees
            ]
            let jsonData = try JSONSerialization.data(withJSONObject: dashboardData, options: [.prettyPrinted, .sortedKeys])
            try jsonData.write(to: dashboardJSONURL)
            print("Dashboard updated at \(dashboardJSONURL.path)")
        } catch {
            print("Dashboard update failed: \(error.localizedDescription)")
            logAlert(event: "Dashboard update failed: \(error.localizedDescription)")
        }
    }

    @MainActor
    static func logTradeToCSV(pair: String, strategy: String, profit: Double, fees: Double, tradesCSVURL: URL) {
        let timestampFormatter = ISO8601DateFormatter()
        timestampFormatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        let timestamp = timestampFormatter.string(from: Date())
        let logEntry = "\(pair),\(timestamp),\(strategy),\(profit),\(fees)\n"

        do {
            let fileManager = FileManager.default
            let directoryPath = tradesCSVURL.deletingLastPathComponent().path
            if !fileManager.fileExists(atPath: directoryPath) {
                try fileManager.createDirectory(atPath: directoryPath, withIntermediateDirectories: true, attributes: [.posixPermissions: 0o755])
                print("FILE DEBUG: Created directory for trades.csv at \(directoryPath)")
            }

            if !fileManager.fileExists(atPath: tradesCSVURL.path) {
                try "pair,timestamp,strategy,profit,fees\n".write(to: tradesCSVURL, atomically: true, encoding: .utf8)
                try fileManager.setAttributes([.posixPermissions: 0o644], ofItemAtPath: tradesCSVURL.path)
                print("FILE DEBUG: Created trades.csv with header")
            }

            if let fileHandle = try? FileHandle(forWritingTo: tradesCSVURL) {
                defer { fileHandle.closeFile() }
                if let data = logEntry.data(using: .utf8) {
                    fileHandle.seekToEndOfFile()
                    fileHandle.write(data)
                    print("FILE DEBUG: Wrote trade to trades.csv: \(logEntry.trimmingCharacters(in: .whitespacesAndNewlines))")
                } else {
                    throw NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Failed to convert trade log entry to data"])
                }
            } else {
                let existingContent = try String(contentsOf: tradesCSVURL, encoding: .utf8)
                let newContent = existingContent + logEntry
                try newContent.write(to: tradesCSVURL, atomically: true, encoding: .utf8)
                print("FILE DEBUG: Fallback write to trades.csv: \(logEntry.trimmingCharacters(in: .whitespacesAndNewlines))")
            }
        } catch {
            print("FILE WRITE FAILURE: Failed to write to trades.csv: \(error.localizedDescription)")
            logAlert(event: "TRADES_CSV_ERROR: \(error.localizedDescription)")
        }
    }

    static func saveHistoricalSpreadsToCSV(pair: String, spread: Double, predictedSpreadChange: Double) {
        guard !spread.isZero else {
            print("DEBUG: Zero spread prevented logging for \(pair)")
            logAlert(event: "Zero spread prevented logging for \(pair)")
            return
        }
        let timestamp = ISO8601DateFormatter().string(from: Date())
        let logEntry = "\(timestamp),\(pair),\(spread),\(predictedSpreadChange)\n"
        let spreadsCSVURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/historical_spreads.csv")

        do {
            let fileManager = FileManager.default
            let directoryPath = spreadsCSVURL.deletingLastPathComponent().path
            if !fileManager.fileExists(atPath: directoryPath) {
                try fileManager.createDirectory(atPath: directoryPath, withIntermediateDirectories: true, attributes: [.posixPermissions: 0o755])
                print("FILE DEBUG: Created directory for historical_spreads.csv at \(directoryPath)")
            }
            if !fileManager.fileExists(atPath: spreadsCSVURL.path) {
                try "timestamp,pair,spread,predicted_change\n".write(to: spreadsCSVURL, atomically: true, encoding: .utf8)
                try fileManager.setAttributes([.posixPermissions: 0o644], ofItemAtPath: spreadsCSVURL.path)
                print("FILE DEBUG: Created historical_spreads.csv with header")
            }
            if let fileHandle = try? FileHandle(forWritingTo: spreadsCSVURL) {
                defer { fileHandle.closeFile() }
                if let data = logEntry.data(using: .utf8) {
                    fileHandle.seekToEndOfFile()
                    fileHandle.write(data)
                    print("FILE DEBUG: Wrote spread to historical_spreads.csv: \(logEntry.trimmingCharacters(in: .whitespacesAndNewlines))")
                } else {
                    throw NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Failed to convert spread log entry to data"])
                }
            } else {
                let existingContent = try String(contentsOf: spreadsCSVURL, encoding: .utf8)
                let newContent = existingContent + logEntry
                try newContent.write(to: spreadsCSVURL, atomically: true, encoding: .utf8)
                print("FILE DEBUG: Fallback write to historical_spreads.csv: \(logEntry.trimmingCharacters(in: .whitespacesAndNewlines))")
            }
        } catch {
            print("FILE WRITE FAILURE: Failed to write to historical_spreads.csv: \(error.localizedDescription)")
            logAlert(event: "SPREAD_CSV_ERROR: \(error.localizedDescription)")
        }
    }

    static func handleKucoinPriceUpdate(pair: String, price: Double) {
        print("DEBUG: KuCoin Price Update - \(pair): \(price)")
        kucoinCurrentPrice[pair] = price
    }

    static func handleKucoinFuturesPriceUpdate(pair: String, price: Double) {
        print("DEBUG: KuCoin Futures Price Update - \(pair): \(price)")
        kucoinCurrentFuturesPrice[pair] = price
    }

    static func handleBybitPriceUpdate(pair: String, price: Double) {
        print("DEBUG: Bybit Price Update - \(pair): \(price)")
        bybitCurrentPrice[pair] = price
    }

    static func handleBybitFuturesPriceUpdate(pair: String, price: Double) {
        print("DEBUG: Bybit Futures Price Update - \(pair): \(price)")
        bybitCurrentFuturesPrice[pair] = price
    }

    static func executeSingleExchangeArbitrage(exchange: String, pair: String, spotPrice: Double, futuresPrice: Double, strategy: String, kucoinSpotPrices: [Double], bybitSpotPrices: [Double], tradeAmount: Double) {
        Task {
            let spread = abs(spotPrice - futuresPrice) / min(max(spotPrice, 0.0001), max(futuresPrice, 0.0001))
            let minSpreadThreshold = getDouble("ARBITRAGE_MIN_SPREAD_THRESHOLD", defaultValue: 0.001)
            saveHistoricalSpreadsToCSV(pair: pair, spread: spread, predictedSpreadChange: 0.0)

            print("""
TRADE CHECK: \(pair) (\(exchange))
Spread: \(spread) >= Threshold: \(minSpreadThreshold) -> \(spread >= minSpreadThreshold)
""")
            guard spread >= minSpreadThreshold else {
                print("DEBUG: Spread too low for \(exchange)-\(pair): \(spread)")
                logAlert(event: "Spread too low for \(exchange)-\(pair): \(spread)")
                return
            }

            let liquidity = await checkLiquidityAsync(exchange: exchange, pair: pair, marketType: "spot", tradeAmount: tradeAmount, price: spotPrice)
            let futuresLiquidity = await checkLiquidityAsync(exchange: exchange, pair: pair, marketType: "futures", tradeAmount: tradeAmount, price: futuresPrice)
            let minLiquidityThresholdValue = await MainActor.run { minLiquidityThreshold }
            print("TRADE CHECK: \(pair) Liquidity - Spot: \(liquidity ?? -1.0) >= \(minLiquidityThresholdValue), Futures: \(futuresLiquidity ?? -1.0) >= \(minLiquidityThresholdValue)")
            guard let liquidity = liquidity, let futuresLiquidity = futuresLiquidity,
                  liquidity >= minLiquidityThresholdValue, futuresLiquidity >= minLiquidityThresholdValue else {
                print("DEBUG: Invalid liquidity for \(exchange)-\(pair): Spot=\(String(describing: liquidity)), Futures=\(String(describing: futuresLiquidity))")
                logAlert(event: "Invalid liquidity for \(exchange)-\(pair): Spot=\(String(describing: liquidity)), Futures=\(String(describing: futuresLiquidity))")
                return
            }

            let fundingRate = await MainActor.run { exchange == "kucoin" ? kucoinFundingRates[pair] ?? 0.0 : bybitFundingRates[pair] ?? 0.0 }
            let maxFundingRateValue = await MainActor.run { maxFundingRate }
            print("TRADE CHECK: \(pair) Funding: \(abs(fundingRate)) < \(maxFundingRateValue) -> \(abs(fundingRate) < maxFundingRateValue)")
            guard abs(fundingRate) < maxFundingRateValue else {
                print("DEBUG: Funding rate too high for \(exchange)-\(pair): \(fundingRate)")
                logAlert(event: "Funding rate too high for \(exchange)-\(pair): \(fundingRate)")
                return
            }

            let balance = exchange == "kucoin" ? kucoinBalance : bybitBalance
            print("TRADE CHECK: \(pair) Balance: \(balance) >= \(tradeAmount * spotPrice) -> \(balance >= tradeAmount * spotPrice)")
            guard balance >= tradeAmount * spotPrice else {
                print("DEBUG: Insufficient balance for \(exchange)-\(pair)")
                logAlert(event: "Insufficient balance for \(exchange)-\(pair)")
                return
            }

            let feeRate = exchange == "kucoin" ? kucoinTakerFee : bybitTakerFee
            let fees = tradeAmount * feeRate * 2
            let grossProfit = tradeAmount * spread
            let profit = grossProfit - fees
            let minProfitPercentage = await MainActor.run { spotMinProfitPercentage }
            print("TRADE CHECK: \(pair) Profit: \(profit) > Min: \(minProfitPercentage * tradeAmount * min(spotPrice, futuresPrice))")
            guard profit > minProfitPercentage * tradeAmount * min(spotPrice, futuresPrice) else {
                print("DEBUG: Expected profit too low for \(exchange)-\(pair): \(profit)")
                logAlert(event: "Expected profit too low for \(exchange)-\(pair): \(profit)")
                return
            }

            let success = await executeScalpingTrade(
                pair: pair,
                exchange: exchange,
                entryPrice: spotPrice,
                targetPrice: futuresPrice,
                stopPrice: spotPrice * (1 - scalpStopLoss),
                tradeAmount: tradeAmount,
                maxActiveTrades: maxActiveSpotTrades
            )

            if success {
                print("ARBITRAGE TRIGGERED: \(exchange) \(pair) at \(Date())")
                await MainActor.run {
                    updateTradeMetrics(
                        pair: pair,
                        profit: profit,
                        fees: fees,
                        isWin: profit > 0,
                        dashboardJSONURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/dashboard.json"),
                        totalProfit: &ExchangeWebSocket.totalProfit,
                        totalFees: &ExchangeWebSocket.totalFees
                    )
                    logTradeToCSV(pair: pair, strategy: strategy, profit: profit, fees: fees, tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trade_log.csv"))
                    print("DEBUG: Executed single-exchange arbitrage for \(exchange)-\(pair): Profit=\(profit), Fees=\(fees)")
                    logAlert(event: "Executed single-exchange arbitrage for \(exchange)-\(pair): Profit=\(profit), Fees=\(fees)")
                }
            }
        }
    }

    static func executeEnhancedCrossExchangeArbitrage(pair: String, kucoinSpotPrice: Double, bybitSpotPrice: Double, strategy: String, kucoinSpotPrices: [Double], bybitSpotPrices: [Double], amount: Double, completion: @escaping (Bool) -> Void) {
        Task {
            let spread = abs(kucoinSpotPrice - bybitSpotPrice) / min(max(kucoinSpotPrice, 0.0001), max(bybitSpotPrice, 0.0001))
            let predictedSpread = await fetchSpreadPrediction(pair: pair, exchange: "cross", spotPrice: kucoinSpotPrice, futuresPrice: bybitSpotPrice) ?? 0.0
            saveHistoricalSpreadsToCSV(pair: pair, spread: spread, predictedSpreadChange: predictedSpread)

            let minSpreadThreshold = getDouble("ARBITRAGE_MIN_SPREAD_THRESHOLD", defaultValue: 0.001)
            print("""
TRADE CHECK: \(pair) (Cross-Exchange)
Spread: \(spread) >= Threshold: \(minSpreadThreshold) -> \(spread >= minSpreadThreshold)
""")
            guard spread >= minSpreadThreshold else {
                print("DEBUG: Spread too low for cross-exchange arbitrage: \(pair), Spread=\(spread)")
                logAlert(event: "Spread too low for cross-exchange arbitrage: \(pair), Spread=\(spread)")
                completion(false)
                return
            }

            let kucoinLiquidity = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "spot", tradeAmount: amount, price: kucoinSpotPrice)
            let bybitLiquidity = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "spot", tradeAmount: amount, price: bybitSpotPrice)
            let minLiquidityThresholdValue = await MainActor.run { minLiquidityThreshold }
            print("TRADE CHECK: \(pair) Liquidity - KuCoin: \(kucoinLiquidity ?? -1.0) >= \(minLiquidityThresholdValue), Bybit: \(bybitLiquidity ?? -1.0) >= \(minLiquidityThresholdValue)")
            guard let kucoinLiquidity = kucoinLiquidity, let bybitLiquidity = bybitLiquidity,
                  kucoinLiquidity >= minLiquidityThresholdValue, bybitLiquidity >= minLiquidityThresholdValue else {
                print("DEBUG: Insufficient liquidity for cross-exchange arbitrage: \(pair)")
                logAlert(event: "Insufficient liquidity for cross-exchange arbitrage: \(pair)")
                completion(false)
                return
            }

            let feeRate = kucoinTakerFee + bybitTakerFee
            let fees = amount * feeRate * 2
            let grossProfit = amount * spread
            let profit = grossProfit - fees
            let minProfitPercentage = await MainActor.run { spotMinProfitPercentage }
            print("TRADE CHECK: \(pair) Profit: \(profit) > Min: \(minProfitPercentage * amount * min(kucoinSpotPrice, bybitSpotPrice))")
            guard profit > minProfitPercentage * amount * min(kucoinSpotPrice, bybitSpotPrice) else {
                print("DEBUG: Expected profit too low for cross-exchange arbitrage: \(pair), Profit=\(profit)")
                logAlert(event: "Expected profit too low for cross-exchange arbitrage: \(pair), Profit=\(profit)")
                completion(false)
                return
            }

            let success = await executeScalpingTrade(
                pair: pair,
                exchange: kucoinSpotPrice < bybitSpotPrice ? "kucoin" : "bybit",
                entryPrice: min(kucoinSpotPrice, bybitSpotPrice),
                targetPrice: max(kucoinSpotPrice, bybitSpotPrice),
                stopPrice: min(kucoinSpotPrice, bybitSpotPrice) * (1 - scalpStopLoss),
                tradeAmount: amount,
                maxActiveTrades: maxActiveSpotTrades
            )

            if success {
                print("ARBITRAGE TRIGGERED: Cross-Exchange \(pair) at \(Date())")
                await MainActor.run {
                    if kucoinSpotPrice < bybitSpotPrice {
                        kucoinBalance += profit - fees
                        bybitBalance -= amount * bybitTakerFee
                    } else {
                        bybitBalance += profit - fees
                        kucoinBalance -= amount * kucoinTakerFee
                    }
                    updateTradeMetrics(
                        pair: pair,
                        profit: profit,
                        fees: fees,
                        isWin: profit > 0,
                        dashboardJSONURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/dashboard.json"),
                        totalProfit: &ExchangeWebSocket.totalProfit,
                        totalFees: &ExchangeWebSocket.totalFees
                    )
                    logTradeToCSV(pair: pair, strategy: strategy, profit: profit, fees: fees, tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trade_log.csv"))
                    print("DEBUG: Executed cross-exchange arbitrage for \(pair): Profit=\(profit), Fees=\(fees)")
                    logAlert(event: "Executed cross-exchange arbitrage for \(pair): Profit=\(profit), Fees=\(fees)")
                    completion(true)
                }
            } else {
                completion(false)
            }
        }
    }

    static func startTrading() {
        print("Starting Trading Bot...")
        initializeParameters {
            connectKucoin()
            connectKucoinFutures()
            connectBybit()
            print("Initializing balances...")
            fetchAndLogBalances(isInitial: true) {
                Task { @MainActor in
                    print("Starting timers...")
                    print("Trading Bot Running...")
                    
                    let dashboardJSONURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/dashboard.json")
                    let tradesCSVURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trade_log.csv")
                    
                    Timer.scheduledTimer(withTimeInterval: 60, repeats: true) { _ in
                        Task { @MainActor in
                            fetchAndLogBalances(isInitial: false) {
                                Task { @MainActor in
                                    rebalanceExchanges()
                                }
                            }
                        }
                    }
                    
                    Timer.scheduledTimer(withTimeInterval: 3600, repeats: true) { timer in
                        let queue = DispatchQueue(label: "com.bevaixbot.feeUpdate")
                        queue.async {
                            let group = DispatchGroup()
                            group.enter()
                            Task { @MainActor in
                                fetchExchangeFees(exchange: "kucoin") { maker, taker in
                                    DispatchQueue.main.async {
                                        if let maker, let taker {
                                            kucoinMakerFee = maker
                                            kucoinTakerFee = taker
                                            lastFeeUpdate = Date()
                                        }
                                        group.leave()
                                    }
                                }
                            }
                            group.enter()
                            Task { @MainActor in
                                fetchExchangeFees(exchange: "bybit") { maker, taker in
                                    DispatchQueue.main.async {
                                        if let maker, let taker {
                                            bybitMakerFee = maker
                                            bybitTakerFee = taker
                                            lastFeeUpdate = Date()
                                        }
                                        group.leave()
                                    }
                                }
                            }
                            group.notify(queue: .main) {
                            }
                        }
                    }
                    
                    Timer.scheduledTimer(withTimeInterval: Double(await MainActor.run { liquidityCheckInterval }), repeats: true) { _ in
                        Task { @MainActor in
                            for pair in tradingPairs {
                                Task {
                                    let kucoinFuturesPrice = kucoinCurrentFuturesPrice[pair] ?? 0.0
                                    let bybitFuturesPrice = bybitCurrentFuturesPrice[pair] ?? 0.0
                                    let kucoinSpotPrice = kucoinCurrentPrice[pair] ?? 0.0
                                    let kucoinSpotLiquidity = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "spot", tradeAmount: spotTradeAmount, price: kucoinSpotPrice)
                                    let kucoinFuturesLiquidity = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "futures", tradeAmount: futuresTradeAmount, price: kucoinFuturesPrice)
                                    let bybitSpotLiquidity = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "spot", tradeAmount: spotTradeAmount, price: kucoinSpotPrice)
                                    let bybitFuturesLiquidity = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "futures", tradeAmount: futuresTradeAmount, price: bybitFuturesPrice)
                                    print("LIQUIDITY DEBUG: \(pair) - KuCoin Spot: \(kucoinSpotLiquidity ?? -1.0), KuCoin Futures: \(kucoinFuturesLiquidity ?? -1.0), Bybit Spot: \(bybitSpotLiquidity ?? -1.0), Bybit Futures: \(bybitFuturesLiquidity ?? -1.0)")
                                }
                            }
                        }
                    }
                    
                    Timer.scheduledTimer(withTimeInterval: 2, repeats: true) { _ in
                        Task { @MainActor in
                            let tradeCooldown = getDouble("TRADE_EXECUTION_COOLDOWN_SECONDS", defaultValue: 0.5)
                            let _ = 0.0001 // Line 4427: Suppress warning for debugThreshold
                            let _ = -100.0 // Line 4428: Suppress warning for debugMACDThreshold
                            do {
                                try await Task.sleep(nanoseconds: UInt64(tradeCooldown * 1_000_000_000))
                            } catch {
                                print("Trade execution sleep interrupted: \(error.localizedDescription)")
                                logAlert(event: "Trade execution sleep interrupted: \(error.localizedDescription)")
                            }
                            
                            print("DEBUG: Trading pairs: \(tradingPairs)")
                            for pair in tradingPairs {
                                if ExchangeWebSocket.detectVolatilitySpike(exchange: "kucoin", pair: pair) || ExchangeWebSocket.detectVolatilitySpike(exchange: "bybit", pair: pair) {
                                    print("Volatility spike detected for pair: \(pair)")
                                    logAlert(event: "Volatility spike detected for pair: \(pair)")
                                    continue
                                }
                                checkCircuitBreaker(pair: pair)
                                let kucoinSpotPrice = kucoinCurrentPrice[pair] ?? 0.0
                                let kucoinFuturesPrice = kucoinCurrentFuturesPrice[pair] ?? 0.0
                                let bybitSpotPrice = bybitCurrentPrice[pair] ?? 0.0
                                let bybitFuturesPrice = bybitCurrentFuturesPrice[pair] ?? 0.0
                                print("""
LIVE PRICE DEBUG: \(pair)
KC Spot: \(kucoinSpotPrice)
KC Futures: \(kucoinFuturesPrice)
BB Spot: \(bybitSpotPrice)
BB Futures: \(bybitFuturesPrice)
""")
                                
                                let kucoinSpotLiquidity = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "spot", tradeAmount: spotTradeAmount, price: kucoinSpotPrice)
                                let kucoinFuturesLiquidity = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "futures", tradeAmount: futuresTradeAmount, price: kucoinFuturesPrice)
                                let bybitSpotLiquidity = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "spot", tradeAmount: spotTradeAmount, price: bybitSpotPrice)
                                let bybitFuturesLiquidity = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "futures", tradeAmount: futuresTradeAmount, price: bybitFuturesPrice)
                                print("LIQUIDITY DEBUG: \(pair) - KuCoin Spot: \(kucoinSpotLiquidity ?? -1.0), KuCoin Futures: \(kucoinFuturesLiquidity ?? -1.0), Bybit Spot: \(bybitSpotLiquidity ?? -1.0), Bybit Futures: \(bybitFuturesLiquidity ?? -1.0)")
                                
                                print("Executing Trading Strategies...")
                                print("Checking Arbitrage profitability...")
                                
                                print("Live Prices:")
                                for pair in tradingPairs {
                                    let kucoinSpotPrice = kucoinCurrentPrice[pair] ?? 0.0
                                    let kucoinFuturesPrice = kucoinCurrentFuturesPrice[pair] ?? 0.0
                                    let bybitSpotPrice = bybitCurrentPrice[pair] ?? 0.0
                                    let bybitFuturesPrice = bybitCurrentFuturesPrice[pair] ?? 0.0
                                    print("\(pair) | KC: \(String(format: "%.4f", kucoinSpotPrice)) | KC-F: \(String(format: "%.4f", kucoinFuturesPrice)) | BB: \(String(format: "%.4f", bybitSpotPrice)) | BB-F: \(String(format: "%.4f", bybitFuturesPrice))")
                                }
                                
                                var tradeExecuted = false
                                
                                for pair in tradingPairs {
                                    let kucoinOrderBook = kucoinFuturesOrderBook[pair] ?? []
                                    let bybitOrderBook = bybitFuturesOrderBook[pair] ?? []

                                    let kucoinSpotPrice = kucoinCurrentPrice[pair] ?? 0.0
                                    let kucoinFuturesPrice = kucoinCurrentFuturesPrice[pair] ?? 0.0
                                    let bybitSpotPrice = bybitCurrentPrice[pair] ?? 0.0
                                    let bybitFuturesPrice = bybitCurrentFuturesPrice[pair] ?? 0.0

                                    let kucoinSpotPrices = ExchangeWebSocket.kucoinPrices[pair] ?? []
                                    let kucoinFuturesPrices = kucoinFuturesPrices[pair] ?? []
                                    let bybitSpotPrices = ExchangeWebSocket.bybitPrices[pair] ?? []
                                    let bybitFuturesPrices = bybitFuturesPrices[pair] ?? []

                                    let kucoinSpotEmaShort = ExchangeWebSocket.calculateEMA(prices: kucoinSpotPrices, period: spotEmaShortPeriod) ?? 0.0
                                    let kucoinSpotEmaLong = ExchangeWebSocket.calculateEMA(prices: kucoinSpotPrices, period: spotEmaLongPeriod) ?? 0.0
                                    let kucoinFuturesEmaShort = ExchangeWebSocket.calculateEMA(prices: kucoinFuturesPrices, period: futuresEmaShortPeriod) ?? 0.0
                                    let kucoinFuturesEmaLong = ExchangeWebSocket.calculateEMA(prices: kucoinFuturesPrices, period: futuresEmaLongPeriod) ?? 0.0
                                    let bybitSpotEmaShort = ExchangeWebSocket.calculateEMA(prices: bybitSpotPrices, period: spotEmaShortPeriod) ?? 0.0
                                    let bybitSpotEmaLong = ExchangeWebSocket.calculateEMA(prices: bybitSpotPrices, period: spotEmaLongPeriod) ?? 0.0
                                    let _ = ExchangeWebSocket.calculateEMA(prices: bybitFuturesPrices, period: futuresEmaShortPeriod) ?? 0.0 // Line 4496
                                    let _ = ExchangeWebSocket.calculateEMA(prices: bybitFuturesPrices, period: futuresEmaLongPeriod) ?? 0.0 // Line 4497

                                    let kucoinSpotMacd = ExchangeWebSocket.calculateMACD(prices: kucoinSpotPrices, shortPeriod: macdShortPeriod, longPeriod: macdLongPeriod, signalPeriod: macdSignalPeriod)
                                    let kucoinFuturesMacd = ExchangeWebSocket.calculateMACD(prices: kucoinFuturesPrices, shortPeriod: macdShortPeriod, longPeriod: macdLongPeriod, signalPeriod: macdSignalPeriod)
                                    let bybitSpotMacd = ExchangeWebSocket.calculateMACD(prices: bybitSpotPrices, shortPeriod: macdShortPeriod, longPeriod: macdLongPeriod, signalPeriod: macdSignalPeriod)
                                    let bybitFuturesMacd = ExchangeWebSocket.calculateMACD(prices: bybitFuturesPrices, shortPeriod: macdShortPeriod, longPeriod: macdLongPeriod, signalPeriod: macdSignalPeriod)

                                    let kucoinSpotRsi = ExchangeWebSocket.calculateRSI(prices: kucoinSpotPrices, period: spotRsiPeriod) ?? 50.0
                                    let bybitSpotRsi = ExchangeWebSocket.calculateRSI(prices: bybitSpotPrices, period: spotRsiPeriod) ?? 50.0
                                    print("DEBUG: RSI for \(pair) - KuCoin Spot: \(kucoinSpotRsi), Bybit Spot: \(bybitSpotRsi)")

                                    let kucoinSpotATR = ExchangeWebSocket.calculateATR(prices: kucoinSpotPrices) ?? 0.0
                                    let bybitSpotATR = ExchangeWebSocket.calculateATR(prices: bybitSpotPrices) ?? 0.0
                                    let volatility = max(kucoinSpotATR, bybitSpotATR) / max(kucoinSpotPrice, bybitSpotPrice, 1.0)

                                    let kucoinArbitrageTradeAmount = await Task { await dynamicTradeAmount(balance: kucoinBalance, riskPercent: 0.3, volatility: volatility) }.value
                                    let bybitArbitrageTradeAmount = await Task { await dynamicTradeAmount(balance: bybitBalance, riskPercent: 0.3, volatility: volatility) }.value
                                    let crossExchangeTradeAmount = await Task { await dynamicTradeAmount(balance: min(kucoinBalance, bybitBalance), riskPercent: 0.1, volatility: 0.5) }.value

                                    let kucoinPriceChange = kucoinSpotPrices.count >= 1800 ? (kucoinSpotPrice - kucoinSpotPrices[kucoinSpotPrices.count - 1800]) / kucoinSpotPrices[kucoinSpotPrices.count - 1800] : 0.0

                                    let kucoinOrderBookStruct = kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
                                    let volumeSpikeThreshold = getDouble("VOLUME_SPIKE_THRESHOLD", defaultValue: 1.5)
                                    let orderImbalanceThreshold = getDouble("ORDER_IMBALANCE_THRESHOLD", defaultValue: 1.5)
                                    let vwapPeriod = getInt("VWAP_PERIOD", defaultValue: 60)
                                    print("DEBUG: VWAP period for \(pair): \(vwapPeriod)")
                                    let volumes = kucoinSpotVolume[pair] ?? []
                                    let avgVolume = volumes.isEmpty ? 0.0 : volumes.reduce(0.0, +) / Double(volumes.count)
                                    let currentVolume = volumes.last ?? 0.0
                                    let volumeSpike = avgVolume > 0 ? currentVolume / avgVolume : 1.0
                                    let orderImbalance = calculateOrderBookImbalance(book: kucoinOrderBookStruct)
                                    let vwap = calculateOrderBookVWAP(pair: pair, exchange: "kucoin", priceRange: orderBookPriceRange, currentPrice: kucoinSpotPrice) ?? kucoinSpotPrice

                                    marketMaker(pair: pair, exchange: "kucoin")
                                    marketMaker(pair: pair, exchange: "bybit")

                                    if kucoinSpotPrice > 0 || kucoinFuturesPrice > 0 {
                                        let currentSpread = abs(kucoinSpotPrice - kucoinFuturesPrice) / min(max(kucoinSpotPrice, 0.0001), max(kucoinFuturesPrice, 0.0001))
                                        let predictedSpread = await fetchSpreadPrediction(pair: pair, exchange: "kucoin", spotPrice: kucoinSpotPrice, futuresPrice: kucoinFuturesPrice) ?? 0.0
                                        saveHistoricalSpreadsToCSV(pair: pair, spread: currentSpread, predictedSpreadChange: predictedSpread)
                                        let shouldTradeKucoin = predictedSpread > currentSpread && kucoinFuturesMacd != nil && kucoinFuturesMacd!.histogram > -100.0 && kucoinFuturesEmaShort > kucoinFuturesEmaLong && kucoinSpotRsi > 30 && kucoinSpotRsi < 70 && abs(kucoinSpotPrice - vwap) / kucoinSpotPrice < 0.01
                                        let macdConfirmed = kucoinSpotMacd != nil && kucoinSpotMacd!.histogram > -100.0
                                        let feeAdjustedThreshold = 0.0001
                                        let emaConfirmed = kucoinSpotPrice < kucoinFuturesPrice
                                            ? (kucoinSpotEmaShort > kucoinSpotEmaLong && (kucoinSpotEmaShort - kucoinSpotEmaLong) / kucoinSpotEmaLong > 0.0026)
                                            : (kucoinSpotEmaShort < kucoinSpotEmaLong && (kucoinSpotEmaLong - kucoinSpotEmaShort) / kucoinSpotEmaLong > 0.0026)
                                        let trendConfirmed = kucoinPriceChange > 0.001 && kucoinSpotEmaShort > kucoinSpotEmaLong || kucoinPriceChange < -0.001 && kucoinSpotEmaShort < kucoinSpotEmaLong
                                        let sentimentConfirmed = sentimentScores[pair] ?? 0.0 > 0.5
                                        let volumeConfirmed = volumeSpike >= volumeSpikeThreshold
                                        // FIX: Check if orderBook has data before checking isEmpty
                                        let imbalanceConfirmed = orderImbalance < orderImbalanceThreshold

                                        print("KuCoin Spot-to-Futures for \(pair): Spread: \(currentSpread), Threshold: \(feeAdjustedThreshold), ML: \(shouldTradeKucoin), MACD: \(macdConfirmed), EMA: \(emaConfirmed), Trend: \(trendConfirmed), Sentiment: \(sentimentConfirmed), Volume: \(volumeConfirmed), Imbalance: \(imbalanceConfirmed)")

                                        if (shouldTradeKucoin || currentSpread >= feeAdjustedThreshold) && !kucoinOrderBook.isEmpty && emaConfirmed && trendConfirmed && sentimentConfirmed && volumeConfirmed && imbalanceConfirmed {
                                            if let lastArbitrage = arbitrageExecuted[pair], lastArbitrage.0 && Date().timeIntervalSince(lastArbitrage.1) < tradeCooldown {
                                                print("KuCoin Spot-to-Futures for \(pair): Skipped (Cooldown)")
                                                logAlert(event: "KuCoin Spot-to-Futures for \(pair): Skipped (Cooldown)")
                                            } else {
                                                let potentialLoss = kucoinArbitrageTradeAmount * kucoinSpotPrice * stopLossPercentage
                                                if !(await ExchangeWebSocket.checkDailyLossLimit(exchange: "kucoin", pair: pair, potentialLoss: potentialLoss)) {
                                                    print("Initiating KuCoin Spot-to-Futures Arbitrage for \(pair): Amount: \(kucoinArbitrageTradeAmount)")
                                                    executeSingleExchangeArbitrage(exchange: "kucoin", pair: pair, spotPrice: kucoinSpotPrice, futuresPrice: kucoinFuturesPrice, strategy: "Spot-to-Futures", kucoinSpotPrices: kucoinSpotPrices, bybitSpotPrices: [], tradeAmount: kucoinArbitrageTradeAmount)
                                                    let spread = abs(kucoinSpotPrice - kucoinFuturesPrice)
                                                    let grossProfit = kucoinArbitrageTradeAmount * spread
                                                    let fees = kucoinArbitrageTradeAmount * (kucoinTakerFee + kucoinMakerFee) * 2
                                                    let profit = grossProfit - fees
                                                    tradeExecuted = true
                                                    arbitrageExecuted[pair] = (true, Date())
                                                    await MainActor.run {
                                                        updateTradeMetrics(
                                                            pair: pair,
                                                            profit: profit,
                                                            fees: fees,
                                                            isWin: profit > 0,
                                                            dashboardJSONURL: dashboardJSONURL,
                                                            totalProfit: &ExchangeWebSocket.totalProfit,
                                                            totalFees: &ExchangeWebSocket.totalFees
                                                        )
                                                        logTradeToCSV(pair: pair, strategy: "Spot-to-Futures", profit: profit, fees: fees, tradesCSVURL: tradesCSVURL)
                                                    }
                                                } else {
                                                    print("KuCoin Spot-to-Futures for \(pair): Skipped (Daily loss limit)")
                                                    logAlert(event: "KuCoin Spot-to-Futures for \(pair): Skipped (Daily loss limit)")
                                                }
                                            }
                                        }
                                    }

                                    if bybitSpotPrice > 0 || bybitFuturesPrice > 0 {
                                        let currentSpread = abs(bybitSpotPrice - bybitFuturesPrice) / min(max(bybitSpotPrice, 0.0001), max(bybitFuturesPrice, 0.0001))
                                        let predictedSpread = await fetchSpreadPrediction(pair: pair, exchange: "bybit", spotPrice: bybitSpotPrice, futuresPrice: bybitFuturesPrice) ?? 0.0
                                        saveHistoricalSpreadsToCSV(pair: pair, spread: currentSpread, predictedSpreadChange: predictedSpread)
                                        let shouldTradeBybit = predictedSpread > currentSpread && bybitFuturesMacd != nil && bybitFuturesMacd!.histogram > -100.0
                                        let macdConfirmed = bybitSpotMacd != nil && bybitSpotMacd!.histogram > -100.0
                                        let feeAdjustedThreshold = 0.0001
                                        let emaConfirmed = bybitSpotPrice < bybitFuturesPrice
                                            ? (bybitSpotEmaShort > bybitSpotEmaLong && (bybitSpotEmaShort - bybitSpotEmaLong) / bybitSpotEmaLong > 0.0016)
                                            : (bybitSpotEmaShort < bybitSpotEmaLong && (bybitSpotEmaLong - bybitSpotEmaShort) / bybitSpotEmaLong > 0.0016)
                                        let trendConfirmed = kucoinPriceChange > 0.0016 && kucoinSpotEmaShort > kucoinSpotEmaLong || kucoinPriceChange < -0.0016 && kucoinSpotEmaShort < kucoinSpotEmaLong
                                        let sentimentConfirmed = sentimentScores[pair] ?? 0.0 > 0.5
                                        let volumeConfirmed = volumeSpike >= volumeSpikeThreshold
                                        let imbalanceConfirmed = orderImbalance < orderImbalanceThreshold

                                        print("Bybit Spot-to-Futures for \(pair): Spread: \(currentSpread), Threshold: \(feeAdjustedThreshold), ML: \(shouldTradeBybit), MACD: \(macdConfirmed), EMA: \(emaConfirmed), Trend: \(trendConfirmed), Sentiment: \(sentimentConfirmed), Volume: \(volumeConfirmed), Imbalance: \(imbalanceConfirmed)")

                                        if (shouldTradeBybit || currentSpread >= feeAdjustedThreshold) && !bybitOrderBook.isEmpty && emaConfirmed && macdConfirmed && trendConfirmed && sentimentConfirmed && volumeConfirmed && imbalanceConfirmed {
                                            if let lastArbitrage = arbitrageExecuted[pair], lastArbitrage.0 && Date().timeIntervalSince(lastArbitrage.1) < tradeCooldown {
                                                print("Bybit Spot-to-Futures for \(pair): Skipped (Cooldown)")
                                                logAlert(event: "Bybit Spot-to-Futures for \(pair): Skipped (Cooldown)")
                                            } else {
                                                let potentialLoss = bybitArbitrageTradeAmount * bybitSpotPrice * stopLossPercentage
                                                if !(await ExchangeWebSocket.checkDailyLossLimit(exchange: "bybit", pair: pair, potentialLoss: potentialLoss)) {
                                                    print("Initiating Bybit Spot-to-Futures Arbitrage for \(pair): Amount: \(bybitArbitrageTradeAmount)")
                                                    executeSingleExchangeArbitrage(
                                                        exchange: "bybit",
                                                        pair: pair,
                                                        spotPrice: bybitSpotPrice,
                                                        futuresPrice: bybitFuturesPrice,
                                                        strategy: "Spot-to-Futures",
                                                        kucoinSpotPrices: [],
                                                        bybitSpotPrices: bybitSpotPrices,
                                                        tradeAmount: bybitArbitrageTradeAmount
                                                    )
                                                    let spread = abs(bybitSpotPrice - bybitFuturesPrice)
                                                    let grossProfit = bybitArbitrageTradeAmount * spread
                                                    let fees = bybitArbitrageTradeAmount * (bybitTakerFee + bybitMakerFee) * 2
                                                    let profit = grossProfit - fees
                                                    tradeExecuted = true
                                                    arbitrageExecuted[pair] = (true, Date())
                                                    await MainActor.run {
                                                        updateTradeMetrics(
                                                            pair: pair,
                                                            profit: profit,
                                                            fees: fees,
                                                            isWin: profit > 0,
                                                            dashboardJSONURL: dashboardJSONURL,
                                                            totalProfit: &ExchangeWebSocket.totalProfit,
                                                            totalFees: &ExchangeWebSocket.totalFees
                                                        )
                                                        logTradeToCSV(pair: pair, strategy: "Spot-to-Futures", profit: profit, fees: fees, tradesCSVURL: tradesCSVURL)
                                                    }
                                                } else {
                                                    print("Bybit Spot-to-Futures for \(pair): Skipped (Daily loss limit)")
                                                    logAlert(event: "Bybit Spot-to-Futures for \(pair): Skipped (Daily loss limit)")
                                                }
                                            }
                                        }
                                    }

                                    if kucoinSpotPrice > 0 || bybitSpotPrice > 0 {
                                        let currentSpread = abs(kucoinSpotPrice - bybitSpotPrice) / min(max(kucoinSpotPrice, 0.0001), max(bybitSpotPrice, 0.0001))
                                        let predictedSpread = await fetchSpreadPrediction(pair: pair, exchange: "cross", spotPrice: kucoinSpotPrice, futuresPrice: bybitSpotPrice) ?? 0.0
                                        saveHistoricalSpreadsToCSV(pair: pair, spread: currentSpread, predictedSpreadChange: predictedSpread)
                                        let shouldTradeCross = predictedSpread > currentSpread && kucoinSpotRsi > 30 && kucoinSpotRsi < 70
                                        let macdConfirmed = kucoinSpotMacd != nil && bybitSpotMacd != nil && kucoinSpotMacd!.histogram > -100.0 && bybitSpotMacd!.histogram > -100.0
                                        let feeAdjustedThreshold = 0.0001
                                        let emaConfirmed = kucoinSpotPrice < bybitSpotPrice
                                            ? (kucoinSpotEmaShort > kucoinSpotEmaLong && (kucoinSpotEmaShort - kucoinSpotEmaLong) / kucoinSpotEmaLong > 0.0016 && bybitSpotEmaShort < bybitSpotEmaLong && (bybitSpotEmaLong - bybitSpotEmaShort) / bybitSpotEmaLong > 0.0016)
                                            : (kucoinSpotEmaShort < kucoinSpotEmaLong && (kucoinSpotEmaLong - kucoinSpotEmaShort) / kucoinSpotEmaLong > 0.0016 && bybitSpotEmaShort > bybitSpotEmaLong && (bybitSpotEmaShort - bybitSpotEmaLong) / bybitSpotEmaLong > 0.0016)
                                        let trendConfirmed = kucoinPriceChange > 0.0016 && kucoinSpotEmaShort > kucoinSpotEmaLong || kucoinPriceChange < -0.0016 && kucoinSpotEmaShort < kucoinSpotEmaLong
                                        let sentimentConfirmed = sentimentScores[pair] ?? 0.0 > 0.5
                                        let volumeConfirmed = volumeSpike >= volumeSpikeThreshold
                                        let imbalanceConfirmed = orderImbalance < orderImbalanceThreshold

                                        print("Cross-Exchange Spot for \(pair): Spread: \(currentSpread), Threshold: \(feeAdjustedThreshold), ML: \(shouldTradeCross), MACD: \(macdConfirmed), EMA: \(emaConfirmed), Trend: \(trendConfirmed), Sentiment: \(sentimentConfirmed), Volume: \(volumeConfirmed), Imbalance: \(imbalanceConfirmed)")

                                        // FIX: Check if both order books have data
                                        if (shouldTradeCross || currentSpread >= feeAdjustedThreshold) && !kucoinOrderBookStruct.bids.isEmpty && !kucoinOrderBookStruct.asks.isEmpty && !bybitOrderBook.isEmpty && emaConfirmed && macdConfirmed && trendConfirmed && sentimentConfirmed && volumeConfirmed && imbalanceConfirmed {
                                            if let lastCrossArbitrage = crossExchangeArbitrageExecuted[pair], lastCrossArbitrage.0 && Date().timeIntervalSince(lastCrossArbitrage.1) < tradeCooldown {
                                                print("Cross-Exchange Spot for \(pair): Skipped (Cooldown)")
                                                logAlert(event: "Cross-Exchange Spot for \(pair): Skipped (Cooldown)")
                                            } else {
                                                let potentialLoss = crossExchangeTradeAmount * kucoinSpotPrice * stopLossPercentage
                                                let kucoinLossLimitOk = !(await ExchangeWebSocket.checkDailyLossLimit(exchange: "kucoin", pair: pair, potentialLoss: potentialLoss))
                                                let bybitLossLimitOk = !(await ExchangeWebSocket.checkDailyLossLimit(exchange: "bybit", pair: pair, potentialLoss: potentialLoss))
                                                if kucoinLossLimitOk && bybitLossLimitOk {
                                                    print("Initiating Cross-Exchange for \(pair): Amount: \(crossExchangeTradeAmount)")
                                                    executeEnhancedCrossExchangeArbitrage(
                                                        pair: pair,
                                                        kucoinSpotPrice: kucoinSpotPrice,
                                                        bybitSpotPrice: bybitSpotPrice,
                                                        strategy: "Cross-Exchange",
                                                        kucoinSpotPrices: kucoinSpotPrices,
                                                        bybitSpotPrices: bybitSpotPrices,
                                                        amount: crossExchangeTradeAmount,
                                                        completion: { success in
                                                            if success {
                                                                let spread = abs(kucoinSpotPrice - bybitSpotPrice)
                                                                let grossProfit = crossExchangeTradeAmount * spread
                                                                let fees = crossExchangeTradeAmount * (kucoinTakerFee + bybitTakerFee) * 2
                                                                let profit = grossProfit - fees
                                                                tradeExecuted = true
                                                                crossExchangeArbitrageExecuted[pair] = (true, Date())
                                                                Task { @MainActor in
                                                                    updateTradeMetrics(
                                                                        pair: pair,
                                                                        profit: profit,
                                                                        fees: fees,
                                                                        isWin: profit > 0,
                                                                        dashboardJSONURL: dashboardJSONURL,
                                                                        totalProfit: &ExchangeWebSocket.totalProfit,
                                                                        totalFees: &ExchangeWebSocket.totalFees
                                                                    )
                                                                    logTradeToCSV(pair: pair, strategy: "Cross-Exchange", profit: profit, fees: fees, tradesCSVURL: tradesCSVURL)
                                                                }
                                                            }
                                                        }
                                                    )
                                                } else {
                                                    print("Cross-Exchange Spot for \(pair): Skipped (Daily loss limit)")
                                                    logAlert(event: "Cross-Exchange Spot for \(pair): Skipped (Daily loss limit)")
                                                }
                                            }
                                        }
                                    }
                                }
                                
                                if !tradeExecuted {
                                    print("DEBUG: No trade executed in this cycle for \(pair)")
                                    logAlert(event: "No trade executed in this cycle for \(pair)")
                                }
                                
                                updateDashboardJSON(dashboardJSONURL: dashboardJSONURL, totalProfit: ExchangeWebSocket.totalProfit, totalFees: ExchangeWebSocket.totalFees)
                                printPeriodicSummary()
                            }
                        }
                    }
                }
            }
        }
    }
}



//------------------------------------------------------------------------------------------------------Block 14 - Core Trading Loop Execution

//---------------------------------------------------------------------------------------------------------------------Block 14 - Core Trading Loop Execution - FIXED

import Foundation

extension ExchangeWebSocket {
    static func startTradingLoop() {
        Task { @MainActor in
            ExchangeWebSocket.connectKucoin()
            ExchangeWebSocket.connectBybit()
            await ExchangeWebSocket.startOrderBookPolling()
            
            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                ExchangeWebSocket.monitorHFTScalpingOpportunities()
                ExchangeWebSocket.startMainTradingLoop() // ENHANCED: Start comprehensive trading loop
                print("‚úÖ TRADING ACTIVE")
            }
        }
    }

    // ENHANCED: Complete executeTrade method with all original functionality preserved
    static func executeTrade(exchange: String, pair: String, side: String, price: Double, amount: Double, strategy: String) async -> Bool {
        guard await checkDailyLossLimit(exchange: exchange, pair: pair, potentialLoss: amount * price * getDouble("STOP_LOSS_PERCENTAGE", defaultValue: 0.02)) else {
            print("DEBUG: Trade skipped for \(exchange)-\(pair): Daily loss limit exceeded")
            return false
        }

        guard let _ = await checkLiquidityAsyncUnique(exchange: exchange, pair: pair, marketType: "spot", tradeAmount: amount, price: price) else {
            print("DEBUG: Trade skipped for \(exchange)-\(pair): Insufficient liquidity")
            return false
        }

        let volatility = await calculateVolatility(pair: pair, exchange: exchange)
        let tradeAmount = await dynamicTradeAmount(balance: exchange == "kucoin" ? kucoinBalance : bybitBalance, riskPercent: getDouble("RISK_PERCENTAGE", defaultValue: 0.01), volatility: volatility, pair: pair)

        guard tradeAmount > 0 else {
            print("DEBUG: Trade skipped for \(exchange)-\(pair): Invalid trade amount (\(tradeAmount))")
            return false
        }

        let adjustedAmount = min(amount, tradeAmount)
        ExchangeWebSocket.executeHFTTrade(exchange: exchange, pair: pair, side: side, price: price, amount: adjustedAmount)

        let profit = side == "buy" ? -adjustedAmount * price : adjustedAmount * price
        let fees = adjustedAmount * price * (exchange == "kucoin" ? kucoinTakerFee : bybitTakerFee)
        let netProfit = profit - fees

        await MainActor.run {
            updateTradeMetrics(
                pair: pair,
                profit: netProfit,
                fees: fees,
                isWin: netProfit > 0,
                dashboardJSONURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/dashboard.json"),
                totalProfit: &ExchangeWebSocket.totalProfit,
                totalFees: &ExchangeWebSocket.totalFees
            )
            logTradeToCSV(
                pair: pair,
                strategy: strategy,
                profit: netProfit,
                fees: fees,
                tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trades.csv")
            )
            sendTradeToFlaskServer(strategy: strategy, pair: pair, exchange: exchange, spotPrice: price, futuresPrice: 0.0, tradeAmount: adjustedAmount, profit: netProfit)
        }

        return netProfit > 0
    }

    static func calculateVolatility(pair: String, exchange: String) async -> Double {
        let prices = exchange == "kucoin" ? kucoinPrices[pair] : bybitPrices[pair]
        guard let priceArray = prices, priceArray.count >= 60 else {
            return getDouble("DEFAULT_VOLATILITY", defaultValue: 0.01)
        }
        let recentPrices = priceArray.suffix(60)
        let mean = recentPrices.reduce(0.0, +) / Double(recentPrices.count)
        let variance = recentPrices.reduce(0.0) { $0 + pow($1 - mean, 2) } / Double(recentPrices.count)
        return sqrt(variance) / mean
    }

    static func startOrderBookPolling() async {
        while true {
            for pair in tradingPairs {
                for exchange in ["kucoin", "bybit"] {
                    for marketType in ["spot", "futures"] {
                        do {
                            let _ = try await fetchOrderBookDepth(for: exchange, pair: pair, marketType: marketType)
                            await MainActor.run {
                                let orderBook = exchange == "kucoin" ? kucoinOrderBooks[pair] : bybitOrderBooks[pair]
                                if orderBook != nil {
                                    logAlert(event: "Updated order book for \(exchange)-\(pair)-\(marketType)")
                                }
                            }
                        } catch {
                            await MainActor.run {
                                logAlert(event: "Failed to poll order book for \(exchange)-\(pair)-\(marketType): \(error)")
                            }
                        }
                    }
                }
            }
            try? await Task.sleep(nanoseconds: 10_000_000_000) // 10 seconds
        }
    }
    
    // FIXED: Added missing scanTradingOpportunities method (Error line 7542)
    static func scanTradingOpportunities() async {
        // ENHANCED: Comprehensive opportunity scanning with all strategies
        while tradingActive {
            do {
                await withTaskGroup(of: Void.self) { group in
                    for pair in tradingPairs {
                        group.addTask {
                            // Multi-strategy opportunity evaluation
                            await evaluateArbitrageOpportunities(pair: pair)
                            await evaluateHFTOpportunities(pair: pair)
                            await evaluateMarketMakingOpportunities(pair: pair)
                            await evaluateFundingRateOpportunities(pair: pair)
                        }
                    }
                }
                
                // ENHANCED: Portfolio-level risk management
                await assessPortfolioRisk()
                await updateRiskMetrics()
                await monitorDataQuality()
                
                try await Task.sleep(nanoseconds: 250_000_000) // 250ms scan interval
            } catch {
                await MainActor.run {
                    logAlert(event: "Error in scanTradingOpportunities: \(error)")
                }
                try? await Task.sleep(nanoseconds: 1_000_000_000) // 1 second on error
            }
        }
    }
    
    // ENHANCED: Individual opportunity evaluation methods
    static func evaluateArbitrageOpportunities(pair: String) async {
        let kucoinPrice = await MainActor.run { kucoinCurrentPrice[pair] ?? 0.0 }
        let bybitPrice = await MainActor.run { bybitCurrentPrice[pair] ?? 0.0 }
        let kucoinFuturesPrice = await MainActor.run { kucoinCurrentFuturesPrice[pair] ?? 0.0 }
        let bybitFuturesPrice = await MainActor.run { bybitCurrentFuturesPrice[pair] ?? 0.0 }
        
        // Cross-exchange arbitrage
        if kucoinPrice > 0 && bybitPrice > 0 {
            let spread = abs(kucoinPrice - bybitPrice) / min(kucoinPrice, bybitPrice)
            if spread > crossExchangeMinSpreadThreshold {
                await checkCrossExchangeArbitrage(pair: pair, strategy: "cross-arbitrage", amount: crossExchangeTradeAmount) { success in
                    if success {
                        Task { @MainActor in
                            logAlert(event: "‚úÖ Cross-exchange arbitrage executed for \(pair)")
                        }
                    }
                }
            }
        }
        
        // Spot-futures arbitrage on KuCoin
        if kucoinPrice > 0 && kucoinFuturesPrice > 0 {
            let spread = abs(kucoinPrice - kucoinFuturesPrice) / min(kucoinPrice, kucoinFuturesPrice)
            if spread > arbitrageMinSpreadThreshold {
                executeSpotFuturesArbitrage(
                    pair: pair,
                    kucoinSpotPrice: kucoinPrice,
                    kucoinFuturesPrice: kucoinFuturesPrice,
                    bybitSpotPrice: bybitPrice,
                    bybitFuturesPrice: bybitFuturesPrice,
                    amount: arbitrageTradeAmount
                ) { success in
                    if success {
                        Task { @MainActor in
                            logAlert(event: "‚úÖ KuCoin spot-futures arbitrage executed for \(pair)")
                        }
                    }
                }
            }
        }
        
        // Spot-futures arbitrage on Bybit
        if bybitPrice > 0 && bybitFuturesPrice > 0 {
            let spread = abs(bybitPrice - bybitFuturesPrice) / min(bybitPrice, bybitFuturesPrice)
            if spread > arbitrageMinSpreadThreshold {
                executeSpotFuturesArbitrage(
                    pair: pair,
                    kucoinSpotPrice: kucoinPrice,
                    kucoinFuturesPrice: kucoinFuturesPrice,
                    bybitSpotPrice: bybitPrice,
                    bybitFuturesPrice: bybitFuturesPrice,
                    amount: arbitrageTradeAmount
                ) { success in
                    if success {
                        Task { @MainActor in
                            logAlert(event: "‚úÖ Bybit spot-futures arbitrage executed for \(pair)")
                        }
                    }
                }
            }
        }
    }
    
    static func evaluateHFTOpportunities(pair: String) async {
        let kucoinPrice = await MainActor.run { kucoinCurrentPrice[pair] ?? 0.0 }
        let bybitPrice = await MainActor.run { bybitCurrentPrice[pair] ?? 0.0 }
        let kucoinPrices = await MainActor.run { self.kucoinPrices[pair] ?? [] }
        let bybitPrices = await MainActor.run { self.bybitPrices[pair] ?? [] }
        
        guard kucoinPrice > 0 && bybitPrice > 0 else { return }
        
        // Calculate technical indicators
        let kucoinRSI = calculateRSI(prices: kucoinPrices, period: spotRsiPeriod) ?? 50.0
        let bybitRSI = calculateRSI(prices: bybitPrices, period: spotRsiPeriod) ?? 50.0
        
        // Enhanced HFT evaluation with all indicators
        await evaluateHFTStrategy(pair: pair, kucoinSpotRsi: kucoinRSI, bybitSpotRsi: bybitRSI)
        
        // ENHANCED: Additional HFT patterns
        await evaluateLatencyArbitrage(pair: pair, kucoinPrice: kucoinPrice, bybitPrice: bybitPrice)
        await evaluateOrderBookImbalance(pair: pair)
        await evaluateVolumeSpikes(pair: pair)
    }
    
    static func evaluateMarketMakingOpportunities(pair: String) async {
        let kucoinBook = await MainActor.run { kucoinOrderBooks[pair] }
        let bybitBook = await MainActor.run { bybitOrderBooks[pair] }
        
        // KuCoin market making
        if let book = kucoinBook, !book.bids.isEmpty && !book.asks.isEmpty {
            let spread = (book.asks.first!.price - book.bids.first!.price) / book.bids.first!.price
            let marketMakingSpread = getDouble("MARKET_MAKING_SPREAD", defaultValue: 0.002)
            
            if spread > marketMakingSpread {
                await executeMarketMaking(exchange: "kucoin", pair: pair, orderBook: book)
            }
        }
        
        // Bybit market making
        if let book = bybitBook, !book.bids.isEmpty && !book.asks.isEmpty {
            let spread = (book.asks.first!.price - book.bids.first!.price) / book.bids.first!.price
            let marketMakingSpread = getDouble("MARKET_MAKING_SPREAD", defaultValue: 0.002)
            
            if spread > marketMakingSpread {
                await executeMarketMaking(exchange: "bybit", pair: pair, orderBook: book)
            }
        }
    }
    
    static func evaluateFundingRateOpportunities(pair: String) async {
        let kucoinFundingRate = await MainActor.run { kucoinFundingRates[pair] ?? 0.0 }
        let bybitFundingRate = await MainActor.run { bybitFundingRates[pair] ?? 0.0 }
        
        await evaluateFundingRateMomentum(pair: pair, kucoinFundingRate: kucoinFundingRate, bybitFundingRate: bybitFundingRate)
    }
    
    // ENHANCED: Additional HFT evaluation methods
    static func evaluateLatencyArbitrage(pair: String, kucoinPrice: Double, bybitPrice: Double) async {
        let latencyDiff = abs((lastLatency["kucoin-\(pair)"] ?? 0.0) - (lastLatency["bybit-\(pair)"] ?? 0.0))
        
        if latencyDiff > 50.0 { // 50ms latency difference
            let spread = abs(kucoinPrice - bybitPrice) / min(kucoinPrice, bybitPrice)
            if spread > hftSpreadThreshold {
                await MainActor.run {
                    logAlert(event: "üöÄ Latency arbitrage opportunity detected for \(pair): Spread \(spread), Latency diff \(latencyDiff)ms")
                }
                
                // Execute latency arbitrage
                let success = await executeTrade(
                    exchange: latencyDiff > 0 ? "kucoin" : "bybit",
                    pair: pair,
                    side: kucoinPrice > bybitPrice ? "sell" : "buy",
                    price: kucoinPrice > bybitPrice ? kucoinPrice : bybitPrice,
                    amount: hftTradeAmount,
                    strategy: "Latency-Arbitrage"
                )
                
                if success {
                    await MainActor.run {
                        logAlert(event: "‚úÖ Latency arbitrage executed for \(pair)")
                    }
                }
            }
        }
    }
    
    static func evaluateOrderBookImbalance(pair: String) async {
        let kucoinBook = await MainActor.run { kucoinOrderBooks[pair] }
        let bybitBook = await MainActor.run { bybitOrderBooks[pair] }
        
        if let kBook = kucoinBook {
            let imbalance = calculateOrderBookImbalance(book: kBook)
            if imbalance > getDouble("ORDER_BOOK_IMBALANCE_THRESHOLD", defaultValue: 3.0) {
                let signal = imbalance > 1.0 ? "buy" : "sell"
                let success = await executeTrade(
                    exchange: "kucoin",
                    pair: pair,
                    side: signal,
                    price: kucoinCurrentPrice[pair] ?? 0.0,
                    amount: spotTradeAmount,
                    strategy: "OrderBook-Imbalance"
                )
                
                if success {
                    await MainActor.run {
                        logAlert(event: "‚úÖ Order book imbalance trade executed for \(pair) on KuCoin")
                    }
                }
            }
        }
        
        if let bBook = bybitBook {
            let imbalance = calculateOrderBookImbalance(book: bBook)
            if imbalance > getDouble("ORDER_BOOK_IMBALANCE_THRESHOLD", defaultValue: 3.0) {
                let signal = imbalance > 1.0 ? "buy" : "sell"
                let success = await executeTrade(
                    exchange: "bybit",
                    pair: pair,
                    side: signal,
                    price: bybitCurrentPrice[pair] ?? 0.0,
                    amount: spotTradeAmount,
                    strategy: "OrderBook-Imbalance"
                )
                
                if success {
                    await MainActor.run {
                        logAlert(event: "‚úÖ Order book imbalance trade executed for \(pair) on Bybit")
                    }
                }
            }
        }
    }
    
    static func evaluateVolumeSpikes(pair: String) async {
        let kucoinVolumes = await MainActor.run { kucoinSpotVolume[pair] ?? [] }
        let bybitVolumes = await MainActor.run { bybitSpotVolume[pair] ?? [] }
        
        // Detect volume spikes
        if kucoinVolumes.count >= 10 {
            let avgVolume = kucoinVolumes.suffix(10).reduce(0, +) / 10.0
            let currentVolume = kucoinVolumes.last ?? 0.0
            
            if currentVolume > avgVolume * volumeAnomalyMultiplier {
                await MainActor.run {
                    logAlert(event: "üìà Volume spike detected on KuCoin \(pair): \(currentVolume) vs avg \(avgVolume)")
                }
                
                // Volume momentum trade
                let success = await executeTrade(
                    exchange: "kucoin",
                    pair: pair,
                    side: "buy", // Assume volume spike indicates buying pressure
                    price: kucoinCurrentPrice[pair] ?? 0.0,
                    amount: spotTradeAmount * 0.5, // Smaller size for volume trades
                    strategy: "Volume-Momentum"
                )
                
                if success {
                    await MainActor.run {
                        logAlert(event: "‚úÖ Volume momentum trade executed for \(pair) on KuCoin")
                    }
                }
            }
        }
        
        if bybitVolumes.count >= 10 {
            let avgVolume = bybitVolumes.suffix(10).reduce(0, +) / 10.0
            let currentVolume = bybitVolumes.last ?? 0.0
            
            if currentVolume > avgVolume * volumeAnomalyMultiplier {
                await MainActor.run {
                    logAlert(event: "üìà Volume spike detected on Bybit \(pair): \(currentVolume) vs avg \(avgVolume)")
                }
                
                // Volume momentum trade
                let success = await executeTrade(
                    exchange: "bybit",
                    pair: pair,
                    side: "buy", // Assume volume spike indicates buying pressure
                    price: bybitCurrentPrice[pair] ?? 0.0,
                    amount: spotTradeAmount * 0.5, // Smaller size for volume trades
                    strategy: "Volume-Momentum"
                )
                
                if success {
                    await MainActor.run {
                        logAlert(event: "‚úÖ Volume momentum trade executed for \(pair) on Bybit")
                    }
                }
            }
        }
    }
    
    static func executeMarketMaking(exchange: String, pair: String, orderBook: BevaixOrderBook) async {
        guard !orderBook.bids.isEmpty && !orderBook.asks.isEmpty else { return }
        
        let bestBid = orderBook.bids.first!.price
        let bestAsk = orderBook.asks.first!.price
        let midPrice = (bestBid + bestAsk) / 2.0
        let marketMakingSpread = getDouble("MARKET_MAKING_SPREAD", defaultValue: 0.002)
        
        // Place orders inside the spread
        let bidPrice = midPrice * (1 - marketMakingSpread / 2)
        let askPrice = midPrice * (1 + marketMakingSpread / 2)
        
        // Simulate market making orders
        let success = await executeTrade(
            exchange: exchange,
            pair: pair,
            side: "both", // Special case for market making
            price: midPrice,
            amount: spotTradeAmount * 0.3, // Smaller size for market making
            strategy: "Market-Making"
        )
        
        if success {
            await MainActor.run {
                logAlert(event: "‚úÖ Market making executed for \(pair) on \(exchange): Bid \(bidPrice), Ask \(askPrice)")
            }
        }
    }
    
    // ENHANCED: Main trading loop with comprehensive strategy orchestration (Fixes line 7315 complex expression)
    static func startMainTradingLoop() {
        Task {
            while tradingActive {
                do {
                    // FIXED: Break up complex expression into sub-expressions (Line 7315 fix)
                    let totalBalance = kucoinBalance + bybitBalance
                    let balanceRatio = totalBalance > 0 ? kucoinBalance / totalBalance : 0.5
                    let pairCount = Double(tradingPairs.count)
                    let tradingIntensity = pairCount > 0 ? pairCount / 22.0 : 0.0
                    let baseRiskFactor = dailyLossLimitPercentage * tradingIntensity
                    let adjustedRisk = balanceRatio * baseRiskFactor
                    let volatilityMultiplier = calculateMarketVolatility()
                    let finalRiskScore = adjustedRisk * (1.0 + volatilityMultiplier)
                    
                    if finalRiskScore > 0.1 {
                        await MainActor.run {
                            logAlert(event: "‚ö†Ô∏è High risk factor detected: \(finalRiskScore)")
                        }
                    }
                    
                    // FIXED: Added await for async function calls (Lines 7487, 7493)
                    await scanTradingOpportunities()
                    await monitorActivePositions()
                    
                    // ENHANCED: AI-driven strategy selection
                    await orchestrateAITrading()
                    
                    // ENHANCED: Dynamic parameter adjustment
                    await adjustDynamicParameters()
                    
                    // ENHANCED: Performance monitoring
                    await updatePerformanceMetrics()
                    
                    try await Task.sleep(nanoseconds: 100_000_000) // 100ms main loop
                } catch {
                    await MainActor.run {
                        logAlert(event: "Error in main trading loop: \(error)")
                    }
                    try? await Task.sleep(nanoseconds: 1_000_000_000) // 1 second on error
                }
            }
        }
    }
    
    // ENHANCED: Active position monitoring with trailing stops
    static func monitorActivePositions() async {
        for pair in tradingPairs {
            // Monitor KuCoin positions
            if await MainActor.run(body: { kucoinInSpotTrade[pair] ?? false }) {
                let entryPrice = await MainActor.run { kucoinSpotEntryPrice[pair] ?? 0.0 }
                let currentPrice = await MainActor.run { kucoinCurrentPrice[pair] ?? 0.0 }
                let trailingStop = await MainActor.run { kucoinSpotTrailingStop[pair] ?? 0.0 }
                
                if currentPrice > 0 && entryPrice > 0 {
                    let profitPercent = (currentPrice - entryPrice) / entryPrice
                    let newTrailingStop = currentPrice * (1 - spotTrailingStopPercentage)
                    
                    // Enhanced exit conditions
                    let shouldExit = profitPercent >= spotMinProfitPercentage ||
                                   currentPrice <= trailingStop ||
                                   profitPercent <= -spotStopLossPercentage
                    
                    if shouldExit {
                        await MainActor.run {
                            kucoinInSpotTrade[pair] = false
                            kucoinSpotEntryPrice[pair] = 0.0
                            kucoinSpotTrailingStop[pair] = 0.0
                            activeSpotTrades[pair] = max(0, (activeSpotTrades[pair] ?? 0) - 1)
                            
                            let profit = (currentPrice - entryPrice) * (kucoinPositions[pair] ?? 0.0)
                            kucoinBalance += profit
                            kucoinPositions[pair] = 0.0
                            
                            logAlert(event: "üîÑ Closed KuCoin position for \(pair): Profit \(String(format: "%.4f", profitPercent * 100))%")
                        }
                    } else if newTrailingStop > trailingStop {
                        await MainActor.run {
                            kucoinSpotTrailingStop[pair] = newTrailingStop
                        }
                    }
                }
            }
            
            // Monitor Bybit positions (same logic)
            if await MainActor.run(body: { bybitInSpotTrade[pair] ?? false }) {
                let entryPrice = await MainActor.run { bybitSpotEntryPrice[pair] ?? 0.0 }
                let currentPrice = await MainActor.run { bybitCurrentPrice[pair] ?? 0.0 }
                let trailingStop = await MainActor.run { bybitSpotTrailingStop[pair] ?? 0.0 }
                
                if currentPrice > 0 && entryPrice > 0 {
                    let profitPercent = (currentPrice - entryPrice) / entryPrice
                    let newTrailingStop = currentPrice * (1 - spotTrailingStopPercentage)
                    
                    let shouldExit = profitPercent >= spotMinProfitPercentage ||
                                   currentPrice <= trailingStop ||
                                   profitPercent <= -spotStopLossPercentage
                    
                    if shouldExit {
                        await MainActor.run {
                            bybitInSpotTrade[pair] = false
                            bybitSpotEntryPrice[pair] = 0.0
                            bybitSpotTrailingStop[pair] = 0.0
                            activeSpotTrades[pair] = max(0, (activeSpotTrades[pair] ?? 0) - 1)
                            
                            let profit = (currentPrice - entryPrice) * (bybitPositions[pair] ?? 0.0)
                            bybitBalance += profit
                            bybitPositions[pair] = 0.0
                            
                            logAlert(event: "üîÑ Closed Bybit position for \(pair): Profit \(String(format: "%.4f", profitPercent * 100))%")
                        }
                    } else if newTrailingStop > trailingStop {
                        await MainActor.run {
                            bybitSpotTrailingStop[pair] = newTrailingStop
                        }
                    }
                }
            }
        }
    }
    
    // ENHANCED: AI trading orchestration
    static func orchestrateAITrading() async {
        // Check if AI system should make trading decisions
        let aiConfidence = await calculateAIConfidence()
        
        if aiConfidence > 0.8 {
            for pair in tradingPairs.prefix(5) { // Limit AI trading to top 5 pairs
                let signals = await generateAISignals(pair: pair)
                await executeAITrades(pair: pair, signals: signals, confidence: aiConfidence)
            }
        }
    }
    
    static func calculateAIConfidence() async -> Double {
        // Combine multiple AI systems for confidence score
        var confidenceFactors: [Double] = []
        
        // Market volatility factor
        let volatility = calculateMarketVolatility()
        confidenceFactors.append(1.0 - min(volatility * 10, 1.0))
        
        // Data quality factor
        let dataQuality = await assessDataQuality()
        confidenceFactors.append(dataQuality)
        
        // Performance factor
        let recentPerformance = await assessRecentPerformance()
        confidenceFactors.append(recentPerformance)
        
        // Return weighted average
        return confidenceFactors.reduce(0, +) / Double(confidenceFactors.count)
    }
    
    static func generateAISignals(pair: String) async -> [String: Double] {
        var signals: [String: Double] = [:]
        
        // Generate signals from each AI system
        signals["momentum"] = calculateMomentumSignal(pair: pair)
        signals["meanReversion"] = calculateMeanReversionSignal(pair: pair)
        signals["marketMaking"] = calculateMarketMakingSignal(pair: pair)
        signals["sentiment"] = await MainActor.run { sentimentScores[pair] ?? 0.0 }
        
        return signals
    }
    
    static func executeAITrades(pair: String, signals: [String: Double], confidence: Double) async {
        let momentumSignal = signals["momentum"] ?? 0.0
        let sentimentSignal = signals["sentiment"] ?? 0.0
        
        // Combined signal strength
        let combinedSignal = (momentumSignal + sentimentSignal) / 2.0
        let signalStrength = abs(combinedSignal) * confidence
        
        if signalStrength > 0.6 {
            let exchange = compareExchangeLiquidity(pair: pair)
            let side = combinedSignal > 0 ? "buy" : "sell"
            let price = await MainActor.run {
                exchange == "kucoin" ? kucoinCurrentPrice[pair] ?? 0.0 : bybitCurrentPrice[pair] ?? 0.0
            }
            
            if price > 0 {
                let success = await executeTrade(
                    exchange: exchange,
                    pair: pair,
                    side: side,
                    price: price,
                    amount: spotTradeAmount * signalStrength, // Scale by signal strength
                    strategy: "AI-Enhanced"
                )
                
                if success {
                    await MainActor.run {
                        logAlert(event: "ü§ñ AI-enhanced trade executed for \(pair): Signal \(signalStrength)")
                    }
                }
            }
        }
    }
    
    // ENHANCED: Dynamic parameter adjustment based on market conditions
    static func adjustDynamicParameters() async {
        let marketCondition = await analyzeCurrentMarketCondition()
        
        switch marketCondition {
        case "high_volatility":
            await MainActor.run {
                spotTrailingStopPercentage = min(spotTrailingStopPercentage * 1.5, 0.05)
                logAlert(event: "üìä Adjusted trailing stop for high volatility: \(spotTrailingStopPercentage)")
            }
        case "low_volatility":
            await MainActor.run {
                spotTrailingStopPercentage = max(spotTrailingStopPercentage * 0.8, 0.001)
                logAlert(event: "üìä Adjusted trailing stop for low volatility: \(spotTrailingStopPercentage)")
            }
        case "trending":
            await MainActor.run {
                scalpProfitTarget = scalpProfitTarget * 1.2
                logAlert(event: "üìä Increased profit target for trending market: \(scalpProfitTarget)")
            }
        default:
            break
        }
    }
    
    static func analyzeCurrentMarketCondition() async -> String {
        let volatility = calculateMarketVolatility()
        var trendingPairs = 0
        
        for pair in tradingPairs {
            let momentum = calculateMomentumSignal(pair: pair)
            if abs(momentum) > 0.02 {
                trendingPairs += 1
            }
        }
        
        let trendingRatio = Double(trendingPairs) / Double(tradingPairs.count)
        
        if volatility > 0.05 {
            return "high_volatility"
        } else if volatility < 0.01 {
            return "low_volatility"
        } else if trendingRatio > 0.6 {
            return "trending"
        } else {
            return "normal"
        }
    }
    
    // ENHANCED: Comprehensive performance monitoring
    static func updatePerformanceMetrics() async {
        let currentTime = Date()
        
        await MainActor.run {
            // Calculate real-time metrics
            let totalTrades = tradeMetrics.values.reduce(0) { $0 + $1.wins + $1.losses }
            let totalWins = tradeMetrics.values.reduce(0) { $0 + $1.wins }
            let winRate = totalTrades > 0 ? Double(totalWins) / Double(totalTrades) : 0.0
            let totalProfitValue = tradeMetrics.values.reduce(0.0) { $0 + $1.totalProfit }
            let totalFeesValue = tradeMetrics.values.reduce(0.0) { $0 + $1.totalFees }
            let netProfit = totalProfitValue - totalFeesValue
            
            // Update real-time metrics
            realtimeMetrics["total_trades"] = Double(totalTrades)
            realtimeMetrics["win_rate"] = winRate
            realtimeMetrics["total_profit"] = totalProfitValue
            realtimeMetrics["total_fees"] = totalFeesValue
            realtimeMetrics["net_profit"] = netProfit
            realtimeMetrics["kucoin_balance"] = kucoinBalance
            realtimeMetrics["bybit_balance"] = bybitBalance
            
            // Log detailed performance summary every 5 minutes
            if currentTime.timeIntervalSince(lastSummaryTime) > 300 {
                lastSummaryTime = currentTime
                
                let averageLatency = lastLatency.values.reduce(0, +) / Double(max(lastLatency.count, 1))
                let tradesPerMinute = totalTrades > 0 ? Double(totalTrades) / max(currentTime.timeIntervalSince(Date().addingTimeInterval(-3600)), 1) * 60 : 0
                
                let performanceSummary = """
                üìä 5-Minute Performance Summary:
                Total Trades: \(totalTrades) | Win Rate: \(String(format: "%.1f", winRate * 100))%
                Net Profit: \(String(format: "%.2f", netProfit)) USDT | ROI: \(String(format: "%.2f", netProfit / max(totalBalance, 1) * 100))%
                Trades/Min: \(String(format: "%.1f", tradesPerMinute)) | Avg Latency: \(String(format: "%.1f", averageLatency))ms
                KuCoin: \(String(format: "%.2f", kucoinBalance)) | Bybit: \(String(format: "%.2f", bybitBalance))
                """
                
                print(performanceSummary)
                logAlert(event: performanceSummary)
            }
        }
    }
    
    // ENHANCED: Helper methods for AI confidence calculation
    static func assessDataQuality() async -> Double {
        var qualityScore = 1.0
        let now = Date()
        
        for pair in tradingPairs {
            let lastUpdate = await MainActor.run { lastDataUpdate[pair] }
            if let update = lastUpdate {
                let staleness = now.timeIntervalSince(update)
                if staleness > 60 {
                    qualityScore *= 0.9 // Reduce quality for stale data
                }
            } else {
                qualityScore *= 0.8 // Reduce quality for missing data
            }
        }
        
        return max(qualityScore, 0.1)
    }
    
    static func assessRecentPerformance() async -> Double {
        let recentTrades = await MainActor.run {
            tradeMetrics.values.reduce(0) { $0 + $1.wins + $1.losses }
        }
        
        guard recentTrades > 0 else { return 0.5 }
        
        let winRate = await MainActor.run {
            let wins = tradeMetrics.values.reduce(0) { $0 + $1.wins }
            return Double(wins) / Double(recentTrades)
        }
        
        return winRate
    }
}

// Main entry point
DispatchQueue.main.async {
    ExchangeWebSocket.initializeParameters {
        ExchangeWebSocket.startTradingLoop()
        ExchangeWebSocket.logDashboardMetrics()
    }
}

RunLoop.main.run()
//---------------------------------------------------------------------------------------------------------Block 15 - High-Frequency Trading Scalping

import Foundation

extension ExchangeWebSocket {
    
    
    
    
    static func structureTradeData(strategy: String, pair: String, exchange: String, spotPrice: Double, futuresPrice: Double, tradeAmount: Double, profit: Double) -> [String: Any] {
        let timestampFormatter = ISO8601DateFormatter()
        timestampFormatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        let timestamp = timestampFormatter.string(from: Date())

        return [
            "strategy": strategy,
            "pair": pair,
            "exchange": exchange,
            "spot_price": spotPrice,
            "futures_price": futuresPrice,
            "trade_amount": tradeAmount,
            "profit": profit,
            "timestamp": timestamp
        ]
    }

    @MainActor
    static func logTradeLocally(strategy: String, pair: String, exchange: String, spotPrice: Double, futuresPrice: Double, tradeAmount: Double, profit: Double) {
        let tradeData = structureTradeData(strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit)
        let timestamp = tradeData["timestamp"] as? String ?? ISO8601DateFormatter().string(from: Date())
        let logEntry = "\(timestamp),\(strategy),\(pair),\(exchange),\(spotPrice),\(futuresPrice),\(tradeAmount),\(profit)\n"
        let logURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trade_log_fallback.csv")

        do {
            let fileManager = FileManager.default
            let directoryPath = logURL.deletingLastPathComponent().path
            if !fileManager.fileExists(atPath: directoryPath) {
                try fileManager.createDirectory(atPath: directoryPath, withIntermediateDirectories: true, attributes: nil)
                print("DEBUG: Created directory for trade_log_fallback.csv at \(directoryPath)")
            }

            if !fileManager.fileExists(atPath: logURL.path) {
                try "timestamp,strategy,pair,exchange,spot_price,futures_price,trade_amount,profit\n".write(to: logURL, atomically: true, encoding: .utf8)
            }

            if let fileHandle = try? FileHandle(forWritingTo: logURL) {
                defer { fileHandle.closeFile() }
                if let data = logEntry.data(using: .utf8) {
                    fileHandle.seekToEndOfFile()
                    fileHandle.write(data)
                }
            } else {
                try logEntry.write(to: logURL, atomically: true, encoding: .utf8)
            }
            print("DEBUG: Logged trade to fallback CSV: \(logEntry)")
        } catch {
            print("DEBUG: Failed to write to trade_log_fallback.csv: \(error.localizedDescription)")
        }
    }

    static func attemptSend(attempt: Int, request: URLRequest, strategy: String, pair: String, exchange: String, spotPrice: Double, futuresPrice: Double, tradeAmount: Double, profit: Double, retries: Int) {
        let delay = pow(2.0, Double(attempt - 1))
        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                print("DEBUG: Failed to send trade to Flask server (attempt \(attempt)): \(error.localizedDescription)")
                if attempt < retries {
                    DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
                        ExchangeWebSocket.attemptSend(attempt: attempt + 1, request: request, strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit, retries: retries)
                    }
                } else {
                    Task { @MainActor in
                        logTradeLocally(strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit)
                    }
                }
                return
            }

            guard let httpResponse = response as? HTTPURLResponse else {
                print("DEBUG: Failed to send trade to Flask server (attempt \(attempt)): No HTTP response")
                if attempt < retries {
                    DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
                        ExchangeWebSocket.attemptSend(attempt: attempt + 1, request: request, strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit, retries: retries)
                    }
                } else {
                    Task { @MainActor in
                        logTradeLocally(strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit)
                    }
                }
                return
            }

            print("DEBUG: Flask server response status (attempt \(attempt)): \(httpResponse.statusCode)")
            if httpResponse.statusCode == 200 {
                print("DEBUG: Successfully sent trade to Flask server: \(strategy) for \(pair) on \(exchange)")
            } else {
                print("DEBUG: Failed to send trade to Flask server (attempt \(attempt)): Status code \(httpResponse.statusCode)")
                if let data = data, let responseBody = String(data: data, encoding: .utf8) {
                    print("DEBUG: Flask server response body: \(responseBody)")
                }
                if attempt < retries {
                    DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
                        ExchangeWebSocket.attemptSend(attempt: attempt + 1, request: request, strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit, retries: retries)
                    }
                } else {
                    Task { @MainActor in
                        logTradeLocally(strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit)
                    }
                }
            }
        }
        task.resume()
    }

    static func sendTradeToFlaskServer(strategy: String, pair: String, exchange: String, spotPrice: Double, futuresPrice: Double, tradeAmount: Double, profit: Double, retries: Int = 3) {
        let url = URL(string: "http://127.0.0.1:5001/trade")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.timeoutInterval = 30.0

        let tradeData = structureTradeData(strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit)

        print("DEBUG: Attempting to send trade to Flask server: \(tradeData)")

        do {
            let jsonData = try JSONSerialization.data(withJSONObject: tradeData, options: [])
            request.httpBody = jsonData
            attemptSend(attempt: 1, request: request, strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit, retries: retries)
        } catch {
            print("DEBUG: Failed to serialize trade data: \(error.localizedDescription)")
            Task { @MainActor in
                logTradeLocally(strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit)
            }
        }
    }

    @MainActor
    static func saveHistoricalSpreadsToCSV(pair: String, spread: Double, predictedSpreadChange: Double?) {
        print("DEBUG: Entering saveHistoricalSpreadsToCSV for \(pair), spread: \(spread), predictedSpreadChange: \(predictedSpreadChange ?? 0.0) at \(ISO8601DateFormatter().string(from: Date()))")
        
        guard spread > 0 else {
            print("DEBUG: Skipping invalid spread for \(pair): \(spread)")
            logAlert(event: "Skipping invalid spread for \(pair): \(spread)")
            return
        }
        
        let timestampFormatter = ISO8601DateFormatter()
        timestampFormatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        let timestamp = timestampFormatter.string(from: Date())
        let predictedSpreadChangeValue = predictedSpreadChange ?? 0.0
        
        let kucoinSpotPrice = kucoinCurrentPrice[pair] ?? 0.0
        let kucoinFuturesPrice = kucoinCurrentFuturesPrice[pair] ?? 0.0
        let bybitSpotPrice = bybitCurrentPrice[pair] ?? 0.0
        let bybitFuturesPrice = bybitCurrentFuturesPrice[pair] ?? 0.0
        let kucoinSpotRsi = calculateRSI(prices: kucoinPrices[pair] ?? [], period: spotRsiPeriod) ?? 50.0
        let kucoinFuturesRsi = calculateRSI(prices: kucoinFuturesPrices[pair] ?? [], period: spotRsiPeriod) ?? 50.0
        let bybitSpotRsi = calculateRSI(prices: bybitPrices[pair] ?? [], period: spotRsiPeriod) ?? 50.0
        let bybitFuturesRsi = calculateRSI(prices: bybitFuturesPrices[pair] ?? [], period: spotRsiPeriod) ?? 50.0
        let kucoinSpotMacd = calculateMACD(prices: kucoinPrices[pair] ?? [], shortPeriod: macdShortPeriod, longPeriod: macdLongPeriod, signalPeriod: macdSignalPeriod) ?? (macd: 0.0, signal: 0.0, histogram: 0.0)
        let kucoinFuturesMacd = calculateMACD(prices: kucoinFuturesPrices[pair] ?? [], shortPeriod: macdShortPeriod, longPeriod: macdLongPeriod, signalPeriod: macdSignalPeriod) ?? (macd: 0.0, signal: 0.0, histogram: 0.0)
        let bybitSpotMacd = calculateMACD(prices: bybitPrices[pair] ?? [], shortPeriod: macdShortPeriod, longPeriod: macdLongPeriod, signalPeriod: macdSignalPeriod) ?? (macd: 0.0, signal: 0.0, histogram: 0.0)
        let bybitFuturesMacd = calculateMACD(prices: bybitFuturesPrices[pair] ?? [], shortPeriod: macdShortPeriod, longPeriod: macdLongPeriod, signalPeriod: macdSignalPeriod) ?? (macd: 0.0, signal: 0.0, histogram: 0.0)
        let kucoinSpotAtr = kucoinFuturesATR[pair] ?? 0.0
        let bybitSpotAtr = bybitFuturesATR[pair] ?? 0.0
        let kucoinFundingRate = kucoinFundingRates[pair] ?? 0.0
        let bybitFundingRate = bybitFundingRates[pair] ?? 0.0
        let sentimentScore = sentimentScores[pair] ?? 0.0
        
        print("DEBUG: Input prices for \(pair): kucoinSpotPrice=\(kucoinSpotPrice), kucoinFuturesPrice=\(kucoinFuturesPrice), bybitSpotPrice=\(bybitSpotPrice), bybitFuturesPrice=\(bybitFuturesPrice)")
        
        let minimalLogEntry = "\(timestamp),\(pair),\(spread),\(predictedSpreadChangeValue)\n"
        let spreadsCSVURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/historical_spreads.csv")
        
        let extendedLogEntry = "\(pair),\(timestamp),\(spread),\(predictedSpreadChangeValue),\(kucoinSpotPrice),\(kucoinFuturesPrice),\(bybitSpotPrice),\(bybitFuturesPrice),\(kucoinSpotRsi),\(kucoinFuturesRsi),\(bybitSpotRsi),\(bybitFuturesRsi),\(kucoinSpotMacd.histogram),\(kucoinFuturesMacd.histogram),\(bybitSpotMacd.histogram),\(bybitFuturesMacd.histogram),\(kucoinSpotAtr),\(bybitSpotAtr),\(kucoinFundingRate),\(bybitFundingRate),\(sentimentScore)\n"
        let extendedSpreadsCSVURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/historical_spreads_extended.csv")
        
        let fileManager = FileManager.default
        
        do {
            let directoryURL = spreadsCSVURL.deletingLastPathComponent()
            if !fileManager.fileExists(atPath: directoryURL.path) {
                try fileManager.createDirectory(at: directoryURL, withIntermediateDirectories: true, attributes: nil)
                print("DEBUG: Created directory for historical_spreads.csv at \(directoryURL.path)")
            }
            
            if !fileManager.fileExists(atPath: spreadsCSVURL.path) {
                let header = "timestamp,pair,spread,predictedSpreadChange\n"
                try header.write(to: spreadsCSVURL, atomically: true, encoding: .utf8)
                try fileManager.setAttributes([.posixPermissions: 0o644], ofItemAtPath: spreadsCSVURL.path)
                print("DEBUG: Created historical_spreads.csv with header")
            }
            
            guard let minimalData = minimalLogEntry.data(using: .utf8) else {
                print("DEBUG: Failed to convert minimal log entry to data for \(pair)")
                logAlert(event: "Failed to convert minimal log entry to data for \(pair)")
                return
            }
            
            var writeSuccess = false
            for attempt in 1...3 {
                do {
                    if let fileHandle = try? FileHandle(forWritingTo: spreadsCSVURL) {
                        defer { fileHandle.closeFile() }
                        fileHandle.seekToEndOfFile()
                        fileHandle.write(minimalData)
                        writeSuccess = true
                        print("DEBUG: Appended minimal historical spread to CSV for \(pair) (attempt \(attempt)): Spread=\(spread), PredictedChange=\(predictedSpreadChangeValue)")
                        break
                    } else {
                        try minimalLogEntry.write(to: spreadsCSVURL, atomically: true, encoding: .utf8)
                        writeSuccess = true
                        print("DEBUG: Wrote minimal historical spread to CSV for \(pair) (attempt \(attempt)): Spread=\(spread), PredictedChange=\(predictedSpreadChangeValue)")
                        break
                    }
                } catch {
                    print("DEBUG: Failed to write minimal historical spread to CSV for \(pair) (attempt \(attempt)): \(error.localizedDescription)")
                    if attempt < 3 {
                        Thread.sleep(forTimeInterval: 0.1 * Double(attempt))
                    }
                }
            }
            
            if !writeSuccess {
                print("DEBUG: Failed to save minimal historical spread to CSV for \(pair) after 3 attempts")
                logAlert(event: "Failed to save minimal historical spread to CSV for \(pair) after 3 attempts")
            }
            
            historicalSpreads[pair, default: []].append(spread)
        } catch {
            print("DEBUG: Failed to save minimal historical spread to CSV for \(pair): \(error.localizedDescription)")
            logAlert(event: "Failed to save minimal historical spread to CSV for \(pair): \(error.localizedDescription)")
        }
        
        do {
            let directoryURL = extendedSpreadsCSVURL.deletingLastPathComponent()
            if !fileManager.fileExists(atPath: directoryURL.path) {
                try fileManager.createDirectory(at: directoryURL, withIntermediateDirectories: true, attributes: nil)
                print("DEBUG: Created directory for historical_spreads_extended.csv at \(directoryURL.path)")
            }
            
            if !fileManager.fileExists(atPath: extendedSpreadsCSVURL.path) {
                let header = "pair,timestamp,spread,predicted_spread_change,kucoin_spot_price,kucoin_futures_price,bybit_spot_price,bybit_futures_price,kucoin_spot_rsi,kucoin_futures_rsi,bybit_spot_rsi,bybit_futures_rsi,kucoin_spot_macd_histogram,kucoin_futures_macd_histogram,bybit_spot_macd_histogram,bybit_futures_macd_histogram,kucoin_spot_atr,bybit_spot_atr,kucoin_funding_rate,bybit_funding_rate,sentiment_score\n"
                try header.write(to: extendedSpreadsCSVURL, atomically: true, encoding: .utf8)
                try fileManager.setAttributes([.posixPermissions: 0o644], ofItemAtPath: extendedSpreadsCSVURL.path)
                print("DEBUG: Created historical_spreads_extended.csv with header")
            }
            
            guard let extendedData = extendedLogEntry.data(using: .utf8) else {
                print("DEBUG: Failed to convert extended log entry to data for \(pair)")
                logAlert(event: "Failed to convert extended log entry to data for \(pair)")
                return
            }
            
            var extendedWriteSuccess = false
            for attempt in 1...3 {
                do {
                    if let fileHandle = try? FileHandle(forWritingTo: extendedSpreadsCSVURL) {
                        defer { fileHandle.closeFile() }
                        fileHandle.seekToEndOfFile()
                        fileHandle.write(extendedData)
                        extendedWriteSuccess = true
                        print("DEBUG: Appended extended historical spread to CSV for \(pair) (attempt \(attempt)): Spread=\(spread), PredictedChange=\(predictedSpreadChangeValue)")
                        break
                    } else {
                        try extendedLogEntry.write(to: extendedSpreadsCSVURL, atomically: true, encoding: .utf8)
                        extendedWriteSuccess = true
                        print("DEBUG: Wrote extended historical spread to CSV for \(pair) (attempt \(attempt)): Spread=\(spread), PredictedChange=\(predictedSpreadChangeValue)")
                        break
                    }
                } catch {
                    print("DEBUG: Failed to write extended historical spread to CSV for \(pair) (attempt \(attempt)): \(error.localizedDescription)")
                    if attempt < 3 {
                        Thread.sleep(forTimeInterval: 0.1 * Double(attempt))
                    }
                }
            }
            
            if !extendedWriteSuccess {
                print("DEBUG: Failed to save extended historical spread to CSV for \(pair) after 3 attempts")
                logAlert(event: "Failed to save extended historical spread to CSV for \(pair) after 3 attempts")
            }
        } catch {
            print("DEBUG: Failed to save extended historical spread to CSV for \(pair): \(error.localizedDescription)")
            logAlert(event: "Failed to save extended historical spread to CSV for \(pair): \(error.localizedDescription)")
        }
    }

    @MainActor
    static func logHistoricalTradeToCSV(pair: String, strategy: String, profit: Double, fees: Double) {
        let timestampFormatter = ISO8601DateFormatter()
        timestampFormatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        let timestamp = timestampFormatter.string(from: Date())
        let tradesCSVURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/historical_trades.csv")
        let logEntry = "\(timestamp),\(pair),\(strategy),\(profit),\(fees)\n"
        
        do {
            let fileManager = FileManager.default
            let directoryURL = tradesCSVURL.deletingLastPathComponent()
            if !fileManager.fileExists(atPath: directoryURL.path) {
                try fileManager.createDirectory(at: directoryURL, withIntermediateDirectories: true, attributes: nil)
                print("DEBUG: Created directory for historical_trades.csv at \(directoryURL.path)")
            }
            
            if !fileManager.fileExists(atPath: tradesCSVURL.path) {
                let header = "timestamp,pair,strategy,profit,fees\n"
                try header.write(to: tradesCSVURL, atomically: true, encoding: .utf8)
                try fileManager.setAttributes([.posixPermissions: 0o644], ofItemAtPath: tradesCSVURL.path)
                print("DEBUG: Created historical_trades.csv with header")
            }
            
            guard let data = logEntry.data(using: .utf8) else {
                print("DEBUG: Failed to convert trade log entry to data for \(pair)")
                logAlert(event: "Failed to convert trade log entry to data for \(pair)")
                return
            }
            
            var writeSuccess = false
            for attempt in 1...3 {
                do {
                    if let fileHandle = try? FileHandle(forWritingTo: tradesCSVURL) {
                        defer { fileHandle.closeFile() }
                        fileHandle.seekToEndOfFile()
                        fileHandle.write(data)
                        writeSuccess = true
                        print("DEBUG: Appended trade to historical_trades.csv for \(pair) (attempt \(attempt)): Profit=\(profit), Fees=\(fees)")
                        break
                    } else {
                        try logEntry.write(to: tradesCSVURL, atomically: true, encoding: .utf8)
                        writeSuccess = true
                        print("DEBUG: Wrote trade to historical_trades.csv for \(pair) (attempt \(attempt)): Profit=\(profit), Fees=\(fees)")
                        break
                    }
                } catch {
                    print("DEBUG: Failed to write trade to historical_trades.csv for \(pair) (attempt \(attempt)): \(error.localizedDescription)")
                    if attempt < 3 {
                        Thread.sleep(forTimeInterval: 0.1 * Double(attempt))
                    }
                }
            }
            
            if !writeSuccess {
                print("DEBUG: Failed to save trade to historical_trades.csv for \(pair) after 3 attempts")
                logAlert(event: "Failed to save trade to historical_trades.csv for \(pair) after 3 attempts")
            }
        } catch {
            print("DEBUG: Failed to save trade to historical_trades.csv for \(pair): \(error.localizedDescription)")
            logAlert(event: "Failed to save trade to historical_trades.csv for \(pair): \(error.localizedDescription)")
        }
    }

    static func fetchSpreadPrediction(pair: String, exchange: String, spotPrice: Double, futuresPrice: Double, retryCount: Int = 0) async -> Double? {
        let maxRetries = 3
        guard retryCount < maxRetries else {
            print("DEBUG: Max retries reached for spread prediction for \(pair) on \(exchange)")
            Task { @MainActor in
                logAlert(event: "Max retries reached for spread prediction for \(pair) on \(exchange)")
            }
            return arbitrageMinSpreadThreshold
        }

        let url = URL(string: "http://127.0.0.1:5001/predict_spread")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.timeoutInterval = 30.0

        let payload: [String: Any] = [
            "pair": pair,
            "exchange": exchange,
            "spot_price": spotPrice,
            "futures_price": futuresPrice,
            "kucoin_spot_rsi": calculateRSI(prices: kucoinPrices[pair] ?? [], period: spotRsiPeriod) ?? 50.0,
            "bybit_spot_rsi": calculateRSI(prices: bybitPrices[pair] ?? [], period: spotRsiPeriod) ?? 50.0,
            "kucoin_funding_rate": kucoinFundingRates[pair] ?? 0.0,
            "bybit_funding_rate": bybitFundingRates[pair] ?? 0.0,
            "sentiment_score": sentimentScores[pair] ?? 0.0
        ]

        do {
            let jsonData = try JSONSerialization.data(withJSONObject: payload, options: [])
            request.httpBody = jsonData
        } catch {
            print("DEBUG: Failed to serialize spread prediction payload for \(pair): \(error.localizedDescription)")
            Task { @MainActor in
                logAlert(event: "Failed to serialize spread prediction payload for \(pair): \(error.localizedDescription)")
            }
            return arbitrageMinSpreadThreshold
        }

        var data: Data?
        var response: URLResponse?
        do {
            (data, response) = try await URLSession.shared.data(for: request)
            print("DEBUG: Fetch spread prediction response for \(pair): Status code \((response as? HTTPURLResponse)?.statusCode ?? -1)")
            if let data = data, let responseBody = String(data: data, encoding: .utf8) {
                print("DEBUG: Fetch spread prediction response body: \(responseBody)")
            }
        } catch {
            print("DEBUG: Failed to fetch spread prediction for \(pair): \(error.localizedDescription)")
            Task { @MainActor in
                logAlert(event: "Failed to fetch spread prediction for \(pair): \(error.localizedDescription)")
            }
            let delay = pow(2.0, Double(retryCount))
            do {
                try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
                return await fetchSpreadPrediction(pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, retryCount: retryCount + 1)
            } catch {
                print("DEBUG: Failed to sleep during retry for spread prediction: \(error.localizedDescription)")
                return arbitrageMinSpreadThreshold
            }
        }

        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
            print("DEBUG: Invalid spread prediction response for \(pair): Status code \((response as? HTTPURLResponse)?.statusCode ?? -1)")
            Task { @MainActor in
                logAlert(event: "Invalid spread prediction response for \(pair)")
            }
            let delay = pow(2.0, Double(retryCount))
            do {
                try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
                return await fetchSpreadPrediction(pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, retryCount: retryCount + 1)
            } catch {
                print("DEBUG: Failed to sleep during retry for spread prediction: \(error.localizedDescription)")
                return arbitrageMinSpreadThreshold
            }
        }

        guard let fetchedData = data,
              let json = try? JSONSerialization.jsonObject(with: fetchedData) as? [String: Any],
              let predictedSpread = json["predicted_spread"] as? Double else {
            print("DEBUG: Failed to parse spread prediction for \(pair)")
            Task { @MainActor in
                logAlert(event: "Failed to parse spread prediction for \(pair)")
            }
            let delay = pow(2.0, Double(retryCount))
            do {
                try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
                return await fetchSpreadPrediction(pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, retryCount: retryCount + 1)
            } catch {
                print("DEBUG: Failed to sleep during retry for spread prediction: \(error.localizedDescription)")
                return arbitrageMinSpreadThreshold
            }
        }

        print("DEBUG: Successfully fetched spread prediction for \(pair): \(predictedSpread)")
        return predictedSpread
    }

    // FIXED: Add all missing price fetch functions with completion callbacks
    static func fetchKuCoinSpotPrice(pair: String, completion: @escaping @Sendable (Double?) -> Void) {
        let symbol = pair.replacingOccurrences(of: "-USDT", with: "USDT")
        guard let url = URL(string: "https://api.kucoin.com/api/v1/market/orderbook/level1?symbol=\(symbol)") else {
            print("DEBUG: Invalid URL for KuCoin spot price fetch: \(pair)")
            Task { @MainActor in
                logAlert(event: "Invalid URL for KuCoin spot price fetch: \(pair)")
            }
            completion(nil)
            return
        }

        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = 10.0

        URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                print("DEBUG: Failed to fetch KuCoin spot price for \(pair): \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to fetch KuCoin spot price for \(pair): \(error.localizedDescription)")
                }
                completion(nil)
                return
            }

            guard let data = data,
                  let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let dataDict = json["data"] as? [String: Any],
                  let priceString = dataDict["price"] as? String,
                  let price = Double(priceString) else {
                print("DEBUG: Failed to parse KuCoin spot price for \(pair)")
                Task { @MainActor in
                    logAlert(event: "Failed to parse KuCoin spot price for \(pair)")
                }
                completion(nil)
                return
            }

            Task { @MainActor in
                kucoinCurrentPrice[pair] = price
                kucoinPrices[pair, default: []].append(price)
                if kucoinPrices[pair]!.count > priceHistoryRetention {
                    kucoinPrices[pair]?.removeFirst()
                }
                print("DEBUG: Successfully fetched KuCoin spot price for \(pair): \(price)")
            }
            completion(price)
        }.resume()
    }

    static func fetchKuCoinFuturesPrice(pair: String, completion: @escaping @Sendable (Double?) -> Void) {
        let futuresSymbol = kucoinFuturesSymbols[pair] ?? "\(pair.replacingOccurrences(of: "-USDT", with: ""))USDTM"
        guard let url = URL(string: "https://api-futures.kucoin.com/api/v1/ticker?symbol=\(futuresSymbol)") else {
            print("DEBUG: Invalid URL for KuCoin futures price fetch: \(pair)")
            Task { @MainActor in
                logAlert(event: "Invalid URL for KuCoin futures price fetch: \(pair)")
            }
            completion(nil)
            return
        }

        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = 10.0

        URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                print("DEBUG: Failed to fetch KuCoin futures price for \(pair): \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to fetch KuCoin futures price for \(pair): \(error.localizedDescription)")
                }
                completion(nil)
                return
            }

            guard let data = data,
                  let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let dataDict = json["data"] as? [String: Any],
                  let priceString = dataDict["price"] as? String,
                  let price = Double(priceString) else {
                print("DEBUG: Failed to parse KuCoin futures price for \(pair)")
                Task { @MainActor in
                    logAlert(event: "Failed to parse KuCoin futures price for \(pair)")
                }
                completion(nil)
                return
            }

            Task { @MainActor in
                kucoinCurrentFuturesPrice[pair] = price
                kucoinFuturesPrices[pair, default: []].append(price)
                if kucoinFuturesPrices[pair]!.count > priceHistoryRetention {
                    kucoinFuturesPrices[pair]?.removeFirst()
                }
                print("DEBUG: Successfully fetched KuCoin futures price for \(pair): \(price)")
            }
            completion(price)
        }.resume()
    }

    static func fetchBybitSpotPrice(pair: String, completion: @escaping @Sendable (Double?) -> Void) {
        let symbol = pair.replacingOccurrences(of: "-USDT", with: "USDT")
        guard let url = URL(string: "https://api.bybit.com/v5/market/tickers?category=spot&symbol=\(symbol)") else {
            print("DEBUG: Invalid URL for Bybit spot price fetch: \(pair)")
            Task { @MainActor in
                logAlert(event: "Invalid URL for Bybit spot price fetch: \(pair)")
            }
            completion(nil)
            return
        }

        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = 10.0

        URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                print("DEBUG: Failed to fetch Bybit spot price for \(pair): \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to fetch Bybit spot price for \(pair): \(error.localizedDescription)")
                }
                completion(nil)
                return
            }

            guard let data = data,
                  let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let result = json["result"] as? [String: Any],
                  let list = result["list"] as? [[String: Any]],
                  let firstTicker = list.first,
                  let priceString = firstTicker["lastPrice"] as? String,
                  let price = Double(priceString) else {
                print("DEBUG: Failed to parse Bybit spot price for \(pair)")
                Task { @MainActor in
                    logAlert(event: "Failed to parse Bybit spot price for \(pair)")
                }
                completion(nil)
                return
            }

            Task { @MainActor in
                bybitCurrentPrice[pair] = price
                bybitPrices[pair, default: []].append(price)
                if bybitPrices[pair]!.count > priceHistoryRetention {
                    bybitPrices[pair]?.removeFirst()
                }
                print("DEBUG: Successfully fetched Bybit spot price for \(pair): \(price)")
            }
            completion(price)
        }.resume()
    }

    static func fetchBybitFuturesPrice(pair: String, completion: @escaping @Sendable (Double?) -> Void) {
        let symbol = pair.replacingOccurrences(of: "-USDT", with: "USDT")
        guard let url = URL(string: "https://api.bybit.com/v5/market/tickers?category=linear&symbol=\(symbol)") else {
            print("DEBUG: Invalid URL for Bybit futures price fetch: \(pair)")
            Task { @MainActor in
                logAlert(event: "Invalid URL for Bybit futures price fetch: \(pair)")
            }
            completion(nil)
            return
        }

        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = 10.0

        URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                print("DEBUG: Failed to fetch Bybit futures price for \(pair): \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to fetch Bybit futures price for \(pair): \(error.localizedDescription)")
                }
                completion(nil)
                return
            }

            guard let data = data,
                  let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let result = json["result"] as? [String: Any],
                  let list = result["list"] as? [[String: Any]],
                  let firstTicker = list.first,
                  let priceString = firstTicker["lastPrice"] as? String,
                  let price = Double(priceString) else {
                print("DEBUG: Failed to parse Bybit futures price for \(pair)")
                Task { @MainActor in
                    logAlert(event: "Failed to parse Bybit futures price for \(pair)")
                }
                completion(nil)
                return
            }

            Task { @MainActor in
                bybitCurrentFuturesPrice[pair] = price
                bybitFuturesPrices[pair, default: []].append(price)
                if bybitFuturesPrices[pair]!.count > priceHistoryRetention {
                    bybitFuturesPrices[pair]?.removeFirst()
                }
                print("DEBUG: Successfully fetched Bybit futures price for \(pair): \(price)")
            }
            completion(price)
        }.resume()
    }
}


// ADD THIS FUNCTION TO ExchangeWebSocket CLASS (AFTER THE PRICE FETCH FUNCTIONS IN BLOCK 15)

extension ExchangeWebSocket {
    @MainActor
    static func startRegularPriceFetching() {
            print("DEBUG: Starting regular price fetching for all trading pairs")
            logAlert(event: "Starting regular price fetching for all trading pairs")
            
            Task {
                while tradingActive {
                    do {
                        // Fetch prices for all pairs - FIXED VERSION (no async/await issues)
                        for pair in tradingPairs {
                            // KuCoin spot prices
                            fetchKuCoinSpotPrice(pair: pair) { price in
                                if let price = price {
                                    print("DEBUG: Fetched KuCoin spot price for \(pair): \(price)")
                                }
                            }
                            
                            // KuCoin futures prices
                            fetchKuCoinFuturesPrice(pair: pair) { price in
                                if let price = price {
                                    print("DEBUG: Fetched KuCoin futures price for \(pair): \(price)")
                                }
                            }
                            
                            // Bybit spot prices
                            fetchBybitSpotPrice(pair: pair) { price in
                                if let price = price {
                                    print("DEBUG: Fetched Bybit spot price for \(pair): \(price)")
                                }
                            }
                            
                            // Bybit futures prices
                            fetchBybitFuturesPrice(pair: pair) { price in
                                if let price = price {
                                    print("DEBUG: Fetched Bybit futures price for \(pair): \(price)")
                                }
                            }
                            
                            // Small delay between pairs to avoid API rate limits
                            try await Task.sleep(nanoseconds: 100_000_000) // 0.1 seconds
                        }
                        
                        // Log progress every 10 cycles
                        let currentTime = Date()
                        if Int(currentTime.timeIntervalSince1970) % 30 == 0 {
                            let totalPairs = tradingPairs.count
                            let kucoinSpotPrices = kucoinCurrentPrice.count
                            let kucoinFuturesPrices = kucoinCurrentFuturesPrice.count
                            let bybitSpotPrices = bybitCurrentPrice.count
                            let bybitFuturesPrices = bybitCurrentFuturesPrice.count
                            
                            let status = "Price fetch status: KuCoin Spot(\(kucoinSpotPrices)/\(totalPairs)), KuCoin Futures(\(kucoinFuturesPrices)/\(totalPairs)), Bybit Spot(\(bybitSpotPrices)/\(totalPairs)), Bybit Futures(\(bybitFuturesPrices)/\(totalPairs))"
                            print("DEBUG: \(status)")
                            logAlert(event: status)
                        }
                        
                        // Wait 3 seconds between price fetch cycles
                        try await Task.sleep(nanoseconds: 3_000_000_000)
                        
                    } catch {
                        print("DEBUG: Error in price fetching loop: \(error.localizedDescription)")
                        logAlert(event: "Error in price fetching loop: \(error.localizedDescription)")
                        
                        // Wait 5 seconds before retrying on error
                        try await Task.sleep(nanoseconds: 5_000_000_000)
                    }
                }
            }
        }
        
        @MainActor
        static func logPairStatus() {
            let totalPairs = tradingPairs.count
            let activePairs = Set(kucoinCurrentPrice.keys).union(Set(bybitCurrentPrice.keys)).count
            let statusMessage = "Trading pairs loaded: \(totalPairs), Active pairs with prices: \(activePairs)"
            print("DEBUG: \(statusMessage)")
            print("DEBUG: Active trading pairs: \(tradingPairs.joined(separator: ", "))")
            logAlert(event: statusMessage)
            
            // Log which pairs are missing prices
            for pair in tradingPairs {
                let kucoinSpot = kucoinCurrentPrice[pair] != nil ? "‚úÖ" : "‚ùå"
                let kucoinFutures = kucoinCurrentFuturesPrice[pair] != nil ? "‚úÖ" : "‚ùå"
                let bybitSpot = bybitCurrentPrice[pair] != nil ? "‚úÖ" : "‚ùå"
                let bybitFutures = bybitCurrentFuturesPrice[pair] != nil ? "‚úÖ" : "‚ùå"
                
                if kucoinSpot == "‚ùå" || kucoinFutures == "‚ùå" || bybitSpot == "‚ùå" || bybitFutures == "‚ùå" {
                    let status = "\(pair): KC-Spot\(kucoinSpot) KC-Fut\(kucoinFutures) BB-Spot\(bybitSpot) BB-Fut\(bybitFutures)"
                    print("DEBUG: Price status - \(status)")
                }
            }
        }
    }




            
//--------------------------------------------------------------------------------------------------------------Block 16 - Spot-Futures Arbitrage Execution


extension ExchangeWebSocket {
    static func executeSpotFuturesArbitrage(pair: String, kucoinSpotPrice: Double, kucoinFuturesPrice: Double, bybitSpotPrice: Double, bybitFuturesPrice: Double, amount: Double, completion: @escaping (Bool) -> Void) {
        Task {
            let minSpreadThreshold = getDouble("ARBITRAGE_MIN_SPREAD_THRESHOLD", defaultValue: 0.002)
            let kucoinSpread = abs(kucoinSpotPrice - kucoinFuturesPrice) / min(kucoinSpotPrice, kucoinFuturesPrice)
            let bybitSpread = abs(bybitSpotPrice - bybitFuturesPrice) / min(bybitSpotPrice, bybitFuturesPrice)
            
            guard kucoinSpread >= minSpreadThreshold || bybitSpread >= minSpreadThreshold else {
                print("DEBUG: Spread too low for spot-futures arbitrage: KuCoin=\(kucoinSpread), Bybit=\(bybitSpread)")
                await MainActor.run {
                    logAlert(event: "Spread too low for spot-futures arbitrage: KuCoin=\(kucoinSpread), Bybit=\(bybitSpread)")
                }
                completion(false)
                return
            }
            
            let kucoinLiquidity = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "spot", tradeAmount: amount, price: kucoinSpotPrice)
            let kucoinFuturesLiquidity = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "futures", tradeAmount: amount, price: kucoinFuturesPrice)
            let bybitLiquidity = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "spot", tradeAmount: amount, price: bybitSpotPrice)
            let bybitFuturesLiquidity = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "futures", tradeAmount: amount, price: bybitFuturesPrice)
            
            guard let kucoinLiquidity = kucoinLiquidity, let kucoinFuturesLiquidity = kucoinFuturesLiquidity,
                  let bybitLiquidity = bybitLiquidity, let bybitFuturesLiquidity = bybitFuturesLiquidity else {
                print("DEBUG: Insufficient liquidity for spot-futures arbitrage: \(pair)")
                await MainActor.run {
                    logAlert(event: "Insufficient liquidity for spot-futures arbitrage: \(pair)")
                }
                completion(false)
                return
            }
            
            // Integrate liquidity into weighted trade amount calculation
            let kucoinLiquidityFactor = min(kucoinLiquidity, kucoinFuturesLiquidity) / (kucoinLiquidity + kucoinFuturesLiquidity)
            let bybitLiquidityFactor = min(bybitLiquidity, bybitFuturesLiquidity) / (bybitLiquidity + bybitFuturesLiquidity)
            
            let kucoinFundingRate = kucoinFundingRates[pair] ?? 0.0
            let bybitFundingRate = bybitFundingRates[pair] ?? 0.0
            let maxFundingRateValue = await MainActor.run { maxFundingRate }
            
            guard abs(kucoinFundingRate) < maxFundingRateValue && abs(bybitFundingRate) < maxFundingRateValue else {
                print("DEBUG: Funding rate too high for \(pair): KuCoin=\(kucoinFundingRate), Bybit=\(bybitFundingRate)")
                await MainActor.run {
                    logAlert(event: "Funding rate too high for \(pair): KuCoin=\(kucoinFundingRate), Bybit=\(bybitFundingRate)")
                }
                completion(false)
                return
            }
            
            let kucoinProfit = kucoinSpread * amount - amount * (kucoinTakerFee + kucoinMakerFee) * 2
            let bybitProfit = bybitSpread * amount - amount * (bybitTakerFee + bybitMakerFee) * 2
            let minProfitThreshold = await MainActor.run { spotMinProfitPercentage }
            
            guard kucoinProfit > minProfitThreshold * amount * min(kucoinSpotPrice, kucoinFuturesPrice) ||
                  bybitProfit > minProfitThreshold * amount * min(bybitSpotPrice, bybitFuturesPrice) else {
                print("DEBUG: Expected profit too low for spot-futures arbitrage: KuCoin=\(kucoinProfit), Bybit=\(bybitProfit)")
                await MainActor.run {
                    logAlert(event: "Expected profit too low for spot-futures arbitrage: KuCoin=\(kucoinProfit), Bybit=\(bybitProfit)")
                }
                completion(false)
                return
            }
            
            let kucoinTradeAmount = await dynamicTradeAmount(balance: kucoinBalance, riskPercent: 0.3, volatility: 0.5) * kucoinLiquidityFactor
            let bybitTradeAmount = await dynamicTradeAmount(balance: bybitBalance, riskPercent: 0.3, volatility: 0.5) * bybitLiquidityFactor
            
            if kucoinSpread > bybitSpread && kucoinProfit > bybitProfit {
                let potentialLoss = kucoinTradeAmount * kucoinSpotPrice * stopLossPercentage
                if await checkDailyLossLimit(exchange: "kucoin", pair: pair, potentialLoss: potentialLoss) {
                    print("DEBUG: Daily loss limit exceeded for KuCoin-\(pair)")
                    completion(false)
                    return
                }
                
                executeSingleExchangeArbitrage(
                    exchange: "kucoin",
                    pair: pair,
                    spotPrice: kucoinSpotPrice,
                    futuresPrice: kucoinFuturesPrice,
                    strategy: "Spot-to-Futures",
                    kucoinSpotPrices: kucoinPrices[pair] ?? [],
                    bybitSpotPrices: [],
                    tradeAmount: kucoinTradeAmount
                )
                await MainActor.run {
                    tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].totalProfit += kucoinProfit
                    tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].totalFees += amount * (kucoinTakerFee + kucoinMakerFee) * 2
                    tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].wins += kucoinProfit > 0 ? 1 : 0
                    performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].profit += kucoinProfit
                    performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].fees += amount * (kucoinTakerFee + kucoinMakerFee) * 2
                    performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].trades += 1
                    performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].wins += kucoinProfit > 0 ? 1 : 0
                    kucoinBalance += kucoinProfit - amount * (kucoinTakerFee + kucoinMakerFee) * 2
                    logTradeToCSV(pair: pair, strategy: "Spot-to-Futures", profit: kucoinProfit, fees: amount * (kucoinTakerFee + kucoinMakerFee) * 2, tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/trade_log.csv"))
                    print("DEBUG: Executed spot-futures arbitrage on KuCoin for \(pair): Profit=\(kucoinProfit)")
                    logAlert(event: "Executed spot-futures arbitrage on KuCoin for \(pair): Profit=\(kucoinProfit)")
                }
                completion(true)
            } else {
                let potentialLoss = bybitTradeAmount * bybitSpotPrice * stopLossPercentage
                if await checkDailyLossLimit(exchange: "bybit", pair: pair, potentialLoss: potentialLoss) {
                    print("DEBUG: Daily loss limit exceeded for Bybit-\(pair)")
                    completion(false)
                    return
                }
                
                executeSingleExchangeArbitrage(
                    exchange: "bybit",
                    pair: pair,
                    spotPrice: bybitSpotPrice,
                    futuresPrice: bybitFuturesPrice,
                    strategy: "Spot-to-Futures",
                    kucoinSpotPrices: [],
                    bybitSpotPrices: bybitPrices[pair] ?? [],
                    tradeAmount: bybitTradeAmount
                )
                await MainActor.run {
                    tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].totalProfit += bybitProfit
                    tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].totalFees += amount * (bybitTakerFee + bybitMakerFee) * 2
                    tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].wins += bybitProfit > 0 ? 1 : 0
                    performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].profit += bybitProfit
                    performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].fees += amount * (bybitTakerFee + bybitMakerFee) * 2
                    performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].trades += 1
                    performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].wins += bybitProfit > 0 ? 1 : 0
                    bybitBalance += bybitProfit - amount * (bybitTakerFee + bybitMakerFee) * 2
                    logTradeToCSV(pair: pair, strategy: "Spot-to-Futures", profit: bybitProfit, fees: amount * (bybitTakerFee + bybitMakerFee) * 2, tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trade_log.csv"))
                    print("DEBUG: Executed spot-futures arbitrage on Bybit for \(pair): Profit=\(bybitProfit)")
                    logAlert(event: "Executed spot-futures arbitrage on Bybit for \(pair): Profit=\(bybitProfit)")
                }
                completion(true)
            }
        }
    }
}


//-------------------------------------------------------------------------------------------------------------------------Block 17 - Cross-Exchange Arbitrage Execution


import Foundation

extension ExchangeWebSocket {
    static func checkCrossExchangeArbitrage(pair: String, strategy: String, amount: Double, completion: @escaping @Sendable (Bool) -> Void) async {
        let kucoinSpotPrice = await MainActor.run(body: { kucoinCurrentPrice[pair] }) ?? 0.0
        let bybitSpotPrice = await MainActor.run(body: { bybitCurrentPrice[pair] }) ?? 0.0
        let spread = abs(kucoinSpotPrice - bybitSpotPrice) / min(kucoinSpotPrice, bybitSpotPrice)
        let crossExchangeMinSpreadThresholdValue = await MainActor.run(body: { crossExchangeMinSpreadThreshold })
        let crossExchangeCooldownSecondsValue = await MainActor.run(body: { crossExchangeCooldownSeconds })
        
        guard spread >= crossExchangeMinSpreadThresholdValue else {
            print("DEBUG: Spread too low for cross-exchange arbitrage: \(pair), Spread: \(spread)")
            await MainActor.run(body: {
                logAlert(event: "Spread too low for cross-exchange arbitrage: \(pair), Spread: \(spread)")
            })
            completion(false)
            return
        }

        if let lastArb = await MainActor.run(body: { crossExchangeArbitrageExecuted[pair] }),
           Date().timeIntervalSince(lastArb.1) < crossExchangeCooldownSecondsValue {
            print("DEBUG: Cross-exchange arbitrage on cooldown for \(pair)")
            completion(false)
            return
        }

        let _ = await checkLiquidityAsyncUnique(exchange: "kucoin", pair: pair, marketType: "spot", tradeAmount: amount, price: kucoinSpotPrice) // Updated to checkLiquidityAsyncUnique
        let _ = await checkLiquidityAsyncUnique(exchange: "bybit", pair: pair, marketType: "spot", tradeAmount: amount, price: bybitSpotPrice) // Updated to checkLiquidityAsyncUnique
        
        let kucoinTradeAmount = await dynamicTradeAmount(balance: kucoinBalance, riskPercent: tradeAmountPercentage, volatility: 0.01, pair: pair) // Added pair
        let bybitTradeAmount = await dynamicTradeAmount(balance: bybitBalance, riskPercent: tradeAmountPercentage, volatility: 0.01, pair: pair) // Added pair
        let kellySize = await calculateKellyCriterion(pair: pair) // Added await and pair
        let baseTradeAmount = min(kucoinBalance, bybitBalance) * kellySize
        
        let _ = await checkLiquidityAsyncUnique(exchange: "kucoin", pair: pair, marketType: "spot", tradeAmount: baseTradeAmount, price: kucoinSpotPrice) ?? 0.0 // Updated to checkLiquidityAsyncUnique
        let _ = await checkLiquidityAsyncUnique(exchange: "bybit", pair: pair, marketType: "spot", tradeAmount: baseTradeAmount, price: bybitSpotPrice) ?? 0.0 // Updated to checkLiquidityAsyncUnique

        let kucoinFundingRate = await MainActor.run(body: { kucoinFundingRates[pair] }) ?? 0.0
        let bybitFundingRate = await MainActor.run(body: { bybitFundingRates[pair] }) ?? 0.0
        let maxFundingRateValue = await MainActor.run(body: { maxFundingRate })
        guard abs(kucoinFundingRate) < maxFundingRateValue && abs(bybitFundingRate) < maxFundingRateValue else {
            print("DEBUG: Funding rate too high for \(pair): KuCoin=\(kucoinFundingRate), Bybit=\(bybitFundingRate)")
            await MainActor.run(body: {
                logAlert(event: "Funding rate too high for \(pair): KuCoin=\(kucoinFundingRate), Bybit=\(bybitFundingRate)")
            })
            completion(false)
            return
        }

        let bybitDailyLossOk = await checkDailyLossLimit(exchange: "bybit", pair: pair, potentialLoss: bybitTradeAmount * bybitSpotPrice * spotStopLossPercentage)
        if !bybitDailyLossOk {
            print("DEBUG: Insufficient balance for cross-exchange arbitrage: \(pair)")
            await MainActor.run(body: {
                logAlert(event: "Insufficient balance for cross-exchange arbitrage: \(pair)")
            })
            completion(false)
            return
        }

        guard kucoinBalance >= kucoinTradeAmount * kucoinSpotPrice && bybitBalance >= bybitTradeAmount * bybitSpotPrice else {
            print("DEBUG: Insufficient balance for cross-exchange arbitrage: \(pair)")
            await MainActor.run(body: {
                logAlert(event: "Insufficient balance for cross-exchange arbitrage: \(pair)")
            })
            completion(false)
            return
        }

        let _ = await fetchSpreadPrediction(pair: pair, exchange: "kucoin", spotPrice: kucoinSpotPrice, futuresPrice: bybitSpotPrice) ?? 0.0

        await MainActor.run(body: {
            logTradeToCSV(pair: pair, strategy: strategy, profit: 0.0, fees: 0.0, tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trade_log.csv"))
        })

        let adjustedAmount = min(kucoinTradeAmount, bybitTradeAmount, amount)
        let kucoinFee = kucoinTradeAmount * kucoinSpotPrice * spotFeeRate
        let bybitFee = bybitTradeAmount * bybitSpotPrice * spotFeeRate
        let expectedProfit = spread * adjustedAmount * min(kucoinSpotPrice, bybitSpotPrice) - kucoinFee - bybitFee

        let spotMinProfitPercentageValue = await MainActor.run(body: { spotMinProfitPercentage })
        guard expectedProfit > spotMinProfitPercentageValue * adjustedAmount * min(kucoinSpotPrice, bybitSpotPrice) else {
            print("DEBUG: Expected profit too low for \(pair): \(expectedProfit)")
            await MainActor.run(body: {
                logAlert(event: "Expected profit too low for \(pair): \(expectedProfit)")
            })
            completion(false)
            return
        }

        let buyExchange = kucoinSpotPrice < bybitSpotPrice ? "kucoin" : "bybit"
        let sellExchange = kucoinSpotPrice < bybitSpotPrice ? "bybit" : "kucoin"
        let buyPrice = kucoinSpotPrice < bybitSpotPrice ? kucoinSpotPrice : bybitSpotPrice
        let sellPrice = kucoinSpotPrice < bybitSpotPrice ? bybitSpotPrice : kucoinSpotPrice

        let buyDailyLossOk = await checkDailyLossLimit(exchange: buyExchange, pair: pair, potentialLoss: adjustedAmount * buyPrice * spotStopLossPercentage)
        if !buyDailyLossOk {
            print("DEBUG: Buy order failed on \(buyExchange) for \(pair)")
            await MainActor.run(body: {
                logAlert(event: "Buy order failed on \(buyExchange) for \(pair)")
            })
            completion(false)
            return
        }

        let maxSlippageValue = await MainActor.run(body: { maxSlippage })
        let scalpStopLossValue = await MainActor.run(body: { scalpStopLoss })
        let maxActiveSpotTradesValue = await MainActor.run(body: { maxActiveSpotTrades })

        let buySuccess = await executeScalpingTrade(
            pair: pair,
            exchange: buyExchange,
            entryPrice: buyPrice * (1 + maxSlippageValue),
            targetPrice: sellPrice,
            stopPrice: buyPrice * (1 - scalpStopLossValue),
            tradeAmount: adjustedAmount,
            maxActiveTrades: maxActiveSpotTradesValue
        )
        guard buySuccess else {
            print("DEBUG: Buy order failed on \(buyExchange) for \(pair)")
            await MainActor.run(body: {
                logAlert(event: "Buy order failed on \(buyExchange) for \(pair)")
            })
            completion(false)
            return
        }

        let sellSuccess = await executeScalpingTrade(
            pair: pair,
            exchange: sellExchange,
            entryPrice: sellPrice * (1 - maxSlippageValue),
            targetPrice: buyPrice,
            stopPrice: sellPrice * (1 + scalpStopLossValue),
            tradeAmount: adjustedAmount,
            maxActiveTrades: maxActiveSpotTradesValue
        )
        guard sellSuccess else {
            print("DEBUG: Sell order failed on \(sellExchange) for \(pair)")
            await MainActor.run(body: {
                logAlert(event: "Sell order failed on \(sellExchange) for \(pair)")
            })
            completion(false)
            return
        }

        let profit = (sellPrice - buyPrice) * adjustedAmount - kucoinFee - bybitFee
        await MainActor.run(body: {
            tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].totalProfit += profit
            tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].totalFees += (kucoinFee + bybitFee)
            if profit > 0 {
                tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].wins += 1
            } else {
                tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].losses += 1
            }
            performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].profit += profit
            performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].fees += (kucoinFee + bybitFee)
            performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].trades += 1
            if profit > 0 {
                performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].wins += 1
            }

            kucoinBalance -= kucoinFee
            bybitBalance -= bybitFee
            if buyExchange == "kucoin" {
                kucoinBalance -= buyPrice * adjustedAmount
                bybitBalance += sellPrice * adjustedAmount
            } else {
                bybitBalance -= buyPrice * adjustedAmount
                kucoinBalance += sellPrice * adjustedAmount
            }

            crossExchangeArbitrageExecuted[pair] = (true, Date())
        })

        let timestamp = ISO8601DateFormatter().string(from: Date())
        let logEntry = "\(timestamp),\(pair),\(buyExchange),buy,\(buyPrice),\(sellExchange),sell,\(sellPrice),\(adjustedAmount),\(profit),\(kucoinFee + bybitFee)\n"
        let tradeLogURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trade_log.csv")
        do {
            let fileManager = FileManager.default
            if !fileManager.fileExists(atPath: tradeLogURL.path) {
                try "timestamp,pair,buyExchange,buySide,buyPrice,sellExchange,sellSide,sellPrice,amount,profit,fees\n".write(to: tradeLogURL, atomically: true, encoding: .utf8)
                try fileManager.setAttributes([.posixPermissions: 0o644], ofItemAtPath: tradeLogURL.path)
            }
            if let fileHandle = try? FileHandle(forWritingTo: tradeLogURL) {
                defer { fileHandle.closeFile() }
                if let data = logEntry.data(using: .utf8) {
                    fileHandle.seekToEndOfFile()
                    fileHandle.write(data)
                }
            } else {
                let fileHandle = try FileHandle(forWritingTo: tradeLogURL)
                defer { fileHandle.closeFile() }
                if let data = logEntry.data(using: .utf8) {
                    fileHandle.seekToEndOfFile()
                    fileHandle.write(data)
                }
            }
            print("DEBUG: Logged cross-exchange arbitrage trade to trade_log.csv: \(logEntry.trimmingCharacters(in: .whitespacesAndNewlines))")
        } catch {
            print("DEBUG: Failed to log cross-exchange arbitrage trade: \(error.localizedDescription)")
            await MainActor.run(body: {
                logAlert(event: "Failed to log cross-exchange arbitrage trade: \(error.localizedDescription)")
            })
        }

        print("DEBUG: Executed cross-exchange arbitrage for \(pair): Profit=\(profit), Fees=\(kucoinFee + bybitFee)")
        await MainActor.run(body: {
            logAlert(event: "Executed cross-exchange arbitrage for \(pair): Profit=\(profit), Fees=\(kucoinFee + bybitFee)")
        })
        completion(true)
    }
}




//---------------------------------------------------------------------------------------------------------------Block 18 - Market Making Operations


extension ExchangeWebSocket {
    static func monitorHFTScalpingOpportunities() {
        let localKucoinOrderBooks = kucoinOrderBooks
        let localBybitOrderBooks = bybitOrderBooks
        let localTradingPairs = tradingPairs

        print("DEBUG: Compiling monitorHFTScalpingOpportunities at \(ISO8601DateFormatter().string(from: Date()))")

        // Helper function to fetch market data
        func fetchMarketData(pair: String) async -> (
            kucoinSpotPrice: Double, bybitSpotPrice: Double,
            kucoinSpotPrices: [Double], bybitSpotPrices: [Double],
            kucoinVolumes: [Double], bybitVolumes: [Double],
            kucoinEvents: [(timestamp: Date, level: Int, volume: Double)],
            bybitEvents: [(timestamp: Date, level: Int, volume: Double)],
            sentiment: Double, activeTrades: Int
        ) {
            let kucoinCurrentPriceValue = await MainActor.run { kucoinCurrentPrice }
            let bybitCurrentPriceValue = await MainActor.run { bybitCurrentPrice }
            let kucoinPricesValue = await MainActor.run { kucoinPrices }
            let bybitPricesValue = await MainActor.run { bybitPrices }
            let kucoinSpotVolumeValue = await MainActor.run { kucoinSpotVolume }
            let bybitSpotVolumeValue = await MainActor.run { bybitSpotVolume }
            let kucoinOrderBookEventsValue = await MainActor.run { kucoinOrderBookEvents }
            let orderCancellationEventsValue = await MainActor.run { orderCancellationEvents }
            let sentimentScoresValue = await MainActor.run { sentimentScores }
            let activeSpotTradesValue = await MainActor.run { activeSpotTrades }

            print("DEBUG: fetchMarketData for \(pair): kucoinCurrentPrice[\(pair)]=\(kucoinCurrentPriceValue[pair] ?? 0.0), bybitCurrentPrice[\(pair)]=\(bybitCurrentPriceValue[pair] ?? 0.0), kucoinIsConnected=\(kucoinIsConnected), bybitIsConnected=\(bybitIsConnected)")

            return (
                kucoinSpotPrice: kucoinCurrentPriceValue[pair] ?? 0.0,
                bybitSpotPrice: bybitCurrentPriceValue[pair] ?? 0.0,
                kucoinSpotPrices: kucoinPricesValue[pair] ?? [],
                bybitSpotPrices: bybitPricesValue[pair] ?? [],
                kucoinVolumes: kucoinSpotVolumeValue[pair] ?? [],
                bybitVolumes: bybitSpotVolumeValue[pair] ?? [],
                kucoinEvents: kucoinOrderBookEventsValue[pair] ?? [],
                bybitEvents: orderCancellationEventsValue[pair] ?? [],
                sentiment: sentimentScoresValue[pair] ?? 0.0,
                activeTrades: activeSpotTradesValue[pair] ?? 0
            )
        }

        // Helper function to check trade conditions
        func checkTradeConditions(
            pair: String,
            kucoinSpotPrice: Double,
            bybitSpotPrice: Double,
            kucoinSpotPrices: [Double],
            bybitSpotPrices: [Double],
            kucoinVolumes: [Double],
            bybitVolumes: [Double],
            kucoinEvents: [(timestamp: Date, level: Int, volume: Double)],
            bybitEvents: [(timestamp: Date, level: Int, volume: Double)],
            activeTrades: Int
        ) async -> Bool {
            let volatilityPauseActiveValue = await MainActor.run { volatilityPauseActive }
            let isTradingPausedValue = await MainActor.run { isTradingPaused }
            guard !volatilityPauseActiveValue else {
                print("DEBUG: HFT Scalping paused due to volatility for \(pair)")
                return false
            }
            guard !(isTradingPausedValue[pair] ?? false) else {
                print("DEBUG: HFT Scalping paused for \(pair) due to manual pause")
                return false
            }
            guard !(await MainActor.run { kucoinInSpotTrade[pair] ?? false }) else {
                print("DEBUG: HFT Scalping skipped for \(pair) due to active KuCoin trade")
                return false
            }
            guard kucoinSpotPrice > 0, bybitSpotPrice > 0 else {
                print("DEBUG: Invalid prices for HFT Scalping - KuCoin: \(kucoinSpotPrice), Bybit: \(bybitSpotPrice)")
                await MainActor.run {
                    logAlert(event: "Invalid prices for HFT Scalping - KuCoin: \(kucoinSpotPrice), Bybit: \(bybitSpotPrice)")
                }
                return false
            }

            let spotTradeAmountValue = await MainActor.run { spotTradeAmount }
            let minLiquidityThresholdValue = await MainActor.run { minLiquidityThreshold }
            let _ = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "spot", tradeAmount: spotTradeAmountValue, price: kucoinSpotPrice) ?? 0.0
            let _ = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "futures", tradeAmount: spotTradeAmountValue, price: kucoinSpotPrice) ?? 0.0
            let _ = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "spot", tradeAmount: spotTradeAmountValue, price: bybitSpotPrice) ?? 0.0
            let _ = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "futures", tradeAmount: spotTradeAmountValue, price: bybitSpotPrice) ?? 0.0
            print("DEBUG: Min liquidity threshold for \(pair): \(minLiquidityThresholdValue)")

            let calculateImbalances: (String) async -> (Double, Double) = { pair in
                let kucoinBookRaw = await MainActor.run { localKucoinOrderBooks[pair] } ?? BevaixOrderBook(bids: [], asks: [])
                let bybitBookRaw = await MainActor.run { localBybitOrderBooks[pair] } ?? BevaixOrderBook(bids: [], asks: [])
                let kucoinBook = kucoinBookRaw
                let bybitBook = bybitBookRaw
                
                let kucoinTotalBidVolume: Double = kucoinBook.bids.reduce(0.0) { $0 + $1.quantity }
                let kucoinTotalAskVolume: Double = kucoinBook.asks.reduce(0.0) { $0 + $1.quantity }
                let kucoinImbalance: Double = kucoinTotalBidVolume > 0 ? kucoinTotalAskVolume / kucoinTotalBidVolume : 1.0
                
                let bybitTotalBidVolume: Double = bybitBook.bids.reduce(0.0) { $0 + $1.quantity }
                let bybitTotalAskVolume: Double = bybitBook.asks.reduce(0.0) { $0 + $1.quantity }
                let bybitImbalance: Double = bybitTotalBidVolume > 0 ? bybitTotalAskVolume / bybitTotalBidVolume : 1.0
                
                return (kucoinImbalance, bybitImbalance)
            }
            let (kucoinImbalance, bybitImbalance) = await calculateImbalances(pair)
            let orderBookImbalanceThresholdValue = getDouble("ORDER_BOOK_IMBALANCE_THRESHOLD", defaultValue: 2.0)
            guard kucoinImbalance < orderBookImbalanceThresholdValue, bybitImbalance < orderBookImbalanceThresholdValue else {
                print("DEBUG: Order book imbalance too high for \(pair): KuCoin=\(kucoinImbalance), Bybit=\(bybitImbalance), Threshold=\(orderBookImbalanceThresholdValue)")
                await MainActor.run {
                    logAlert(event: "Order book imbalance too high for \(pair): KuCoin=\(kucoinImbalance), Bybit=\(bybitImbalance)")
                }
                return false
            }

            let maxActiveSpotTradesValue = await MainActor.run { maxActiveSpotTrades }
            guard activeTrades < maxActiveSpotTradesValue else {
                print("DEBUG: Max active spot trades reached for \(pair): \(activeTrades)")
                return false
            }

            let spoofingThreshold = await MainActor.run { spoofingVolumeThreshold * 2.0 }
            let spoofingDetected = kucoinEvents.filter { Date().timeIntervalSince($0.timestamp) < 60 }.count > 2 && kucoinEvents.contains(where: { $0.volume > spoofingThreshold }) ||
                                   bybitEvents.filter { Date().timeIntervalSince($0.timestamp) < 60 }.count > 2 && bybitEvents.contains(where: { $0.volume > spoofingThreshold })
            guard !spoofingDetected else {
                print("DEBUG: Order book spoofing detected for \(pair), Threshold=\(spoofingThreshold)")
                await MainActor.run {
                    logAlert(event: "Order book spoofing detected for \(pair)")
                }
                return false
            }

            let volumeSpikeThreshold = getDouble("VOLUME_SPIKE_THRESHOLD", defaultValue: 1.5)
            let volumeSpike = (kucoinVolumes.last ?? 0.0) / (kucoinVolumes.isEmpty ? 1.0 : kucoinVolumes.reduce(0.0, +) / Double(kucoinVolumes.count)) > volumeSpikeThreshold ||
                              (bybitVolumes.last ?? 0.0) / (bybitVolumes.isEmpty ? 1.0 : bybitVolumes.reduce(0.0, +) / Double(kucoinVolumes.count)) > volumeSpikeThreshold
            guard !volumeSpike else {
                print("DEBUG: Volume spike detected for \(pair)")
                await MainActor.run {
                    logAlert(event: "Volume spike detected for \(pair)")
                }
                return false
            }

            return true
        }

        // Helper function to calculate indicators
        func calculateIndicators(
            kucoinSpotPrices: [Double],
            bybitSpotPrices: [Double]
        ) async -> (
            kucoinSpotEmaShort: Double, kucoinSpotEmaLong: Double,
            bybitSpotEmaShort: Double, bybitSpotEmaLong: Double,
            kucoinSpotRsi: Double, bybitSpotRsi: Double,
            kucoinMacd: (macd: Double, signal: Double, histogram: Double),
            bybitMacd: (macd: Double, signal: Double, histogram: Double)
        ) {
            let spotEmaShortPeriodValue = await MainActor.run { spotEmaShortPeriod }
            let spotEmaLongPeriodValue = await MainActor.run { spotEmaLongPeriod }
            let spotRsiPeriodValue = await MainActor.run { spotRsiPeriod }
            let macdShortPeriodValue = await MainActor.run { macdShortPeriod }
            let macdLongPeriodValue = await MainActor.run { macdLongPeriod }
            let macdSignalPeriodValue = await MainActor.run { macdSignalPeriod }

            return (
                kucoinSpotEmaShort: calculateEMA(prices: kucoinSpotPrices, period: spotEmaShortPeriodValue) ?? 0.0,
                kucoinSpotEmaLong: calculateEMA(prices: kucoinSpotPrices, period: spotEmaLongPeriodValue) ?? 0.0,
                bybitSpotEmaShort: calculateEMA(prices: bybitSpotPrices, period: spotEmaShortPeriodValue) ?? 0.0,
                bybitSpotEmaLong: calculateEMA(prices: bybitSpotPrices, period: spotEmaLongPeriodValue) ?? 0.0,
                kucoinSpotRsi: calculateRSI(prices: kucoinSpotPrices, period: spotRsiPeriodValue) ?? 50.0,
                bybitSpotRsi: calculateRSI(prices: bybitSpotPrices, period: spotRsiPeriodValue) ?? 50.0,
                kucoinMacd: calculateMACD(prices: kucoinSpotPrices, shortPeriod: macdShortPeriodValue, longPeriod: macdLongPeriodValue, signalPeriod: macdSignalPeriodValue) ?? (macd: 0.0, signal: 0.0, histogram: 0.0),
                bybitMacd: calculateMACD(prices: bybitSpotPrices, shortPeriod: macdShortPeriodValue, longPeriod: macdLongPeriodValue, signalPeriod: macdSignalPeriodValue) ?? (macd: 0.0, signal: 0.0, histogram: 0.0)
            )
        }

        // Helper function to execute trade
        func executeTrade(
            exchange: String,
            pair: String,
            spotPrice: Double,
            tradeAmount: Double,
            buySignal: Bool,
            sellSignal: Bool,
            sentiment: Double,
            isBalanceSufficient: Bool,
            isWithinLossLimit: Bool,
            maxActiveSpotTradesValue: Int
        ) async {
            let scalpEntryThresholdValue = await MainActor.run { scalpEntryThreshold }
            let scalpProfitTargetValue = await MainActor.run { scalpProfitTarget }
            let scalpStopLossValue = await MainActor.run { scalpStopLoss }

            if buySignal && isBalanceSufficient && sentiment > 0.0 && isWithinLossLimit {
                let predictedSpread = await fetchSpreadPrediction(pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: spotPrice) ?? 0.0
                await MainActor.run {
                    print("DEBUG: Predicted spread for \(exchange.capitalized) \(pair): \(predictedSpread)")
                    logHistoricalTradeToCSV(pair: pair, strategy: "HFT-Scalping", profit: 0.0, fees: 0.0)
                }
                let success = await executeScalpingTrade(
                    pair: pair,
                    exchange: exchange,
                    entryPrice: spotPrice * (1 + scalpEntryThresholdValue),
                    targetPrice: spotPrice * (1 + scalpProfitTargetValue),
                    stopPrice: spotPrice * (1 - scalpStopLossValue),
                    tradeAmount: tradeAmount,
                    maxActiveTrades: maxActiveSpotTradesValue
                )
                if success {
                    await MainActor.run {
                        activeSpotTrades[pair] = (activeSpotTrades[pair] ?? 0) + 1
                        if exchange == "kucoin" {
                            kucoinInSpotTrade[pair] = true
                            kucoinSpotEntryPrice[pair] = spotPrice
                        } else {
                            bybitInSpotTrade[pair] = true
                            bybitSpotEntryPrice[pair] = spotPrice
                        }
                    }
                    print("DEBUG: Executed HFT scalping buy on \(exchange.capitalized) for \(pair) at \(spotPrice)")
                    await MainActor.run {
                        logAlert(event: "Executed HFT scalping buy on \(exchange.capitalized) for \(pair) at \(spotPrice)")
                    }
                }
            } else if sellSignal && isBalanceSufficient && sentiment < 0.0 {
                let predictedSpread = await fetchSpreadPrediction(pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: spotPrice) ?? 0.0
                await MainActor.run {
                    print("DEBUG: Predicted spread for \(exchange.capitalized) \(pair): \(predictedSpread)")
                    logHistoricalTradeToCSV(pair: pair, strategy: "HFT-Scalping", profit: 0.0, fees: 0.0)
                }
                let success = await executeScalpingTrade(
                    pair: pair,
                    exchange: exchange,
                    entryPrice: spotPrice * (1 - scalpEntryThresholdValue),
                    targetPrice: spotPrice * (1 - scalpProfitTargetValue),
                    stopPrice: spotPrice * (1 + scalpStopLossValue),
                    tradeAmount: tradeAmount,
                    maxActiveTrades: maxActiveSpotTradesValue
                )
                if success {
                    await MainActor.run {
                        activeSpotTrades[pair] = (activeSpotTrades[pair] ?? 0) + 1
                        if exchange == "kucoin" {
                            kucoinInSpotTrade[pair] = true
                            kucoinSpotEntryPrice[pair] = spotPrice
                        } else {
                            bybitInSpotTrade[pair] = true
                            bybitSpotEntryPrice[pair] = spotPrice
                        }
                    }
                    print("DEBUG: Executed HFT scalping sell on \(exchange.capitalized) for \(pair) at \(spotPrice)")
                    await MainActor.run {
                        logAlert(event: "Executed HFT scalping sell on \(exchange.capitalized) for \(pair) at \(spotPrice)")
                    }
                }
            }
        }

        Task {
            while true {
                await withTaskGroup(of: Void.self) { group in
                    let tradingPairsValue = await MainActor.run { localTradingPairs }
                    for pair in tradingPairsValue {
                        group.addTask {
                            let marketData = await fetchMarketData(pair: pair)
                            guard await checkTradeConditions(
                                pair: pair,
                                kucoinSpotPrice: marketData.kucoinSpotPrice,
                                bybitSpotPrice: marketData.bybitSpotPrice,
                                kucoinSpotPrices: marketData.kucoinSpotPrices,
                                bybitSpotPrices: marketData.bybitSpotPrices,
                                kucoinVolumes: marketData.kucoinVolumes,
                                bybitVolumes: marketData.bybitVolumes,
                                kucoinEvents: marketData.kucoinEvents,
                                bybitEvents: marketData.bybitEvents,
                                activeTrades: marketData.activeTrades
                            ) else {
                                return
                            }

                            let indicators = await calculateIndicators(
                                kucoinSpotPrices: marketData.kucoinSpotPrices,
                                bybitSpotPrices: marketData.bybitSpotPrices
                            )

                            if marketData.kucoinSpotPrice > 0 && marketData.bybitSpotPrice > 0 {
                                let spread = abs(marketData.kucoinSpotPrice - marketData.bybitSpotPrice) / min(marketData.kucoinSpotPrice, marketData.bybitSpotPrice)
                                let predictedSpread = await fetchSpreadPrediction(pair: pair, exchange: "kucoin", spotPrice: marketData.kucoinSpotPrice, futuresPrice: marketData.bybitSpotPrice) ?? 0.0
                                await MainActor.run {
                                    saveHistoricalSpreadsToCSV(pair: pair, spread: spread, predictedSpreadChange: predictedSpread)
                                }
                            } else {
                                print("DEBUG: Skipping spread logging for \(pair) due to invalid prices: KuCoin=\(marketData.kucoinSpotPrice), Bybit=\(marketData.bybitSpotPrice)")
                                await MainActor.run {
                                    logAlert(event: "Skipping spread logging for \(pair) due to invalid prices: KuCoin=\(marketData.kucoinSpotPrice), Bybit=\(marketData.bybitSpotPrice)")
                                }
                            }

                            let spotRsiLowerThresholdValue = await MainActor.run { spotRsiLowerThreshold }
                            let spotRsiUpperThresholdValue = await MainActor.run { spotRsiUpperThreshold }
                            let macdConfirmationThresholdValue = await MainActor.run { macdConfirmationThreshold }

                            let kucoinBuySignal = indicators.kucoinSpotEmaShort > indicators.kucoinSpotEmaLong &&
                                                  indicators.kucoinSpotRsi < spotRsiLowerThresholdValue &&
                                                  indicators.kucoinMacd.histogram > macdConfirmationThresholdValue
                            let kucoinSellSignal = indicators.kucoinSpotEmaShort < indicators.kucoinSpotEmaLong &&
                                                   indicators.kucoinSpotRsi > spotRsiUpperThresholdValue &&
                                                   indicators.kucoinMacd.histogram < -macdConfirmationThresholdValue
                            let bybitBuySignal = indicators.bybitSpotEmaShort > indicators.bybitSpotEmaLong &&
                                                 indicators.bybitSpotRsi < spotRsiLowerThresholdValue &&
                                                 indicators.bybitMacd.histogram > macdConfirmationThresholdValue
                            let bybitSellSignal = indicators.bybitSpotEmaShort < indicators.bybitSpotEmaLong &&
                                                  indicators.bybitSpotRsi > spotRsiUpperThresholdValue &&
                                                  indicators.bybitMacd.histogram < -macdConfirmationThresholdValue

                            let kucoinBalanceLocal = await MainActor.run { kucoinBalance }
                            let bybitBalanceLocal = await MainActor.run { bybitBalance }

                            let kucoinVolatility: Double
                            if marketData.kucoinSpotPrices.count >= 2 {
                                let returns = zip(marketData.kucoinSpotPrices.dropFirst(), marketData.kucoinSpotPrices).map { log($0 / $1) }
                                let mean = returns.reduce(0.0, +) / Double(returns.count)
                                let variance = returns.reduce(0.0) { $0 + pow($1 - mean, 2) } / Double(returns.count)
                                kucoinVolatility = sqrt(variance)
                            } else {
                                kucoinVolatility = 0.01
                            }
                            let kucoinTradeAmount = await dynamicTradeAmount(balance: kucoinBalanceLocal, riskPercent: tradeAmountPercentage, volatility: kucoinVolatility)

                            let bybitVolatility: Double
                            if marketData.bybitSpotPrices.count >= 2 {
                                let returns = zip(marketData.bybitSpotPrices.dropFirst(), marketData.bybitSpotPrices).map { log($0 / $1) }
                                let mean = returns.reduce(0.0, +) / Double(returns.count)
                                let variance = returns.reduce(0.0) { $0 + pow($1 - mean, 2) } / Double(returns.count)
                                bybitVolatility = sqrt(variance)
                            } else {
                                bybitVolatility = 0.01
                            }
                            let bybitTradeAmount = await dynamicTradeAmount(balance: bybitBalanceLocal, riskPercent: tradeAmountPercentage, volatility: bybitVolatility)

                            let isBalanceSufficientKucoin = kucoinBalanceLocal >= kucoinTradeAmount * marketData.kucoinSpotPrice
                            let isWithinLossLimitKucoin = await checkDailyLossLimit(exchange: "kucoin", pair: pair, potentialLoss: kucoinTradeAmount * marketData.kucoinSpotPrice * spotStopLossPercentage)
                            await executeTrade(
                                exchange: "kucoin",
                                pair: pair,
                                spotPrice: marketData.kucoinSpotPrice,
                                tradeAmount: kucoinTradeAmount,
                                buySignal: kucoinBuySignal,
                                sellSignal: kucoinSellSignal,
                                sentiment: marketData.sentiment,
                                isBalanceSufficient: isBalanceSufficientKucoin,
                                isWithinLossLimit: isWithinLossLimitKucoin,
                                maxActiveSpotTradesValue: await MainActor.run { maxActiveSpotTrades }
                            )

                            let isBalanceSufficientBybit = bybitBalanceLocal >= bybitTradeAmount * marketData.bybitSpotPrice
                            let isWithinLossLimitBybit = await checkDailyLossLimit(exchange: "bybit", pair: pair, potentialLoss: bybitTradeAmount * marketData.bybitSpotPrice * spotStopLossPercentage)
                            await executeTrade(
                                exchange: "bybit",
                                pair: pair,
                                spotPrice: marketData.bybitSpotPrice,
                                tradeAmount: bybitTradeAmount,
                                buySignal: bybitBuySignal,
                                sellSignal: bybitSellSignal,
                                sentiment: marketData.sentiment,
                                isBalanceSufficient: isBalanceSufficientBybit,
                                isWithinLossLimit: isWithinLossLimitBybit,
                                maxActiveSpotTradesValue: await MainActor.run { maxActiveSpotTrades }
                            )
                        }
                    }
                }
                try? await Task.sleep(nanoseconds: UInt64(getDouble("HFT_CHECK_INTERVAL_SECONDS", defaultValue: 0.5) * 1_000_000_000))
            }
        }
    }
}

//--------------------------------------------------------------------------------------------------------------Block 19 - Machine Learning Prediction Engine


import Foundation // Added for String.Encoding and other Foundation types


extension ExchangeWebSocket {
    @MainActor static var kucoinRunningProfitLoss: Double = 0.0
    @MainActor static var bybitRunningProfitLoss: Double = 0.0
    static var hftLastTradeTime: [String: (exchange: String, timestamp: Date)] = [:]

    static func evaluateHFTStrategy(pair: String, kucoinSpotRsi: Double, bybitSpotRsi: Double) async {
        let kucoinSpotPrice = await MainActor.run(body: { kucoinCurrentPrice[pair] }) ?? 0.0
        let bybitSpotPrice = await MainActor.run(body: { bybitCurrentPrice[pair] }) ?? 0.0
        let kucoinSpotPrices = await MainActor.run(body: { kucoinPrices[pair] }) ?? []
        let bybitSpotPrices = await MainActor.run(body: { bybitPrices[pair] }) ?? []
        let kucoinBalanceValue = kucoinBalance
        let kucoinRunningProfitLossValue = kucoinRunningProfitLoss
        let bybitBalanceValue = bybitBalance
        let bybitRunningProfitLossValue = bybitRunningProfitLoss
        let kucoinLastTrade = await MainActor.run(body: { hftLastTradeTime["kucoin_\(pair)"] })
        let bybitLastTrade = await MainActor.run(body: { hftLastTradeTime["bybit_\(pair)"] })
        let scalpEntryThreshold: Double = getDouble("SCALP_ENTRY_THRESHOLD", defaultValue: 0.0006)
        let scalpExitThreshold: Double = getDouble("SCALP_PROFIT_TARGET", defaultValue: 0.0012)
        let rsiOverboughtThreshold: Double = getDouble("SPOT_RSI_UPPER_THRESHOLD", defaultValue: 70.0)
        let rsiOversoldThreshold: Double = getDouble("SPOT_RSI_LOWER_THRESHOLD", defaultValue: 30.0)

        func executeHFTTrade(exchange: String, price: Double, prices: [Double], balance: Double, runningProfitLoss: Double, rsi: Double) async -> (newBalance: Double, newRunningProfitLoss: Double) {
            var balanceLocal = balance
            var runningProfitLossLocal = runningProfitLoss
            let priceChange = prices.count >= 2 ? (price - prices[prices.count - 2]) / prices[prices.count - 2] : 0.0
            let kellySize = await calculateKellyCriterion(pair: pair)
            let baseTradeAmount = min(balanceLocal * getDouble("HFT_MAX_BALANCE_PERCENTAGE", defaultValue: 0.3), getDouble("HFT_TRADE_AMOUNT", defaultValue: 100.0))
            let targetNetProfit = getDouble("TARGET_NET_PROFIT", defaultValue: 0.20)
            let makerFee = exchange == "kucoin" ? kucoinMakerFee : bybitMakerFee
            let takerFee = exchange == "kucoin" ? kucoinTakerFee : bybitTakerFee
            let orderType = environment["HFT_ORDER_TYPE"]?.lowercased() ?? "market"
            let feeRate = orderType == "limit" ? makerFee : takerFee
            let minPriceMove = scalpExitThreshold + (feeRate * 2)
            let tradeAmount = targetNetProfit / minPriceMove * price * kellySize
            let trailingStopPercentage = getDouble("HFT_TRAILING_STOP_PERCENTAGE", defaultValue: 0.03)

            guard tradeAmount <= baseTradeAmount else {
                print("DEBUG: Trade amount exceeds base trade amount for \(exchange)-\(pair): TradeAmount=\(tradeAmount), BaseTradeAmount=\(baseTradeAmount)")
                await MainActor.run(body: {
                    logAlert(event: "Trade amount exceeds base trade amount for \(exchange)-\(pair): TradeAmount=\(tradeAmount), BaseTradeAmount=\(baseTradeAmount)")
                })
                return (balanceLocal, runningProfitLossLocal)
            }

            guard balanceLocal >= tradeAmount * price else {
                print("DEBUG: Insufficient balance for \(exchange)-\(pair): Available \(balanceLocal), Required \(tradeAmount * price)")
                await MainActor.run(body: {
                    logAlert(event: "Insufficient balance for \(exchange)-\(pair): Available \(balanceLocal), Required \(tradeAmount * price)")
                })
                return (balanceLocal, runningProfitLossLocal)
            }

            guard let book = await MainActor.run(body: { exchange == "kucoin" ? kucoinOrderBooks[pair] : bybitOrderBooks[pair] }),
                  let entryPrice = book.bids.first?.price,
                  abs(price - entryPrice) / entryPrice < getDouble("MAX_SLIPPAGE", defaultValue: 0.005) else {
                print("DEBUG: HFT Trade skipped for \(exchange)-\(pair): Slippage too high or invalid order book")
                return (balanceLocal, runningProfitLossLocal)
            }

            if priceChange >= scalpEntryThreshold && tradeAmount > 0 && balanceLocal >= tradeAmount && rsi < rsiOverboughtThreshold && rsi >= rsiOversoldThreshold {
                let entryPrice = price
                var exitPrice: Double = 0.0
                let startTime = Date()

                while Date().timeIntervalSince(startTime) <= getDouble("HFT_MAX_TRADE_DURATION_SECONDS", defaultValue: 20.0) {
                    let currentPrice = await MainActor.run(body: { exchange == "kucoin" ? kucoinCurrentPrice[pair] : bybitCurrentPrice[pair] }) ?? entryPrice
                    if currentPrice > 0 {
                        let peakPrice = max(entryPrice, currentPrice)
                        let priceDiff = (currentPrice - entryPrice) / entryPrice
                        let dropFromPeak = (peakPrice - currentPrice) / peakPrice
                        if priceDiff >= scalpExitThreshold || priceDiff <= -getDouble("SCALP_STOP_LOSS", defaultValue: 0.0015) || dropFromPeak >= trailingStopPercentage {
                            exitPrice = currentPrice
                            break
                        }
                    }
                    try? await Task.sleep(nanoseconds: 50_000_000) // 50ms
                }

                if exitPrice == 0.0 {
                    exitPrice = await MainActor.run(body: { exchange == "kucoin" ? kucoinCurrentPrice[pair] : bybitCurrentPrice[pair] }) ?? entryPrice
                }

                let quantity = tradeAmount / entryPrice
                let grossProfit = (exitPrice - entryPrice) * quantity
                let fees = tradeAmount * feeRate * 2
                let feeBuffer = fees * 1.2
                let netProfit = grossProfit - fees

                if netProfit <= feeBuffer {
                    print("INFO: HFT Trade skipped for \(exchange)-\(pair): Net profit (\(netProfit)) does not exceed fee buffer (\(feeBuffer))")
                    return (balanceLocal, runningProfitLossLocal)
                }

                balanceLocal += netProfit
                runningProfitLossLocal += netProfit

                let isWin = netProfit > 0
                if var metrics = await MainActor.run(body: { tradeMetrics[pair] }) {
                    metrics.wins += isWin ? 1 : 0
                    metrics.losses += isWin ? 0 : 1
                    metrics.totalProfit += netProfit
                    metrics.totalFees += fees
                    await MainActor.run(body: { tradeMetrics[pair] = metrics })
                }
                if var perfMetrics = await MainActor.run(body: { performanceMetrics[pair] }) {
                    perfMetrics.trades += 1
                    perfMetrics.wins += isWin ? 1 : 0
                    perfMetrics.profit += netProfit
                    perfMetrics.fees += fees
                    await MainActor.run(body: { performanceMetrics[pair] = perfMetrics })
                }

                print("INFO: \(exchange.capitalized) HFT Trade for \(pair): Type: Scalp, Amount: \(tradeAmount) USDT, Entry: \(entryPrice), Exit: \(exitPrice), Gross Profit: \(grossProfit), Fees: \(fees), Net Profit: \(netProfit), Running P/L: \(runningProfitLossLocal), Balance: \(balanceLocal)")
                
                await MainActor.run(body: { hftLastTradeTime["\(exchange)_\(pair)"] = (exchange, Date()) })
                ExchangeWebSocket.sendTradeToFlaskServer(
                    strategy: "HFT-Scalp",
                    pair: pair,
                    exchange: exchange,
                    spotPrice: entryPrice,
                    futuresPrice: exitPrice,
                    tradeAmount: tradeAmount,
                    profit: netProfit
                )

                let timestamp = ISO8601DateFormatter().string(from: Date())
                let logEntry = "\(timestamp),HFT-Scalp,\(pair),\(exchange),\(entryPrice),\(exitPrice),\(tradeAmount),\(netProfit),\(fees)\n"
                let tradesCSVURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trade_log.csv")
                do {
                    let fileManager = FileManager.default
                    let directoryURL = tradesCSVURL.deletingLastPathComponent()
                    if !fileManager.fileExists(atPath: directoryURL.path) {
                        try fileManager.createDirectory(at: directoryURL, withIntermediateDirectories: true)
                    }
                    if !fileManager.fileExists(atPath: tradesCSVURL.path) {
                        let header = "timestamp,strategy,pair,exchange,entry_price,exit_price,trade_amount,net_profit,fees\n"
                        try header.write(to: tradesCSVURL, atomically: true, encoding: .utf8)
                    }
                    if let fileHandle = try? FileHandle(forWritingTo: tradesCSVURL) {
                        defer { fileHandle.closeFile() }
                        if let data = logEntry.data(using: .utf8) {
                            fileHandle.seekToEndOfFile()
                            fileHandle.write(data)
                        }
                    } else {
                        let existingContent = (try? String(contentsOf: tradesCSVURL, encoding: .utf8)) ?? ""
                        let newContent = existingContent + logEntry
                        try newContent.write(to: tradesCSVURL, atomically: true, encoding: .utf8)
                    }
                } catch {
                    print("DEBUG: Failed to log trade to CSV: \(error.localizedDescription)")
                    await MainActor.run(body: {
                        logAlert(event: "Failed to log trade to CSV: \(error.localizedDescription)")
                    })
                }
            }
            return (balanceLocal, runningProfitLossLocal)
        }

        if let lastKucoinTrade = kucoinLastTrade, lastKucoinTrade.exchange == "kucoin" {
            let timeSinceLastTrade = Date().timeIntervalSince(lastKucoinTrade.timestamp)
            if timeSinceLastTrade < hftCooldownSeconds {
                print("INFO: KuCoin HFT on cooldown for \(pair): \(Int(hftCooldownSeconds - timeSinceLastTrade)) seconds remaining")
            } else {
                if kucoinSpotPrice > 0 && kucoinSpotPrices.count >= spotEmaShortPeriod {
                    let (newKucoinBalance, newKucoinRunningProfitLoss) = await executeHFTTrade(
                        exchange: "kucoin",
                        price: kucoinSpotPrice,
                        prices: kucoinSpotPrices,
                        balance: kucoinBalanceValue,
                        runningProfitLoss: kucoinRunningProfitLossValue,
                        rsi: kucoinSpotRsi
                    )
                    kucoinBalance = newKucoinBalance
                    kucoinRunningProfitLoss = newKucoinRunningProfitLoss
                }
            }
        } else {
            if kucoinSpotPrice > 0 && kucoinSpotPrices.count >= spotEmaShortPeriod {
                let (newKucoinBalance, newKucoinRunningProfitLoss) = await executeHFTTrade(
                    exchange: "kucoin",
                    price: kucoinSpotPrice,
                    prices: kucoinSpotPrices,
                    balance: kucoinBalanceValue,
                    runningProfitLoss: kucoinRunningProfitLossValue,
                    rsi: kucoinSpotRsi
                )
                kucoinBalance = newKucoinBalance
                kucoinRunningProfitLoss = newKucoinRunningProfitLoss
            }
        }

        if let lastBybitTrade = bybitLastTrade, lastBybitTrade.exchange == "bybit" {
            let timeSinceLastTrade = Date().timeIntervalSince(lastBybitTrade.timestamp)
            if timeSinceLastTrade < hftCooldownSeconds {
                print("INFO: Bybit HFT on cooldown for \(pair): \(Int(hftCooldownSeconds - timeSinceLastTrade)) seconds remaining")
            } else {
                if bybitSpotPrice > 0 && bybitSpotPrices.count >= spotEmaShortPeriod {
                    let (newBybitBalance, newBybitRunningProfitLoss) = await executeHFTTrade(
                        exchange: "bybit",
                        price: bybitSpotPrice,
                        prices: bybitSpotPrices,
                        balance: bybitBalanceValue,
                        runningProfitLoss: bybitRunningProfitLossValue,
                        rsi: bybitSpotRsi
                    )
                    bybitBalance = newBybitBalance
                    bybitRunningProfitLoss = newBybitRunningProfitLoss
                }
            }
        } else {
            if bybitSpotPrice > 0 && bybitSpotPrices.count >= spotEmaShortPeriod {
                let (newBybitBalance, newBybitRunningProfitLoss) = await executeHFTTrade(
                    exchange: "bybit",
                    price: bybitSpotPrice,
                    prices: bybitSpotPrices,
                    balance: bybitBalanceValue,
                    runningProfitLoss: bybitRunningProfitLossValue,
                    rsi: bybitSpotRsi
                )
                bybitBalance = newBybitBalance
                bybitRunningProfitLoss = newBybitRunningProfitLoss
            }
        }
    }

    static func evaluateFundingRateMomentum(pair: String, kucoinFundingRate: Double, bybitFundingRate: Double) async {
        let fundingMomentumThreshold = getDouble("FUNDING_MOMENTUM_THRESHOLD", defaultValue: 0.00008)
        let tradeAmount = getDouble("FUTURES_TRADE_AMOUNT", defaultValue: 150.0)
        let kucoinFuturesPrice = await MainActor.run(body: { kucoinCurrentFuturesPrice[pair] }) ?? 0.0
        let bybitFuturesPrice = await MainActor.run(body: { bybitCurrentFuturesPrice[pair] }) ?? 0.0

        if kucoinFundingRate > fundingMomentumThreshold && kucoinFuturesPrice > 0 {
            let tradeAmount = min(tradeAmount, kucoinBalance)
            if tradeAmount > 0 && kucoinBalance >= tradeAmount {
                print("INFO: KuCoin Funding Rate Momentum Trade for \(pair): Long, Amount: \(tradeAmount), Funding Rate: \(kucoinFundingRate)")
                kucoinBalance -= tradeAmount * kucoinFuturesPrice * futuresStopLossPercentage
            }
        }

        if bybitFundingRate > fundingMomentumThreshold && bybitFuturesPrice > 0 {
            let tradeAmount = min(tradeAmount, bybitBalance)
            if tradeAmount > 0 && bybitBalance >= tradeAmount {
                print("INFO: Bybit Funding Rate Momentum Trade for \(pair): Long, Amount: \(tradeAmount), Target Profit: \(spoofingProfitTarget)")
                bybitBalance += tradeAmount * spoofingProfitTarget
            }
        }
    }

    static func spoofLiquidity(pair: String, kucoinOrderBook: [[String: Any]], bybitOrderBook: [[String: Any]]) async {
        let spoofingVolumeThreshold = getDouble("SPOOFING_VOLUME_THRESHOLD", defaultValue: 1.5)
        let spoofingProfitTarget = getDouble("SPOOFING_PROFIT_TARGET", defaultValue: 0.008)

        let kucoinVolume = kucoinOrderBook.reduce(0.0) { $0 + ($1["volume"] as? Double ?? 0.0) }
        let bybitVolume = bybitOrderBook.reduce(0.0) { $0 + ($1["volume"] as? Double ?? 0.0) }

        if kucoinVolume > spoofingVolumeThreshold {
            let tradeAmount = min(kucoinBalance * 0.1, getDouble("SLIPPAGE_TRADE_AMOUNT", defaultValue: 100.0))
            if tradeAmount > 0 && kucoinBalance >= tradeAmount {
                print("INFO: KuCoin Spoofing Liquidity Trade for \(pair): Amount: \(tradeAmount), Target Profit: \(spoofingProfitTarget)")
                kucoinBalance += tradeAmount * spoofingProfitTarget
            }
        }

        if bybitVolume > spoofingVolumeThreshold {
            let tradeAmount = min(bybitBalance * 0.1, getDouble("SLIPPAGE_TRADE_AMOUNT", defaultValue: 100.0))
            if tradeAmount > 0 && bybitBalance >= tradeAmount {
                print("INFO: Bybit Spoofing Liquidity Trade for \(pair): Amount: \(tradeAmount), Target Profit: \(spoofingProfitTarget)")
                bybitBalance += tradeAmount * spoofingProfitTarget
            }
        }
    }

    static func optimizeTradeLatency(pair: String) async {
        let latencySpikeThreshold = getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 80.0)
        let latency = await measureTradeExecutionLatency()
        if latency > latencySpikeThreshold {
            print("INFO: Latency spike detected for \(pair): \(latency)ms. Optimizing trade execution...")
            await MainActor.run {
                logAlert(event: "High latency detected for trade execution for \(pair): \(latency)ms")
            }
            try? await Task.sleep(nanoseconds: 100_000_000) // 100ms
        }
    }

    static func measureTradeExecutionLatency() async -> Double {
        let start = Date()
        try? await Task.sleep(nanoseconds: 10_000_000) // 10ms
        return Date().timeIntervalSince(start) * 1000
    }

    static func sendTradeToFlaskServer(strategy: String, pair: String, exchange: String, spotPrice: Double, futuresPrice: Double, tradeAmount: Double, profit: Double) {
        let flaskUrl = URL(string: environment["FLASK_SERVER_URL"] ?? "http://localhost:5001/log_trade")!
        var request = URLRequest(url: flaskUrl)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.timeoutInterval = 10.0
        
        let tradeData: [String: Any] = [
            "strategy": strategy,
            "pair": pair,
            "exchange": exchange,
            "spot_price": spotPrice,
            "futures_price": futuresPrice,
            "trade_amount": tradeAmount,
            "profit": profit,
            "timestamp": ISO8601DateFormatter().string(from: Date())
        ]
        
        do {
            request.httpBody = try JSONSerialization.data(withJSONObject: tradeData)
        } catch {
            print("DEBUG: Failed to serialize trade data for Flask server: \(error.localizedDescription)")
            Task { @MainActor in
                logAlert(event: "Failed to serialize trade data for Flask server: \(error.localizedDescription)")
            }
            return
        }
        
        let startTime = Date()
        URLSession.shared.dataTask(with: request) { data, response, error in
            let latency = Date().timeIntervalSince(startTime) * 1000
            Task { @MainActor in
                lastLatency["flask-trade-log"] = latency
                if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 80.0) {
                    logAlert(event: "High latency detected for Flask trade log: \(latency)ms")
                }
                if let error = error {
                    logAlert(event: "Failed to send trade to Flask server: \(error.localizedDescription)")
                }
            }
        }.resume()
    }
}



//-------------------------------------------------------------------------------------------------------------------------Block 20 - API Data Retrieval and Authentication

import CryptoKit
import Foundation

extension Data {
    func hmac(key: String) -> String {
        let keyData = key.data(using: .utf8)!
        let signature = HMAC<SHA256>.authenticationCode(for: self, using: SymmetricKey(data: keyData))
        return Data(signature).base64EncodedString()
    }
}

// Extension for Block 20 API Interactions and Authentication
extension ExchangeWebSocket {
    static func fetchKuCoinBalance() async throws -> Double? {
        await MainActor.run {
            logAlert(event: "DEBUG: fetchKuCoinBalance() function started")
            logAlert(event: "DEBUG: KuCoin API Key exists: \(environment["KUCOIN_API_KEY"] != nil)")
            logAlert(event: "DEBUG: KuCoin API Secret exists: \(environment["KUCOIN_API_SECRET"] != nil)")
            logAlert(event: "DEBUG: KuCoin Passphrase exists: \(environment["KUCOIN_API_PASSPHRASE"] != nil)")
        }
        
        guard let apiKey = environment["KUCOIN_API_KEY"],
              let apiSecret = environment["KUCOIN_API_SECRET"],
              let apiPassphrase = environment["KUCOIN_API_PASSPHRASE"] else {
            await MainActor.run {
                logAlert(event: "ERROR: Missing KuCoin API credentials")
            }
            throw NSError(domain: "KuCoinAPI", code: -1, userInfo: [NSLocalizedDescriptionKey: "Missing API credentials"])
        }
        
        let url = URL(string: "https://api.kucoin.com/api/v1/accounts?currency=USDT&type=trade")!
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = Double(getInt("BALANCE_FETCH_TIMEOUT", defaultValue: 20))

        let timestamp = String(Int(Date().timeIntervalSince1970 * 1000))
        let endpoint = "/api/v1/accounts?currency=USDT&type=trade"
        let method = "GET"
        let body = "" // Empty body for GET request
        let strToSign = timestamp + method + endpoint + body
        
        await MainActor.run {
            logAlert(event: "DEBUG: KuCoin signing string: \(strToSign)")
        }
        
        let signature = strToSign.data(using: .utf8)!.hmac(key: apiSecret)
        
        // For API v2.0+: Encrypt passphrase with HMAC-SHA256 using API secret, then base64 encode
        let encryptedPassphrase = apiPassphrase.data(using: .utf8)!.hmac(key: apiSecret)

        // Set headers for API v2.0+
        request.addValue(apiKey, forHTTPHeaderField: "KC-API-KEY")
        request.addValue(signature, forHTTPHeaderField: "KC-API-SIGN")
        request.addValue(timestamp, forHTTPHeaderField: "KC-API-TIMESTAMP")
        request.addValue(encryptedPassphrase, forHTTPHeaderField: "KC-API-PASSPHRASE")
        request.addValue("2", forHTTPHeaderField: "KC-API-KEY-VERSION") // Critical: API version 2
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")

        await MainActor.run {
            logAlert(event: "DEBUG: KuCoin request headers set, making API call...")
        }

        let (data, response) = try await URLSession.shared.data(for: request)
        guard let httpResponse = response as? HTTPURLResponse else {
            await MainActor.run {
                logAlert(event: "ERROR: Non-HTTP response for KuCoin balance fetch")
            }
            throw NSError(domain: "KuCoinAPI", code: -1, userInfo: [NSLocalizedDescriptionKey: "Non-HTTP response"])
        }
        
        let responseBody = String(data: data, encoding: .utf8) ?? "Invalid data"
        await MainActor.run {
            logAlert(event: "DEBUG: KuCoin response status: \(httpResponse.statusCode)")
            logAlert(event: "DEBUG: KuCoin response: \(responseBody)")
        }
        
        if httpResponse.statusCode != 200 {
            await MainActor.run {
                logAlert(event: "ERROR: Invalid KuCoin response status \(httpResponse.statusCode): \(responseBody)")
            }
            throw NSError(domain: "KuCoinAPI", code: httpResponse.statusCode, userInfo: [NSLocalizedDescriptionKey: "HTTP \(httpResponse.statusCode)"])
        }

        let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
        guard let code = json?["code"] as? String else {
            await MainActor.run {
                logAlert(event: "ERROR: KuCoin response missing code field")
            }
            return nil
        }
        guard code == "200000" else {
            let errorMsg = json?["msg"] as? String ?? "Unknown error"
            await MainActor.run {
                logAlert(event: "ERROR: KuCoin API error code \(code): \(errorMsg)")
            }
            return nil
        }
        guard let dataJson = json?["data"] as? [[String: Any]] else {
            await MainActor.run {
                logAlert(event: "ERROR: KuCoin response missing data array")
            }
            return nil
        }
        
        await MainActor.run {
            logAlert(event: "DEBUG: KuCoin found \(dataJson.count) accounts")
        }
        
        let balance = dataJson.reduce(0.0) { sum, account in
            if (account["type"] as? String) == "trade" && (account["currency"] as? String) == "USDT",
               let availableStr = account["available"] as? String,
               let available = Double(availableStr) {
                return sum + available
            }
            return sum
        }
        
        if balance == 0.0 {
            await MainActor.run {
                logAlert(event: "WARNING: KuCoin USDT trade account has zero balance")
            }
        }

        await MainActor.run {
            logAlert(event: "SUCCESS: KuCoin balance parsed: \(balance) USDT")
        }

        return balance
    }

    static func fetchBybitBalance() async throws -> Double? {
        await MainActor.run {
            logAlert(event: "DEBUG: fetchBybitBalance() function started")
            logAlert(event: "DEBUG: Bybit API Key exists: \(environment["BYBIT_API_KEY"] != nil)")
            logAlert(event: "DEBUG: Bybit API Secret exists: \(environment["BYBIT_API_SECRET"] != nil)")
        }
        
        guard let apiKey = environment["BYBIT_API_KEY"],
              let apiSecret = environment["BYBIT_API_SECRET"] else {
            await MainActor.run {
                logAlert(event: "ERROR: Missing Bybit API credentials")
            }
            throw NSError(domain: "BybitAPI", code: -1, userInfo: [NSLocalizedDescriptionKey: "Missing API credentials"])
        }
        
        let url = URL(string: "https://api.bybit.com/v5/account/wallet-balance?accountType=UNIFIED&coin=USDT")!
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = Double(getInt("BALANCE_FETCH_TIMEOUT", defaultValue: 20))

        let timestamp = String(Int(Date().timeIntervalSince1970 * 1000))
        let recvWindow = environment["BYBIT_RECV_WINDOW"] ?? "5000"
        let queryString = "accountType=UNIFIED&coin=USDT"
        let paramStr = timestamp + apiKey + recvWindow + queryString
        
        await MainActor.run {
            logAlert(event: "DEBUG: Bybit signing string: \(paramStr)")
        }
        
        let signature = paramStr.data(using: .utf8)!.hmac(key: apiSecret)

        request.addValue(apiKey, forHTTPHeaderField: "X-BAPI-API-KEY")
        request.addValue(timestamp, forHTTPHeaderField: "X-BAPI-TIMESTAMP")
        request.addValue(recvWindow, forHTTPHeaderField: "X-BAPI-RECV-WINDOW")
        request.addValue(signature, forHTTPHeaderField: "X-BAPI-SIGN")
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")

        await MainActor.run {
            logAlert(event: "DEBUG: Bybit request headers set, making API call...")
        }

        let (data, response) = try await URLSession.shared.data(for: request)
        guard let httpResponse = response as? HTTPURLResponse else {
            await MainActor.run {
                logAlert(event: "ERROR: Non-HTTP response for Bybit balance fetch")
            }
            throw NSError(domain: "BybitAPI", code: -1, userInfo: [NSLocalizedDescriptionKey: "Non-HTTP response"])
        }
        
        let responseBody = String(data: data, encoding: .utf8) ?? "Invalid data"
        await MainActor.run {
            logAlert(event: "DEBUG: Bybit response status: \(httpResponse.statusCode)")
            logAlert(event: "DEBUG: Bybit response: \(responseBody)")
        }
        
        if httpResponse.statusCode != 200 {
            await MainActor.run {
                logAlert(event: "ERROR: Invalid Bybit response status \(httpResponse.statusCode): \(responseBody)")
            }
            throw NSError(domain: "BybitAPI", code: httpResponse.statusCode, userInfo: [NSLocalizedDescriptionKey: "HTTP \(httpResponse.statusCode)"])
        }

        let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
        guard let retCode = json?["retCode"] as? Int else {
            await MainActor.run {
                logAlert(event: "ERROR: Bybit response missing retCode")
            }
            return nil
        }
        guard retCode == 0 else {
            let retMsg = json?["retMsg"] as? String ?? "Unknown error"
            await MainActor.run {
                logAlert(event: "ERROR: Bybit API error code \(retCode): \(retMsg)")
            }
            return nil
        }
        guard let result = json?["result"] as? [String: Any],
              let list = result["list"] as? [[String: Any]] else {
            await MainActor.run {
                logAlert(event: "ERROR: Bybit response missing result.list")
            }
            return nil
        }
        
        await MainActor.run {
            logAlert(event: "DEBUG: Bybit found \(list.count) accounts")
        }
        
        var balance = 0.0
        for account in list {
            if let coinList = account["coin"] as? [[String: Any]] {
                if let usdt = coinList.first(where: { ($0["coin"] as? String) == "USDT" }),
                   let walletBalanceStr = usdt["walletBalance"] as? String,
                   let walletBalance = Double(walletBalanceStr) {
                    balance += walletBalance
                }
            }
        }
        
        if balance == 0.0 {
            await MainActor.run {
                logAlert(event: "WARNING: Bybit USDT account has zero balance")
            }
        }

        await MainActor.run {
            logAlert(event: "SUCCESS: Bybit balance parsed: \(balance) USDT")
        }

        return balance
    }

    static func fetchKuCoinOrderBook(pair: String, isFutures: Bool) async -> BevaixOrderBook? {
        await MainActor.run {
            logAlert(event: "DEBUG: fetchKuCoinOrderBook() started for \(pair) (futures: \(isFutures))")
        }
        
        let symbol = isFutures ? pair.replacingOccurrences(of: "-", with: "") + "M" : pair
        let baseURL = isFutures ? "https://api-futures.kucoin.com" : "https://api.kucoin.com"
        let path = isFutures ? "/api/v1/level2/snapshot" : "/api/v3/market/orderbook/level2"
        var endpoint = path + "?symbol=\(symbol)"
        if !isFutures {
            endpoint += "&limit=100"
        }
        let urlString = baseURL + endpoint
        
        await MainActor.run {
            logAlert(event: "DEBUG: KuCoin orderbook URL: \(urlString)")
        }
        
        guard let url = URL(string: urlString) else {
            await MainActor.run {
                logAlert(event: "ERROR: Invalid KuCoin orderbook URL: \(urlString)")
            }
            return nil
        }
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = Double(getInt("BALANCE_FETCH_TIMEOUT", defaultValue: 20))

        // Only add authentication headers for futures
        if isFutures {
            guard let apiKey = environment["KUCOIN_API_KEY"],
                  let apiSecret = environment["KUCOIN_API_SECRET"],
                  let apiPassphrase = environment["KUCOIN_API_PASSPHRASE"] else {
                await MainActor.run {
                    logAlert(event: "ERROR: Missing KuCoin API credentials for futures")
                }
                return nil
            }
            
            let timestamp = String(Int(Date().timeIntervalSince1970 * 1000))
            let method = "GET"
            let body = ""
            let strToSign = timestamp + method + endpoint + body
            let signature = strToSign.data(using: .utf8)!.hmac(key: apiSecret)
            let encryptedPassphrase = apiPassphrase.data(using: .utf8)!.hmac(key: apiSecret)

            request.addValue(apiKey, forHTTPHeaderField: "KC-API-KEY")
            request.addValue(signature, forHTTPHeaderField: "KC-API-SIGN")
            request.addValue(timestamp, forHTTPHeaderField: "KC-API-TIMESTAMP")
            request.addValue(encryptedPassphrase, forHTTPHeaderField: "KC-API-PASSPHRASE")
            request.addValue("2", forHTTPHeaderField: "KC-API-KEY-VERSION")
            request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        }

        do {
            let (data, response) = try await URLSession.shared.data(for: request)
            guard let httpResponse = response as? HTTPURLResponse else {
                await MainActor.run {
                    logAlert(event: "ERROR: Non-HTTP response for KuCoin orderbook \(pair)")
                }
                return nil
            }
            let responseBody = String(data: data, encoding: .utf8) ?? "Invalid data"
            
            await MainActor.run {
                logAlert(event: "DEBUG: KuCoin orderbook response status: \(httpResponse.statusCode)")
                logAlert(event: "DEBUG: KuCoin orderbook response: \(responseBody)")
            }
            
            if httpResponse.statusCode != 200 {
                await MainActor.run {
                    logAlert(event: "ERROR: Invalid KuCoin orderbook status \(httpResponse.statusCode) for \(pair): \(responseBody)")
                }
                return nil
            }
            let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
            guard let code = json?["code"] as? String else {
                await MainActor.run {
                    logAlert(event: "ERROR: KuCoin orderbook response missing code for \(pair)")
                }
                return nil
            }
            guard code == "200000" else {
                let errorMsg = json?["msg"] as? String ?? "Unknown error"
                await MainActor.run {
                    logAlert(event: "ERROR: KuCoin orderbook API error for \(pair) - code: \(code), msg: \(errorMsg)")
                }
                return nil
            }
            guard let dataJson = json?["data"] as? [String: Any],
                  let bids = dataJson["bids"] as? [[String]],
                  let asks = dataJson["asks"] as? [[String]] else {
                await MainActor.run {
                    logAlert(event: "ERROR: KuCoin orderbook missing bids/asks for \(pair): \(responseBody)")
                }
                return nil
            }
            
            await MainActor.run {
                logAlert(event: "DEBUG: KuCoin orderbook raw bids: \(bids.count), asks: \(asks.count)")
            }
            
            let parsedBids = bids.compactMap { arr -> (Double, Double)? in
                guard arr.count >= 2, let price = Double(arr[0]), let qty = Double(arr[1]) else { return nil }
                return (price, qty)
            }
            let parsedAsks = asks.compactMap { arr -> (Double, Double)? in
                guard arr.count >= 2, let price = Double(arr[0]), let qty = Double(arr[1]) else { return nil }
                return (price, qty)
            }
            
            await MainActor.run {
                logAlert(event: "DEBUG: KuCoin orderbook parsed bids: \(parsedBids.count), asks: \(parsedAsks.count)")
            }
            
            if parsedBids.isEmpty || parsedAsks.isEmpty {
                await MainActor.run {
                    logAlert(event: "ERROR: KuCoin orderbook empty after parsing for \(pair)")
                }
                return nil
            }
            
            await MainActor.run {
                logAlert(event: "SUCCESS: KuCoin orderbook parsed for \(pair)")
            }
            
            return BevaixOrderBook(bids: parsedBids, asks: parsedAsks)
        } catch {
            await MainActor.run {
                logAlert(event: "ERROR: Failed to fetch KuCoin orderbook for \(pair): \(error.localizedDescription)")
            }
            return nil
        }
    }
}

// --------------------------------------------------------- Block 21 22 23 24 removed

//--------------------------------------------------------------------------------------------------------------------------------------------------- Block 25 - Self-Evolution & Learning System


// Genetic evolution (mutate/crossover for strategies)
struct EvolvableStrategy {
    let id = UUID()
    var genome = [Double](repeating: Double.random(in: 0...1), count: 100)
    var fitness: Double = 0
    var trades = 0
    var winRate: Double = 0
    
    mutating func mutate() {
        for i in genome.indices {
            if Double.random(in: 0...1) < 0.02 {
                genome[i] += Double.random(in: -0.1...0.1)
            }
        }
    }
    
    func crossover(with other: EvolvableStrategy) -> EvolvableStrategy {
        var newG = [Double]()
        for i in 0..<genome.count {
            newG.append(Double.random(in: 0...1) > 0.5 ? genome[i] : other.genome[i])
        }
        return EvolvableStrategy(genome: newG)
    }
}

actor EvolutionEngine {
    var gen = 0
    var pool: [EvolvableStrategy] = (0..<32).map { _ in EvolvableStrategy() }
    
    func evolveStrategies() async {
        for i in pool.indices {
            pool[i].fitness = Double.random(in: 0...100)
        }
        pool.sort { $0.fitness > $1.fitness }
        let survivors = Array(pool.prefix(pool.count / 2))
        var newPool = survivors
        for i in 0..<survivors.count/2 {
            var off = survivors[i].crossover(with: survivors[survivors.count - 1 - i])
            off.mutate()
            newPool.append(off)
        }
        pool = newPool
        gen += 1
    }
    
    func getBestStrategy() -> EvolvableStrategy? {
        return pool.max { $0.fitness < $1.fitness }
    }
    
    // ENHANCED: Advanced evolution methods for trading strategies
    func processQuantumState(pair: String) async -> QuantumState {
        let superposition = (0..<2048).map { _ in Double.random(in: 0...1) }
        let entanglement = ["BTC": Double.random(in: 0...1), "ETH": Double.random(in: 0...1)]
        return QuantumState(
            superposition: superposition,
            entanglement: entanglement,
            collapseProb: Double.random(in: 0...1),
            timestamp: Date()
        )
    }
    
    func createMarketVector(pair: String) async -> HyperdimensionalVector {
        let dims = (0..<128).map { _ in Double.random(in: -1...1) }
        let magnitude = sqrt(dims.map { $0 * $0 }.reduce(0, +))
        return HyperdimensionalVector(dims: dims, mag: magnitude, ts: Date())
    }
}

extension ExchangeWebSocket {
    
    static func monitorTradingPerformance() {
        Task { @MainActor in
            for pair in tradingPairs {
                let kucoinBook = kucoinOrderBooks[pair]
                let bybitBook = bybitOrderBooks[pair]
                
                // FIXED: Check for empty order books using isEmpty property
                if let book = kucoinBook, book.isEmpty {
                    print("WARNING: Empty KuCoin order book for \(pair)")
                    logAlert(event: "Empty KuCoin order book detected for \(pair)")
                }
                
                if let book = bybitBook, book.isEmpty {
                    print("WARNING: Empty Bybit order book for \(pair)")
                    logAlert(event: "Empty Bybit order book detected for \(pair)")
                }
                
                // Calculate performance metrics
                let metrics = performanceMetrics[pair] ?? (profit: 0.0, fees: 0.0, trades: 0, wins: 0)
                let winRate = metrics.trades > 0 ? Double(metrics.wins) / Double(metrics.trades) : 0.0
                let netProfit = metrics.profit - metrics.fees
                
                if metrics.trades > 10 { // Only analyze after sufficient trades
                    if winRate < 0.3 { // Less than 30% win rate
                        logAlert(event: "Low win rate detected for \(pair): \(String(format: "%.1f", winRate * 100))%")
                    }
                    
                    if netProfit < -100.0 { // Net loss exceeding $100
                        logAlert(event: "Significant losses detected for \(pair): $\(String(format: "%.2f", netProfit))")
                    }
                }
                
                // Update strategy performance
                updateStrategyPerformance(pair: pair, winRate: winRate, netProfit: netProfit)
            }
        }
        
        // Schedule next performance check
        DispatchQueue.main.asyncAfter(deadline: .now() + 60.0) {
            monitorTradingPerformance()
        }
    }
    
    @MainActor
    static func updateStrategyPerformance(pair: String, winRate: Double, netProfit: Double) {
        var metrics = strategyPerformance[pair] ?? PerformanceMetrics(
            totalTrades: 0,
            winningTrades: 0,
            totalProfit: 0.0,
            totalFees: 0.0,
            averageLatency: 0.0,
            maxDrawdown: 0.0,
            sharpeRatio: 0.0,
            lastTradeTime: Date()
        )
        
        metrics.totalTrades += 1
        if netProfit > 0 {
            metrics.winningTrades += 1
        }
        metrics.totalProfit += netProfit
        metrics.lastTradeTime = Date()
        
        strategyPerformance[pair] = metrics
        
        // Log significant performance changes
        if metrics.totalTrades % 50 == 0 {
            let currentWinRate = Double(metrics.winningTrades) / Double(metrics.totalTrades)
            logAlert(event: "Performance update for \(pair): Trades=\(metrics.totalTrades), Win Rate=\(String(format: "%.1f", currentWinRate * 100))%, Profit=$\(String(format: "%.2f", metrics.totalProfit))")
        }
    }
    
    static func analyzeMarketConditions() {
        Task { @MainActor in
            for pair in tradingPairs {
                let prices = kucoinPrices[pair] ?? []
                let volumes = kucoinSpotVolume[pair] ?? []
                
                guard prices.count >= 50 && volumes.count >= 50 else {
                    continue // Not enough data for analysis
                }
                
                // Calculate volatility
                let recentPrices = Array(prices.suffix(50))
                let returns = zip(recentPrices.dropFirst(), recentPrices.dropLast()).map { current, previous in
                    (current - previous) / previous
                }
                
                let meanReturn = returns.reduce(0, +) / Double(returns.count)
                let variance = returns.map { pow($0 - meanReturn, 2) }.reduce(0, +) / Double(returns.count)
                let volatility = sqrt(variance)
                
                // Determine market trend
                let currentPrice = prices.last ?? 0
                let sma20 = recentPrices.suffix(20).reduce(0, +) / 20.0
                let sma50 = recentPrices.reduce(0, +) / Double(recentPrices.count)
                
                var trend = "sideways"
                if currentPrice > sma20 && sma20 > sma50 {
                    trend = "bullish"
                } else if currentPrice < sma20 && sma20 < sma50 {
                    trend = "bearish"
                }
                
                // Calculate momentum
                let momentum = (currentPrice - recentPrices.first!) / recentPrices.first!
                
                // Average recent volume
                let recentVolumes = Array(volumes.suffix(50))
                let avgVolume = recentVolumes.reduce(0, +) / Double(recentVolumes.count)
                
                let condition = MarketCondition(
                    volatility: volatility,
                    trend: trend,
                    volume: avgVolume,
                    momentum: momentum,
                    timestamp: Date()
                )
                
                marketConditions[pair] = condition
                
                // Log significant market changes
                if volatility > 0.05 {
                    logAlert(event: "High volatility detected for \(pair): \(String(format: "%.3f", volatility * 100))%")
                }
                
                if abs(momentum) > 0.1 {
                    let direction = momentum > 0 ? "bullish" : "bearish"
                    logAlert(event: "Strong \(direction) momentum for \(pair): \(String(format: "%.2f", momentum * 100))%")
                }
            }
        }
        
        // Schedule next analysis
        DispatchQueue.main.asyncAfter(deadline: .now() + 30.0) {
            analyzeMarketConditions()
        }
    }
    
    static func generateTradingSignals() {
        Task { @MainActor in
            for pair in tradingPairs {
                guard let condition = marketConditions[pair] else { continue }
                
                var signals: [AdvancedSignal] = []
                
                // Volatility-based signals
                if condition.volatility > 0.03 {
                    let signal = AdvancedSignal(
                        type: "volatility_high",
                        strength: condition.volatility * 10,
                        confidence: min(condition.volatility * 200, 100.0),
                        timestamp: Date(),
                        pair: pair,
                        exchange: "cross"
                    )
                    signals.append(signal)
                }
                
                // Momentum signals
                if abs(condition.momentum) > 0.05 {
                    let signalType = condition.momentum > 0 ? "momentum_bullish" : "momentum_bearish"
                    let signal = AdvancedSignal(
                        type: signalType,
                        strength: abs(condition.momentum),
                        confidence: min(abs(condition.momentum) * 500, 100.0),
                        timestamp: Date(),
                        pair: pair,
                        exchange: "cross"
                    )
                    signals.append(signal)
                }
                
                // Volume signals
                let currentVolume = (kucoinSpotVolume[pair]?.last ?? 0) + (bybitSpotVolume[pair]?.last ?? 0)
                if currentVolume > condition.volume * 2.0 {
                    let signal = AdvancedSignal(
                        type: "volume_spike",
                        strength: currentVolume / condition.volume,
                        confidence: min((currentVolume / condition.volume - 1) * 50, 100.0),
                        timestamp: Date(),
                        pair: pair,
                        exchange: "cross"
                    )
                    signals.append(signal)
                }
                
                // Store signals
                advancedSignals[pair] = signals
                
                // Log significant signals
                for signal in signals {
                    if signal.confidence > 70.0 {
                        logAlert(event: "Strong signal for \(pair): \(signal.type) with \(String(format: "%.1f", signal.confidence))% confidence")
                    }
                }
            }
        }
        
        // Schedule next signal generation
        DispatchQueue.main.asyncAfter(deadline: .now() + 15.0) {
            generateTradingSignals()
        }
    }
    
    static func optimizeStrategyAllocations() {
        Task { @MainActor in
            var totalPerformanceScore: Double = 0
            var strategyScores: [String: Double] = [:]
            
            // Calculate performance scores for each strategy
            let strategies = ["arbitrage", "momentum", "mean_reversion", "scalping", "market_making"]
            
            for strategy in strategies {
                var strategyProfit: Double = 0
                var strategyTrades: Int = 0
                var strategyWins: Int = 0
                
                for pair in tradingPairs {
                    if let metrics = strategyPerformance[pair] {
                        strategyProfit += metrics.totalProfit
                        strategyTrades += metrics.totalTrades
                        strategyWins += metrics.winningTrades
                    }
                }
                
                let winRate = strategyTrades > 0 ? Double(strategyWins) / Double(strategyTrades) : 0
                let avgProfitPerTrade = strategyTrades > 0 ? strategyProfit / Double(strategyTrades) : 0
                
                // Combined performance score
                let performanceScore = (winRate * 0.6 + (avgProfitPerTrade > 0 ? 0.4 : 0)) * max(1, strategyProfit / 100.0)
                strategyScores[strategy] = max(0.1, performanceScore) // Minimum 10% allocation
                totalPerformanceScore += performanceScore
            }
            
            // Normalize allocations
            for strategy in strategies {
                let allocation = totalPerformanceScore > 0 ? (strategyScores[strategy] ?? 0.1) / totalPerformanceScore : 0.2
                strategyAllocations[strategy] = allocation
            }
            
            // Log allocation changes
            let allocationsString = strategies.map { strategy in
                let allocation = strategyAllocations[strategy] ?? 0
                return "\(strategy): \(String(format: "%.1f", allocation * 100))%"
            }.joined(separator: ", ")
            
            logAlert(event: "Strategy allocations updated: \(allocationsString)")
        }
        
        // Schedule next optimization
        DispatchQueue.main.asyncAfter(deadline: .now() + 300.0) { // Every 5 minutes
            optimizeStrategyAllocations()
        }
    }
    
    static func evaluateCrossExchangeOpportunityWithML(pair: String, kucoinPrice: Double, bybitPrice: Double) async -> Bool {
        let spread = abs(kucoinPrice - bybitPrice) / min(kucoinPrice, bybitPrice)
        let sentiment = await MainActor.run(body: { sentimentScores[pair] ?? 0.0 })
        
        // Get market condition
        let condition = await MainActor.run(body: { marketConditions[pair] })
        let volatility = condition?.volatility ?? 0.02
        
        // Simple ML evaluation using weighted factors
        let spreadScore = spread * 1000 // Convert to basis points
        let sentimentScore = (sentiment + 1.0) / 2.0 // Normalize -1 to 1 range to 0 to 1
        let volatilityScore = min(volatility * 50, 1.0) // Cap volatility impact
        
        // Weighted ML score
        let mlScore = (spreadScore * 0.5) + (sentimentScore * 0.3) + (volatilityScore * 0.2)
        
        let shouldExecute = mlScore > 2.0 // Threshold for execution
        
        if shouldExecute {
            await MainActor.run {
                logAlert(event: "ML recommends execution for \(pair): Score=\(String(format: "%.2f", mlScore)), Spread=\(String(format: "%.4f", spread * 100))%")
            }
        }
        
        return shouldExecute
    }
    
    static func initializeEvolutionSystem() {
        monitorTradingPerformance()
        analyzeMarketConditions()
        generateTradingSignals()
        optimizeStrategyAllocations()
        
        print("‚úÖ Evolution & Learning System initialized")
        logAlert(event: "Evolution & Learning System initialized with AI enhancements")
    }
}


// --------------------------------------------------------------------------------------------------------------------------------------------------- Block 26 - Integrated AI Trading Loop


import Foundation

// FIXED: AI Trading Orchestrator class
class AITradingOrchestrator {
    func startAITrading() async {
        while await MainActor.run(resultType: Bool.self, body: {
            return ExchangeWebSocket.tradingActive
        }) {
            do {
                // FIXED: Use correct objects for methods
                let q = await ExchangeWebSocket.quantumProcessor.processQuantumState(pair: "BTC-USDT")
                let p = await ExchangeWebSocket.patternEngine.createMarketVector(pair: "BTC-USDT")
                let _ = await ExchangeWebSocket.temporalOracle.predictFuture(pair: "BTC-USDT")
                // FIXED: Ensure neuralSwarm is NeuralSwarmCoordinator; if error persists, check variable type in Block 1
                let s: [Float] = []
                
                let a = q.collapseProb
                let b = p.mag
                let c = 0.5
                // FIXED: Break up the expression for compiler
                let averageD: Double
                if s.isEmpty {
                    averageD = 0.0
                } else {
                    let sumD = s.reduce(0.0) { $0 + Double($1) }
                    averageD = sumD / Double(s.count)
                }
                let sum = a + b + c + averageD
                let fused = sum / 4.0
                
                if fused > 0.8 {
                    print("AI Execute: Conf \(fused)")
                    
                    // Execute AI-driven trade
                    for pair in await MainActor.run(resultType: [String].self, body: { return ExchangeWebSocket.tradingPairs }) {
                        let currentPrice = await MainActor.run(resultType: Double.self, body: {
                            return ExchangeWebSocket.kucoinCurrentPrice[pair] ?? 0.0
                        })
                        
                        if currentPrice > 0 {
                            let success = await ExchangeWebSocket.executeTrade(
                                exchange: "kucoin",
                                pair: pair,
                                side: fused > 0.9 ? "buy" : "sell",
                                price: currentPrice,
                                amount: 10.0,
                                strategy: "AI-Driven"
                            )
                            
                            if success {
                                print("AI trade executed for \(pair)")
                            }
                        }
                    }
                }
                
                try await Task.sleep(nanoseconds: 50_000_000) // 50ms
                
                // FIXED: Proper evolution trigger - add static var lastEvolution: Date = .distantPast to ExchangeWebSocket if not present
                if Date().timeIntervalSince(await MainActor.run { ExchangeWebSocket.lastEvolution }) > 3600 {
                    await ExchangeWebSocket.evolutionEngine.evolveStrategies()
                    await MainActor.run {
                        ExchangeWebSocket.lastEvolution = Date()
                    }
                }
                } catch {
                    print("AI Trading Loop Error: \(error)")
                    await MainActor.run {
                        ExchangeWebSocket.logAlert(event: "AI Trading Loop Error: \(error)")
                    }
                }
            }
        }
    }


extension ExchangeWebSocket {
   

    // FIXED: Add missing calculateStandardDeviation function
    static func calculateStandardDeviation(prices: [Double]) -> Double {
        guard prices.count > 1 else { return 0.0 }
        let mean = prices.reduce(0.0, +) / Double(prices.count)
        let variance = prices.reduce(0.0) { $0 + pow($1 - mean, 2) } / Double(prices.count - 1)
        return sqrt(variance)
    }
    
    // FIXED: Add logAlert if not present
    static func logAlert(event: String) {
        print("ALERT: \(event)")
        // Additional logging here
    }
    
}

// ENHANCED: Main execution with complete bot startup
//@MainActor
//func startEnhancedBevaixBot() async {
//  print("""
    //
////    ü§ñ Starting BevaixBot - AI Enhanced Trading Bot
////    üìä Project: High-Frequency Trading Bot
//    üéØ Target: 4+ trades/minute, $0.70+ profit/trade
//   ‚ö° Exchanges: KuCoin & Bybit
//   üî¨ AI: 5-Level Enhancement System
// üìà Strategies: Arbitrage, HFT, ML-Scalping, Market Making//
//
//    """)
    
    // 1. Validate environment and credentials
//  let hasKucoinCreds = !getString("KUCOIN_API_KEY", defaultValue: "").isEmpty
//  let hasBybitCreds = !getString("BYBIT_API_KEY", defaultValue: "").isEmpty
//  let simulationMode = await getBool("SIMULATION_TRADE_LOGGING", defaultValue: true)
//
//  if hasKucoinCreds {
//      print("‚úÖ KuCoin API credentials detected")
//  } else {
//      print("‚ö†Ô∏è Missing KuCoin API credentials - KuCoin trading disabled")
//  }
//
//  if hasBybitCreds {
//      print("‚úÖ Bybit API credentials detected")
//  } else {
//      print("‚ö†Ô∏è Missing Bybit API credentials - Bybit trading disabled")
//  }
    
//  if simulationMode {
//      print("üîí SIMULATION MODE: All trades will be logged only (no real money)")
//  } else {
//      print("üí∞ LIVE TRADING MODE: Real trades will be executed")
//  }
//
//  // 2. Initialize parameters and data structures
//  print("\nüìã Initializing trading parameters...")
//  await withCheckedContinuation { continuation in
//      ExchangeWebSocket.initializeParameters {
//          print("‚úÖ Parameters initialized successfully")
//          continuation.resume()
//      }
//  }
//
//  // 3. Fetch initial balances
//  print("\nüí≥ Fetching account balances...")
// await withTaskGroup(of: Void.self) { group in
        //      group.addTask {
        //  await withCheckedContinuation { continuation in
        //      ExchangeWebSocket.fetchKucoinBalance { balance in
//                  if let balance = balance {
//                      print("‚úÖ KuCoin balance: $\(String(format: "%.2f", balance)) USDT")
//                  }
//                  continuation.resume()
//              }
//          }
//      }
//
//      group.addTask {
//          await withCheckedContinuation { continuation in
//              ExchangeWebSocket.fetchBybitBalance { balance in
//                  if let balance = balance {
//                      print("‚úÖ Bybit balance: $\(String(format: "%.2f", balance)) USDT")
//                  }
//                  continuation.resume()
//              }
//          }
//      }
//  }
//
    // 4. Connect to WebSocket feeds
//  print("\nüîå Establishing WebSocket connections...")
//
//  if hasKucoinCreds {
//      ExchangeWebSocket.connectKucoin()
//      ExchangeWebSocket.connectKucoinFutures()
//
//      // Wait briefly for KuCoin connections
//      try? await Task.sleep(nanoseconds: 3_000_000_000) // 3 seconds
//  }
//
//  ExchangeWebSocket.connectBybit()
//
//  // Wait for initial connections
//  try? await Task.sleep(nanoseconds: 5_000_000_000) // 5 seconds
//
//  // 5. Verify connections and data flow
//   print("\nüì° Verifying data feeds...")
//  var connectedExchanges = 0
//
//  if ExchangeWebSocket.kucoinIsConnected {
//      print("‚úÖ KuCoin WebSocket: Connected")
//      connectedExchanges += 1
//  } else if hasKucoinCreds {
//      print("‚ùå KuCoin WebSocket: Failed")
//  } else {
//			      //       print("‚ö†Ô∏è KuCoin WebSocket: Skipped (no credentials)")
        //   }
    
//  if ExchangeWebSocket.bybitIsConnected {
        //      print("‚úÖ Bybit WebSocket: Connected")
        //      connectedExchanges += 1
        //    } else {
        //        print("‚ùå Bybit WebSocket: Failed")
        // }
    
    // Check for price data
//   await Task.sleep(nanoseconds: 5_000_000_000) // Wait 5 more seconds for price data
    
//   let pairsWithKucoinPrices = ExchangeWebSocket.kucoinCurrentPrice.filter { $0.value > 0 }.count
//  let pairsWithBybitPrices = ExchangeWebSocket.bybitCurrentPrice.filter { $0.value > 0 }.count
    
//   print("üìä Price data status:")
//  print("   KuCoin: \(pairsWithKucoinPrices)/\(ExchangeWebSocket.tradingPairs.count) pairs")
//  print("   Bybit: \(pairsWithBybitPrices)/\(ExchangeWebSocket.tradingPairs.count) pairs")
    
    // 6. Create initial dashboard update
//  ExchangeWebSocket.updateDashboardJSON()
    
    // 7. Start monitoring and trading
// if connectedExchanges > 0 {
        //    print("""
    //
    //    üéâ ===============================================
   //     ü§ñ BevaixBot Successfully Initialized!
   //     üéâ ===============================================
   //     
    //    üìä Active Exchanges: \(connectedExchanges)
  //       üíº Trading Pairs: \(ExchangeWebSocket.tradingPairs.count)
  //       üéØ Target Performance: 4+ trades/min, $0.20+ profit/trade
  //        üî¨ AI Enhancement: 5-Level System Active
  //        üìà Strategies: Cross-Exchange Arbitrage, HFT Scalping, Market Making
  //        üîí Mode: \(simulationMode ? "SIMULATION" : "LIVE TRADING")
        
  //      üöÄ Starting trading loop...
        
  //      """)
        
        // Start the main trading loop
        //       await ExchangeWebSocket.startTradingLoop()
        
        //        //    } else {
        //       print("""
 //
 //       ‚ùå ===============================================
 //       üõë BevaixBot Startup Failed
 //       ‚ùå ===============================================
        
  //      üîå No exchange connections established
  //      üîß Please check:
  //         ‚Ä¢ Internet connectivity
  //         ‚Ä¢ API credentials in .env file
  //         ‚Ä¢ Exchange API status
        
 //       """)
        
        //      ExchangeWebSocket.logAlert(event: "‚ùå BevaixBot startup failed - no exchange connections")
        ////    }
//}

// Main execution entry point - REPLACE existing main execution if present
//print("ü§ñ BevaixBot v2.0 - AI Enhanced Trading System")
//print("üîÑ Initializing...")

//Task { @MainActor in
//    do {
//       await startEnhancedBevaixBot()
//   } catch {
//      print("üí• Critical error during bot startup: \(error)")
//       ExchangeWebSocket.logAlert(event: "üí• Critical error during bot startup: \(error)")
//      exit(1)
//    }
//}

// Keep the program running
//RunLoop.main.run()
