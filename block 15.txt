//---------------------------------------------------------------------------------------------------------Block 15 - High-Frequency Trading Scalping



import Foundation

extension ExchangeWebSocket {
    
    
    static func structureTradeData(strategy: String, pair: String, exchange: String, spotPrice: Double, futuresPrice: Double, tradeAmount: Double, profit: Double) -> [String: Any] {
        let timestampFormatter = ISO8601DateFormatter()
        timestampFormatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        let timestamp = timestampFormatter.string(from: Date())

        return [
            "strategy": strategy,
            "pair": pair,
            "exchange": exchange,
            "spot_price": spotPrice,
            "futures_price": futuresPrice,
            "trade_amount": tradeAmount,
            "profit": profit,
            "timestamp": timestamp
        ]
    }

    @MainActor
    static func logTradeLocally(strategy: String, pair: String, exchange: String, spotPrice: Double, futuresPrice: Double, tradeAmount: Double, profit: Double) {
        let tradeData = structureTradeData(strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit)
        let timestamp = tradeData["timestamp"] as? String ?? ISO8601DateFormatter().string(from: Date())
        let logEntry = "\(timestamp),\(strategy),\(pair),\(exchange),\(spotPrice),\(futuresPrice),\(tradeAmount),\(profit)\n"
        let logURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trade_log_fallback.csv")

        do {
            let fileManager = FileManager.default
            let directoryPath = logURL.deletingLastPathComponent().path
            if !fileManager.fileExists(atPath: directoryPath) {
                try fileManager.createDirectory(atPath: directoryPath, withIntermediateDirectories: true, attributes: nil)
                print("DEBUG: Created directory for trade_log_fallback.csv at \(directoryPath)")
            }

            if !fileManager.fileExists(atPath: logURL.path) {
                try "timestamp,strategy,pair,exchange,spot_price,futures_price,trade_amount,profit\n".write(to: logURL, atomically: true, encoding: .utf8)
            }

            if let fileHandle = try? FileHandle(forWritingTo: logURL) {
                defer { fileHandle.closeFile() }
                if let data = logEntry.data(using: .utf8) {
                    fileHandle.seekToEndOfFile()
                    fileHandle.write(data)
                }
            } else {
                try logEntry.write(to: logURL, atomically: true, encoding: .utf8)
            }
            print("DEBUG: Logged trade to fallback CSV: \(logEntry)")
        } catch {
            print("DEBUG: Failed to write to trade_log_fallback.csv: \(error.localizedDescription)")
        }
    }

    // FIX: Remove @Sendable from main actor-isolated synchronous static method
    static func attemptSend(attempt: Int, request: URLRequest, strategy: String, pair: String, exchange: String, spotPrice: Double, futuresPrice: Double, tradeAmount: Double, profit: Double, retries: Int) {
        let delay = pow(2.0, Double(attempt - 1))
        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                print("DEBUG: Failed to send trade to Flask server (attempt \(attempt)): \(error.localizedDescription)")
                if attempt < retries {
                    DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
                        ExchangeWebSocket.attemptSend(attempt: attempt + 1, request: request, strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit, retries: retries)
                    }
                } else {
                    Task { @MainActor in
                        logTradeLocally(strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit)
                    }
                }
                return
            }

            guard let httpResponse = response as? HTTPURLResponse else {
                print("DEBUG: Failed to send trade to Flask server (attempt \(attempt)): No HTTP response")
                if attempt < retries {
                    DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
                        ExchangeWebSocket.attemptSend(attempt: attempt + 1, request: request, strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit, retries: retries)
                    }
                } else {
                    Task { @MainActor in
                        logTradeLocally(strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit)
                    }
                }
                return
            }

            print("DEBUG: Flask server response status (attempt \(attempt)): \(httpResponse.statusCode)")
            if httpResponse.statusCode == 200 {
                print("DEBUG: Successfully sent trade to Flask server: \(strategy) for \(pair) on \(exchange)")
            } else {
                print("DEBUG: Failed to send trade to Flask server (attempt \(attempt)): Status code \(httpResponse.statusCode)")
                if let data = data, let responseBody = String(data: data, encoding: .utf8) {
                    print("DEBUG: Flask server response body: \(responseBody)")
                }
                if attempt < retries {
                    DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
                        ExchangeWebSocket.attemptSend(attempt: attempt + 1, request: request, strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit, retries: retries)
                    }
                } else {
                    Task { @MainActor in
                        logTradeLocally(strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit)
                    }
                }
            }
        }
        task.resume()
    }

    static func sendTradeToFlaskServer(strategy: String, pair: String, exchange: String, spotPrice: Double, futuresPrice: Double, tradeAmount: Double, profit: Double, retries: Int = 3) {
        let url = URL(string: "http://127.0.0.1:5001/trade")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.timeoutInterval = 30.0

        let tradeData = structureTradeData(strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit)

        print("DEBUG: Attempting to send trade to Flask server: \(tradeData)")

        do {
            let jsonData = try JSONSerialization.data(withJSONObject: tradeData, options: [])
            request.httpBody = jsonData
            attemptSend(attempt: 1, request: request, strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit, retries: retries)
        } catch {
            print("DEBUG: Failed to serialize trade data: \(error.localizedDescription)")
            Task { @MainActor in
                logTradeLocally(strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit)
            }
        }
    }

    @MainActor
    static func saveHistoricalSpreadsToCSV(pair: String, spread: Double, predictedSpreadChange: Double?) {
        print("DEBUG: Entering saveHistoricalSpreadsToCSV for \(pair), spread: \(spread), predictedSpreadChange: \(predictedSpreadChange ?? 0.0) at \(ISO8601DateFormatter().string(from: Date()))")
        
        guard spread > 0 else {
            print("DEBUG: Skipping invalid spread for \(pair): \(spread)")
            logAlert(event: "Skipping invalid spread for \(pair): \(spread)")
            return
        }
        
        let timestampFormatter = ISO8601DateFormatter()
        timestampFormatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        let timestamp = timestampFormatter.string(from: Date())
        // FIX: Safely unwrap optional with nil coalescing
        let predictedSpreadChangeValue = predictedSpreadChange ?? 0.0
        
        let kucoinSpotPrice = kucoinCurrentPrice[pair] ?? 0.0
        let kucoinFuturesPrice = kucoinCurrentFuturesPrice[pair] ?? 0.0
        let bybitSpotPrice = bybitCurrentPrice[pair] ?? 0.0
        let bybitFuturesPrice = bybitCurrentFuturesPrice[pair] ?? 0.0
        let kucoinSpotRsi = calculateRSI(prices: kucoinPrices[pair] ?? [], period: spotRsiPeriod) ?? 50.0
        let kucoinFuturesRsi = calculateRSI(prices: kucoinFuturesPrices[pair] ?? [], period: spotRsiPeriod) ?? 50.0
        let bybitSpotRsi = calculateRSI(prices: bybitPrices[pair] ?? [], period: spotRsiPeriod) ?? 50.0
        let bybitFuturesRsi = calculateRSI(prices: bybitFuturesPrices[pair] ?? [], period: spotRsiPeriod) ?? 50.0
        let kucoinSpotMacd = calculateMACD(prices: kucoinPrices[pair] ?? [], shortPeriod: macdShortPeriod, longPeriod: macdLongPeriod, signalPeriod: macdSignalPeriod) ?? (macd: 0.0, signal: 0.0, histogram: 0.0)
        let kucoinFuturesMacd = calculateMACD(prices: kucoinFuturesPrices[pair] ?? [], shortPeriod: macdShortPeriod, longPeriod: macdLongPeriod, signalPeriod: macdSignalPeriod) ?? (macd: 0.0, signal: 0.0, histogram: 0.0)
        let bybitSpotMacd = calculateMACD(prices: bybitPrices[pair] ?? [], shortPeriod: macdShortPeriod, longPeriod: macdLongPeriod, signalPeriod: macdSignalPeriod) ?? (macd: 0.0, signal: 0.0, histogram: 0.0)
        let bybitFuturesMacd = calculateMACD(prices: bybitFuturesPrices[pair] ?? [], shortPeriod: macdShortPeriod, longPeriod: macdLongPeriod, signalPeriod: macdSignalPeriod) ?? (macd: 0.0, signal: 0.0, histogram: 0.0)
        let kucoinSpotAtr = kucoinFuturesATR[pair] ?? 0.0
        let bybitSpotAtr = bybitFuturesATR[pair] ?? 0.0
        let kucoinFundingRate = kucoinFundingRates[pair] ?? 0.0
        let bybitFundingRate = bybitFundingRates[pair] ?? 0.0
        let sentimentScore = sentimentScores[pair] ?? 0.0
        
        print("DEBUG: Input prices for \(pair): kucoinSpotPrice=\(kucoinSpotPrice), kucoinFuturesPrice=\(kucoinFuturesPrice), bybitSpotPrice=\(bybitSpotPrice), bybitFuturesPrice=\(bybitFuturesPrice)")
        
        let minimalLogEntry = "\(timestamp),\(pair),\(spread),\(predictedSpreadChangeValue)\n"
        let spreadsCSVURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/historical_spreads.csv")
        
        let extendedLogEntry = "\(pair),\(timestamp),\(spread),\(predictedSpreadChangeValue),\(kucoinSpotPrice),\(kucoinFuturesPrice),\(bybitSpotPrice),\(bybitFuturesPrice),\(kucoinSpotRsi),\(kucoinFuturesRsi),\(bybitSpotRsi),\(bybitFuturesRsi),\(kucoinSpotMacd.histogram),\(kucoinFuturesMacd.histogram),\(bybitSpotMacd.histogram),\(bybitFuturesMacd.histogram),\(kucoinSpotAtr),\(bybitSpotAtr),\(kucoinFundingRate),\(bybitFundingRate),\(sentimentScore)\n"
        let extendedSpreadsCSVURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/historical_spreads_extended.csv")
        
        let fileManager = FileManager.default
        
        do {
            let directoryURL = spreadsCSVURL.deletingLastPathComponent()
            if !fileManager.fileExists(atPath: directoryURL.path) {
                try fileManager.createDirectory(at: directoryURL, withIntermediateDirectories: true, attributes: nil)
                print("DEBUG: Created directory for historical_spreads.csv at \(directoryURL.path)")
            }
            
            if !fileManager.fileExists(atPath: spreadsCSVURL.path) {
                let header = "timestamp,pair,spread,predictedSpreadChange\n"
                try header.write(to: spreadsCSVURL, atomically: true, encoding: .utf8)
                try fileManager.setAttributes([.posixPermissions: 0o644], ofItemAtPath: spreadsCSVURL.path)
                print("DEBUG: Created historical_spreads.csv with header")
            }
            
            guard let minimalData = minimalLogEntry.data(using: .utf8) else {
                print("DEBUG: Failed to convert minimal log entry to data for \(pair)")
                logAlert(event: "Failed to convert minimal log entry to data for \(pair)")
                return
            }
            
            var writeSuccess = false
            for attempt in 1...3 {
                do {
                    if let fileHandle = try? FileHandle(forWritingTo: spreadsCSVURL) {
                        defer { fileHandle.closeFile() }
                        fileHandle.seekToEndOfFile()
                        fileHandle.write(minimalData)
                        writeSuccess = true
                        print("DEBUG: Appended minimal historical spread to CSV for \(pair) (attempt \(attempt)): Spread=\(spread), PredictedChange=\(predictedSpreadChangeValue)")
                        break
                    } else {
                        try minimalLogEntry.write(to: spreadsCSVURL, atomically: true, encoding: .utf8)
                        writeSuccess = true
                        print("DEBUG: Wrote minimal historical spread to CSV for \(pair) (attempt \(attempt)): Spread=\(spread), PredictedChange=\(predictedSpreadChangeValue)")
                        break
                    }
                } catch {
                    print("DEBUG: Failed to write minimal historical spread to CSV for \(pair) (attempt \(attempt)): \(error.localizedDescription)")
                    if attempt < 3 {
                        Thread.sleep(forTimeInterval: 0.1 * Double(attempt))
                    }
                }
            }
            
            if !writeSuccess {
                print("DEBUG: Failed to save minimal historical spread to CSV for \(pair) after 3 attempts")
                logAlert(event: "Failed to save minimal historical spread to CSV for \(pair) after 3 attempts")
            }
            
            historicalSpreads[pair, default: []].append(spread)
        } catch {
            print("DEBUG: Failed to save minimal historical spread to CSV for \(pair): \(error.localizedDescription)")
            logAlert(event: "Failed to save minimal historical spread to CSV for \(pair): \(error.localizedDescription)")
        }
        
        do {
            let directoryURL = extendedSpreadsCSVURL.deletingLastPathComponent()
            if !fileManager.fileExists(atPath: directoryURL.path) {
                try fileManager.createDirectory(at: directoryURL, withIntermediateDirectories: true, attributes: nil)
                print("DEBUG: Created directory for historical_spreads_extended.csv at \(directoryURL.path)")
            }
            
            if !fileManager.fileExists(atPath: extendedSpreadsCSVURL.path) {
                let header = "pair,timestamp,spread,predicted_spread_change,kucoin_spot_price,kucoin_futures_price,bybit_spot_price,bybit_futures_price,kucoin_spot_rsi,kucoin_futures_rsi,bybit_spot_rsi,bybit_futures_rsi,kucoin_spot_macd_histogram,kucoin_futures_macd_histogram,bybit_spot_macd_histogram,bybit_futures_macd_histogram,kucoin_spot_atr,bybit_spot_atr,kucoin_funding_rate,bybit_funding_rate,sentiment_score\n"
                try header.write(to: extendedSpreadsCSVURL, atomically: true, encoding: .utf8)
                try fileManager.setAttributes([.posixPermissions: 0o644], ofItemAtPath: extendedSpreadsCSVURL.path)
                print("DEBUG: Created historical_spreads_extended.csv with header")
            }
            
            guard let extendedData = extendedLogEntry.data(using: .utf8) else {
                print("DEBUG: Failed to convert extended log entry to data for \(pair)")
                logAlert(event: "Failed to convert extended log entry to data for \(pair)")
                return
            }
            
            var extendedWriteSuccess = false
            for attempt in 1...3 {
                do {
                    if let fileHandle = try? FileHandle(forWritingTo: extendedSpreadsCSVURL) {
                        defer { fileHandle.closeFile() }
                        fileHandle.seekToEndOfFile()
                        fileHandle.write(extendedData)
                        extendedWriteSuccess = true
                        print("DEBUG: Appended extended historical spread to CSV for \(pair) (attempt \(attempt)): Spread=\(spread), PredictedChange=\(predictedSpreadChangeValue)")
                        break
                    } else {
                        try extendedLogEntry.write(to: extendedSpreadsCSVURL, atomically: true, encoding: .utf8)
                        extendedWriteSuccess = true
                        print("DEBUG: Wrote extended historical spread to CSV for \(pair) (attempt \(attempt)): Spread=\(spread), PredictedChange=\(predictedSpreadChangeValue)")
                        break
                    }
                } catch {
                    print("DEBUG: Failed to write extended historical spread to CSV for \(pair) (attempt \(attempt)): \(error.localizedDescription)")
                    if attempt < 3 {
                        Thread.sleep(forTimeInterval: 0.1 * Double(attempt))
                    }
                }
            }
            
            if !extendedWriteSuccess {
                print("DEBUG: Failed to save extended historical spread to CSV for \(pair) after 3 attempts")
                logAlert(event: "Failed to save extended historical spread to CSV for \(pair) after 3 attempts")
            }
        } catch {
            print("DEBUG: Failed to save extended historical spread to CSV for \(pair): \(error.localizedDescription)")
            logAlert(event: "Failed to save extended historical spread to CSV for \(pair): \(error.localizedDescription)")
        }
    }

    @MainActor
    static func logHistoricalTradeToCSV(pair: String, strategy: String, profit: Double, fees: Double) {
        let timestampFormatter = ISO8601DateFormatter()
        timestampFormatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        let timestamp = timestampFormatter.string(from: Date())
        let tradesCSVURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/historical_trades.csv")
        let logEntry = "\(timestamp),\(pair),\(strategy),\(profit),\(fees)\n"
        
        do {
            let fileManager = FileManager.default
            let directoryURL = tradesCSVURL.deletingLastPathComponent()
            if !fileManager.fileExists(atPath: directoryURL.path) {
                try fileManager.createDirectory(at: directoryURL, withIntermediateDirectories: true, attributes: nil)
                print("DEBUG: Created directory for historical_trades.csv at \(directoryURL.path)")
            }
            
            if !fileManager.fileExists(atPath: tradesCSVURL.path) {
                let header = "timestamp,pair,strategy,profit,fees\n"
                try header.write(to: tradesCSVURL, atomically: true, encoding: .utf8)
                try fileManager.setAttributes([.posixPermissions: 0o644], ofItemAtPath: tradesCSVURL.path)
                print("DEBUG: Created historical_trades.csv with header")
            }
            
            guard let data = logEntry.data(using: .utf8) else {
                print("DEBUG: Failed to convert trade log entry to data for \(pair)")
                logAlert(event: "Failed to convert trade log entry to data for \(pair)")
                return
            }
            
            var writeSuccess = false
            for attempt in 1...3 {
                do {
                    if let fileHandle = try? FileHandle(forWritingTo: tradesCSVURL) {
                        defer { fileHandle.closeFile() }
                        fileHandle.seekToEndOfFile()
                        fileHandle.write(data)
                        writeSuccess = true
                        print("DEBUG: Appended trade to historical_trades.csv for \(pair) (attempt \(attempt)): Profit=\(profit), Fees=\(fees)")
                        break
                    } else {
                        try logEntry.write(to: tradesCSVURL, atomically: true, encoding: .utf8)
                        writeSuccess = true
                        print("DEBUG: Wrote trade to historical_trades.csv for \(pair) (attempt \(attempt)): Profit=\(profit), Fees=\(fees)")
                        break
                    }
                } catch {
                    print("DEBUG: Failed to write trade to historical_trades.csv for \(pair) (attempt \(attempt)): \(error.localizedDescription)")
                    if attempt < 3 {
                        Thread.sleep(forTimeInterval: 0.1 * Double(attempt))
                    }
                }
            }
            
            if !writeSuccess {
                print("DEBUG: Failed to save trade to historical_trades.csv for \(pair) after 3 attempts")
                logAlert(event: "Failed to save trade to historical_trades.csv for \(pair) after 3 attempts")
            }
        } catch {
            print("DEBUG: Failed to save trade to historical_trades.csv for \(pair): \(error.localizedDescription)")
            logAlert(event: "Failed to save trade to historical_trades.csv for \(pair): \(error.localizedDescription)")
        }
    }

    static func fetchSpreadPrediction(pair: String, exchange: String, spotPrice: Double, futuresPrice: Double, retryCount: Int = 0) async -> Double? {
           let maxRetries = 3
           guard retryCount < maxRetries else {
               print("DEBUG: Max retries reached for spread prediction for \(pair) on \(exchange)")
               Task { @MainActor in
                   logAlert(event: "Max retries reached for spread prediction for \(pair) on \(exchange)")
               }
               return arbitrageMinSpreadThreshold
           }

           let url = URL(string: "http://127.0.0.1:5001/predict_spread")!
           var request = URLRequest(url: url)
           request.httpMethod = "POST"
           request.addValue("application/json", forHTTPHeaderField: "Content-Type")
           request.timeoutInterval = 5.0

           let payload: [String: Any] = [
               "pair": pair,
               "exchange": exchange,
               "spot_price": spotPrice,
               "futures_price": futuresPrice,
               "kucoin_spot_rsi": calculateRSI(prices: kucoinPrices[pair] ?? [], period: spotRsiPeriod) ?? 50.0,
               "bybit_spot_rsi": calculateRSI(prices: bybitPrices[pair] ?? [], period: spotRsiPeriod) ?? 50.0,
               "kucoin_funding_rate": kucoinFundingRates[pair] ?? 0.0,
               "bybit_funding_rate": bybitFundingRates[pair] ?? 0.0,
               "sentiment_score": sentimentScores[pair] ?? 0.0
           ]

           do {
               let jsonData = try JSONSerialization.data(withJSONObject: payload, options: [])
               request.httpBody = jsonData
           } catch {
               print("DEBUG: Failed to serialize spread prediction payload for \(pair): \(error.localizedDescription)")
               return arbitrageMinSpreadThreshold
           }

           do {
               let (data, response) = try await URLSession.shared.data(for: request)
               
               guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                   print("DEBUG: ML server not available for \(pair), using fallback threshold")
                   return arbitrageMinSpreadThreshold
               }

               guard let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                     let predictedSpread = json["predicted_spread"] as? Double else {
                   print("DEBUG: Failed to parse spread prediction for \(pair), using fallback")
                   return arbitrageMinSpreadThreshold
               }

               print("✅ ML prediction for \(pair): \(predictedSpread)")
               return predictedSpread
           } catch {
               print("DEBUG: ML server connection failed for \(pair): \(error)")
               return arbitrageMinSpreadThreshold
           }
       }
    static func evaluateCrossExchangeOpportunityWithML(
           pair: String,
           kucoinPrice: Double,
           bybitPrice: Double,
           strategy: String,
           completion: @escaping (Bool, Double) -> Void
       ) async {
           let spread = abs(kucoinPrice - bybitPrice) / min(kucoinPrice, bybitPrice)
           
           // Get ML prediction
           let mlPrediction = await fetchSpreadPrediction(
               pair: pair,
               exchange: "cross",
               spotPrice: kucoinPrice,
               futuresPrice: bybitPrice
           ) ?? 0.0
           
           // Enhanced decision logic with ML
           let baseThreshold = crossExchangeMinSpreadThreshold
           let mlAdjustedThreshold = baseThreshold * (1 - mlPrediction)
           let shouldExecute = spread > mlAdjustedThreshold
           
           print("🤖 ML ANALYSIS for \(pair):")
           print("   Current Spread: \(String(format: "%.6f", spread))")
           print("   ML Prediction: \(String(format: "%.6f", mlPrediction))")
           print("   Adjusted Threshold: \(String(format: "%.6f", mlAdjustedThreshold))")
           print("   Decision: \(shouldExecute ? "EXECUTE" : "SKIP")")
           
           await MainActor.run {
               logAlert(event: "🤖 ML DECISION: \(pair) - \(shouldExecute ? "EXECUTE" : "SKIP") (spread: \(String(format: "%.6f", spread)), ML: \(String(format: "%.6f", mlPrediction)))")
           }
           
           completion(shouldExecute, spread)
       }

       // Enhanced price fetching with error handling and logging
       static func fetchAllPricesWithLogging() async {
           await MainActor.run {
               logAlert(event: "🔄 Fetching all prices for \(tradingPairs.count) pairs...")
           }
           
           for (index, pair) in tradingPairs.enumerated() {
               print("🔄 Fetching prices for \(pair) (\(index + 1)/\(tradingPairs.count))")
               
               // Fetch all 4 price types and use the results
               async let kucoinSpotPrice = fetchKuCoinSpotPrice(pair: pair)
               async let kucoinFuturesPrice = fetchKuCoinFuturesPrice(pair: pair)
               async let bybitSpotPrice = fetchBybitSpotPrice(pair: pair)
               async let bybitFuturesPrice = fetchBybitFuturesPrice(pair: pair)

               // Actually use the fetched prices
               let fetchedKucoinSpot = await kucoinSpotPrice ?? 0.0
               let fetchedKucoinFutures = await kucoinFuturesPrice ?? 0.0
               let fetchedBybitSpot = await bybitSpotPrice ?? 0.0
               let fetchedBybitFutures = await bybitFuturesPrice ?? 0.0

               print("📊 Fetched prices for \(pair): KuCoin Spot=$\(fetchedKucoinSpot), Futures=$\(fetchedKucoinFutures), Bybit Spot=$\(fetchedBybitSpot), Futures=$\(fetchedBybitFutures)")
               
               // Wait for all to complete
               // Wait for all to complete
               let _ = await kucoinSpotPrice
               let _ = await kucoinFuturesPrice
               let _ = await bybitSpotPrice
               let _ = await bybitFuturesPrice
               
               
               await MainActor.run {
                   let kcSpot = kucoinCurrentPrice[pair] ?? 0.0
                   let kcFutures = kucoinCurrentFuturesPrice[pair] ?? 0.0
                   let bbSpot = bybitCurrentPrice[pair] ?? 0.0
                   let bbFutures = bybitCurrentFuturesPrice[pair] ?? 0.0
                   
                   let validPrices = (kcSpot > 0 ? 1 : 0) + (kcFutures > 0 ? 1 : 0) + (bbSpot > 0 ? 1 : 0) + (bbFutures > 0 ? 1 : 0)
                   
                   if validPrices > 0 {
                       print("✅ \(pair): \(validPrices)/4 prices updated")
                       logAlert(event: "✅ \(pair): \(validPrices)/4 prices active")
                   } else {
                       print("❌ \(pair): No prices updated")
                       logAlert(event: "❌ \(pair): No prices received")
                   }
               }
           }
       }

       // Enhanced trading monitoring with CSV output
       static func startEnhancedTradingMonitor() {
           print("🎯 Starting enhanced trading monitor...")
           
           Task {
               while true {
                   do {
                       await fetchAllPricesWithLogging()
                       
                       await MainActor.run {
                           let validPairCount = tradingPairs.filter { pair in
                               let kcSpot = kucoinCurrentPrice[pair] ?? 0.0
                               let bbSpot = bybitCurrentPrice[pair] ?? 0.0
                               return kcSpot > 0 || bbSpot > 0
                           }.count
                           
                           logAlert(event: "📊 Monitor cycle: \(validPairCount)/\(tradingPairs.count) pairs have prices")
                           
                           // Generate some sample spread data for testing
                           for pair in tradingPairs.prefix(5) {
                               let kcPrice = kucoinCurrentPrice[pair] ?? 0.0
                               let bbPrice = bybitCurrentPrice[pair] ?? 0.0
                               if kcPrice > 0 && bbPrice > 0 {
                                   let spread = abs(kcPrice - bbPrice) / min(kcPrice, bbPrice)
                                   saveHistoricalSpreadsToCSV(pair: pair, spread: spread, predictedSpreadChange: 0.0)
                               }
                           }
                       }
                       
                       try await Task.sleep(nanoseconds: 10_000_000_000) // 10 seconds
                   } catch {
                       await MainActor.run {
                           logAlert(event: "Trading monitor sleep interrupted: \(error)")
                       }
                   }
               }
           }
       }

       // Test function to generate sample trades for CSV testing
       @MainActor
       static func generateTestTrade(pair: String) {
           let strategies = ["Test_Arbitrage", "Test_Scalping", "Test_Cross_Exchange"]
           let strategy = strategies.randomElement() ?? "Test"
           let profit = Double.random(in: 0.10...2.50)
           let fees = Double.random(in: 0.05...0.15)
           
           print("🧪 Generating test trade for \(pair): Strategy=\(strategy), Profit=$\(String(format: "%.4f", profit))")
           
           updateTradeMetrics(
               pair: pair,
               profit: profit,
               fees: fees,
               isWin: profit > fees,
               dashboardJSONURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/dashboard.json"),
               totalProfit: &ExchangeWebSocket.totalProfit,
               totalFees: &ExchangeWebSocket.totalFees
           )
           
           logTradeToCSV(
               pair: pair,
               strategy: strategy,
               profit: profit,
               fees: fees,
               tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trade_log.csv")
           )
           
           logAlert(event: "🧪 TEST TRADE: \(pair) - \(strategy) - P: $\(String(format: "%.4f", profit))")
       }

       // Function to test CSV output
       @MainActor
       static func testCSVOutput() {
           print("🧪 Testing CSV output functionality...")
           logAlert(event: "🧪 Starting CSV output tests")
           
           // Test trade_log.csv
           for pair in tradingPairs.prefix(3) {
               generateTestTrade(pair: pair)
           }
           
           // Test historical_spreads.csv
           for pair in tradingPairs.prefix(3) {
               let testSpread = Double.random(in: 0.001...0.01)
               saveHistoricalSpreadsToCSV(pair: pair, spread: testSpread, predictedSpreadChange: 0.0)
           }
           
           // Test alerts.csv
           logAlert(event: "🧪 CSV test completed successfully")
           
           print("✅ CSV test sequence completed")
       }
   }

