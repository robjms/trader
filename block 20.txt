

//-------------------------------------------------------------------------------------------------------------------------Block 20 - API Data Retrieval and Authentication


import CryptoKit
import Foundation

extension Data {
    func hmac(key: String) -> String {
        let keyData = key.data(using: .utf8)!
        let signature = HMAC<SHA256>.authenticationCode(for: self, using: SymmetricKey(data: keyData))
        return Data(signature).base64EncodedString()
    }
}

// Extension for Block 20 API Interactions and Authentication
extension ExchangeWebSocket {
    static func fetchBalance(exchange: String) async {
        let _ = getInt("BALANCE_FETCH_TIMEOUT", defaultValue: 20)
        let maxRetries = getInt("API_MAX_RETRIES", defaultValue: 5)
        var retries = 0

        while retries < maxRetries {
            let startTime = Date()
            do {
                if exchange == "kucoin" {
                    let balance = try await fetchKuCoinBalance()
                    await MainActor.run {
                        kucoinLiveBalance = balance
                        kucoinBalance = balance ?? kucoinFallbackBalance
                        print("DEBUG: Fetched KuCoin balance: \(kucoinBalance) USDT")
                    }
                    break
                } else if exchange == "bybit" {
                    let balance = try await fetchBybitBalance()
                    await MainActor.run {
                        bybitLiveBalance = balance
                        bybitBalance = balance ?? bybitFallbackBalance
                        print("DEBUG: Fetched Bybit balance: \(bybitBalance) USDT")
                    }
                    break
                }
            } catch {
                retries += 1
                let latency = Date().timeIntervalSince(startTime) * 1000
                await MainActor.run {
                    logAlert(event: "Failed to fetch \(exchange) balance: \(error.localizedDescription), retry \(retries)/\(maxRetries), latency: \(latency)ms")
                }
                if retries == maxRetries {
                    await MainActor.run {
                        logAlert(event: "Max retries reached for \(exchange) balance fetch")
                        if exchange == "kucoin" {
                            kucoinBalance = kucoinFallbackBalance
                        } else {
                            bybitBalance = bybitFallbackBalance
                        }
                    }
                }
                try? await Task.sleep(nanoseconds: UInt64(1_000_000_000)) // 1-second delay
            }
        }
    }

    static func fetchKuCoinBalance() async throws -> Double? {
        // DEBUG: Log function start
        await MainActor.run {
            logAlert(event: "游댮 DEBUG: fetchKuCoinBalance() function started")
            logAlert(event: "游댮 DEBUG: KuCoin API Key exists: \(environment["KUCOIN_API_KEY"] != nil)")
            logAlert(event: "游댮 DEBUG: KuCoin API Secret exists: \(environment["KUCOIN_API_SECRET"] != nil)")
            logAlert(event: "游댮 DEBUG: KuCoin Passphrase exists: \(environment["KUCOIN_API_PASSPHRASE"] != nil)")
        }
        
        guard let apiKey = environment["KUCOIN_API_KEY"],
              let apiSecret = environment["KUCOIN_API_SECRET"],
              let apiPassphrase = environment["KUCOIN_API_PASSPHRASE"] else {
            await MainActor.run {
                logAlert(event: "游댮 ERROR: Missing KuCoin API credentials")
            }
            throw NSError(domain: "KuCoinAPI", code: -1, userInfo: [NSLocalizedDescriptionKey: "Missing API credentials"])
        }
        
        let url = URL(string: "https://api.kucoin.com/api/v1/accounts?currency=USDT&type=trade")!
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = Double(getInt("BALANCE_FETCH_TIMEOUT", defaultValue: 20))

        let timestamp = String(Int(Date().timeIntervalSince1970 * 1000))
        let endpoint = "/api/v1/accounts?currency=USDT&type=trade"
        let method = "GET"
        let body = "" // Empty body for GET request
        let strToSign = timestamp + method + endpoint + body
        
        await MainActor.run {
            logAlert(event: "游댮 DEBUG: KuCoin signing string: \(strToSign)")
        }
        
        let signature = strToSign.data(using: .utf8)!.hmac(key: apiSecret)
        
        // For API v2.0+: Encrypt passphrase with HMAC-SHA256 using API secret, then base64 encode
        let encryptedPassphrase = apiPassphrase.data(using: .utf8)!.hmac(key: apiSecret)

        // Set headers for API v2.0+
        request.addValue(apiKey, forHTTPHeaderField: "KC-API-KEY")
        request.addValue(signature, forHTTPHeaderField: "KC-API-SIGN")
        request.addValue(timestamp, forHTTPHeaderField: "KC-API-TIMESTAMP")
        request.addValue(encryptedPassphrase, forHTTPHeaderField: "KC-API-PASSPHRASE")
        request.addValue("2", forHTTPHeaderField: "KC-API-KEY-VERSION") // Critical: API version 2
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")

        await MainActor.run {
            logAlert(event: "游댮 DEBUG: KuCoin request headers set, making API call...")
        }

        let (data, response) = try await URLSession.shared.data(for: request)
        guard let httpResponse = response as? HTTPURLResponse else {
            await MainActor.run {
                logAlert(event: "游댮 ERROR: Non-HTTP response for KuCoin balance fetch")
            }
            throw NSError(domain: "KuCoinAPI", code: -1, userInfo: [NSLocalizedDescriptionKey: "Non-HTTP response"])
        }
        
        let responseBody = String(data: data, encoding: .utf8) ?? "Invalid data"
        await MainActor.run {
            logAlert(event: "游댮 DEBUG: KuCoin response status: \(httpResponse.statusCode)")
            logAlert(event: "游댮 DEBUG: KuCoin response: \(responseBody)")
        }
        
        if httpResponse.statusCode != 200 {
            await MainActor.run {
                logAlert(event: "游댮 ERROR: Invalid KuCoin response status \(httpResponse.statusCode): \(responseBody)")
            }
            throw NSError(domain: "KuCoinAPI", code: httpResponse.statusCode, userInfo: [NSLocalizedDescriptionKey: "HTTP \(httpResponse.statusCode)"])
        }

        let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
        guard let code = json?["code"] as? String else {
            await MainActor.run {
                logAlert(event: "游댮 ERROR: KuCoin response missing code field")
            }
            return nil
        }
        guard code == "200000" else {
            let errorMsg = json?["msg"] as? String ?? "Unknown error"
            await MainActor.run {
                logAlert(event: "游댮 ERROR: KuCoin API error code \(code): \(errorMsg)")
            }
            return nil
        }
        guard let dataJson = json?["data"] as? [[String: Any]] else {
            await MainActor.run {
                logAlert(event: "游댮 ERROR: KuCoin response missing data array")
            }
            return nil
        }
        
        await MainActor.run {
            logAlert(event: "游댮 DEBUG: KuCoin found \(dataJson.count) accounts")
        }
        
        let balance = dataJson.reduce(0.0) { sum, account in
            if (account["type"] as? String) == "trade" && (account["currency"] as? String) == "USDT",
               let availableStr = account["available"] as? String,
               let available = Double(availableStr) {
                return sum + available
            }
            return sum
        }
        
        if balance == 0.0 {
            await MainActor.run {
                logAlert(event: "游댮 WARNING: KuCoin USDT trade account has zero balance")
            }
        }

        await MainActor.run {
            logAlert(event: "游댮 SUCCESS: KuCoin balance parsed: \(balance) USDT")
        }

        return balance
    }

    static func fetchBybitBalance() async throws -> Double? {
        // DEBUG: Log function start
        await MainActor.run {
            logAlert(event: "游댯 DEBUG: fetchBybitBalance() function started")
            logAlert(event: "游댯 DEBUG: Bybit API Key exists: \(environment["BYBIT_API_KEY"] != nil)")
            logAlert(event: "游댯 DEBUG: Bybit API Secret exists: \(environment["BYBIT_API_SECRET"] != nil)")
        }
        
        guard let apiKey = environment["BYBIT_API_KEY"],
              let apiSecret = environment["BYBIT_API_SECRET"] else {
            await MainActor.run {
                logAlert(event: "游댯 ERROR: Missing Bybit API credentials")
            }
            throw NSError(domain: "BybitAPI", code: -1, userInfo: [NSLocalizedDescriptionKey: "Missing API credentials"])
        }
        
        let url = URL(string: "https://api.bybit.com/v5/account/wallet-balance?accountType=UNIFIED&coin=USDT")!
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = Double(getInt("BALANCE_FETCH_TIMEOUT", defaultValue: 20))

        let timestamp = String(Int(Date().timeIntervalSince1970 * 1000))
        let recvWindow = environment["BYBIT_RECV_WINDOW"] ?? "5000"
        let queryString = "accountType=UNIFIED&coin=USDT"
        let paramStr = timestamp + apiKey + recvWindow + queryString
        
        await MainActor.run {
            logAlert(event: "游댯 DEBUG: Bybit signing string: \(paramStr)")
        }
        
        let signature = paramStr.data(using: .utf8)!.hmac(key: apiSecret)

        request.addValue(apiKey, forHTTPHeaderField: "X-BAPI-API-KEY")
        request.addValue(timestamp, forHTTPHeaderField: "X-BAPI-TIMESTAMP")
        request.addValue(recvWindow, forHTTPHeaderField: "X-BAPI-RECV-WINDOW")
        request.addValue(signature, forHTTPHeaderField: "X-BAPI-SIGN")
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")

        await MainActor.run {
            logAlert(event: "游댯 DEBUG: Bybit request headers set, making API call...")
        }

        let (data, response) = try await URLSession.shared.data(for: request)
        guard let httpResponse = response as? HTTPURLResponse else {
            await MainActor.run {
                logAlert(event: "游댯 ERROR: Non-HTTP response for Bybit balance fetch")
            }
            throw NSError(domain: "BybitAPI", code: -1, userInfo: [NSLocalizedDescriptionKey: "Non-HTTP response"])
        }
        
        let responseBody = String(data: data, encoding: .utf8) ?? "Invalid data"
        await MainActor.run {
            logAlert(event: "游댯 DEBUG: Bybit response status: \(httpResponse.statusCode)")
            logAlert(event: "游댯 DEBUG: Bybit response: \(responseBody)")
        }
        
        if httpResponse.statusCode != 200 {
            await MainActor.run {
                logAlert(event: "游댯 ERROR: Invalid Bybit response status \(httpResponse.statusCode): \(responseBody)")
            }
            throw NSError(domain: "BybitAPI", code: httpResponse.statusCode, userInfo: [NSLocalizedDescriptionKey: "HTTP \(httpResponse.statusCode)"])
        }

        let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
        guard let retCode = json?["retCode"] as? Int else {
            await MainActor.run {
                logAlert(event: "游댯 ERROR: Bybit response missing retCode")
            }
            return nil
        }
        guard retCode == 0 else {
            let retMsg = json?["retMsg"] as? String ?? "Unknown error"
            await MainActor.run {
                logAlert(event: "游댯 ERROR: Bybit API error code \(retCode): \(retMsg)")
            }
            return nil
        }
        guard let result = json?["result"] as? [String: Any],
              let list = result["list"] as? [[String: Any]] else {
            await MainActor.run {
                logAlert(event: "游댯 ERROR: Bybit response missing result.list")
            }
            return nil
        }
        
        await MainActor.run {
            logAlert(event: "游댯 DEBUG: Bybit found \(list.count) accounts")
        }
        
        var balance = 0.0
        for account in list {
            if let coinList = account["coin"] as? [[String: Any]] {
                if let usdt = coinList.first(where: { ($0["coin"] as? String) == "USDT" }),
                   let walletBalanceStr = usdt["walletBalance"] as? String,
                   let walletBalance = Double(walletBalanceStr) {
                    balance += walletBalance
                }
            }
        }
        
        if balance == 0.0 {
            await MainActor.run {
                logAlert(event: "游댯 WARNING: Bybit USDT account has zero balance")
            }
        }

        await MainActor.run {
            logAlert(event: "游댯 SUCCESS: Bybit balance parsed: \(balance) USDT")
        }

        return balance
    }

    static func fetchKuCoinOrderBook(pair: String, isFutures: Bool) async -> BevaixOrderBook? {
        // DEBUG: Log function start
        await MainActor.run {
            logAlert(event: "游리 DEBUG: fetchKuCoinOrderBook() started for \(pair) (futures: \(isFutures))")
        }
        
        let symbol = isFutures ? pair.replacingOccurrences(of: "-", with: "") + "M" : pair
        let baseURL = isFutures ? "https://api-futures.kucoin.com" : "https://api.kucoin.com"
        let path = isFutures ? "/api/v1/level2/snapshot" : "/api/v3/market/orderbook/level2"
        var endpoint = path + "?symbol=\(symbol)"
        if !isFutures {
            endpoint += "&limit=100"
        }
        let urlString = baseURL + endpoint
        
        await MainActor.run {
            logAlert(event: "游리 DEBUG: KuCoin orderbook URL: \(urlString)")
        }
        
        guard let url = URL(string: urlString) else {
            await MainActor.run {
                logAlert(event: "游리 ERROR: Invalid KuCoin orderbook URL: \(urlString)")
            }
            return nil
        }
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = Double(getInt("BALANCE_FETCH_TIMEOUT", defaultValue: 20))

        // Only add authentication headers for futures
        if isFutures {
            guard let apiKey = environment["KUCOIN_API_KEY"],
                  let apiSecret = environment["KUCOIN_API_SECRET"],
                  let apiPassphrase = environment["KUCOIN_API_PASSPHRASE"] else {
                await MainActor.run {
                    logAlert(event: "游리 ERROR: Missing KuCoin API credentials for futures")
                }
                return nil
            }
            
            let timestamp = String(Int(Date().timeIntervalSince1970 * 1000))
            let method = "GET"
            let body = ""
            let strToSign = timestamp + method + endpoint + body
            let signature = strToSign.data(using: .utf8)!.hmac(key: apiSecret)
            let encryptedPassphrase = apiPassphrase.data(using: .utf8)!.hmac(key: apiSecret)

            request.addValue(apiKey, forHTTPHeaderField: "KC-API-KEY")
            request.addValue(signature, forHTTPHeaderField: "KC-API-SIGN")
            request.addValue(timestamp, forHTTPHeaderField: "KC-API-TIMESTAMP")
            request.addValue(encryptedPassphrase, forHTTPHeaderField: "KC-API-PASSPHRASE")
            request.addValue("2", forHTTPHeaderField: "KC-API-KEY-VERSION")
            request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        }

        do {
            let (data, response) = try await URLSession.shared.data(for: request)
            guard let httpResponse = response as? HTTPURLResponse else {
                await MainActor.run {
                    logAlert(event: "游리 ERROR: Non-HTTP response for KuCoin orderbook \(pair)")
                }
                return nil
            }
            let responseBody = String(data: data, encoding: .utf8) ?? "Invalid data"
            
            await MainActor.run {
                logAlert(event: "游리 DEBUG: KuCoin orderbook response status: \(httpResponse.statusCode)")
                logAlert(event: "游리 DEBUG: KuCoin orderbook response: \(responseBody)")
            }
            
            if httpResponse.statusCode != 200 {
                await MainActor.run {
                    logAlert(event: "游리 ERROR: Invalid KuCoin orderbook status \(httpResponse.statusCode) for \(pair): \(responseBody)")
                }
                return nil
            }
            let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
            guard let code = json?["code"] as? String else {
                await MainActor.run {
                    logAlert(event: "游리 ERROR: KuCoin orderbook response missing code for \(pair)")
                }
                return nil
            }
            guard code == "200000" else {
                let errorMsg = json?["msg"] as? String ?? "Unknown error"
                await MainActor.run {
                    logAlert(event: "游리 ERROR: KuCoin orderbook API error for \(pair) - code: \(code), msg: \(errorMsg)")
                }
                return nil
            }
            guard let dataJson = json?["data"] as? [String: Any],
                  let bids = dataJson["bids"] as? [[String]],
                  let asks = dataJson["asks"] as? [[String]] else {
                await MainActor.run {
                    logAlert(event: "游리 ERROR: KuCoin orderbook missing bids/asks for \(pair): \(responseBody)")
                }
                return nil
            }
            
            await MainActor.run {
                logAlert(event: "游리 DEBUG: KuCoin orderbook raw bids: \(bids.count), asks: \(asks.count)")
            }
            
            let parsedBids = bids.compactMap { arr -> (Double, Double)? in
                guard arr.count >= 2, let price = Double(arr[0]), let qty = Double(arr[1]) else { return nil }
                return (price, qty)
            }
            let parsedAsks = asks.compactMap { arr -> (Double, Double)? in
                guard arr.count >= 2, let price = Double(arr[0]), let qty = Double(arr[1]) else { return nil }
                return (price, qty)
            }
            
            await MainActor.run {
                logAlert(event: "游리 DEBUG: KuCoin orderbook parsed bids: \(parsedBids.count), asks: \(parsedAsks.count)")
            }
            
            if parsedBids.isEmpty || parsedAsks.isEmpty {
                await MainActor.run {
                    logAlert(event: "游리 ERROR: KuCoin orderbook empty after parsing for \(pair)")
                }
                return nil
            }
            
            await MainActor.run {
                logAlert(event: "游리 SUCCESS: KuCoin orderbook parsed for \(pair)")
            }
            
            return BevaixOrderBook(bids: parsedBids, asks: parsedAsks)
        } catch {
            await MainActor.run {
                logAlert(event: "游리 ERROR: Failed to fetch KuCoin orderbook for \(pair): \(error.localizedDescription)")
            }
            return nil
        }
    }
    
    // FIX: Removed redundant fetchSentimentScore(pair:completion:) to resolve redeclaration at line 7839
    // The enhanced version with retry logic is already defined in Block 1
    
    // FIX: Enhanced sendTradeToFlaskServer with improved error handling and retry logic
    static func sendTradeToFlaskServer(strategy: String, pair: String, exchange: String, spotPrice: Double, futuresPrice: Double, tradeAmount: Double, profit: Double) {
        let maxRetries = 3
        let retryDelay: UInt64 = 2_000_000_000 // 2 seconds
        
        func attemptSend(attempt: Int) {
            let url = URL(string: environment["FLASK_SERVER_URL"] ?? "http://127.0.0.1:5000/trade")!
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.addValue("application/json", forHTTPHeaderField: "Content-Type")
            request.timeoutInterval = Double(getInt("FLASK_TIMEOUT", defaultValue: 10))

            let payload: [String: Any] = [
                "strategy": strategy,
                "pair": pair,
                "exchange": exchange,
                "spotPrice": spotPrice,
                "futuresPrice": futuresPrice,
                "tradeAmount": tradeAmount,
                "profit": profit,
                "timestamp": ISO8601DateFormatter().string(from: Date())
            ]

            do {
                let jsonData = try JSONSerialization.data(withJSONObject: payload, options: [])
                request.httpBody = jsonData
            } catch {
                print("DEBUG: Failed to serialize trade payload: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to serialize trade payload: \(error.localizedDescription)")
                }
                if attempt < maxRetries {
                    DispatchQueue.global().asyncAfter(deadline: .now() + .nanoseconds(Int(retryDelay))) {
                        attemptSend(attempt: attempt + 1)
                    }
                }
                return
            }

            let startTime = Date()
            let task = URLSession.shared.dataTask(with: request) { data, response, error in
                let latency = Date().timeIntervalSince(startTime) * 1000
                Task { @MainActor in
                    if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 80.0) {
                        logAlert(event: "High latency detected for Flask server: \(latency)ms")
                    }
                }

                if let error = error {
                    print("DEBUG: Failed to send trade to Flask server (attempt \(attempt)): \(error.localizedDescription)")
                    Task { @MainActor in
                        logAlert(event: "Failed to send trade to Flask server (attempt \(attempt)): \(error.localizedDescription)")
                    }
                    if attempt < maxRetries {
                        DispatchQueue.global().asyncAfter(deadline: .now() + .nanoseconds(Int(retryDelay))) {
                            attemptSend(attempt: attempt + 1)
                        }
                    }
                    return
                }

                guard let httpResponse = response as? HTTPURLResponse else {
                    print("DEBUG: Invalid HTTP response from Flask server")
                    Task { @MainActor in
                        logAlert(event: "Invalid HTTP response from Flask server")
                    }
                    if attempt < maxRetries {
                        DispatchQueue.global().asyncAfter(deadline: .now() + .nanoseconds(Int(retryDelay))) {
                            attemptSend(attempt: attempt + 1)
                        }
                    }
                    return
                }

                if httpResponse.statusCode == 200 {
                    print("DEBUG: Successfully sent trade to Flask server")
                    Task { @MainActor in
                        logAlert(event: "Successfully sent trade to Flask server: \(strategy) \(pair) profit: \(profit)")
                    }
                } else {
                    let responseBody = data != nil ? String(data: data!, encoding: .utf8) ?? "Invalid data" : "No data"
                    print("DEBUG: Flask server error \(httpResponse.statusCode): \(responseBody)")
                    Task { @MainActor in
                        logAlert(event: "Flask server error \(httpResponse.statusCode): \(responseBody)")
                    }
                    if attempt < maxRetries {
                        DispatchQueue.global().asyncAfter(deadline: .now() + .nanoseconds(Int(retryDelay))) {
                            attemptSend(attempt: attempt + 1)
                        }
                    }
                }
            }
            task.resume()
        }
        
        attemptSend(attempt: 1)
    }
    
    // Enhanced API helper functions for better error handling
    static func validateAPICredentials(exchange: String) -> Bool {
        if exchange == "kucoin" {
            return environment["KUCOIN_API_KEY"] != nil &&
                   environment["KUCOIN_API_SECRET"] != nil &&
                   environment["KUCOIN_API_PASSPHRASE"] != nil &&
                   !environment["KUCOIN_API_KEY"]!.isEmpty &&
                   !environment["KUCOIN_API_SECRET"]!.isEmpty &&
                   !environment["KUCOIN_API_PASSPHRASE"]!.isEmpty
        } else if exchange == "bybit" {
            return environment["BYBIT_API_KEY"] != nil &&
                   environment["BYBIT_API_SECRET"] != nil &&
                   !environment["BYBIT_API_KEY"]!.isEmpty &&
                   !environment["BYBIT_API_SECRET"]!.isEmpty
        }
        return false
    }
    
    // Enhanced error handling for API responses
    static func handleAPIError(exchange: String, statusCode: Int, responseBody: String) async {
        let errorMessage: String
        switch statusCode {
        case 401:
            errorMessage = "\(exchange) API authentication failed (401): Invalid credentials"
        case 403:
            errorMessage = "\(exchange) API access forbidden (403): Check API permissions"
        case 404:
            errorMessage = "\(exchange) API endpoint not found (404): Invalid URL or endpoint deprecated"
        case 429:
            errorMessage = "\(exchange) API rate limit exceeded (429): Too many requests"
        case 500...599:
            errorMessage = "\(exchange) API server error (\(statusCode)): Internal server error"
        default:
            errorMessage = "\(exchange) API error (\(statusCode)): \(responseBody)"
        }
        
        await MainActor.run {
            logAlert(event: errorMessage)
        }
        
        // Implement exponential backoff for certain errors
        if statusCode == 429 || (statusCode >= 500 && statusCode < 600) {
            try? await Task.sleep(nanoseconds: UInt64(5_000_000_000)) // 5 seconds
        }
    }
    
    // Enhanced market data fetching with fallback mechanisms
    static func fetchMarketDataWithFallback(exchange: String, pair: String) async -> [String: Any]? {
        let primaryEndpoints: [String: String] = [
            "kucoin": "https://api.kucoin.com/api/v1/market/stats?symbol=\(pair)",
            "bybit": "https://api.bybit.com/v5/market/tickers?category=spot&symbol=\(pair.replacingOccurrences(of: "-", with: ""))"
        ]
        
        let fallbackEndpoints: [String: String] = [
            "kucoin": "https://api.kucoin.com/api/v1/market/orderbook/level1?symbol=\(pair)",
            "bybit": "https://api.bybit.com/v5/market/orderbook?category=spot&symbol=\(pair.replacingOccurrences(of: "-", with: ""))&limit=1"
        ]
        
        // Try primary endpoint first
        if let data = await fetchMarketDataFromEndpoint(primaryEndpoints[exchange] ?? "", exchange: exchange) {
            return data
        }
        
        // Fall back to secondary endpoint
        if let data = await fetchMarketDataFromEndpoint(fallbackEndpoints[exchange] ?? "", exchange: exchange) {
            return data
        }
        
        await MainActor.run {
            logAlert(event: "Failed to fetch market data for \(exchange)-\(pair) from all endpoints")
        }
        return nil
    }
    
    private static func fetchMarketDataFromEndpoint(_ urlString: String, exchange: String) async -> [String: Any]? {
        guard let url = URL(string: urlString) else { return nil }
        
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = 10.0
        
        do {
            let (data, response) = try await URLSession.shared.data(for: request)
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                return nil
            }
            
            let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
            return json
        } catch {
            await MainActor.run {
                logAlert(event: "Error fetching market data from \(urlString): \(error.localizedDescription)")
            }
            return nil
        }
    }
    
    // Enhanced spread prediction with multiple data sources
    static func fetchSpreadPrediction(pair: String, exchange: String, spotPrice: Double, futuresPrice: Double) async -> Double? {
        // Calculate basic spread prediction using historical data
        let historicalData = historicalSpreads[pair] ?? []
        guard historicalData.count >= 10 else {
            return nil // Not enough historical data
        }
        
        // Simple moving average prediction
        let recentSpreads = historicalData.suffix(10)
        let averageSpread = recentSpreads.reduce(0.0, +) / Double(recentSpreads.count)
        
        // Add volatility adjustment
        let currentSpread = abs(spotPrice - futuresPrice) / min(spotPrice, futuresPrice)
        let volatility = calculateSpreadVolatility(spreads: Array(recentSpreads))
        
        // Predict based on trend and volatility
        let trendAdjustment = recentSpreads.last! - averageSpread
        let prediction = averageSpread + trendAdjustment * 0.5 + volatility * 0.1
        
        return max(0.0, prediction) // Ensure non-negative prediction
    }
    
    private static func calculateSpreadVolatility(spreads: [Double]) -> Double {
        guard spreads.count > 1 else { return 0.0 }
        
        let mean = spreads.reduce(0.0, +) / Double(spreads.count)
        let variance = spreads.reduce(0.0) { result, spread in
            result + pow(spread - mean, 2)
        } / Double(spreads.count - 1)
        
        return sqrt(variance)
    }
}
