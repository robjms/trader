//---------------------------------------------------------------------------------------------------------------------Block 9 - KuCoin WebSocket Processing
//---------------------------------------------------------------------------------------------------------------------Block 9 - KuCoin WebSocket Processing

// NOTE: Delegate classes are defined elsewhere in the codebase to prevent duplicates
// This block contains only the WebSocket message processing logic

extension ExchangeWebSocket {
    
    // ENHANCED: KuCoin Spot Message Processing
    @MainActor
    static func processKuCoinSpotMessage(_ json: [String: Any]) {
        guard let type = json["type"] as? String, type == "message",
              let topic = json["topic"] as? String,
              topic.hasPrefix("/market/ticker:"),
              let dataDict = json["data"] as? [String: Any] else {
            print("DEBUG: Invalid KuCoin Spot message format")
            return
        }
        
        let priceKeys = ["price", "last", "bestAsk", "bestBid"]
        var priceStr: String?
        for key in priceKeys {
            if let value = dataDict[key] as? String {
                priceStr = value
                break
            }
        }
        
        guard let priceStr = priceStr else {
            print("Failed to find price in KuCoin Spot message. Available keys: \(dataDict.keys)")
            return
        }
        
        // Fix ambiguous type expression by being explicit
        guard let price: Double = Double(priceStr) else {
            print("Failed to parse price '\(priceStr)' from KuCoin Spot message")
            return
        }
        
        let spotSymbol = topic.components(separatedBy: ":").last ?? ""
        let pair = spotSymbol
        
        kucoinCurrentPrice[pair] = price
        kucoinPrices[pair, default: []].append(price)
        
        if kucoinPrices[pair]!.count > priceHistoryRetention {
            kucoinPrices[pair]!.removeFirst()
        }
        
        // Process volume if available
        if let volStr = dataDict["size"] as? String ?? dataDict["volume"] as? String,
           let vol: Double = Double(volStr) {
            kucoinSpotVolume[pair, default: []].append(vol)
            if kucoinSpotVolume[pair]!.count > priceHistoryRetention {
                kucoinSpotVolume[pair]!.removeFirst()
            }
        }
        
        print("Updated KuCoin spot price for \(pair): \(price)")
        logAlert(event: "‚úÖ KuCoin Spot price update: \(pair) = $\(price)")
    }
    
    // ENHANCED: KuCoin Futures Message Processing
    @MainActor
    static func processKuCoinFuturesMessage(_ json: [String: Any]) {
        guard let type = json["type"] as? String, type == "message",
              let topic = json["topic"] as? String,
              let dataDict = json["data"] as? [String: Any] else {
            print("DEBUG: Invalid KuCoin Futures message format")
            return
        }
        
        if topic.hasPrefix("/contractMarket/tickerV2:") {
            processKuCoinFuturesTicker(topic: topic, data: dataDict)
        } else if topic.hasPrefix("/contractMarket/level2:") {
            processKuCoinFuturesOrderBook(topic: topic, data: dataDict)
        } else if topic.hasPrefix("/contract/instrument:") {
            processKuCoinFuturesFunding(topic: topic, data: dataDict)
        }
    }
    
    @MainActor
    private static func processKuCoinFuturesTicker(topic: String, data: [String: Any]) {
        let priceKeys = ["bestAskPrice", "bestBidPrice", "lastPrice", "indexPrice"]
        var priceStr: String?
        for key in priceKeys {
            if let value = data[key] as? String {
                priceStr = value
                break
            }
        }
        
        guard let priceStr = priceStr,
              let price: Double = Double(priceStr) else {
            print("Failed to find/parse price in KuCoin Futures message")
            return
        }
        
        let futuresSymbol = topic.components(separatedBy: ":").last ?? ""
        guard let pair = kucoinFuturesSymbols.first(where: { $0.value == futuresSymbol })?.key else {
            print("No pair found for futures symbol: \(futuresSymbol)")
            return
        }
        
        kucoinCurrentFuturesPrice[pair] = price
        kucoinFuturesPrices[pair, default: []].append(price)
        
        if kucoinFuturesPrices[pair]!.count > priceHistoryRetention {
            kucoinFuturesPrices[pair]!.removeFirst()
        }
        
        // Process volume
        if let volStr = data["volume"] as? String ?? data["size"] as? String,
           let vol: Double = Double(volStr) {
            kucoinFuturesVolume[pair, default: []].append(vol)
            if kucoinFuturesVolume[pair]!.count > priceHistoryRetention {
                kucoinFuturesVolume[pair]!.removeFirst()
            }
        }
        
        print("Updated KuCoin futures price for \(pair): \(price)")
        logAlert(event: "‚úÖ KuCoin Futures price update: \(pair) = $\(price)")
    }
    
    @MainActor
    private static func processKuCoinFuturesOrderBook(topic: String, data: [String: Any]) {
        let futuresSymbol = topic.components(separatedBy: ":").last ?? ""
        guard let pair = kucoinFuturesSymbols.first(where: { $0.value == futuresSymbol })?.key else {
            print("No pair found for futures symbol: \(futuresSymbol)")
            return
        }
        
        var orderBook: [(price: Double, volume: Double, side: String)] = []
        
        if let bids = data["bids"] as? [[String]],
           let asks = data["asks"] as? [[String]] {
            // Snapshot
            for bid in bids {
                if let priceStr = bid.first, let qtyStr = bid.last,
                   let price: Double = Double(priceStr),
                   let qty: Double = Double(qtyStr), qty > 0 {
                    orderBook.append((price: price, volume: qty, side: "buy"))
                }
            }
            for ask in asks {
                if let priceStr = ask.first, let qtyStr = ask.last,
                   let price: Double = Double(priceStr),
                   let qty: Double = Double(qtyStr), qty > 0 {
                    orderBook.append((price: price, volume: qty, side: "sell"))
                }
            }
        } else if let change = data["change"] as? String {
            // Incremental update
            orderBook = kucoinFuturesOrderBook[pair] ?? []
            let components = change.components(separatedBy: ",")
            if components.count == 3,
               let price: Double = Double(components[0]),
               let size: Double = Double(components[2]) {
                let side = components[1].lowercased() == "buy" ? "buy" : "sell"
                orderBook.removeAll { $0.price == price && $0.side == side }
                if size > 0 {
                    orderBook.append((price: price, volume: size, side: side))
                }
            }
        }
        
        kucoinFuturesOrderBook[pair] = orderBook
        print("DEBUG: Updated KuCoin futures order book for \(pair): \(orderBook.count) entries")
    }
    
    @MainActor
    private static func processKuCoinFuturesFunding(topic: String, data: [String: Any]) {
        guard let fundingRateStr = data["fundingRate"] as? String,
              let fundingRate: Double = Double(fundingRateStr),
              let futuresSymbol = topic.components(separatedBy: ":").last,
              let pair = kucoinFuturesSymbols.first(where: { $0.value == futuresSymbol })?.key else {
            return
        }
        
        kucoinFundingRates[pair] = fundingRate
        kucoinFundingRateHistory[pair, default: []].append(fundingRate)
        
        if kucoinFundingRateHistory[pair]!.count > 24 { // Keep 24 hours of history
            kucoinFundingRateHistory[pair]!.removeFirst()
        }
        
        print("Updated KuCoin funding rate for \(pair): \(fundingRate)")
        logAlert(event: "‚úÖ KuCoin Funding rate update: \(pair) = \(fundingRate * 100)%")
    }
    
    // ENHANCED: Bybit Spot Message Processing
    @MainActor
    static func processBybitSpotMessage(_ json: [String: Any]) {
        if let success = json["success"] as? Bool {
            if success, let retMsg = json["ret_msg"] as? String, retMsg == "subscribe" {
                print("Bybit Spot subscription confirmed")
            } else if !success {
                print("Bybit Spot WebSocket error: \(json)")
                logAlert(event: "‚ùå Bybit Spot WebSocket error: \(json)")
            }
        } else if let topic = json["topic"] as? String {
            if topic.hasPrefix("tickers.") {
                processBybitSpotTicker(data: json)
            } else if topic.hasPrefix("orderbook.50.") {
                processBybitSpotOrderBook(data: json)
            } else if topic.hasPrefix("publicTrade.") {
                processBybitSpotTrade(data: json)
            }
        }
    }
    
    @MainActor
    private static func processBybitSpotTicker(data: [String: Any]) {
        guard let dataDict = data["data"] as? [String: Any],
              let symbol = dataDict["symbol"] as? String else { return }
        
        let priceKeys = ["lastPrice", "bestAskPrice", "ask1Price", "indexPrice"]
        var priceStr: String?
        for key in priceKeys {
            if let value = dataDict[key] as? String {
                priceStr = value
                break
            }
        }
        
        guard let priceStr = priceStr,
              let price: Double = Double(priceStr) else {
            print("Failed to find/parse price in Bybit Spot ticker")
            return
        }
        
        let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
        bybitCurrentPrice[pair] = price
        bybitPrices[pair, default: []].append(price)
        
        if bybitPrices[pair]!.count > priceHistoryRetention {
            bybitPrices[pair]!.removeFirst()
        }
        
        // Process volume
        if let volStr = dataDict["volume24h"] as? String,
           let vol: Double = Double(volStr) {
            bybitSpotVolume[pair, default: []].append(vol)
            if bybitSpotVolume[pair]!.count > priceHistoryRetention {
                bybitSpotVolume[pair]!.removeFirst()
            }
        }
        
        print("Updated Bybit spot price for \(pair): \(price)")
        logAlert(event: "‚úÖ Bybit Spot price update: \(pair) = $\(price)")
    }
    
    @MainActor
    private static func processBybitSpotOrderBook(data: [String: Any]) {
        guard let dataDict = data["data"] as? [String: Any],
              let symbol = dataDict["s"] as? String,
              let asks = dataDict["a"] as? [[String]],
              let bids = dataDict["b"] as? [[String]] else { return }
        
        let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
        var orderBookEntries: [(price: Double, quantity: Double)] = []
        
        // Process asks and bids into BevaixOrderBook format
        let bidBook = bids.compactMap { bid -> (price: Double, quantity: Double)? in
            guard let priceStr = bid.first, let volStr = bid.last,
                  let price: Double = Double(priceStr),
                  let vol: Double = Double(volStr) else { return nil }
            return (price: price, quantity: vol)
        }
        
        let askBook = asks.compactMap { ask -> (price: Double, quantity: Double)? in
            guard let priceStr = ask.first, let volStr = ask.last,
                  let price: Double = Double(priceStr),
                  let vol: Double = Double(volStr) else { return nil }
            return (price: price, quantity: vol)
        }
        
        bybitOrderBooks[pair] = BevaixOrderBook(bids: bidBook, asks: askBook)
        print("Updated Bybit spot order book for \(pair): bids=\(bidBook.count), asks=\(askBook.count)")
    }
    
    @MainActor
    private static func processBybitSpotTrade(data: [String: Any]) {
        guard let dataArray = data["data"] as? [[String: Any]],
              let firstTrade = dataArray.first,
              let priceStr = firstTrade["p"] as? String,
              let price: Double = Double(priceStr),
              let symbol = firstTrade["s"] as? String else { return }
        
        let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
        bybitCurrentPrice[pair] = price
        bybitPrices[pair, default: []].append(price)
        
        if bybitPrices[pair]!.count > priceHistoryRetention {
            bybitPrices[pair]!.removeFirst()
        }
        
        print("Updated Bybit spot price from trade for \(pair): \(price)")
    }
    
    // ENHANCED: Bybit Futures Message Processing
    @MainActor
    static func processBybitFuturesMessage(_ json: [String: Any]) {
        if let success = json["success"] as? Bool {
            if success, let retMsg = json["ret_msg"] as? String, retMsg == "subscribe" {
                print("Bybit Futures subscription confirmed")
            } else if !success {
                print("Bybit Futures WebSocket error: \(json)")
                logAlert(event: "‚ùå Bybit Futures WebSocket error: \(json)")
            }
        } else if let topic = json["topic"] as? String {
            if topic.hasPrefix("tickers.") {
                processBybitFuturesTicker(data: json)
            } else if topic.hasPrefix("orderbook.50.") {
                processBybitFuturesOrderBook(data: json)
            } else if topic.hasPrefix("publicTrade.") {
                processBybitFuturesTrade(data: json)
            }
        }
    }
    
    @MainActor
    private static func processBybitFuturesTicker(data: [String: Any]) {
        guard let dataDict = data["data"] as? [String: Any],
              let symbol = dataDict["symbol"] as? String else { return }
        
        let priceKeys = ["lastPrice", "bestAskPrice", "ask1Price", "bid1Price", "indexPrice", "markPrice"]
        var priceStr: String?
        for key in priceKeys {
            if let value = dataDict[key] as? String {
                priceStr = value
                break
            }
        }
        
        guard let priceStr = priceStr,
              let price: Double = Double(priceStr) else {
            print("Failed to find/parse price in Bybit Futures ticker")
            return
        }
        
        let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
        bybitCurrentFuturesPrice[pair] = price
        bybitFuturesPrices[pair, default: []].append(price)
        
        if bybitFuturesPrices[pair]!.count > priceHistoryRetention {
            bybitFuturesPrices[pair]!.removeFirst()
        }
        
        // Process volume
        if let volStr = dataDict["volume24h"] as? String,
           let vol: Double = Double(volStr) {
            bybitFuturesVolume[pair, default: []].append(vol)
            if bybitFuturesVolume[pair]!.count > priceHistoryRetention {
                bybitFuturesVolume[pair]!.removeFirst()
            }
        }
        
        // Process funding rate
        if let fundingRateStr = dataDict["fundingRate"] as? String,
           let fundingRate: Double = Double(fundingRateStr) {
            bybitFundingRates[pair] = fundingRate
            bybitFundingRateHistory[pair, default: []].append(fundingRate)
            
            if bybitFundingRateHistory[pair]!.count > 24 { // Keep 24 hours
                bybitFundingRateHistory[pair]!.removeFirst()
            }
            
            print("Updated Bybit funding rate for \(pair): \(fundingRate)")
        }
        
        print("Updated Bybit futures price for \(pair): \(price)")
        logAlert(event: "‚úÖ Bybit Futures price update: \(pair) = $\(price)")
    }
    
    @MainActor
    private static func processBybitFuturesOrderBook(data: [String: Any]) {
        guard let dataDict = data["data"] as? [String: Any],
              let symbol = dataDict["s"] as? String,
              let updateType = dataDict["type"] as? String else { return }
        
        let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
        var orderBook: [(price: Double, volume: Double, side: String)]
        
        if updateType == "snapshot" {
            orderBook = []
        } else {
            orderBook = bybitFuturesOrderBook[pair] ?? []
        }
        
        if let asks = dataDict["a"] as? [[String]] {
            for ask in asks {
                if let priceStr = ask.first, let volStr = ask.last,
                   let price: Double = Double(priceStr),
                   let vol: Double = Double(volStr) {
                    orderBook.removeAll { $0.price == price && $0.side == "sell" }
                    if vol > 0 {
                        orderBook.append((price: price, volume: vol, side: "sell"))
                    }
                }
            }
        }
        
        if let bids = dataDict["b"] as? [[String]] {
            for bid in bids {
                if let priceStr = bid.first, let volStr = bid.last,
                   let price: Double = Double(priceStr),
                   let vol: Double = Double(volStr) {
                    orderBook.removeAll { $0.price == price && $0.side == "buy" }
                    if vol > 0 {
                        orderBook.append((price: price, volume: vol, side: "buy"))
                    }
                }
            }
        }
        
        bybitFuturesOrderBook[pair] = orderBook
        print("DEBUG: Updated Bybit futures order book for \(pair): \(orderBook.count) entries")
    }
    
    @MainActor
    private static func processBybitFuturesTrade(data: [String: Any]) {
        guard let dataArray = data["data"] as? [[String: Any]],
              let firstTrade = dataArray.first,
              let priceStr = firstTrade["p"] as? String,
              let price: Double = Double(priceStr),
              let symbol = firstTrade["s"] as? String else { return }
        
        let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
        bybitCurrentFuturesPrice[pair] = price
        bybitFuturesPrices[pair, default: []].append(price)
        
        if bybitFuturesPrices[pair]!.count > priceHistoryRetention {
            bybitFuturesPrices[pair]!.removeFirst()
        }
        
        print("Updated Bybit futures price from trade for \(pair): \(price)")
    }
    
    // ENHANCED: Centralized WebSocket Health Monitoring
    @MainActor
    static func monitorWebSocketHealth() {
        let healthCheck = [
            "KuCoin Spot": kucoinIsConnected,
            "KuCoin Futures": kucoinFuturesIsConnected,
            "Bybit Spot": bybitIsConnected,
            "Bybit Futures": bybitFuturesIsConnected
        ]
        
        var disconnectedCount = 0
        var healthReport = "üîç WebSocket Health Report:\n"
        
        for (exchange, connected) in healthCheck {
            let status = connected ? "‚úÖ Connected" : "‚ùå Disconnected"
            healthReport += "  \(exchange): \(status)\n"
            if !connected { disconnectedCount += 1 }
        }
        
        if disconnectedCount > 0 {
            healthReport += "‚ö†Ô∏è  \(disconnectedCount) connection(s) need attention"
            logAlert(event: healthReport)
        }
        
        print(healthReport)
    }
}
