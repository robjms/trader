//-------------------------------------------------------------------------------------------------------------------- Block 9 - Enhanced KuCoin WebSocket Processing with Spot Price Support

class ExchangeWebSocketDelegate: NSObject, WebSocketDelegate {
    func didReceive(event: WebSocketEvent, client: WebSocketClient) {
        Task { @MainActor in
            switch event {
            case .connected(let headers):
                ExchangeWebSocket.handleWebSocketConnected(client: client, headers: headers)
            case .disconnected(let reason, let code):
                ExchangeWebSocket.handleWebSocketDisconnected(client: client, reason: reason, code: code)
            case .text(let string):
                ExchangeWebSocket.handleWebSocketTextMessage(client: client, text: string)
            case .binary(let data):
                ExchangeWebSocket.handleWebSocketBinaryMessage(client: client, data: data)
            case .error(let error):
                ExchangeWebSocket.handleWebSocketError(client: client, error: error)
            default:
                break
            }
        }
    }
}
class KuCoinSpotWebSocketDelegateEnhanced: WebSocketDelegate {
    private var hasReceivedWelcome = false
    
    func didReceive(event: Starscream.WebSocketEvent, client: any Starscream.WebSocketClient) {
        Task { @MainActor [weak self] in
            guard let self = self else { return }
            
            switch event {
            case .connected(let headers):
                print("ðŸ”— [KuCoin Spot] WebSocket connected: \(headers)")
                ExchangeWebSocket.logAlert(event: "ðŸ”— KuCoin Spot WebSocket connected, waiting for welcome...")
                self.hasReceivedWelcome = false
                
            case .disconnected(let reason, let code):
                ExchangeWebSocket.kucoinIsConnected = false
                self.hasReceivedWelcome = false
                print("âŒ [KuCoin Spot] WebSocket disconnected: \(reason) (\(code))")
                ExchangeWebSocket.logAlert(event: "âŒ KuCoin Spot WebSocket disconnected: \(reason)")
                
                // Auto-reconnect after delay with weak self
                DispatchQueue.main.asyncAfter(deadline: .now() + 30) { [weak self] in
                    guard self != nil else { return }
                    ExchangeWebSocket.connectToKuCoinSpotWebSocket()
                }
                
            case .text(let text):
                if let data = text.data(using: .utf8),
                   let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                    
                    // STEP 1: Handle welcome message FIRST (CRITICAL)
                    if let type = json["type"] as? String, type == "welcome" {
                        self.hasReceivedWelcome = true
                        ExchangeWebSocket.kucoinIsConnected = true
                        print("âœ… [KuCoin Spot] Welcome message received! Now subscribing...")
                        ExchangeWebSocket.logAlert(event: "âœ… KuCoin Spot welcome received, subscribing to pairs...")
                        
                        // STEP 2: Subscribe to all pairs AFTER welcome
                        for pair in ExchangeWebSocket.tradingPairs {
                            // CRITICAL: Use correct KuCoin API format (BTCUSDT not BTC-USDT)
                            let symbol = pair.replacingOccurrences(of: "-", with: "")
                            let subscriptionMessage = [
                                "id": UUID().uuidString,
                                "type": "subscribe",
                                "topic": "/market/ticker:\(symbol)", // FIXED: BTCUSDT format
                                "privateChannel": false,
                                "response": true
                            ] as [String : Any]
                            
                            if let data = try? JSONSerialization.data(withJSONObject: subscriptionMessage),
                               let jsonString = String(data: data, encoding: .utf8) {
                                client.write(string: jsonString)
                                print("ðŸ“¡ [KuCoin Spot] Subscribed to: \(symbol) (pair: \(pair))")
                            }
                        }
                        return
                    }
                    
                    // STEP 3: Don't process other messages until welcome received
                    guard self.hasReceivedWelcome else {
                        print("âš ï¸ [KuCoin Spot] Ignoring message - no welcome received yet: \(json["type"] as? String ?? "unknown")")
                        return
                    }
                    
                    // Handle subscription confirmations
                    if json["type"] as? String == "ack" {
                        print("âœ… KuCoin Spot WebSocket subscription confirmed")
                        ExchangeWebSocket.logAlert(event: "âœ… KuCoin Spot subscription confirmed")
                        return
                    }
                    
                    // FIXED: Extract price correctly and update immediately to fix $0.000000 issue
                    if let subject = json["subject"] as? String,
                       subject == "trade.ticker",
                       let topic = json["topic"] as? String,
                       let data = json["data"] as? [String: Any] {
                        
                        print("ðŸ” [KuCoin Spot] Processing ticker message:")
                        print("   Topic: \(topic)")
                        print("   Data keys: \(Array(data.keys))")
                        
                        // Extract symbol from topic (/market/ticker:BTCUSDT)
                        let symbol = topic.replacingOccurrences(of: "/market/ticker:", with: "")
                        
                        // Convert BTCUSDT back to BTC-USDT for internal storage
                        let pair: String
                        if symbol.hasSuffix("USDT") && symbol.count > 4 {
                            let baseAsset = symbol.replacingOccurrences(of: "USDT", with: "")
                            pair = "\(baseAsset)-USDT"
                        } else {
                            pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
                        }
                        
                        print("   Symbol: \(symbol) -> Pair: \(pair)")
                        
                        // CRITICAL FIX: Extract price using multiple keys (enhanced)
                        let priceKeys = ["price", "last", "bestAsk", "bestBid", "close", "c"]
                        var extractedPrice: Double?
                        var usedKey = ""
                        
                        for key in priceKeys {
                            if let priceStr = data[key] as? String,
                               let price = Double(priceStr), price > 0 {
                                extractedPrice = price
                                usedKey = key
                                break
                            }
                        }
                        
                        if let price = extractedPrice {
                            print("âœ… [KuCoin Spot] Found price for \(pair): $\(price) (key: \(usedKey))")
                            
                            // FIXED: Immediate update to fix $0.000000 dashboard issue
                            ExchangeWebSocket.kucoinCurrentPrice[pair] = price
                            ExchangeWebSocket.kucoinPrices[pair, default: []].append(price)
                            
                            // Maintain price history limit
                            if ExchangeWebSocket.kucoinPrices[pair]!.count > ExchangeWebSocket.priceHistoryRetention {
                                ExchangeWebSocket.kucoinPrices[pair]?.removeFirst()
                            }
                            
                            print("âœ… [KuCoin Spot] Updated price for \(pair): $\(price)")
                            ExchangeWebSocket.logAlert(event: "âœ… [KuCoin Spot] Updated price for \(pair): $\(price)")
                            
                            // Update last data timestamp
                            ExchangeWebSocket.lastDataUpdate[pair] = Date()
                            
                            // Trigger arbitrage check and dashboard update
                            ExchangeWebSocket.triggerCrossExchangeArbitrageCheck(pair: pair)
                            ExchangeWebSocket.updateDashboardData()
                            
                        } else {
                            print("âŒ [KuCoin Spot] NO VALID PRICE found for \(pair)")
                            print("   Available data: \(data)")
                            ExchangeWebSocket.logAlert(event: "âŒ KuCoin Spot: NO PRICE for \(pair)")
                        }
                    }
                }
                
            case .binary(_):
                break
                
            case .ping(_):
                client.write(pong: Data())
                
            case .pong(_):
                break
                
            case .viabilityChanged(_):
                break
                
            case .reconnectSuggested(_):
                ExchangeWebSocket.logAlert(event: "KuCoin Spot WebSocket reconnection suggested")
                DispatchQueue.main.asyncAfter(deadline: .now() + 10) { [weak self] in
                    guard self != nil else { return }
                    ExchangeWebSocket.connectToKuCoinSpotWebSocket()
                }
                
            case .cancelled:
                ExchangeWebSocket.kucoinIsConnected = false
                self.hasReceivedWelcome = false
                print("âŒ [KuCoin Spot] WebSocket cancelled")
                
            case .error(let error):
                ExchangeWebSocket.kucoinIsConnected = false
                self.hasReceivedWelcome = false
                print("âŒ [KuCoin Spot] WebSocket error: \(error?.localizedDescription ?? "unknown")")
                ExchangeWebSocket.logAlert(event: "KuCoin Spot WebSocket error: \(error?.localizedDescription ?? "unknown")")
                
                // Reconnect on error with weak self
                DispatchQueue.main.asyncAfter(deadline: .now() + 30) { [weak self] in
                    guard self != nil else { return }
                    ExchangeWebSocket.connectToKuCoinSpotWebSocket()
                }
                
            case .peerClosed:
                ExchangeWebSocket.kucoinIsConnected = false
                self.hasReceivedWelcome = false
                print("âŒ [KuCoin Spot] WebSocket peer closed")
                ExchangeWebSocket.logAlert(event: "KuCoin Spot WebSocket peer closed")
            }
        }
    }
}

extension ExchangeWebSocket {
    // Add strong reference to prevent delegate deallocation
    static var kucoinSpotEnhancedDelegate: KuCoinSpotWebSocketDelegateEnhanced?
    
    // FIXED: Use ObjectIdentifier to compare WebSocket instances
    @MainActor
    static func handleWebSocketConnected(client: WebSocketClient, headers: [String: String]) {
        let clientId = ObjectIdentifier(client)
        let kucoinId = kucoinSocket.map { ObjectIdentifier($0) }
        let kucoinFuturesId = kucoinFuturesSocket.map { ObjectIdentifier($0) }
        let bybitId = bybitSocket.map { ObjectIdentifier($0) }
        
        if clientId == kucoinId {
            kucoinIsConnected = true
            kucoinReconnectAttempts = 0
            print("âœ… KuCoin Spot WebSocket connected successfully")
            logAlert(event: "âœ… KuCoin Spot WebSocket connected successfully")
            
            // Subscribe to spot tickers for all trading pairs
            subscribeToKuCoinSpotTickers()
        } else if clientId == kucoinFuturesId {
            kucoinFuturesIsConnected = true
            kucoinFuturesReconnectAttempts = 0
            print("âœ… KuCoin Futures WebSocket connected successfully")
            logAlert(event: "âœ… KuCoin Futures WebSocket connected successfully")
        } else if clientId == bybitId {
            bybitIsConnected = true
            bybitReconnectAttempts = 0
            print("âœ… Bybit WebSocket connected successfully")
            logAlert(event: "âœ… Bybit WebSocket connected successfully")
        }
        
        updateDashboardData()
    }
    
    @MainActor
    static func handleWebSocketDisconnected(client: WebSocketClient, reason: String, code: UInt16) {
        let clientId = ObjectIdentifier(client)
        let kucoinId = kucoinSocket.map { ObjectIdentifier($0) }
        let kucoinFuturesId = kucoinFuturesSocket.map { ObjectIdentifier($0) }
        let bybitId = bybitSocket.map { ObjectIdentifier($0) }
        
        if clientId == kucoinId {
            kucoinIsConnected = false
            print("âŒ KuCoin Spot WebSocket disconnected: \(reason) (code: \(code))")
            logAlert(event: "âŒ KuCoin Spot WebSocket disconnected: \(reason) (code: \(code))")
            scheduleKuCoinReconnection()
        } else if clientId == kucoinFuturesId {
            kucoinFuturesIsConnected = false
            print("âŒ KuCoin Futures WebSocket disconnected: \(reason) (code: \(code))")
            logAlert(event: "âŒ KuCoin Futures WebSocket disconnected: \(reason) (code: \(code))")
            scheduleKuCoinFuturesReconnection()
        } else if clientId == bybitId {
            bybitIsConnected = false
            print("âŒ Bybit WebSocket disconnected: \(reason) (code: \(code))")
            logAlert(event: "âŒ Bybit WebSocket disconnected: \(reason) (code: \(code))")
            scheduleBybitReconnection()
        }
        
        updateDashboardData()
    }
    
    @MainActor
    static func handleWebSocketTextMessage(client: WebSocketClient, text: String) {
        let clientId = ObjectIdentifier(client)
        let kucoinId = kucoinSocket.map { ObjectIdentifier($0) }
        let kucoinFuturesId = kucoinFuturesSocket.map { ObjectIdentifier($0) }
        let bybitId = bybitSocket.map { ObjectIdentifier($0) }
        
        // Route to appropriate exchange handler using existing string-based functions
        if clientId == kucoinId {
            Task {
                await handleKuCoinSpotMessage(text)
            }
        } else if clientId == kucoinFuturesId {
            Task {
                await handleKuCoinFuturesMessage(text)
            }
        } else if clientId == bybitId {
            Task {
                await handleBybitSpotMessage(text)
            }
        }
    }
    
    @MainActor
    static func handleWebSocketBinaryMessage(client: WebSocketClient, data: Data) {
        print("ðŸ“¦ Received binary WebSocket message (length: \(data.count))")
    }
    
    @MainActor
    static func handleWebSocketError(client: WebSocketClient, error: Error?) {
        let errorMessage = error?.localizedDescription ?? "Unknown WebSocket error"
        print("âŒ WebSocket error: \(errorMessage)")
        logAlert(event: "âŒ WebSocket error: \(errorMessage)")
        
        let clientId = ObjectIdentifier(client)
        let kucoinId = kucoinSocket.map { ObjectIdentifier($0) }
        let kucoinFuturesId = kucoinFuturesSocket.map { ObjectIdentifier($0) }
        let bybitId = bybitSocket.map { ObjectIdentifier($0) }
        
        // Trigger reconnection for the specific socket
        if clientId == kucoinId {
            scheduleKuCoinReconnection()
        } else if clientId == kucoinFuturesId {
            scheduleKuCoinFuturesReconnection()
        } else if clientId == bybitId {
            scheduleBybitReconnection()
        }
    }
    
    // ENHANCED: Subscribe to KuCoin Spot Tickers with CRITICAL FIX for price updates
    @MainActor
    static func subscribeToKuCoinSpotTickers() {
        guard kucoinIsConnected, let socket = kucoinSocket else {
            print("âŒ Cannot subscribe to KuCoin spot tickers - not connected")
            return
        }
        
        // CRITICAL FIX: Subscribe to individual ticker topics for better reliability
        for pair in tradingPairs {
            // VERIFIED: KuCoin API expects BTCUSDT format (no hyphen) in topic subscription
            let symbol = pair.replacingOccurrences(of: "-", with: "")
            let subscriptionMessage: [String: Any] = [
                "id": UUID().uuidString,
                "type": "subscribe",
                "topic": "/market/ticker:\(symbol)",  // CORRECT: Use BTCUSDT format for KuCoin API
                "privateChannel": false,
                "response": true
            ]
            
            do {
                let jsonData = try JSONSerialization.data(withJSONObject: subscriptionMessage)
                if let jsonString = String(data: jsonData, encoding: .utf8) {
                    socket.write(string: jsonString)
                    print("ðŸ“¡ FIXED: Subscribed to KuCoin SPOT ticker for \(pair) (API symbol: \(symbol))")
                    logAlert(event: "ðŸ“¡ FIXED: Subscribed to KuCoin SPOT ticker for \(pair)")
                }
            } catch {
                print("âŒ Failed to subscribe to KuCoin spot ticker for \(pair): \(error)")
                logAlert(event: "âŒ Failed to subscribe to KuCoin spot ticker for \(pair): \(error)")
            }
        }
        
        // Also subscribe to order book updates for better liquidity analysis
        for pair in tradingPairs {
            // VERIFIED: KuCoin order book also expects BTCUSDT format
            let symbol = pair.replacingOccurrences(of: "-", with: "")
            let orderBookSubscription: [String: Any] = [
                "id": UUID().uuidString,
                "type": "subscribe",
                "topic": "/market/level2:\(symbol)",  // CORRECT: Use BTCUSDT format
                "privateChannel": false,
                "response": true
            ]
            
            do {
                let jsonData = try JSONSerialization.data(withJSONObject: orderBookSubscription)
                if let jsonString = String(data: jsonData, encoding: .utf8) {
                    socket.write(string: jsonString)
                    print("ðŸ“Š FIXED: Subscribed to KuCoin SPOT order book for \(pair) (API symbol: \(symbol))")
                }
            } catch {
                print("âŒ Failed to subscribe to KuCoin spot order book for \(pair): \(error)")
            }
        }
        
        logAlert(event: "âœ… FIXED: Subscribed to KuCoin SPOT tickers for \(tradingPairs.count) pairs")
    }

// EXISTING FUNCTIONS FROM YOUR CODE - PRESERVED COMPLETELY WITH CRITICAL ENHANCEMENTS

static func handleKuCoinSpotMessage(_ message: String) async {
    do {
        guard let data = message.data(using: .utf8),
              let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            await MainActor.run {
                logAlert(event: "ðŸŸ¡âŒ Failed to parse KuCoin Spot message: \(message)")
            }
            return
        }
        
        await MainActor.run {
            lastWebsocketActivity["kucoin-spot"] = Date()
        }
        
        // Handle different message types
        if let type = json["type"] as? String {
            switch type {
            case "welcome":
                await MainActor.run {
                    logAlert(event: "ðŸŸ¡âœ… KuCoin Spot welcome message received")
                }
                
            case "ack":
                await MainActor.run {
                    logAlert(event: "ðŸŸ¡âœ… KuCoin Spot subscription acknowledged")
                }
                
            case "message":
                await handleKuCoinSpotDataMessage(json)
                
            case "pong":
                print("ðŸŸ¡ðŸ’“ KuCoin Spot pong received")
                
            case "error":
                let errorMsg = json["data"] as? String ?? "Unknown error"
                await MainActor.run {
                    logAlert(event: "ðŸŸ¡âŒ KuCoin Spot error: \(errorMsg)")
                }
                
            default:
                print("ðŸŸ¡â“ Unknown KuCoin Spot message type: \(type)")
            }
        }
    } catch {
        await MainActor.run {
            logAlert(event: "ðŸŸ¡âŒ Error processing KuCoin Spot message: \(error.localizedDescription)")
        }
    }
}

// CRITICAL ENHANCEMENT: Fixed price parsing to resolve $0.000000 issue
    // CRITICAL DIAGNOSTIC FIX: Replace your handleKuCoinSpotDataMessage function with this enhanced version

    static func handleKuCoinSpotDataMessage(_ json: [String: Any]) async {
        // STEP 1: Enhanced message validation with detailed logging
        print("ðŸ” DIAGNOSTIC: Received KuCoin message: \(json)")
        
        guard let topic = json["topic"] as? String else {
            print("âŒ DIAGNOSTIC: Missing topic in KuCoin message")
            await MainActor.run {
                logAlert(event: "âŒ DIAGNOSTIC: Missing topic in KuCoin message")
            }
            return
        }
        
        guard let data = json["data"] as? [String: Any] else {
            print("âŒ DIAGNOSTIC: Missing data in KuCoin message for topic: \(topic)")
            await MainActor.run {
                logAlert(event: "âŒ DIAGNOSTIC: Missing data in KuCoin message for topic: \(topic)")
            }
            return
        }
        
        print("ðŸ” DIAGNOSTIC: Topic = \(topic)")
        print("ðŸ” DIAGNOSTIC: Data keys = \(Array(data.keys))")
        print("ðŸ” DIAGNOSTIC: Full data = \(data)")
        
        await MainActor.run {
            // STEP 2: Handle ticker messages with comprehensive validation
            if topic.contains("/market/ticker:") {
                print("ðŸ” DIAGNOSTIC: Processing ticker message for topic: \(topic)")
                
                // STEP 3: Extract symbol using multiple approaches
                var symbol: String = ""
                
                // Method 1: Extract from topic
                if let symbolStart = topic.range(of: ":")?.upperBound {
                    symbol = String(topic[symbolStart...])
                    print("ðŸ” DIAGNOSTIC: Extracted symbol from topic: '\(symbol)'")
                }
                
                // Method 2: Try to get symbol from data
                if symbol.isEmpty, let dataSymbol = data["symbol"] as? String {
                    symbol = dataSymbol
                    print("ðŸ” DIAGNOSTIC: Extracted symbol from data: '\(symbol)'")
                }
                
                guard !symbol.isEmpty else {
                    print("âŒ DIAGNOSTIC: Failed to extract symbol from topic: \(topic)")
                    logAlert(event: "âŒ DIAGNOSTIC: Failed to extract symbol from topic: \(topic)")
                    return
                }
                
                // STEP 4: Convert symbol to pair with enhanced validation
                let pair: String
                if symbol.hasSuffix("USDT") && symbol.count > 4 {
                    let baseAsset = symbol.replacingOccurrences(of: "USDT", with: "")
                    pair = "\(baseAsset)-USDT"
                    print("ðŸ” DIAGNOSTIC: Converted symbol '\(symbol)' to pair '\(pair)'")
                } else {
                    pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
                    print("ðŸ” DIAGNOSTIC: Fallback conversion of symbol '\(symbol)' to pair '\(pair)'")
                }
                
                // STEP 5: Validate pair against trading pairs
                guard tradingPairs.contains(pair) else {
                    print("âš ï¸ DIAGNOSTIC: Pair '\(pair)' not found in trading pairs list")
                    print("âš ï¸ DIAGNOSTIC: Available trading pairs: \(tradingPairs)")
                    return
                }
                
                print("âœ… DIAGNOSTIC: Pair '\(pair)' validated successfully")
                
                // STEP 6: Enhanced price extraction with ALL possible keys
                let allPriceKeys = [
                    "price", "last", "lastPrice", "lastTradePrice",
                    "bestAsk", "bestAskPrice", "bestBid", "bestBidPrice",
                    "close", "mark", "index", "c", "p"
                ]
                
                var extractedPrice: Double?
                var usedKey: String = ""
                
                // Try string values first
                for key in allPriceKeys {
                    if let priceStr = data[key] as? String, !priceStr.isEmpty {
                        if let price = Double(priceStr), price > 0 {
                            extractedPrice = price
                            usedKey = key
                            print("âœ… DIAGNOSTIC: Found price using STRING key '\(key)': '\(priceStr)' = $\(price)")
                            break
                        } else {
                            print("âš ï¸ DIAGNOSTIC: Failed to parse STRING price from key '\(key)': '\(priceStr)'")
                        }
                    }
                }
                
                // If no string value worked, try numeric values
                if extractedPrice == nil {
                    for key in allPriceKeys {
                        if let priceNum = data[key] as? Double, priceNum > 0 {
                            extractedPrice = priceNum
                            usedKey = key
                            print("âœ… DIAGNOSTIC: Found price using NUMERIC key '\(key)': $\(priceNum)")
                            break
                        } else if let priceInt = data[key] as? Int, priceInt > 0 {
                            extractedPrice = Double(priceInt)
                            usedKey = key
                            print("âœ… DIAGNOSTIC: Found price using INTEGER key '\(key)': \(priceInt)")
                            break
                        }
                    }
                }
                
                // STEP 7: Final price validation
                guard let finalPrice = extractedPrice, finalPrice > 0 else {
                    print("âŒ CRITICAL DIAGNOSTIC: NO VALID PRICE FOUND for \(pair)")
                    print("âŒ Searched keys: \(allPriceKeys)")
                    print("âŒ Available data: \(data)")
                    logAlert(event: "âŒ CRITICAL: NO VALID PRICE FOUND for \(pair) - searched \(allPriceKeys.count) keys")
                    
                    // Log all available data for debugging
                    for (key, value) in data {
                        print("âŒ DEBUG: data[\(key)] = \(value) (type: \(type(of: value)))")
                    }
                    return
                }
                
                // STEP 8: Store the price with enhanced logging
                let oldPrice = kucoinCurrentPrice[pair] ?? 0.0
                kucoinCurrentPrice[pair] = finalPrice
                kucoinPrices[pair, default: []].append(finalPrice)
                
                // Maintain price history
                if kucoinPrices[pair]!.count > priceHistoryRetention {
                    kucoinPrices[pair]?.removeFirst()
                }
                
                // Update timestamp
                lastDataUpdate[pair] = Date()
                
                // STEP 9: Success logging with full details
                print("ðŸŽ‰ SUCCESS: KuCoin price updated for \(pair)")
                print("   Old Price: $\(String(format: "%.6f", oldPrice))")
                print("   New Price: $\(String(format: "%.6f", finalPrice))")
                print("   Used Key: '\(usedKey)'")
                print("   Topic: \(topic)")
                print("   Symbol: \(symbol)")
                
                logAlert(event: "ðŸŽ‰ KuCoin SUCCESS: \(pair) = $\(finalPrice) (key: \(usedKey))")
                
                // Trigger arbitrage check
                triggerCrossExchangeArbitrageCheck(pair: pair)
                
                // Update dashboard
                updateDashboardData()
                
                // STEP 10: Extract volume data if available
                let volumeKeys = ["vol", "volume", "size", "volume24h", "volValue", "v"]
                for key in volumeKeys {
                    if let volumeStr = data[key] as? String, let volume = Double(volumeStr), volume > 0 {
                        kucoinSpotVolume[pair, default: []].append(volume)
                        if kucoinSpotVolume[pair]!.count > priceHistoryRetention {
                            kucoinSpotVolume[pair]?.removeFirst()
                        }
                        print("âœ… DIAGNOSTIC: Volume updated for \(pair): \(volume) (key: \(key))")
                        break
                    } else if let volumeNum = data[key] as? Double, volumeNum > 0 {
                        kucoinSpotVolume[pair, default: []].append(volumeNum)
                        if kucoinSpotVolume[pair]!.count > priceHistoryRetention {
                            kucoinSpotVolume[pair]?.removeFirst()
                        }
                        print("âœ… DIAGNOSTIC: Volume updated for \(pair): \(volumeNum) (key: \(key))")
                        break
                    }
                }
                
            } else if topic.contains("/market/level2:") {
                // Handle order book updates
                print("ðŸ” DIAGNOSTIC: Processing order book message for topic: \(topic)")
                let symbolStart = topic.range(of: ":")?.upperBound
                if let start = symbolStart {
                    let symbol = String(topic[start...])
                    let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
                    
                    if let changes = data["changes"] as? [String: [[String]]] {
                        updateKuCoinOrderBook(pair: pair, changes: changes)
                        print("âœ… DIAGNOSTIC: Order book updated for \(pair)")
                    }
                }
            } else {
                print("âš ï¸ DIAGNOSTIC: Unknown topic type: \(topic)")
            }
        }
    }

    // ADDITIONAL DIAGNOSTIC: Enhanced subscription function with better logging
    @MainActor
    static func subscribeToKuCoinSpotTickersEnhanced() {
        guard kucoinIsConnected, let socket = kucoinSocket else {
            print("âŒ Cannot subscribe to KuCoin spot tickers - not connected")
            return
        }
        
        print("ðŸ” DIAGNOSTIC: Starting KuCoin spot ticker subscriptions...")
        print("ðŸ” DIAGNOSTIC: Trading pairs to subscribe: \(tradingPairs)")
        
        // Subscribe with enhanced validation
        for (index, pair) in tradingPairs.enumerated() {
            // Convert BTC-USDT to BTCUSDT for KuCoin API
            let symbol = pair.replacingOccurrences(of: "-", with: "")
            
            let subscriptionMessage: [String: Any] = [
                "id": "\(UUID().uuidString)-\(index)",
                "type": "subscribe",
                "topic": "/market/ticker:\(symbol)",
                "privateChannel": false,
                "response": true
            ]
            
            do {
                let jsonData = try JSONSerialization.data(withJSONObject: subscriptionMessage)
                if let jsonString = String(data: jsonData, encoding: .utf8) {
                    socket.write(string: jsonString)
                    print("ðŸ“¡ DIAGNOSTIC: Subscribed to pair \(pair) (symbol: \(symbol))")
                    print("   Subscription message: \(jsonString)")
                }
            } catch {
                print("âŒ DIAGNOSTIC: Failed to subscribe to \(pair): \(error)")
                logAlert(event: "âŒ Failed to subscribe to KuCoin spot ticker for \(pair): \(error)")
            }
        }
        
        logAlert(event: "ðŸ” DIAGNOSTIC: Attempted KuCoin subscriptions for \(tradingPairs.count) pairs")
    }

    // DIAGNOSTIC HELPER: Add this function to test message parsing
    @MainActor
    static func testKuCoinMessageParsing() {
        // Test with sample KuCoin message format
        let sampleMessage: [String: Any] = [
            "type": "message",
            "topic": "/market/ticker:BTCUSDT",
            "subject": "trade.ticker",
            "data": [
                "symbol": "BTC-USDT",
                "symbolName": "BTCUSDT",
                "buy": "65000.1",
                "sell": "65000.2",
                "changeRate": "-0.0055",
                "changePrice": "-357.6",
                "high": "65400.0",
                "low": "64800.0",
                "vol": "1234.567",
                "volValue": "80000000.123",
                "last": "65000.15",
                "averagePrice": "65100.0",
                "takerFeeRate": "0.001",
                "makerFeeRate": "0.001",
                "takerCoefficient": "1.0",
                "makerCoefficient": "1.0"
            ]
        ]
        
        print("ðŸ§ª TESTING: Parsing sample KuCoin message...")
        Task {
            await handleKuCoinSpotDataMessage(sampleMessage)
        }
    }
static func handleKuCoinFuturesMessage(_ message: String) async {
    do {
        guard let data = message.data(using: .utf8),
              let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            await MainActor.run {
                logAlert(event: "ðŸŸ¡âŒ Failed to parse KuCoin Futures message: \(message)")
            }
            return
        }
        
        await MainActor.run {
            lastWebsocketActivity["kucoin-futures"] = Date()
        }
        
        // Handle different message types
        if let type = json["type"] as? String {
            switch type {
            case "welcome":
                await MainActor.run {
                    logAlert(event: "ðŸŸ¡âœ… KuCoin Futures welcome message received")
                }
                
            case "ack":
                await MainActor.run {
                    logAlert(event: "ðŸŸ¡âœ… KuCoin Futures subscription acknowledged")
                }
                
            case "message":
                await handleKuCoinFuturesDataMessage(json)
                
            case "pong":
                print("ðŸŸ¡ðŸ’“ KuCoin Futures pong received")
                
            case "error":
                let errorMsg = json["data"] as? String ?? "Unknown error"
                await MainActor.run {
                    logAlert(event: "ðŸŸ¡âŒ KuCoin Futures error: \(errorMsg)")
                }
                
            default:
                print("ðŸŸ¡â“ Unknown KuCoin Futures message type: \(type)")
            }
        }
    } catch {
        await MainActor.run {
            logAlert(event: "ðŸŸ¡âŒ Error processing KuCoin Futures message: \(error.localizedDescription)")
        }
    }
}

static func handleKuCoinFuturesDataMessage(_ json: [String: Any]) async {
    guard let topic = json["topic"] as? String,
          let data = json["data"] as? [String: Any] else {
        return
    }
    
    await MainActor.run {
        if topic.contains("/contractMarket/ticker:") {
            // Extract symbol from topic: /contractMarket/ticker:XBTUSDTM
            let symbolStart = topic.range(of: ":")?.upperBound
            if let start = symbolStart {
                let symbol = String(topic[start...])
                let pair = convertSymbolToPair(symbol: symbol, isFutures: true)
                
                // Extract price data
                if let priceStr = data["price"] as? String,
                   let price = Double(priceStr), price > 0 {
                    
                    kucoinCurrentFuturesPrice[pair] = price
                    kucoinFuturesPrices[pair, default: []].append(price)
                    
                    // Maintain price history
                    if kucoinFuturesPrices[pair]!.count > priceHistoryRetention {
                        kucoinFuturesPrices[pair]?.removeFirst()
                    }
                    
                    print("âœ… [KuCoin Futures] Updated price for \(pair): $\(price)")
                    logAlert(event: "âœ… [KuCoin Futures] Updated price for \(pair): $\(price)")
                    
                    // Update dashboard
                    updateDashboardData()
                }
                
                // Extract volume if available
                if let volumeStr = data["vol"] as? String,
                   let volume = Double(volumeStr) {
                    kucoinFuturesVolume[pair, default: []].append(volume)
                    if kucoinFuturesVolume[pair]!.count > priceHistoryRetention {
                        kucoinFuturesVolume[pair]?.removeFirst()
                    }
                }
                
                // Extract funding rate if available
                if let fundingRateStr = data["fundingRate"] as? String,
                   let fundingRate = Double(fundingRateStr) {
                    kucoinFundingRates[pair] = fundingRate
                    kucoinFundingRateHistory[pair, default: []].append(fundingRate)
                    if kucoinFundingRateHistory[pair]!.count > priceHistoryRetention {
                        kucoinFundingRateHistory[pair]?.removeFirst()
                    }
                }
            }
        }
    }
}

static func handleBybitSpotMessage(_ message: String) async {
    do {
        guard let data = message.data(using: .utf8),
              let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            await MainActor.run {
                logAlert(event: "ðŸ”µâŒ Failed to parse Bybit Spot message: \(message)")
            }
            return
        }
        
        await MainActor.run {
            lastWebsocketActivity["bybit-spot"] = Date()
        }
        
        // Handle subscription success
        if let success = json["success"] as? Bool, success == true {
            await MainActor.run {
                logAlert(event: "ðŸ”µâœ… Bybit Spot subscription successful")
            }
            return
        }
        
        // Handle data messages
        if let topic = json["topic"] as? String,
           let data = json["data"] as? [String: Any],
           topic.contains("tickers.") {
            
            await handleBybitSpotDataMessage(topic: topic, data: data)
        }
        
    } catch {
        await MainActor.run {
            logAlert(event: "ðŸ”µâŒ Error processing Bybit Spot message: \(error.localizedDescription)")
        }
    }
}

static func handleBybitSpotDataMessage(topic: String, data: [String: Any]) async {
    // Extract symbol from topic: tickers.BTCUSDT
    let symbolStart = topic.range(of: ".")?.upperBound
    guard let start = symbolStart else { return }
    
    let symbol = String(topic[start...])
    let pair = convertSymbolToPair(symbol: symbol, isFutures: false)
    
    await MainActor.run {
        // Extract price data
        if let priceStr = data["lastPrice"] as? String,
           let price = Double(priceStr), price > 0 {
            
            bybitCurrentPrice[pair] = price
            bybitPrices[pair, default: []].append(price)
            
            // Maintain price history
            if bybitPrices[pair]!.count > priceHistoryRetention {
                bybitPrices[pair]?.removeFirst()
            }
            
            print("âœ… [Bybit Spot] Updated price for \(pair): $\(price)")
            logAlert(event: "âœ… [Bybit Spot] Updated price for \(pair): $\(price)")
            
            // CRITICAL FIX: Trigger arbitrage check when price updates
            triggerCrossExchangeArbitrageCheck(pair: pair)
            
            // Update dashboard
            updateDashboardData()
        }
        
        // Extract volume if available
        if let volumeStr = data["volume24h"] as? String,
           let volume = Double(volumeStr) {
            bybitSpotVolume[pair, default: []].append(volume)
            if bybitSpotVolume[pair]!.count > priceHistoryRetention {
                bybitSpotVolume[pair]?.removeFirst()
            }
        }
    }
}

static func handleBybitFuturesMessage(_ message: String) async {
    do {
        guard let data = message.data(using: .utf8),
              let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            await MainActor.run {
                logAlert(event: "ðŸ”µâŒ Failed to parse Bybit Futures message: \(message)")
            }
            return
        }
        
        await MainActor.run {
            lastWebsocketActivity["bybit-futures"] = Date()
        }
        
        // Handle subscription success
        if let success = json["success"] as? Bool, success == true {
            await MainActor.run {
                logAlert(event: "ðŸ”µâœ… Bybit Futures subscription successful")
            }
            return
        }
        
        // Handle data messages
        if let topic = json["topic"] as? String,
           let data = json["data"] as? [String: Any],
           topic.contains("tickers.") {
            
            await handleBybitFuturesDataMessage(topic: topic, data: data)
        }
        
    } catch {
        await MainActor.run {
            logAlert(event: "ðŸ”µâŒ Error processing Bybit Futures message: \(error.localizedDescription)")
        }
    }
}

static func handleBybitFuturesDataMessage(topic: String, data: [String: Any]) async {
    // Extract symbol from topic: tickers.BTCUSDT
    let symbolStart = topic.range(of: ".")?.upperBound
    guard let start = symbolStart else { return }
    
    let symbol = String(topic[start...])
    let pair = convertSymbolToPair(symbol: symbol, isFutures: false)
    
    await MainActor.run {
        // Extract price data
        if let priceStr = data["lastPrice"] as? String,
           let price = Double(priceStr), price > 0 {
            
            bybitCurrentFuturesPrice[pair] = price
            bybitFuturesPrices[pair, default: []].append(price)
            
            // Maintain price history
            if bybitFuturesPrices[pair]!.count > priceHistoryRetention {
                bybitFuturesPrices[pair]?.removeFirst()
            }
            
            print("âœ… [Bybit Futures] Updated price for \(pair): $\(price)")
            logAlert(event: "âœ… [Bybit Futures] Updated price for \(pair): $\(price)")
            
            // Update dashboard
            updateDashboardData()
        }
        
        // Extract volume if available
        if let volumeStr = data["volume24h"] as? String,
           let volume = Double(volumeStr) {
            bybitFuturesVolume[pair, default: []].append(volume)
            if bybitFuturesVolume[pair]!.count > priceHistoryRetention {
                bybitFuturesVolume[pair]?.removeFirst()
            }
        }
        
        // Extract funding rate if available
        if let fundingRateStr = data["fundingRate"] as? String,
           let fundingRate = Double(fundingRateStr) {
            bybitFundingRates[pair] = fundingRate
            bybitFundingRateHistory[pair, default: []].append(fundingRate)
            if bybitFuturesVolume[pair]!.count > priceHistoryRetention {
                bybitFuturesPrices[pair]?.removeFirst()
            }
        }
    }
}

// ENHANCED: KuCoin Spot Message Processing
@MainActor
static func processKuCoinSpotMessage(_ json: [String: Any]) {
    guard let type = json["type"] as? String, type == "message",
          let topic = json["topic"] as? String,
          topic.hasPrefix("/market/ticker:"),
          let dataDict = json["data"] as? [String: Any] else {
        print("DEBUG: Invalid KuCoin Spot message format")
        return
    }
    
    let priceKeys = ["price", "last", "bestAsk", "bestBid"]
    var priceStr: String?
    for key in priceKeys {
        if let value = dataDict[key] as? String {
            priceStr = value
            break
        }
    }
    
    guard let priceStr = priceStr else {
        print("Failed to find price in KuCoin Spot message. Available keys: \(dataDict.keys)")
        return
    }
    
    // Fix ambiguous type expression by being explicit
    guard let price: Double = Double(priceStr) else {
        print("Failed to parse price '\(priceStr)' from KuCoin Spot message")
        return
    }
    
    let spotSymbol = topic.components(separatedBy: ":").last ?? ""
    let pair = convertSymbolToPair(symbol: spotSymbol, isFutures: false)
    
    kucoinCurrentPrice[pair] = price
    kucoinPrices[pair, default: []].append(price)
    
    if kucoinPrices[pair]!.count > priceHistoryRetention {
        kucoinPrices[pair]!.removeFirst()
    }
    
    // Process volume if available
    if let volStr = dataDict["size"] as? String ?? dataDict["volume"] as? String,
       let vol: Double = Double(volStr) {
        kucoinSpotVolume[pair, default: []].append(vol)
        if kucoinSpotVolume[pair]!.count > priceHistoryRetention {
            kucoinSpotVolume[pair]!.removeFirst()
        }
    }
    
    print("âœ… [KuCoin Spot] Updated price for \(pair): $\(price)")
    logAlert(event: "âœ… KuCoin Spot price update: \(pair) = $\(price)")
}

// ENHANCED: KuCoin Futures Message Processing
@MainActor
static func processKuCoinFuturesMessage(_ json: [String: Any]) {
    guard let type = json["type"] as? String, type == "message",
          let topic = json["topic"] as? String,
          let dataDict = json["data"] as? [String: Any] else {
        print("DEBUG: Invalid KuCoin Futures message format")
        return
    }
    
    if topic.hasPrefix("/contractMarket/tickerV2:") {
        processKuCoinFuturesTicker(topic: topic, data: dataDict)
    } else if topic.hasPrefix("/contractMarket/level2:") {
        processKuCoinFuturesOrderBook(topic: topic, data: dataDict)
    } else if topic.hasPrefix("/contract/instrument:") {
        processKuCoinFuturesFunding(topic: topic, data: dataDict)
    }
}

@MainActor
private static func processKuCoinFuturesTicker(topic: String, data: [String: Any]) {
    let priceKeys = ["bestAskPrice", "bestBidPrice", "lastPrice", "indexPrice"]
    var priceStr: String?
    for key in priceKeys {
        if let value = data[key] as? String {
            priceStr = value
            break
        }
    }
    
    guard let priceStr = priceStr,
          let price: Double = Double(priceStr) else {
        print("Failed to find/parse price in KuCoin Futures message")
        return
    }
    
    let futuresSymbol = topic.components(separatedBy: ":").last ?? ""
    guard let pair = kucoinFuturesSymbols.first(where: { $0.value == futuresSymbol })?.key else {
        print("No pair found for futures symbol: \(futuresSymbol)")
        return
    }
    
    kucoinCurrentFuturesPrice[pair] = price
    kucoinFuturesPrices[pair, default: []].append(price)
    
    if kucoinFuturesPrices[pair]!.count > priceHistoryRetention {
        kucoinFuturesPrices[pair]!.removeFirst()
    }
    
    // Process volume
    if let volStr = data["volume"] as? String ?? data["size"] as? String,
       let vol: Double = Double(volStr) {
        kucoinFuturesVolume[pair, default: []].append(vol)
        if kucoinFuturesVolume[pair]!.count > priceHistoryRetention {
            kucoinFuturesVolume[pair]!.removeFirst()
        }
    }
    
    print("âœ… [KuCoin Futures] Updated price for \(pair): $\(price)")
    logAlert(event: "âœ… KuCoin Futures price update: \(pair) = $\(price)")
}

@MainActor
private static func processKuCoinFuturesOrderBook(topic: String, data: [String: Any]) {
    let futuresSymbol = topic.components(separatedBy: ":").last ?? ""
    guard let pair = kucoinFuturesSymbols.first(where: { $0.value == futuresSymbol })?.key else {
        print("No pair found for futures symbol: \(futuresSymbol)")
        return
    }
    
    var orderBook: [(price: Double, volume: Double, side: String)] = []
    
    if let bids = data["bids"] as? [[String]],
       let asks = data["asks"] as? [[String]] {
        // Snapshot
        for bid in bids {
            if let priceStr = bid.first, let qtyStr = bid.last,
               let price: Double = Double(priceStr),
               let qty: Double = Double(qtyStr), qty > 0 {
                orderBook.append((price: price, volume: qty, side: "buy"))
            }
        }
        for ask in asks {
            if let priceStr = ask.first, let qtyStr = ask.last,
               let price: Double = Double(priceStr),
               let qty: Double = Double(qtyStr), qty > 0 {
                orderBook.append((price: price, volume: qty, side: "sell"))
            }
        }
    } else if let change = data["change"] as? String {
        // Incremental update
        orderBook = kucoinFuturesOrderBook[pair] ?? []
        let components = change.components(separatedBy: ",")
        if components.count == 3,
           let price: Double = Double(components[0]),
           let size: Double = Double(components[2]) {
            let side = components[1].lowercased() == "buy" ? "buy" : "sell"
            orderBook.removeAll { $0.price == price && $0.side == side }
            if size > 0 {
                orderBook.append((price: price, volume: size, side: side))
            }
        }
    }
    
    kucoinFuturesOrderBook[pair] = orderBook
    print("DEBUG: Updated KuCoin futures order book for \(pair): \(orderBook.count) entries")
}

@MainActor
private static func processKuCoinFuturesFunding(topic: String, data: [String: Any]) {
    guard let fundingRateStr = data["fundingRate"] as? String,
          let fundingRate: Double = Double(fundingRateStr),
          let futuresSymbol = topic.components(separatedBy: ":").last,
          let pair = kucoinFuturesSymbols.first(where: { $0.value == futuresSymbol })?.key else {
        return
    }
    
    kucoinFundingRates[pair] = fundingRate
    kucoinFundingRateHistory[pair, default: []].append(fundingRate)
    
    if kucoinFundingRateHistory[pair]!.count > 24 { // Keep 24 hours of history
        kucoinFundingRateHistory[pair]!.removeFirst()
    }
    
    print("âœ… [KuCoin Futures] Updated funding rate for \(pair): \(fundingRate)")
    logAlert(event: "âœ… KuCoin Funding rate update: \(pair) = \(fundingRate * 100)%")
}

// ENHANCED: Bybit Spot Message Processing
@MainActor
static func processBybitSpotMessage(_ json: [String: Any]) {
    if let success = json["success"] as? Bool {
        if success, let retMsg = json["ret_msg"] as? String, retMsg == "subscribe" {
            print("Bybit Spot subscription confirmed")
        } else if !success {
            print("Bybit Spot WebSocket error: \(json)")
            logAlert(event: "âŒ Bybit Spot WebSocket error: \(json)")
        }
    } else if let topic = json["topic"] as? String {
        if topic.hasPrefix("tickers.") {
            processBybitSpotTicker(data: json)
        } else if topic.hasPrefix("orderbook.50.") {
            processBybitSpotOrderBook(data: json)
        } else if topic.hasPrefix("publicTrade.") {
            processBybitSpotTrade(data: json)
        }
    }
}

@MainActor
private static func processBybitSpotTicker(data: [String: Any]) {
    guard let dataDict = data["data"] as? [String: Any],
          let symbol = dataDict["symbol"] as? String else { return }
    
    let priceKeys = ["lastPrice", "bestAskPrice", "ask1Price", "indexPrice"]
    var priceStr: String?
    for key in priceKeys {
        if let value = dataDict[key] as? String {
            priceStr = value
            break
        }
    }
    
    guard let priceStr = priceStr,
          let price: Double = Double(priceStr) else {
        print("Failed to find/parse price in Bybit Spot ticker")
        return
    }
    
    let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
    bybitCurrentPrice[pair] = price
    bybitPrices[pair, default: []].append(price)
    
    if bybitPrices[pair]!.count > priceHistoryRetention {
        bybitPrices[pair]!.removeFirst()
    }
    
    // Process volume
    if let volStr = dataDict["volume24h"] as? String,
       let vol: Double = Double(volStr) {
        bybitSpotVolume[pair, default: []].append(vol)
        if bybitSpotVolume[pair]!.count > priceHistoryRetention {
            bybitSpotVolume[pair]!.removeFirst()
        }
    }
    
    print("âœ… [Bybit Spot] Updated price for \(pair): $\(price)")
    logAlert(event: "âœ… Bybit Spot price update: \(pair) = $\(price)")
}

@MainActor
private static func processBybitSpotOrderBook(data: [String: Any]) {
    guard let dataDict = data["data"] as? [String: Any],
          let symbol = dataDict["s"] as? String,
          let asks = dataDict["a"] as? [[String]],
          let bids = dataDict["b"] as? [[String]] else { return }
    
    let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
    
    // Process asks and bids into BevaixOrderBook format
    let bidBook = bids.compactMap { bid -> (price: Double, quantity: Double)? in
        guard let priceStr = bid.first, let volStr = bid.last,
              let price: Double = Double(priceStr),
              let vol: Double = Double(volStr) else { return nil }
        return (price: price, quantity: vol)
    }
    
    let askBook = asks.compactMap { ask -> (price: Double, quantity: Double)? in
        guard let priceStr = ask.first, let volStr = ask.last,
              let price: Double = Double(priceStr),
              let vol: Double = Double(volStr) else { return nil }
        return (price: price, quantity: vol)
    }
    
    bybitOrderBooks[pair] = BevaixOrderBook(bids: bidBook, asks: askBook)
    print("Updated Bybit spot order book for \(pair): bids=\(bidBook.count), asks=\(askBook.count)")
}

@MainActor
private static func processBybitSpotTrade(data: [String: Any]) {
    guard let dataArray = data["data"] as? [[String: Any]],
          let firstTrade = dataArray.first,
          let priceStr = firstTrade["p"] as? String,
          let price: Double = Double(priceStr),
          let symbol = firstTrade["s"] as? String else { return }
    
    let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
    bybitCurrentPrice[pair] = price
    bybitPrices[pair, default: []].append(price)
    
    if bybitPrices[pair]!.count > priceHistoryRetention {
        bybitPrices[pair]?.removeFirst()
    }
    
    print("âœ… [Bybit Spot] Updated price from trade for \(pair): $\(price)")
}

// ENHANCED: Bybit Futures Message Processing
@MainActor
static func processBybitFuturesMessage(_ json: [String: Any]) {
    if let success = json["success"] as? Bool {
        if success, let retMsg = json["ret_msg"] as? String, retMsg == "subscribe" {
            print("Bybit Futures subscription confirmed")
        } else if !success {
            print("Bybit Futures WebSocket error: \(json)")
            logAlert(event: "âŒ Bybit Futures WebSocket error: \(json)")
        }
    } else if let topic = json["topic"] as? String {
        if topic.hasPrefix("tickers.") {
            processBybitFuturesTicker(data: json)
        } else if topic.hasPrefix("orderbook.50.") {
            processBybitFuturesOrderBook(data: json)
        } else if topic.hasPrefix("publicTrade.") {
            processBybitFuturesTrade(data: json)
        }
    }
}

@MainActor
private static func processBybitFuturesTicker(data: [String: Any]) {
    guard let dataDict = data["data"] as? [String: Any],
          let symbol = dataDict["symbol"] as? String else { return }
    
    let priceKeys = ["lastPrice", "bestAskPrice", "ask1Price", "bid1Price", "indexPrice", "markPrice"]
    var priceStr: String?
    for key in priceKeys {
        if let value = dataDict[key] as? String {
            priceStr = value
            break
        }
    }
    
    guard let priceStr = priceStr,
          let price: Double = Double(priceStr) else {
        print("Failed to find/parse price in Bybit Futures ticker")
        return
    }
    
    let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
    bybitCurrentFuturesPrice[pair] = price
    bybitFuturesPrices[pair, default: []].append(price)
    
    if bybitFuturesPrices[pair]!.count > priceHistoryRetention {
        bybitFuturesPrices[pair]!.removeFirst()
    }
    
    // Process volume
    if let volStr = dataDict["volume24h"] as? String,
       let vol: Double = Double(volStr) {
        bybitFuturesVolume[pair, default: []].append(vol)
        if bybitFuturesVolume[pair]!.count > priceHistoryRetention {
            bybitFuturesVolume[pair]!.removeFirst()
        }
    }
    
    // Process funding rate
    if let fundingRateStr = dataDict["fundingRate"] as? String,
       let fundingRate: Double = Double(fundingRateStr) {
        bybitFundingRates[pair] = fundingRate
        bybitFundingRateHistory[pair, default: []].append(fundingRate)
        
        if bybitFundingRateHistory[pair]!.count > 24 { // Keep 24 hours
            bybitFundingRateHistory[pair]!.removeFirst()
        }
        
        print("âœ… [Bybit Futures] Updated funding rate for \(pair): \(fundingRate)")
    }
    
    print("âœ… [Bybit Futures] Updated price for \(pair): $\(price)")
    logAlert(event: "âœ… Bybit Futures price update: \(pair) = $\(price)")
}

@MainActor
private static func processBybitFuturesOrderBook(data: [String: Any]) {
    guard let dataDict = data["data"] as? [String: Any],
          let symbol = dataDict["s"] as? String,
          let updateType = dataDict["type"] as? String else { return }
    
    let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
    var orderBook: [(price: Double, volume: Double, side: String)]
    
    if updateType == "snapshot" {
        orderBook = []
    } else {
        orderBook = bybitFuturesOrderBook[pair] ?? []
    }
    
    if let asks = dataDict["a"] as? [[String]] {
        for ask in asks {
            if let priceStr = ask.first, let volStr = ask.last,
               let price: Double = Double(priceStr),
               let vol: Double = Double(volStr) {
                orderBook.removeAll { $0.price == price && $0.side == "sell" }
                if vol > 0 {
                    orderBook.append((price: price, volume: vol, side: "sell"))
                }
            }
        }
    }
    
    if let bids = dataDict["b"] as? [[String]] {
        for bid in bids {
            if let priceStr = bid.first, let volStr = bid.last,
               let price: Double = Double(priceStr),
               let vol: Double = Double(volStr) {
                orderBook.removeAll { $0.price == price && $0.side == "buy" }
                if vol > 0 {
                    orderBook.append((price: price, volume: vol, side: "buy"))
                }
            }
        }
    }
    
    bybitFuturesOrderBook[pair] = orderBook
    print("DEBUG: Updated Bybit futures order book for \(pair): \(orderBook.count) entries")
}

@MainActor
private static func processBybitFuturesTrade(data: [String: Any]) {
    guard let dataArray = data["data"] as? [[String: Any]],
          let firstTrade = dataArray.first,
          let priceStr = firstTrade["p"] as? String,
          let price: Double = Double(priceStr),
          let symbol = firstTrade["s"] as? String else { return }
    
    let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
    bybitCurrentFuturesPrice[pair] = price
    bybitFuturesPrices[pair, default: []].append(price)
    
    if bybitFuturesPrices[pair]!.count > priceHistoryRetention {
        bybitFuturesPrices[pair]!.removeFirst()
    }
    
    print("âœ… [Bybit Futures] Updated price from trade for \(pair): $\(price)")
}

// ENHANCED: Centralized WebSocket Health Monitoring
@MainActor
static func monitorWebSocketHealth() {
    let healthCheck = [
        "KuCoin Spot": kucoinIsConnected,
        "KuCoin Futures": kucoinFuturesIsConnected,
        "Bybit Spot": bybitIsConnected,
        "Bybit Futures": bybitFuturesIsConnected
    ]
    
    var disconnectedCount = 0
    var healthReport = "ðŸ” WebSocket Health Report:\n"
    
    for (exchange, connected) in healthCheck {
        let status = connected ? "âœ… Connected" : "âŒ Disconnected"
        healthReport += "  \(exchange): \(status)\n"
        if !connected { disconnectedCount += 1 }
    }
    
    if disconnectedCount > 0 {
        healthReport += "âš ï¸  \(disconnectedCount) connection(s) need attention"
        logAlert(event: healthReport)
    }
    
    print(healthReport)
}

// CRITICAL FIX: Enhanced symbol conversion with better KuCoin handling
static func convertSymbolToPair(symbol: String, isFutures: Bool) -> String {
    if isFutures {
        // KuCoin futures: XBTUSDTM -> BTC-USDT
        let cleanSymbol = symbol.replacingOccurrences(of: "M", with: "")
        let baseSymbol = cleanSymbol.replacingOccurrences(of: "XBT", with: "BTC")
        
        // Find matching pair
        for pair in tradingPairs {
            let pairSymbol = pair.replacingOccurrences(of: "-", with: "")
            if baseSymbol == pairSymbol {
                return pair
            }
        }
    } else {
        // CRITICAL FIX: Enhanced conversion for spot with comprehensive validation
        if symbol.contains("USDT") && symbol.count > 4 {
            // Convert BTCUSDT to BTC-USDT format for internal storage
            let baseAsset = symbol.replacingOccurrences(of: "USDT", with: "")
            let convertedPair = "\(baseAsset)-USDT"
            
            // ENHANCED: Validate against trading pairs list
            if tradingPairs.contains(convertedPair) {
                return convertedPair
            } else {
                print("WARNING: Converted pair \(convertedPair) not found in trading pairs list")
                return convertedPair // Return anyway for logging
            }
        } else {
            // Fallback for any other format
            return symbol.replacingOccurrences(of: "USDT", with: "-USDT")
        }
    }
    
    // Fallback: try to construct pair
    if symbol.contains("USDT") {
        let base = symbol.replacingOccurrences(of: "USDT", with: "")
            .replacingOccurrences(of: "M", with: "")
            .replacingOccurrences(of: "XBT", with: "BTC")
        return "\(base)-USDT"
    }
    
    return symbol
}

// Helper function to update KuCoin order book
static func updateKuCoinOrderBook(pair: String, changes: [String: [[String]]]) {
    var currentBook = kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
    
    // Update bids
    if let bidChanges = changes["bids"] {
        for change in bidChanges {
            guard change.count >= 3,
                  let price = Double(change[0]),
                  let size = Double(change[1]) else { continue }
            
            if size == 0 {
                // Remove level
                currentBook.bids.removeAll { $0.price == price }
            } else {
                // Update or add level
                if let index = currentBook.bids.firstIndex(where: { $0.price == price }) {
                    currentBook.bids[index] = (price: price, quantity: size)
                } else {
                    currentBook.bids.append((price: price, quantity: size))
                }
            }
        }
        // Sort bids descending
        currentBook.bids.sort { $0.price > $1.price }
    }
    
    // Update asks
    if let askChanges = changes["asks"] {
        for change in askChanges {
            guard change.count >= 3,
                  let price = Double(change[0]),
                  let size = Double(change[1]) else { continue }
            
            if size == 0 {
                // Remove level
                currentBook.asks.removeAll { $0.price == price }
            } else {
                // Update or add level
                if let index = currentBook.asks.firstIndex(where: { $0.price == price }) {
                    currentBook.asks[index] = (price: price, quantity: size)
                } else {
                    currentBook.asks.append((price: price, quantity: size))
                }
            }
        }
        // Sort asks ascending
        currentBook.asks.sort { $0.price < $1.price }
    }
    
    kucoinOrderBooks[pair] = currentBook
    
    // Update current price from best bid/ask
    if let bestBid = currentBook.bids.first?.price,
       let bestAsk = currentBook.asks.first?.price {
        let midPrice = (bestBid + bestAsk) / 2
        kucoinCurrentPrice[pair] = midPrice
    }
}

    // Reconnection scheduling functions (preserved)
    @MainActor
    static func scheduleKuCoinReconnection() {
        guard kucoinReconnectAttempts < maxReconnectAttempts else {
            print("âŒ Max KuCoin reconnection attempts reached")
            logAlert(event: "âŒ Max KuCoin reconnection attempts reached")
            return
        }
        
        kucoinReconnectAttempts += 1
        let delay = min(30.0, Double(kucoinReconnectAttempts) * 5.0) // Exponential backoff
        
        print("ðŸ”„ Scheduling KuCoin reconnection in \(delay) seconds (attempt \(kucoinReconnectAttempts))")
        
        Task {
            try? await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
            connectToKuCoinSpotWebSocket()
        }
    }
    
    @MainActor
    static func scheduleKuCoinFuturesReconnection() {
        guard kucoinFuturesReconnectAttempts < maxReconnectAttempts else {
            print("âŒ Max KuCoin Futures reconnection attempts reached")
            logAlert(event: "âŒ Max KuCoin Futures reconnection attempts reached")
            return
        }
        
        kucoinFuturesReconnectAttempts += 1
        let delay = min(30.0, Double(kucoinFuturesReconnectAttempts) * 5.0)
        
        print("ðŸ”„ Scheduling KuCoin Futures reconnection in \(delay) seconds (attempt \(kucoinFuturesReconnectAttempts))")
        
        Task {
            try? await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
            connectToKuCoinFuturesWebSocket()
        }
    }
    
    @MainActor
    static func scheduleBybitReconnection() {
        guard bybitReconnectAttempts < maxReconnectAttempts else {
            print("âŒ Max Bybit reconnection attempts reached")
            logAlert(event: "âŒ Max Bybit reconnection attempts reached")
            return
        }
        
        bybitReconnectAttempts += 1
        let delay = min(30.0, Double(bybitReconnectAttempts) * 5.0)
        
        print("ðŸ”„ Scheduling Bybit reconnection in \(delay) seconds (attempt \(bybitReconnectAttempts))")
        
        Task {
            try? await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
            connectToBybitWebSocket()
        }
    }
    
    // FIXED: KuCoin WebSocket Connection Functions with Token Authentication and Delegate Retention
    @MainActor
    static func connectToKuCoinSpotWebSocket() {
        guard hasValidKuCoinCredentials else {
            print("âŒ Cannot connect to KuCoin - invalid credentials")
            logAlert(event: "âŒ Cannot connect to KuCoin - invalid credentials")
            return
        }
        
        print("ðŸ”Œ Connecting to KuCoin Spot WebSocket...")
        logAlert(event: "ðŸ”Œ Starting KuCoin Spot connection with token fetch...")
        
        // CRITICAL FIX: Get WebSocket token from KuCoin API FIRST
        getKuCoinWebSocketToken { token in
            Task { @MainActor in
                guard let websocketToken = token else {
                    print("âŒ Failed to get KuCoin Spot WebSocket token")
                    logAlert(event: "âŒ Failed to get KuCoin Spot WebSocket token")
                    scheduleKuCoinReconnection()
                    return
                }
                
                print("âœ… Got KuCoin Spot token: \(String(websocketToken.prefix(20)))...")
                kucoinToken = websocketToken
                
                // FIXED: Use the correct KuCoin spot WebSocket URL format
                let wsURL = URL(string: "wss://ws-api-spot.kucoin.com/?token=\(websocketToken)")!
                var request = URLRequest(url: wsURL)
                request.timeoutInterval = Double(websocketTimeoutSeconds)
                
                kucoinSocket = WebSocket(request: request)
                // CRITICAL: Create and retain delegate strongly
                let delegate = KuCoinSpotWebSocketDelegateEnhanced()
                kucoinSpotEnhancedDelegate = delegate // Retain strongly
                kucoinSocket?.delegate = delegate
                kucoinSocket?.connect()
                
                print("ðŸš€ KuCoin Spot WebSocket connection initiated with token")
                logAlert(event: "ðŸš€ KuCoin Spot WebSocket connection initiated with token")
            }
        }
    }
    
    @MainActor
    static func connectToKuCoinFuturesWebSocket() {
        print("ðŸ”Œ Connecting to KuCoin Futures WebSocket...")
        
        getKuCoinFuturesWebSocketToken { token in
            Task { @MainActor in
                guard let websocketToken = token else {
                    print("âŒ Failed to get KuCoin Futures WebSocket token")
                    scheduleKuCoinFuturesReconnection()
                    return
                }
                
                kucoinFuturesToken = websocketToken
                
                // Create shared delegate if not exists
                if webSocketDelegate == nil {
                    webSocketDelegate = ExchangeWebSocketDelegate()
                }
                
                let wsURL = URL(string: "wss://ws-api-futures.kucoin.com/endpoint?token=\(websocketToken)")!
                var request = URLRequest(url: wsURL)
                request.timeoutInterval = Double(websocketTimeoutSeconds)
                
                kucoinFuturesSocket = WebSocket(request: request)
                kucoinFuturesSocket?.delegate = webSocketDelegate
                kucoinFuturesSocket?.connect()
                
                print("ðŸš€ KuCoin Futures WebSocket connection initiated")
            }
        }
    }
    
    @MainActor
    static func connectToBybitWebSocket() {
        print("ðŸ”Œ Connecting to Bybit WebSocket...")
        
        // Create shared delegate if not exists
        if webSocketDelegate == nil {
            webSocketDelegate = ExchangeWebSocketDelegate()
        }
        
        let wsURL = URL(string: "wss://stream.bybit.com/v5/public/spot")!
        var request = URLRequest(url: wsURL)
        request.timeoutInterval = Double(websocketTimeoutSeconds)
        
        bybitSocket = WebSocket(request: request)
        bybitSocket?.delegate = webSocketDelegate
        bybitSocket?.connect()
        
        print("ðŸš€ Bybit WebSocket connection initiated")
    }
    
    // FIXED: Token fetching functions with proper non-throwing URLSession implementations
    static func getKuCoinWebSocketToken(completion: @escaping @Sendable (String?) -> Void) {
        let url = URL(string: "https://api.kucoin.com/api/v1/bullet-public")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.timeoutInterval = 10.0
        
        print("ðŸ”„ Fetching KuCoin spot token...")
        
        URLSession.shared.dataTask(with: request) { (data: Data?, response: URLResponse?, error: Error?) -> Void in
            guard let data = data else {
                print("âŒ Failed to get KuCoin WebSocket token - no data received")
                completion(nil)
                return
            }
            
            do {
                let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
                guard let json = json,
                      let dataDict = json["data"] as? [String: Any],
                      let token = dataDict["token"] as? String else {
                    print("âŒ Failed to parse KuCoin WebSocket token response")
                    completion(nil)
                    return
                }
                
                print("âœ… Successfully fetched KuCoin spot token")
                Task { @MainActor in
                    logAlert(event: "âœ… Successfully fetched KuCoin spot token")
                }
                completion(token)
            } catch {
                print("âŒ Failed to parse KuCoin WebSocket token response: \(error.localizedDescription)")
                completion(nil)
            }
        }.resume()
    }
    
    static func getKuCoinFuturesWebSocketToken(completion: @escaping @Sendable (String?) -> Void) {
        let url = URL(string: "https://api-futures.kucoin.com/api/v1/bullet-public")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        
        URLSession.shared.dataTask(with: request) { (data: Data?, response: URLResponse?, error: Error?) -> Void in
            guard let data = data else {
                print("âŒ Failed to get KuCoin Futures WebSocket token - no data received")
                completion(nil)
                return
            }
            
            do {
                let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
                guard let json = json,
                      let dataDict = json["data"] as? [String: Any],
                      let token = dataDict["token"] as? String else {
                    print("âŒ Failed to parse KuCoin Futures WebSocket token response")
                    completion(nil)
                    return
                }
                completion(token)
            } catch {
                print("âŒ Failed to parse KuCoin Futures WebSocket token response: \(error.localizedDescription)")
                completion(nil)
            }
        }.resume()
    }

// CRITICAL ENHANCEMENT: Enhanced Dashboard Data Update Function
@MainActor
static func updateDashboardData() {
    // Update last data update timestamps
    for pair in tradingPairs {
        lastDataUpdate[pair] = Date()
    }
    
    // Calculate basic metrics for dashboard
    let totalKucoinBalance = kucoinBalances.values.reduce(0, +)
    let totalBybitBalance = bybitBalances.values.reduce(0, +)
    let totalPortfolio = totalKucoinBalance + totalBybitBalance
    
    // Update performance metrics
    let totalTrades = performanceMetrics.values.reduce(0) { $0 + $1.trades }
    let totalProfit = performanceMetrics.values.reduce(0.0) { $0 + $1.profit }
    let totalFees = performanceMetrics.values.reduce(0.0) { $0 + $1.fees }
    let netProfit = totalProfit - totalFees
    
    // CRITICAL ENHANCEMENT: Better dashboard logging with ACTUAL spot prices
    let timestamp = ISO8601DateFormatter().string(from: Date())
    print("ðŸ“Š DASHBOARD UPDATE [\(timestamp)]")
    print("ðŸ’° Balances - KuCoin: $\(String(format: "%.2f", kucoinBalance)), Bybit: $\(String(format: "%.2f", bybitBalance))")
    
    // CRITICAL FIX: Show spot prices with enhanced validation for first 5 pairs
    print("ðŸ’± SPOT PRICES:")
    for pair in tradingPairs.prefix(5) {
        let kPrice = kucoinCurrentPrice[pair] ?? 0.0
        let bPrice = bybitCurrentPrice[pair] ?? 0.0
        let priceStatus = (kPrice > 0 ? "âœ…" : "âŒ") + "/" + (bPrice > 0 ? "âœ…" : "âŒ")
        print("   \(pair) \(priceStatus) - KuCoin: $\(String(format: "%.6f", kPrice)), Bybit: $\(String(format: "%.6f", bPrice))")
        
        // CRITICAL: Calculate and show spread if both prices available
        if kPrice > 0 && bPrice > 0 {
            let spread = abs(kPrice - bPrice) / min(kPrice, bPrice) * 100
            let spreadDirection = kPrice > bPrice ? "K>B" : "B>K"
            print("     Spread: \(String(format: "%.4f%%", spread)) (\(spreadDirection))")
        }
    }
    
    // Show futures prices for first 3 pairs
    print("ðŸ“ˆ FUTURES PRICES:")
    for pair in tradingPairs.prefix(3) {
        let kPrice = kucoinCurrentFuturesPrice[pair] ?? 0.0
        let bPrice = bybitCurrentFuturesPrice[pair] ?? 0.0
        let priceStatus = (kPrice > 0 ? "âœ…" : "âŒ") + "/" + (bPrice > 0 ? "âœ…" : "âŒ")
        print("   \(pair) \(priceStatus) - KuCoin: $\(String(format: "%.6f", kPrice)), Bybit: $\(String(format: "%.6f", bPrice))")
    }
    
    // Show arbitrage opportunities
    if !arbitrageOpportunities.isEmpty {
        print("ðŸ”¥ Active Arbitrage Opportunities: \(arbitrageOpportunities.count)")
        for (pair, spread) in arbitrageOpportunities.prefix(3) {
            print("   \(pair): \(String(format: "%.4f%%", spread * 100)) spread")
        }
    }
    
    print("ðŸ“ˆ Trading Stats - Total Profit: $\(String(format: "%.2f", netProfit)), Trades: \(totalTrades)")
    print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
    
    // Log summary periodically
    let now = Date()
    if now.timeIntervalSince(lastSummaryTime) > 300 { // Every 5 minutes
        lastSummaryTime = now
        let summaryMsg = """
        ðŸ“Š Portfolio Summary:
        Total Balance: $\(String(format: "%.2f", totalPortfolio))
        KuCoin: $\(String(format: "%.2f", totalKucoinBalance))
        Bybit: $\(String(format: "%.2f", totalBybitBalance))
        Total Trades: \(totalTrades)
        Net Profit: $\(String(format: "%.2f", netProfit))
        """
        logAlert(event: summaryMsg)
    }
}

// CRITICAL ENHANCEMENT: Trigger Cross-Exchange Arbitrage Check with detailed logging
@MainActor
static func triggerCrossExchangeArbitrageCheck(pair: String) {
    guard let kucoinSpotPrice = kucoinCurrentPrice[pair],
          let bybitSpotPrice = bybitCurrentPrice[pair],
          kucoinSpotPrice > 0, bybitSpotPrice > 0 else {
        return
    }
    
    let spread = abs(kucoinSpotPrice - bybitSpotPrice) / min(kucoinSpotPrice, bybitSpotPrice)
    let minSpread = crossExchangeMinSpreadThreshold
    
    if spread > minSpread {
        let direction = kucoinSpotPrice > bybitSpotPrice ? "KuCoinâ†’Bybit" : "Bybitâ†’KuCoin"
        print("ðŸ”¥ ARBITRAGE OPPORTUNITY: \(pair) - \(direction) - Spread: \(String(format: "%.4f%%", spread * 100))")
        print("   KuCoin Price: $\(String(format: "%.6f", kucoinSpotPrice))")
        print("   Bybit Price: $\(String(format: "%.6f", bybitSpotPrice))")
        logAlert(event: "ðŸ”¥ ARBITRAGE OPPORTUNITY: \(pair) - \(direction) - Spread: \(String(format: "%.4f%%", spread * 100))")
        
        // Store arbitrage opportunity
        arbitrageOpportunities[pair] = spread
        
        // Update dashboard to show opportunity
        updateDashboardData()
    }
}

// ADD this diagnostic function to test your KuCoin connection manually:
@MainActor
static func testKuCoinSpotConnection() {
    print("ðŸ§ª Testing KuCoin Spot connection manually...")
    logAlert(event: "ðŸ§ª Testing KuCoin Spot connection manually...")
    
    // Test token fetch first
    getKuCoinWebSocketToken { token in
        if let token = token {
            print("âœ… Token fetch successful: \(String(token.prefix(20)))...")
            Task { @MainActor in
                logAlert(event: "âœ… Token fetch successful, now testing connection...")
                connectToKuCoinSpotWebSocket()
            }
        } else {
            print("âŒ Token fetch failed")
            Task { @MainActor in
                logAlert(event: "âŒ Token fetch failed")
            }
        }
    }
}
}
