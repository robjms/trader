//--------------- Block 9 - Enhanced KuCoin WebSocket Processing with Spot Price Support



// FIXED: Create a separate delegate class to handle WebSocket events
class ExchangeWebSocketDelegate: NSObject, WebSocketDelegate {
func didReceive(event: WebSocketEvent, client: WebSocketClient) {
Task { @MainActor in
switch event {
case .connected(let headers):
ExchangeWebSocket.handleWebSocketConnected(client: client, headers: headers)
case .disconnected(let reason, let code):
ExchangeWebSocket.handleWebSocketDisconnected(client: client, reason: reason, code: code)
case .text(let string):
ExchangeWebSocket.handleWebSocketTextMessage(client: client, text: string)
case .binary(let data):
ExchangeWebSocket.handleWebSocketBinaryMessage(client: client, data: data)
case .error(let error):
ExchangeWebSocket.handleWebSocketError(client: client, error: error)
default:
break
}
}
}
}
extension ExchangeWebSocket {
// FIXED: Use ObjectIdentifier to compare WebSocket instances
@MainActor
static func handleWebSocketConnected(client: WebSocketClient, headers: [String: String]) {
let clientId = ObjectIdentifier(client)
let kucoinId = kucoinSocket.map { ObjectIdentifier($0) }
let kucoinFuturesId = kucoinFuturesSocket.map { ObjectIdentifier($0) }
let bybitId = bybitSocket.map { ObjectIdentifier($0) }
    if clientId == kucoinId {
        kucoinIsConnected = true
        kucoinReconnectAttempts = 0
        print("âœ… KuCoin Spot WebSocket connected successfully")
        logAlert(event: "âœ… KuCoin Spot WebSocket connected successfully")
        
        // Subscribe to spot tickers for all trading pairs
        subscribeToKuCoinSpotTickers()
    } else if clientId == kucoinFuturesId {
        kucoinFuturesIsConnected = true
        kucoinFuturesReconnectAttempts = 0
        print("âœ… KuCoin Futures WebSocket connected successfully")
        logAlert(event: "âœ… KuCoin Futures WebSocket connected successfully")
    } else if clientId == bybitId {
        bybitIsConnected = true
        bybitReconnectAttempts = 0
        print("âœ… Bybit WebSocket connected successfully")
        logAlert(event: "âœ… Bybit WebSocket connected successfully")
    }
    
    updateDashboardData()
}

@MainActor
static func handleWebSocketDisconnected(client: WebSocketClient, reason: String, code: UInt16) {
    let clientId = ObjectIdentifier(client)
    let kucoinId = kucoinSocket.map { ObjectIdentifier($0) }
    let kucoinFuturesId = kucoinFuturesSocket.map { ObjectIdentifier($0) }
    let bybitId = bybitSocket.map { ObjectIdentifier($0) }
    
    if clientId == kucoinId {
        kucoinIsConnected = false
        print("âŒ KuCoin Spot WebSocket disconnected: \(reason) (code: \(code))")
        logAlert(event: "âŒ KuCoin Spot WebSocket disconnected: \(reason) (code: \(code))")
        scheduleKuCoinReconnection()
    } else if clientId == kucoinFuturesId {
        kucoinFuturesIsConnected = false
        print("âŒ KuCoin Futures WebSocket disconnected: \(reason) (code: \(code))")
        logAlert(event: "âŒ KuCoin Futures WebSocket disconnected: \(reason) (code: \(code))")
        scheduleKuCoinFuturesReconnection()
    } else if clientId == bybitId {
        bybitIsConnected = false
        print("âŒ Bybit WebSocket disconnected: \(reason) (code: \(code))")
        logAlert(event: "âŒ Bybit WebSocket disconnected: \(reason) (code: \(code))")
        scheduleBybitReconnection()
    }
    
    updateDashboardData()
}

@MainActor
static func handleWebSocketTextMessage(client: WebSocketClient, text: String) {
    let clientId = ObjectIdentifier(client)
    let kucoinId = kucoinSocket.map { ObjectIdentifier($0) }
    let kucoinFuturesId = kucoinFuturesSocket.map { ObjectIdentifier($0) }
    let bybitId = bybitSocket.map { ObjectIdentifier($0) }
    
    // Route to appropriate exchange handler using existing string-based functions
    if clientId == kucoinId {
        Task {
            await handleKuCoinSpotMessage(text)
        }
    } else if clientId == kucoinFuturesId {
        Task {
            await handleKuCoinFuturesMessage(text)
        }
    } else if clientId == bybitId {
        Task {
            await handleBybitSpotMessage(text)
        }
    }
}

@MainActor
static func handleWebSocketBinaryMessage(client: WebSocketClient, data: Data) {
    print("ðŸ“¦ Received binary WebSocket message (length: \(data.count))")
}

@MainActor
static func handleWebSocketError(client: WebSocketClient, error: Error?) {
    let errorMessage = error?.localizedDescription ?? "Unknown WebSocket error"
    print("âŒ WebSocket error: \(errorMessage)")
    logAlert(event: "âŒ WebSocket error: \(errorMessage)")
    
    let clientId = ObjectIdentifier(client)
    let kucoinId = kucoinSocket.map { ObjectIdentifier($0) }
    let kucoinFuturesId = kucoinFuturesSocket.map { ObjectIdentifier($0) }
    let bybitId = bybitSocket.map { ObjectIdentifier($0) }
    
    // Trigger reconnection for the specific socket
    if clientId == kucoinId {
        scheduleKuCoinReconnection()
    } else if clientId == kucoinFuturesId {
        scheduleKuCoinFuturesReconnection()
    } else if clientId == bybitId {
        scheduleBybitReconnection()
    }
}

// FIXED: Subscribe to KuCoin Spot Tickers
@MainActor
static func subscribeToKuCoinSpotTickers() {
    guard kucoinIsConnected, let socket = kucoinSocket else {
        print("âŒ Cannot subscribe to KuCoin spot tickers - not connected")
        return
    }
    
    // Subscribe to individual ticker topics for better reliability
    for pair in tradingPairs {
        let subscriptionMessage: [String: Any] = [
            "id": UUID().uuidString,
            "type": "subscribe",
            "topic": "/market/ticker:\(pair)",
            "privateChannel": false,
            "response": true
        ]
        
        do {
            let jsonData = try JSONSerialization.data(withJSONObject: subscriptionMessage)
            if let jsonString = String(data: jsonData, encoding: .utf8) {
                socket.write(string: jsonString)
                print("ðŸ“¡ Subscribed to KuCoin SPOT ticker for \(pair)")
            }
        } catch {
            print("âŒ Failed to subscribe to KuCoin spot ticker for \(pair): \(error)")
            logAlert(event: "âŒ Failed to subscribe to KuCoin spot ticker for \(pair): \(error)")
        }
    }
    
    // Also subscribe to order book updates for better liquidity analysis
    for pair in tradingPairs {
        let orderBookSubscription: [String: Any] = [
            "id": UUID().uuidString,
            "type": "subscribe",
            "topic": "/market/level2:\(pair)",
            "privateChannel": false,
            "response": true
        ]
        
        do {
            let jsonData = try JSONSerialization.data(withJSONObject: orderBookSubscription)
            if let jsonString = String(data: jsonData, encoding: .utf8) {
                socket.write(string: jsonString)
                print("ðŸ“Š Subscribed to KuCoin SPOT order book for \(pair)")
            }
        } catch {
            print("âŒ Failed to subscribe to KuCoin spot order book for \(pair): \(error)")
        }
    }
    
    logAlert(event: "âœ… Subscribed to KuCoin SPOT tickers for \(tradingPairs.count) pairs")
}
// EXISTING FUNCTIONS FROM YOUR CODE - PRESERVED COMPLETELY
static func handleKuCoinSpotMessage(_ message: String) async {
do {
guard let data = message.data(using: .utf8),
let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
await MainActor.run {
logAlert(event: "ðŸŸ¡âŒ Failed to parse KuCoin Spot message: (message)")
}
return
}
    await MainActor.run {
        lastWebsocketActivity["kucoin-spot"] = Date()
    }
    
    // Handle different message types
    if let type = json["type"] as? String {
        switch type {
        case "welcome":
            await MainActor.run {
                logAlert(event: "ðŸŸ¡âœ… KuCoin Spot welcome message received")
            }
            
        case "ack":
            await MainActor.run {
                logAlert(event: "ðŸŸ¡âœ… KuCoin Spot subscription acknowledged")
            }
            
        case "message":
            await handleKuCoinSpotDataMessage(json)
            
        case "pong":
            print("ðŸŸ¡ðŸ’“ KuCoin Spot pong received")
            
        case "error":
            let errorMsg = json["data"] as? String ?? "Unknown error"
            await MainActor.run {
                logAlert(event: "ðŸŸ¡âŒ KuCoin Spot error: \(errorMsg)")
            }
            
        default:
            print("ðŸŸ¡â“ Unknown KuCoin Spot message type: \(type)")
        }
    }
} catch {
    await MainActor.run {
        logAlert(event: "ðŸŸ¡âŒ Error processing KuCoin Spot message: \(error.localizedDescription)")
    }
}
}
static func handleKuCoinSpotDataMessage(_ json: [String: Any]) async {
guard let topic = json["topic"] as? String,
let data = json["data"] as? [String: Any] else {
print("DEBUG: Invalid KuCoin spot message structure")
return
}
await MainActor.run {
    if topic.contains("/market/ticker:") {
        // Extract symbol from topic: /market/ticker:BTC-USDT
        let symbolStart = topic.range(of: ":")?.upperBound
        if let start = symbolStart {
            let symbol = String(topic[start...])
            let pair = symbol // KuCoin uses BTC-USDT format directly
            
            // Process KuCoin ticker data - use correct field names from API
            var priceUpdated = false
            
            // Try different price fields from KuCoin ticker response
            if let priceStr = data["price"] as? String, let price = Double(priceStr), price > 0 {
                kucoinCurrentPrice[pair] = price
                kucoinPrices[pair, default: []].append(price)
                priceUpdated = true
                print("ðŸŸ¡ðŸ’° [KuCoin Spot] Price update: \(pair) = $\(price)")
            } else if let priceStr = data["bestAsk"] as? String, let price = Double(priceStr), price > 0 {
                kucoinCurrentPrice[pair] = price
                kucoinPrices[pair, default: []].append(price)
                priceUpdated = true
                print("ðŸŸ¡ðŸ’° [KuCoin Spot] Price update (bestAsk): \(pair) = $\(price)")
            } else if let priceStr = data["bestBid"] as? String, let price = Double(priceStr), price > 0 {
                kucoinCurrentPrice[pair] = price
                kucoinPrices[pair, default: []].append(price)
                priceUpdated = true
                print("ðŸŸ¡ðŸ’° [KuCoin Spot] Price update (bestBid): \(pair) = $\(price)")
            }
            
            if priceUpdated {
                // Maintain price history
                if kucoinPrices[pair]!.count > priceHistoryRetention {
                    kucoinPrices[pair]?.removeFirst()
                }
                
                // Log successful price update
                logAlert(event: "âœ… [KuCoin Spot] Updated price for \(pair): $\(kucoinCurrentPrice[pair] ?? 0)")
                
                // Update dashboard
                updateDashboardData()
                
                // Check for arbitrage opportunities and log spreads
                checkAndLogArbitrageOpportunity(pair: pair)
            } else {
                print("ðŸŸ¡âš ï¸ [KuCoin Spot] No valid price found in ticker data for \(pair)")
                print("DEBUG: Available data keys: \(data.keys)")
            }
            
            // Extract volume if available
            if let volumeStr = data["vol"] as? String ?? data["size"] as? String,
               let volume = Double(volumeStr) {
                kucoinSpotVolume[pair, default: []].append(volume)
                if kucoinSpotVolume[pair]!.count > priceHistoryRetention {
                    kucoinSpotVolume[pair]?.removeFirst()
                }
            }
        }
    } else if topic.contains("/market/level2:") {
        // Order book updates - existing logic preserved
        let symbolStart = topic.range(of: ":")?.upperBound
        if let start = symbolStart {
            let symbol = String(topic[start...])
            let pair = symbol
            
            if let changes = data["changes"] as? [String: [[String]]] {
                updateKuCoinOrderBook(pair: pair, changes: changes)
            }
        }
    }
}
}
static func handleKuCoinFuturesMessage(_ message: String) async {
do {
guard let data = message.data(using: .utf8),
let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
await MainActor.run {
logAlert(event: "ðŸŸ¡âŒ Failed to parse KuCoin Futures message: (message)")
}
return
}
    await MainActor.run {
        lastWebsocketActivity["kucoin-futures"] = Date()
    }
    
    // Handle different message types
    if let type = json["type"] as? String {
        switch type {
        case "welcome":
            await MainActor.run {
                logAlert(event: "ðŸŸ¡âœ… KuCoin Futures welcome message received")
            }
            
        case "ack":
            await MainActor.run {
                logAlert(event: "ðŸŸ¡âœ… KuCoin Futures subscription acknowledged")
            }
            
        case "message":
            await handleKuCoinFuturesDataMessage(json)
            
        case "pong":
            print("ðŸŸ¡ðŸ’“ KuCoin Futures pong received")
            
        case "error":
            let errorMsg = json["data"] as? String ?? "Unknown error"
            await MainActor.run {
                logAlert(event: "ðŸŸ¡âŒ KuCoin Futures error: \(errorMsg)")
            }
            
        default:
            print("ðŸŸ¡â“ Unknown KuCoin Futures message type: \(type)")
        }
    }
} catch {
    await MainActor.run {
        logAlert(event: "ðŸŸ¡âŒ Error processing KuCoin Futures message: \(error.localizedDescription)")
    }
}
}
static func handleKuCoinFuturesDataMessage(_ json: [String: Any]) async {
guard let topic = json["topic"] as? String,
let data = json["data"] as? [String: Any] else {
return
}
await MainActor.run {
    if topic.contains("/contractMarket/ticker:") {
        // Extract symbol from topic: /contractMarket/ticker:XBTUSDTM
        let symbolStart = topic.range(of: ":")?.upperBound
        if let start = symbolStart {
            let symbol = String(topic[start...])
            let pair = convertSymbolToPair(symbol: symbol, isFutures: true)
            
            // Extract price data
            if let priceStr = data["price"] as? String,
               let price = Double(priceStr), price > 0 {
                
                kucoinCurrentFuturesPrice[pair] = price
                kucoinFuturesPrices[pair, default: []].append(price)
                
                // Maintain price history
                if kucoinFuturesPrices[pair]!.count > priceHistoryRetention {
                    kucoinFuturesPrices[pair]?.removeFirst()
                }
                
                print("ðŸŸ¡âœ… [KuCoin Futures] Updated price for \(pair): $\(price)")
                logAlert(event: "âœ… [KuCoin Futures] Updated price for \(pair): $\(price)")
                
                // Update dashboard
                updateDashboardData()
            }
            
            // Extract volume if available
            if let volumeStr = data["vol"] as? String,
               let volume = Double(volumeStr) {
                kucoinFuturesVolume[pair, default: []].append(volume)
                if kucoinFuturesVolume[pair]!.count > priceHistoryRetention {
                    kucoinFuturesVolume[pair]?.removeFirst()
                }
            }
            
            // Extract funding rate if available
            if let fundingRateStr = data["fundingRate"] as? String,
               let fundingRate = Double(fundingRateStr) {
                kucoinFundingRates[pair] = fundingRate
                kucoinFundingRateHistory[pair, default: []].append(fundingRate)
                if kucoinFundingRateHistory[pair]!.count > priceHistoryRetention {
                    kucoinFundingRateHistory[pair]?.removeFirst()
                }
            }
        }
    }
}
}
static func handleBybitSpotMessage(_ message: String) async {
do {
guard let data = message.data(using: .utf8),
let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
await MainActor.run {
logAlert(event: "ðŸ”µâŒ Failed to parse Bybit Spot message: (message)")
}
return
}
    await MainActor.run {
        lastWebsocketActivity["bybit-spot"] = Date()
    }
    
    // Handle subscription success
    if let success = json["success"] as? Bool, success == true {
        await MainActor.run {
            logAlert(event: "ðŸ”µâœ… Bybit Spot subscription successful")
        }
        return
    }
    
    // Handle data messages
    if let topic = json["topic"] as? String,
       let data = json["data"] as? [String: Any],
       topic.contains("tickers.") {
        
        await handleBybitSpotDataMessage(topic: topic, data: data)
    }
    
} catch {
    await MainActor.run {
        logAlert(event: "ðŸ”µâŒ Error processing Bybit Spot message: \(error.localizedDescription)")
    }
}
}
static func handleBybitSpotDataMessage(topic: String, data: [String: Any]) async {
// Extract symbol from topic: tickers.BTCUSDT
let symbolStart = topic.range(of: ".")?.upperBound
guard let start = symbolStart else { return }
let symbol = String(topic[start...])
let pair = convertSymbolToPair(symbol: symbol, isFutures: false)

await MainActor.run {
    // Extract price data
    if let priceStr = data["lastPrice"] as? String,
       let price = Double(priceStr), price > 0 {
        
        bybitCurrentPrice[pair] = price
        bybitPrices[pair, default: []].append(price)
        
        // Maintain price history
        if bybitPrices[pair]!.count > priceHistoryRetention {
            bybitPrices[pair]?.removeFirst()
        }
        
        print("ðŸ”µâœ… [Bybit Spot] Updated price for \(pair): $\(price)")
        logAlert(event: "âœ… [Bybit Spot] Updated price for \(pair): $\(price)")
        
        // Update dashboard
        updateDashboardData()
    }
    
    // Extract volume if available
    if let volumeStr = data["volume24h"] as? String,
       let volume = Double(volumeStr) {
        bybitSpotVolume[pair, default: []].append(volume)
        if bybitSpotVolume[pair]!.count > priceHistoryRetention {
            bybitSpotVolume[pair]?.removeFirst()
        }
    }
}
}
static func handleBybitFuturesMessage(_ message: String) async {
do {
guard let data = message.data(using: .utf8),
let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
await MainActor.run {
logAlert(event: "ðŸ”µâŒ Failed to parse Bybit Futures message: (message)")
}
return
}
    await MainActor.run {
        lastWebsocketActivity["bybit-futures"] = Date()
    }
    
    // Handle subscription success
    if let success = json["success"] as? Bool, success == true {
        await MainActor.run {
            logAlert(event: "ðŸ”µâœ… Bybit Futures subscription successful")
        }
        return
    }
    
    // Handle data messages
    if let topic = json["topic"] as? String,
       let data = json["data"] as? [String: Any],
       topic.contains("tickers.") {
        
        await handleBybitFuturesDataMessage(topic: topic, data: data)
    }
    
} catch {
    await MainActor.run {
        logAlert(event: "ðŸ”µâŒ Error processing Bybit Futures message: \(error.localizedDescription)")
    }
}
}
static func handleBybitFuturesDataMessage(topic: String, data: [String: Any]) async {
// Extract symbol from topic: tickers.BTCUSDT
let symbolStart = topic.range(of: ".")?.upperBound
guard let start = symbolStart else { return }
let symbol = String(topic[start...])
let pair = convertSymbolToPair(symbol: symbol, isFutures: false)

await MainActor.run {
    // Extract price data
    if let priceStr = data["lastPrice"] as? String,
       let price = Double(priceStr), price > 0 {
        
        bybitCurrentFuturesPrice[pair] = price
        bybitFuturesPrices[pair, default: []].append(price)
        
        // Maintain price history
        if bybitFuturesPrices[pair]!.count > priceHistoryRetention {
            bybitFuturesPrices[pair]?.removeFirst()
        }
        
        print("ðŸ”µâœ… [Bybit Futures] Updated price for \(pair): $\(price)")
        logAlert(event: "âœ… [Bybit Futures] Updated price for \(pair): $\(price)")
        
        // Update dashboard
        updateDashboardData()
    }
    
    // Extract volume if available
    if let volumeStr = data["volume24h"] as? String,
       let volume = Double(volumeStr) {
        bybitFuturesVolume[pair, default: []].append(volume)
        if bybitFuturesVolume[pair]!.count > priceHistoryRetention {
            bybitFuturesVolume[pair]?.removeFirst()
        }
    }
    
    // Extract funding rate if available
    if let fundingRateStr = data["fundingRate"] as? String,
       let fundingRate = Double(fundingRateStr) {
        bybitFundingRates[pair] = fundingRate
        bybitFundingRateHistory[pair, default: []].append(fundingRate)
        if bybitFundingRateHistory[pair]!.count > priceHistoryRetention {
            bybitFundingRateHistory[pair]?.removeFirst()
        }
    }
}
}
// ENHANCED: KuCoin Spot Message Processing
@MainActor
static func processKuCoinSpotMessage(_ json: [String: Any]) {
guard let type = json["type"] as? String, type == "message",
let topic = json["topic"] as? String,
topic.hasPrefix("/market/ticker:"),
let dataDict = json["data"] as? [String: Any] else {
print("DEBUG: Invalid KuCoin Spot message format")
return
}
let priceKeys = ["price", "last", "bestAsk", "bestBid"]
var priceStr: String?
for key in priceKeys {
    if let value = dataDict[key] as? String {
        priceStr = value
        break
    }
}

guard let priceStr = priceStr else {
    print("Failed to find price in KuCoin Spot message. Available keys: \(dataDict.keys)")
    return
}

// Fix ambiguous type expression by being explicit
guard let price: Double = Double(priceStr) else {
    print("Failed to parse price '\(priceStr)' from KuCoin Spot message")
    return
}

let spotSymbol = topic.components(separatedBy: ":").last ?? ""
let pair = spotSymbol

kucoinCurrentPrice[pair] = price
kucoinPrices[pair, default: []].append(price)

if kucoinPrices[pair]!.count > priceHistoryRetention {
    kucoinPrices[pair]!.removeFirst()
}

// Process volume if available
if let volStr = dataDict["size"] as? String ?? dataDict["volume"] as? String,
   let vol: Double = Double(volStr) {
    kucoinSpotVolume[pair, default: []].append(vol)
    if kucoinSpotVolume[pair]!.count > priceHistoryRetention {
        kucoinSpotVolume[pair]!.removeFirst()
    }
}

print("Updated KuCoin spot price for \(pair): \(price)")
logAlert(event: "âœ… KuCoin Spot price update: \(pair) = $\(price)")
}
// ENHANCED: KuCoin Futures Message Processing
@MainActor
static func processKuCoinFuturesMessage(_ json: [String: Any]) {
guard let type = json["type"] as? String, type == "message",
let topic = json["topic"] as? String,
let dataDict = json["data"] as? [String: Any] else {
print("DEBUG: Invalid KuCoin Futures message format")
return
}
if topic.hasPrefix("/contractMarket/tickerV2:") {
    processKuCoinFuturesTicker(topic: topic, data: dataDict)
} else if topic.hasPrefix("/contractMarket/level2:") {
    processKuCoinFuturesOrderBook(topic: topic, data: dataDict)
} else if topic.hasPrefix("/contract/instrument:") {
    processKuCoinFuturesFunding(topic: topic, data: dataDict)
}
}
@MainActor
private static func processKuCoinFuturesTicker(topic: String, data: [String: Any]) {
let priceKeys = ["bestAskPrice", "bestBidPrice", "lastPrice", "indexPrice"]
var priceStr: String?
for key in priceKeys {
if let value = data[key] as? String {
priceStr = value
break
}
}
guard let priceStr = priceStr,
      let price: Double = Double(priceStr) else {
    print("Failed to find/parse price in KuCoin Futures message")
    return
}

let futuresSymbol = topic.components(separatedBy: ":").last ?? ""
guard let pair = kucoinFuturesSymbols.first(where: { $0.value == futuresSymbol })?.key else {
    print("No pair found for futures symbol: \(futuresSymbol)")
    return
}

kucoinCurrentFuturesPrice[pair] = price
kucoinFuturesPrices[pair, default: []].append(price)

if kucoinFuturesPrices[pair]!.count > priceHistoryRetention {
    kucoinFuturesPrices[pair]!.removeFirst()
}

// Process volume
if let volStr = data["volume"] as? String ?? data["size"] as? String,
   let vol: Double = Double(volStr) {
    kucoinFuturesVolume[pair, default: []].append(vol)
    if kucoinFuturesVolume[pair]!.count > priceHistoryRetention {
        kucoinFuturesVolume[pair]!.removeFirst()
    }
}

print("Updated KuCoin futures price for \(pair): \(price)")
logAlert(event: "âœ… KuCoin Futures price update: \(pair) = $\(price)")
}
@MainActor
private static func processKuCoinFuturesOrderBook(topic: String, data: [String: Any]) {
let futuresSymbol = topic.components(separatedBy: ":").last ?? ""
guard let pair = kucoinFuturesSymbols.first(where: { $0.value == futuresSymbol })?.key else {
print("No pair found for futures symbol: (futuresSymbol)")
return
}
var orderBook: [(price: Double, volume: Double, side: String)] = []

if let bids = data["bids"] as? [[String]],
   let asks = data["asks"] as? [[String]] {
    // Snapshot
    for bid in bids {
        if let priceStr = bid.first, let qtyStr = bid.last,
           let price: Double = Double(priceStr),
           let qty: Double = Double(qtyStr), qty > 0 {
            orderBook.append((price: price, volume: qty, side: "buy"))
        }
    }
    for ask in asks {
        if let priceStr = ask.first, let qtyStr = ask.last,
           let price: Double = Double(priceStr),
           let qty: Double = Double(qtyStr), qty > 0 {
            orderBook.append((price: price, volume: qty, side: "sell"))
        }
    }
} else if let change = data["change"] as? String {
    // Incremental update
    orderBook = kucoinFuturesOrderBook[pair] ?? []
    let components = change.components(separatedBy: ",")
    if components.count == 3,
       let price: Double = Double(components[0]),
       let size: Double = Double(components[2]) {
        let side = components[1].lowercased() == "buy" ? "buy" : "sell"
        orderBook.removeAll { $0.price == price && $0.side == side }
        if size > 0 {
            orderBook.append((price: price, volume: size, side: side))
        }
    }
}

kucoinFuturesOrderBook[pair] = orderBook
print("DEBUG: Updated KuCoin futures order book for \(pair): \(orderBook.count) entries")
}
@MainActor
private static func processKuCoinFuturesFunding(topic: String, data: [String: Any]) {
guard let fundingRateStr = data["fundingRate"] as? String,
let fundingRate: Double = Double(fundingRateStr),
let futuresSymbol = topic.components(separatedBy: ":").last,
let pair = kucoinFuturesSymbols.first(where: { $0.value == futuresSymbol })?.key else {
return
}
kucoinFundingRates[pair] = fundingRate
kucoinFundingRateHistory[pair, default: []].append(fundingRate)

if kucoinFundingRateHistory[pair]!.count > 24 { // Keep 24 hours of history
    kucoinFundingRateHistory[pair]!.removeFirst()
}

print("Updated KuCoin funding rate for \(pair): \(fundingRate)")
logAlert(event: "âœ… KuCoin Funding rate update: \(pair) = \(fundingRate * 100)%")
}
// ENHANCED: Bybit Spot Message Processing
@MainActor
static func processBybitSpotMessage(_ json: [String: Any]) {
if let success = json["success"] as? Bool {
if success, let retMsg = json["ret_msg"] as? String, retMsg == "subscribe" {
print("Bybit Spot subscription confirmed")
} else if !success {
print("Bybit Spot WebSocket error: (json)")
logAlert(event: "âŒ Bybit Spot WebSocket error: (json)")
}
} else if let topic = json["topic"] as? String {
if topic.hasPrefix("tickers.") {
processBybitSpotTicker(data: json)
} else if topic.hasPrefix("orderbook.50.") {
processBybitSpotOrderBook(data: json)
} else if topic.hasPrefix("publicTrade.") {
processBybitSpotTrade(data: json)
}
}
}
@MainActor
private static func processBybitSpotTicker(data: [String: Any]) {
guard let dataDict = data["data"] as? [String: Any],
let symbol = dataDict["symbol"] as? String else { return }
let priceKeys = ["lastPrice", "bestAskPrice", "ask1Price", "indexPrice"]
var priceStr: String?
for key in priceKeys {
    if let value = dataDict[key] as? String {
        priceStr = value
        break
    }
}

guard let priceStr = priceStr,
      let price: Double = Double(priceStr) else {
    print("Failed to find/parse price in Bybit Spot ticker")
    return
}

let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
bybitCurrentPrice[pair] = price
bybitPrices[pair, default: []].append(price)

if bybitPrices[pair]!.count > priceHistoryRetention {
    bybitPrices[pair]!.removeFirst()
}

// Process volume
if let volStr = dataDict["volume24h"] as? String,
   let vol: Double = Double(volStr) {
    bybitSpotVolume[pair, default: []].append(vol)
    if bybitSpotVolume[pair]!.count > priceHistoryRetention {
        bybitSpotVolume[pair]!.removeFirst()
    }
}

print("Updated Bybit spot price for \(pair): \(price)")
logAlert(event: "âœ… Bybit Spot price update: \(pair) = $\(price)")
}
@MainActor
private static func processBybitSpotOrderBook(data: [String: Any]) {
guard let dataDict = data["data"] as? [String: Any],
let symbol = dataDict["s"] as? String,
let asks = dataDict["a"] as? [[String]],
let bids = dataDict["b"] as? [[String]] else { return }
let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")

// Process asks and bids into BevaixOrderBook format
let bidBook = bids.compactMap { bid -> (price: Double, quantity: Double)? in
    guard let priceStr = bid.first, let volStr = bid.last,
          let price: Double = Double(priceStr),
          let vol: Double = Double(volStr) else { return nil }
    return (price: price, quantity: vol)
}

let askBook = asks.compactMap { ask -> (price: Double, quantity: Double)? in
    guard let priceStr = ask.first, let volStr = ask.last,
          let price: Double = Double(priceStr),
          let vol: Double = Double(volStr) else { return nil }
    return (price: price, quantity: vol)
}

bybitOrderBooks[pair] = BevaixOrderBook(bids: bidBook, asks: askBook)
print("Updated Bybit spot order book for \(pair): bids=\(bidBook.count), asks=\(askBook.count)")
}
@MainActor
private static func processBybitSpotTrade(data: [String: Any]) {
guard let dataArray = data["data"] as? [[String: Any]],
let firstTrade = dataArray.first,
let priceStr = firstTrade["p"] as? String,
let price: Double = Double(priceStr),
let symbol = firstTrade["s"] as? String else { return }
let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
bybitCurrentPrice[pair] = price
bybitPrices[pair, default: []].append(price)

if bybitPrices[pair]!.count > priceHistoryRetention {
    bybitPrices[pair]?.removeFirst()
}

print("Updated Bybit spot price from trade for \(pair): \(price)")
}
// ENHANCED: Bybit Futures Message Processing
@MainActor
static func processBybitFuturesMessage(_ json: [String: Any]) {
if let success = json["success"] as? Bool {
if success, let retMsg = json["ret_msg"] as? String, retMsg == "subscribe" {
print("Bybit Futures subscription confirmed")
} else if !success {
print("Bybit Futures WebSocket error: (json)")
logAlert(event: "âŒ Bybit Futures WebSocket error: (json)")
}
} else if let topic = json["topic"] as? String {
if topic.hasPrefix("tickers.") {
processBybitFuturesTicker(data: json)
} else if topic.hasPrefix("orderbook.50.") {
processBybitFuturesOrderBook(data: json)
} else if topic.hasPrefix("publicTrade.") {
processBybitFuturesTrade(data: json)
}
}
}
@MainActor
private static func processBybitFuturesTicker(data: [String: Any]) {
guard let dataDict = data["data"] as? [String: Any],
let symbol = dataDict["symbol"] as? String else { return }
let priceKeys = ["lastPrice", "bestAskPrice", "ask1Price", "bid1Price", "indexPrice", "markPrice"]
var priceStr: String?
for key in priceKeys {
    if let value = dataDict[key] as? String {
        priceStr = value
        break
    }
}

guard let priceStr = priceStr,
      let price: Double = Double(priceStr) else {
    print("Failed to find/parse price in Bybit Futures ticker")
    return
}

let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
bybitCurrentFuturesPrice[pair] = price
bybitFuturesPrices[pair, default: []].append(price)

if bybitFuturesPrices[pair]!.count > priceHistoryRetention {
    bybitFuturesPrices[pair]!.removeFirst()
}

// Process volume
if let volStr = dataDict["volume24h"] as? String,
   let vol: Double = Double(volStr) {
    bybitFuturesVolume[pair, default: []].append(vol)
    if bybitFuturesVolume[pair]!.count > priceHistoryRetention {
        bybitFuturesVolume[pair]!.removeFirst()
    }
}

// Process funding rate
if let fundingRateStr = dataDict["fundingRate"] as? String,
   let fundingRate: Double = Double(fundingRateStr) {
    bybitFundingRates[pair] = fundingRate
    bybitFundingRateHistory[pair, default: []].append(fundingRate)
    
    if bybitFundingRateHistory[pair]!.count > 24 { // Keep 24 hours
        bybitFundingRateHistory[pair]!.removeFirst()
    }
    
    print("Updated Bybit funding rate for \(pair): \(fundingRate)")
}

print("Updated Bybit futures price for \(pair): \(price)")
logAlert(event: "âœ… Bybit Futures price update: \(pair) = $\(price)")
}
@MainActor
private static func processBybitFuturesOrderBook(data: [String: Any]) {
guard let dataDict = data["data"] as? [String: Any],
let symbol = dataDict["s"] as? String,
let updateType = dataDict["type"] as? String else { return }
let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
var orderBook: [(price: Double, volume: Double, side: String)]

if updateType == "snapshot" {
    orderBook = []
} else {
    orderBook = bybitFuturesOrderBook[pair] ?? []
}

if let asks = dataDict["a"] as? [[String]] {
    for ask in asks {
        if let priceStr = ask.first, let volStr = ask.last,
           let price: Double = Double(priceStr),
           let vol: Double = Double(volStr) {
            orderBook.removeAll { $0.price == price && $0.side == "sell" }
            if vol > 0 {
                orderBook.append((price: price, volume: vol, side: "sell"))
            }
        }
    }
}

if let bids = dataDict["b"] as? [[String]] {
    for bid in bids {
        if let priceStr = bid.first, let volStr = bid.last,
           let price: Double = Double(priceStr),
           let vol: Double = Double(volStr) {
            orderBook.removeAll { $0.price == price && $0.side == "buy" }
            if vol > 0 {
                orderBook.append((price: price, volume: vol, side: "buy"))
            }
        }
    }
}

bybitFuturesOrderBook[pair] = orderBook
print("DEBUG: Updated Bybit futures order book for \(pair): \(orderBook.count) entries")
}
@MainActor
private static func processBybitFuturesTrade(data: [String: Any]) {
guard let dataArray = data["data"] as? [[String: Any]],
let firstTrade = dataArray.first,
let priceStr = firstTrade["p"] as? String,
let price: Double = Double(priceStr),
let symbol = firstTrade["s"] as? String else { return }
let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
bybitCurrentFuturesPrice[pair] = price
bybitFuturesPrices[pair, default: []].append(price)

if bybitFuturesPrices[pair]!.count > priceHistoryRetention {
    bybitFuturesPrices[pair]!.removeFirst()
}

print("Updated Bybit futures price from trade for \(pair): \(price)")
}
// ENHANCED: Centralized WebSocket Health Monitoring
@MainActor
static func monitorWebSocketHealth() {
let healthCheck = [
"KuCoin Spot": kucoinIsConnected,
"KuCoin Futures": kucoinFuturesIsConnected,
"Bybit Spot": bybitIsConnected,
"Bybit Futures": bybitFuturesIsConnected
]
var disconnectedCount = 0
var healthReport = "ðŸ” WebSocket Health Report:\n"

for (exchange, connected) in healthCheck {
    let status = connected ? "âœ… Connected" : "âŒ Disconnected"
    healthReport += "  \(exchange): \(status)\n"
    if !connected { disconnectedCount += 1 }
}

if disconnectedCount > 0 {
    healthReport += "âš ï¸  \(disconnectedCount) connection(s) need attention"
    logAlert(event: healthReport)
}

print(healthReport)
}
// Helper function to convert symbol formats to trading pairs
static func convertSymbolToPair(symbol: String, isFutures: Bool) -> String {
if isFutures {
// KuCoin futures: XBTUSDTM -> BTC-USDT
let cleanSymbol = symbol.replacingOccurrences(of: "M", with: "")
let baseSymbol = cleanSymbol.replacingOccurrences(of: "XBT", with: "BTC")
    // Find matching pair
    for pair in tradingPairs {
        let pairSymbol = pair.replacingOccurrences(of: "-", with: "")
        if baseSymbol == pairSymbol {
            return pair
        }
    }
} else {
    // Spot: BTCUSDT -> BTC-USDT
    for pair in tradingPairs {
        let pairSymbol = pair.replacingOccurrences(of: "-", with: "")
        if symbol == pairSymbol {
            return pair
        }
    }
}

// Fallback: try to construct pair
if symbol.contains("USDT") {
    let base = symbol.replacingOccurrences(of: "USDT", with: "")
        .replacingOccurrences(of: "M", with: "")
        .replacingOccurrences(of: "XBT", with: "BTC")
    return "\(base)-USDT"
}

return symbol
}
// Helper function to update KuCoin order book
static func updateKuCoinOrderBook(pair: String, changes: [String: [[String]]]) {
var currentBook = kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
// Update bids
if let bidChanges = changes["bids"] {
    for change in bidChanges {
        guard change.count >= 3,
              let price = Double(change[0]),
              let size = Double(change[1]) else { continue }
        
        if size == 0 {
            // Remove level
            currentBook.bids.removeAll { $0.price == price }
        } else {
            // Update or add level
            if let index = currentBook.bids.firstIndex(where: { $0.price == price }) {
                currentBook.bids[index] = (price: price, quantity: size)
            } else {
                currentBook.bids.append((price: price, quantity: size))
            }
        }
    }
    // Sort bids descending
    currentBook.bids.sort { $0.price > $1.price }
}

// Update asks
if let askChanges = changes["asks"] {
    for change in askChanges {
        guard change.count >= 3,
              let price = Double(change[0]),
              let size = Double(change[1]) else { continue }
        
        if size == 0 {
            // Remove level
            currentBook.asks.removeAll { $0.price == price }
        } else {
            // Update or add level
            if let index = currentBook.asks.firstIndex(where: { $0.price == price }) {
                currentBook.asks[index] = (price: price, quantity: size)
            } else {
                currentBook.asks.append((price: price, quantity: size))
            }
        }
    }
    // Sort asks ascending
    currentBook.asks.sort { $0.price < $1.price }
}

kucoinOrderBooks[pair] = currentBook

// Update current price from best bid/ask
if let bestBid = currentBook.bids.first?.price,
   let bestAsk = currentBook.asks.first?.price {
    let midPrice = (bestBid + bestAsk) / 2
    kucoinCurrentPrice[pair] = midPrice
}
}
// Reconnection scheduling functions (preserved)
@MainActor
static func scheduleKuCoinReconnection() {
    guard kucoinReconnectAttempts < maxReconnectAttempts else {
        print("âŒ Max KuCoin reconnection attempts reached")
        logAlert(event: "âŒ Max KuCoin reconnection attempts reached")
        return
    }
    
    kucoinReconnectAttempts += 1
    let delay = min(30.0, Double(kucoinReconnectAttempts) * 5.0) // Exponential backoff
    
    print("ðŸ”„ Scheduling KuCoin reconnection in \(delay) seconds (attempt \(kucoinReconnectAttempts))")
    
    Task {
        try? await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
        connectToKuCoinSpotWebSocket()
    }
}

@MainActor
static func scheduleKuCoinFuturesReconnection() {
    guard kucoinFuturesReconnectAttempts < maxReconnectAttempts else {
        print("âŒ Max KuCoin Futures reconnection attempts reached")
        logAlert(event: "âŒ Max KuCoin Futures reconnection attempts reached")
        return
    }
    
    kucoinFuturesReconnectAttempts += 1
    let delay = min(30.0, Double(kucoinFuturesReconnectAttempts) * 5.0)
    
    print("ðŸ”„ Scheduling KuCoin Futures reconnection in \(delay) seconds (attempt \(kucoinFuturesReconnectAttempts))")
    
    Task {
        try? await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
        connectToKuCoinFuturesWebSocket()
    }
}

@MainActor
static func scheduleBybitReconnection() {
    guard bybitReconnectAttempts < maxReconnectAttempts else {
        print("âŒ Max Bybit reconnection attempts reached")
        logAlert(event: "âŒ Max Bybit reconnection attempts reached")
        return
    }
    
    bybitReconnectAttempts += 1
    let delay = min(30.0, Double(bybitReconnectAttempts) * 5.0)
    
    print("ðŸ”„ Scheduling Bybit reconnection in \(delay) seconds (attempt \(bybitReconnectAttempts))")
    
    Task {
        try? await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
        connectToBybitWebSocket()
    }
}

// FIXED: KuCoin WebSocket Connection Functions with Shared Delegate
@MainActor
static func connectToKuCoinSpotWebSocket() {
    guard hasValidKuCoinCredentials else {
        print("âŒ Cannot connect to KuCoin - invalid credentials")
        logAlert(event: "âŒ Cannot connect to KuCoin - invalid credentials")
        return
    }
    
    print("ðŸ”Œ Connecting to KuCoin Spot WebSocket...")
    
    // Get WebSocket token from KuCoin API
    getKuCoinWebSocketToken { token in
        Task { @MainActor in
            guard let websocketToken = token else {
                print("âŒ Failed to get KuCoin WebSocket token")
                logAlert(event: "âŒ Failed to get KuCoin WebSocket token")
                scheduleKuCoinReconnection()
                return
            }
            
            kucoinToken = websocketToken
            
            // Create shared delegate if not exists
            if webSocketDelegate == nil {
                webSocketDelegate = ExchangeWebSocketDelegate()
            }
            
            // Construct WebSocket URL for spot trading
            let wsURL = URL(string: "wss://ws-api.kucoin.com/endpoint?token=\(websocketToken)")!
            var request = URLRequest(url: wsURL)
            request.timeoutInterval = Double(websocketTimeoutSeconds)
            
            kucoinSocket = WebSocket(request: request)
            kucoinSocket?.delegate = webSocketDelegate
            kucoinSocket?.connect()
            
            print("ðŸš€ KuCoin Spot WebSocket connection initiated")
        }
    }
}

@MainActor
static func connectToKuCoinFuturesWebSocket() {
    print("ðŸ”Œ Connecting to KuCoin Futures WebSocket...")
    
    getKuCoinFuturesWebSocketToken { token in
        Task { @MainActor in
            guard let websocketToken = token else {
                print("âŒ Failed to get KuCoin Futures WebSocket token")
                scheduleKuCoinFuturesReconnection()
                return
            }
            
            kucoinFuturesToken = websocketToken
            
            // Create shared delegate if not exists
            if webSocketDelegate == nil {
                webSocketDelegate = ExchangeWebSocketDelegate()
            }
            
            let wsURL = URL(string: "wss://ws-api-futures.kucoin.com/endpoint?token=\(websocketToken)")!
            var request = URLRequest(url: wsURL)
            request.timeoutInterval = Double(websocketTimeoutSeconds)
            
            kucoinFuturesSocket = WebSocket(request: request)
            kucoinFuturesSocket?.delegate = webSocketDelegate
            kucoinFuturesSocket?.connect()
            
            print("ðŸš€ KuCoin Futures WebSocket connection initiated")
        }
    }
}

@MainActor
static func connectToBybitWebSocket() {
    print("ðŸ”Œ Connecting to Bybit WebSocket...")
    
    // Create shared delegate if not exists
    if webSocketDelegate == nil {
        webSocketDelegate = ExchangeWebSocketDelegate()
    }
    
    let wsURL = URL(string: "wss://stream.bybit.com/v5/public/spot")!
    var request = URLRequest(url: wsURL)
    request.timeoutInterval = Double(websocketTimeoutSeconds)
    
    bybitSocket = WebSocket(request: request)
    bybitSocket?.delegate = webSocketDelegate
    bybitSocket?.connect()
    
    print("ðŸš€ Bybit WebSocket connection initiated")
}

// FIXED: Token fetching functions with proper non-throwing URLSession implementations
static func getKuCoinWebSocketToken(completion: @escaping @Sendable (String?) -> Void) {
    let url = URL(string: "https://api.kucoin.com/api/v1/bullet-public")!
    var request = URLRequest(url: url)
    request.httpMethod = "POST"
    request.addValue("application/json", forHTTPHeaderField: "Content-Type")
    
    URLSession.shared.dataTask(with: request) { (data: Data?, response: URLResponse?, error: Error?) -> Void in
        guard let data = data else {
            print("âŒ Failed to get KuCoin WebSocket token - no data received")
            completion(nil)
            return
        }
        
        do {
            let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
            guard let json = json,
                  let dataDict = json["data"] as? [String: Any],
                  let token = dataDict["token"] as? String else {
                print("âŒ Failed to parse KuCoin WebSocket token response")
                completion(nil)
                return
            }
            completion(token)
        } catch {
            print("âŒ Failed to parse KuCoin WebSocket token response: \(error.localizedDescription)")
            completion(nil)
        }
    }.resume()
}

static func getKuCoinFuturesWebSocketToken(completion: @escaping @Sendable (String?) -> Void) {
    let url = URL(string: "https://api-futures.kucoin.com/api/v1/bullet-public")!
    var request = URLRequest(url: url)
    request.httpMethod = "POST"
    request.addValue("application/json", forHTTPHeaderField: "Content-Type")
    
    URLSession.shared.dataTask(with: request) { (data: Data?, response: URLResponse?, error: Error?) -> Void in
        guard let data = data else {
            print("âŒ Failed to get KuCoin Futures WebSocket token - no data received")
            completion(nil)
            return
        }
        
        do {
            let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
            guard let json = json,
                  let dataDict = json["data"] as? [String: Any],
                  let token = dataDict["token"] as? String else {
                print("âŒ Failed to parse KuCoin Futures WebSocket token response")
                completion(nil)
                return
            }
            completion(token)
        } catch {
            print("âŒ Failed to parse KuCoin Futures WebSocket token response: \(error.localizedDescription)")
            completion(nil)
        }
    }.resume()
}
// Enhanced Dashboard Data Update Function
@MainActor
static func updateDashboardData() {
// Update last data update timestamps
for pair in tradingPairs {
lastDataUpdate[pair] = Date()
}
// Calculate metrics
let totalKucoinBalance = kucoinBalances.values.reduce(0, +)
let totalBybitBalance = bybitBalances.values.reduce(0, +)
let totalPortfolio = totalKucoinBalance + totalBybitBalance

let totalTrades = performanceMetrics.values.reduce(0) { $0 + $1.trades }
let totalProfit = performanceMetrics.values.reduce(0.0) { $0 + $1.profit }
let totalFees = performanceMetrics.values.reduce(0.0) { $0 + $1.fees }
let netProfit = totalProfit - totalFees

// Enhanced dashboard output with spot prices
let timestamp = ISO8601DateFormatter().string(from: Date())
print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
print("ðŸ“Š BEVAIXBOT DASHBOARD UPDATE [\(timestamp)]")
print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
print("ðŸ’° BALANCES:")
print("   KuCoin: $\(String(format: "%.2f", kucoinBalance))")
print("   Bybit:  $\(String(format: "%.2f", bybitBalance))")
print("   Total:  $\(String(format: "%.2f", totalPortfolio))")
print("")

// Show SPOT prices prominently
print("ðŸ’± SPOT PRICES (Live):")
var spotPricesShown = 0
for pair in tradingPairs.prefix(6) {
    let kPrice = kucoinCurrentPrice[pair] ?? 0.0
    let bPrice = bybitCurrentPrice[pair] ?? 0.0
    if kPrice > 0 || bPrice > 0 {
        let kPriceStr = kPrice > 0 ? String(format: "%.6f", kPrice) : "offline"
        let bPriceStr = bPrice > 0 ? String(format: "%.6f", bPrice) : "offline"
        print("   \(pair): KuCoin=$\(kPriceStr) | Bybit=$\(bPriceStr)")
        spotPricesShown += 1
    }
}

if spotPricesShown == 0 {
    print("   âš ï¸  No spot prices available yet")
}
print("")

// Show FUTURES prices
print("ðŸ“ˆ FUTURES PRICES:")
for pair in tradingPairs.prefix(3) {
    let kPrice = kucoinCurrentFuturesPrice[pair] ?? 0.0
    let bPrice = bybitCurrentFuturesPrice[pair] ?? 0.0
    if kPrice > 0 || bPrice > 0 {
        let kPriceStr = kPrice > 0 ? String(format: "%.6f", kPrice) : "offline"
        let bPriceStr = bPrice > 0 ? String(format: "%.6f", bPrice) : "offline"
        print("   \(pair): KuCoin=$\(kPriceStr) | Bybit=$\(bPriceStr)")
    }
}
print("")

// Show arbitrage opportunities
if !arbitrageOpportunities.isEmpty {
    print("ðŸ”¥ ARBITRAGE OPPORTUNITIES (\(arbitrageOpportunities.count)):")
    for (pair, spread) in arbitrageOpportunities.prefix(5) {
        print("   \(pair): \(String(format: "%.4f%%", spread * 100)) spread")
    }
    print("")
}

// Show connection status
print("ðŸ”— CONNECTION STATUS:")
print("   KuCoin Spot:    \(kucoinIsConnected ? "âœ… Connected" : "âŒ Disconnected")")
print("   KuCoin Futures: \(kucoinFuturesIsConnected ? "âœ… Connected" : "âŒ Disconnected")")
print("   Bybit Spot:     \(bybitIsConnected ? "âœ… Connected" : "âŒ Disconnected")")
print("   Bybit Futures:  \(bybitFuturesIsConnected ? "âœ… Connected" : "âŒ Disconnected")")
print("")

print("ðŸ“Š TRADING STATS:")
print("   Total Trades: \(totalTrades)")
print("   Total Profit: $\(String(format: "%.2f", netProfit))")
print("   Total Fees:   $\(String(format: "%.2f", totalFees))")
print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")

// Log summary periodically
let now = Date()
if now.timeIntervalSince(lastSummaryTime) > 300 { // Every 5 minutes
    lastSummaryTime = now
    let summaryMsg = """
    ðŸ“Š Portfolio Summary: Total=$\(String(format: "%.2f", totalPortfolio)), KuCoin=$\(String(format: "%.2f", totalKucoinBalance)), Bybit=$\(String(format: "%.2f", totalBybitBalance)), Trades=\(totalTrades), Profit=$\(String(format: "%.2f", netProfit))
    """
    logAlert(event: summaryMsg)
}
}
// ENHANCED: Trigger Cross-Exchange Arbitrage Check
@MainActor
static func triggerCrossExchangeArbitrageCheck(pair: String) {
guard let kucoinSpotPrice = kucoinCurrentPrice[pair],
let bybitSpotPrice = bybitCurrentPrice[pair],
kucoinSpotPrice > 0, bybitSpotPrice > 0 else {
return
}
let spread = abs(kucoinSpotPrice - bybitSpotPrice) / min(kucoinSpotPrice, bybitSpotPrice)
let minSpread = crossExchangeMinSpreadThreshold

if spread > minSpread {
    let direction = kucoinSpotPrice > bybitSpotPrice ? "KuCoinâ†’Bybit" : "Bybitâ†’KuCoin"
    print("ðŸ”¥ ARBITRAGE OPPORTUNITY: \(pair) - \(direction) - Spread: \(String(format: "%.4f%%", spread * 100))")
    logAlert(event: "ðŸ”¥ ARBITRAGE OPPORTUNITY: \(pair) - \(direction) - Spread: \(String(format: "%.4f%%", spread * 100))")
    
    // Store arbitrage opportunity
    arbitrageOpportunities[pair] = spread
    
    // Update dashboard to show opportunity
    updateDashboardData()
}
}
// ADDED: Arbitrage Opportunity Detection and Logging
@MainActor
static func checkAndLogArbitrageOpportunity(pair: String) {
guard let kucoinPrice = kucoinCurrentPrice[pair],
let bybitPrice = bybitCurrentPrice[pair],
kucoinPrice > 0, bybitPrice > 0 else {
return
}
let spread = abs(kucoinPrice - bybitPrice) / min(kucoinPrice, bybitPrice)
let spreadPercent = spread * 100
let isOpportunity = spread > crossExchangeMinSpreadThreshold

// Log all spreads to CSV for analysis
logSpreadToCSV(pair: pair, kucoinPrice: kucoinPrice, bybitPrice: bybitPrice,
               spreadPercent: spreadPercent, isOpportunity: isOpportunity)

if isOpportunity {
    let direction = kucoinPrice > bybitPrice ? "KuCoinâ†’Bybit" : "Bybitâ†’KuCoin"
    let alertMessage = "ðŸ”¥ ARBITRAGE OPPORTUNITY: \(pair) - \(direction) - Spread: \(String(format: "%.4f%%", spreadPercent))"
    
    print(alertMessage)
    logAlert(event: alertMessage)
    
    // Store opportunity
    arbitrageOpportunities[pair] = spread
    
    // Log potential trade
    logTradeToCSV(pair: pair, exchange: "cross", action: "arbitrage_detected",
                 price: (kucoinPrice + bybitPrice) / 2, amount: crossExchangeTradeAmount,
                 profit: 0, fee: 0, strategy: "cross_exchange_arbitrage")
}
}
// ADDED: Enhanced WebSocket Activity Logging
@MainActor
static var lastWebsocketActivity: [String: Date] = [:]
static func logWebSocketActivity(exchange: String, pair: String, messageType: String) {
let key = "(exchange)-(pair)"
lastWebsocketActivity[key] = Date()
// Log significant events
if messageType == "price_update" {
    print("ðŸ“¡ \(exchange.uppercased()) \(pair): Price update received")
} else if messageType == "connection" {
    logAlert(event: "âœ… \(exchange.uppercased()) WebSocket connected for \(pair)")
} else if messageType == "disconnection" {
    logAlert(event: "âŒ \(exchange.uppercased()) WebSocket disconnected for \(pair)")
}
}
}

