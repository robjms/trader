//--------------------------------------------------------------------------------------------------------------------------Block 12 - Trading Loop Monitoring and Support

import Foundation // Added for String.Encoding and other Foundation types

extension ExchangeWebSocket {
    static var totalProfit: Double = 0.0
    static var totalFees: Double = 0.0
    static var kellyCreditRatio: Double = getDouble("KELLY_CREDIT_RATIO", defaultValue: 2.0)

    static func checkLiquidityAsyncUnique(exchange: String, pair: String, marketType: String, tradeAmount: Double, price: Double) async -> Double? {
        let minLiquidity = getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 500.0)
        let requiredLiquidity = tradeAmount * price * liquidityDepthMultiplier

        do {
            let depth = try await fetchOrderBookDepth(for: exchange, pair: pair, marketType: marketType, retryCount: 0)
            guard let unwrappedDepth = depth, unwrappedDepth >= max(minLiquidity, requiredLiquidity) else {
                print("üìù DEBUG: Insufficient liquidity for \(exchange)-\(pair)-\(marketType): Depth \(String(describing: depth)), Required \(requiredLiquidity)")
                await MainActor.run(body: {
                    logAlert(event: "Insufficient liquidity for \(exchange)-\(pair)-\(marketType): Depth \(String(describing: depth))")
                })
                return nil
            }
            print("DEBUG: Liquidity check passed for \(exchange)-\(pair)-\(marketType): Depth \(unwrappedDepth)")
            return unwrappedDepth
        } catch {
            print("DEBUG: Error fetching order book depth for \(exchange)-\(pair)-\(marketType): \(error.localizedDescription)")
            await MainActor.run(body: {
                logAlert(event: "Error fetching order book depth for \(exchange)-\(pair)-\(marketType): \(error.localizedDescription)")
            })
            return nil
        }
    }

    // REMOVED: fetchOrderBookDepth(for exchange: String, pair: String, marketType: String, retryCount: Int = 0) async throws -> Double?
    // This was the duplicate function that was causing conflicts

    private static func fetchAndLogBalances(isInitial: Bool = false, completion: @escaping @Sendable () -> Void) {
        fetchKucoinBalance { _ in
            Task { @MainActor in
                fetchBybitBalance { _ in
                    Task { @MainActor in
                        if isInitial {
                            print("üíµ Initial Balances: KuCoin: \(ExchangeWebSocket.kucoinBalance) | Bybit: \(ExchangeWebSocket.bybitBalance)")
                        }
                        completion()
                    }
                }
            }
        }
    }

    static func dynamicTradeAmount(balance: Double, riskPercent: Double, volatility: Double, pair: String = tradingPairs.first ?? "BTC-USDT") async -> Double {
        let kellyFraction = await calculateKellyCriterion(pair: pair)
        let baseAmount = min(balance * riskPercent, balance * 0.6)
        let volatilityAdjusted = baseAmount * (1.0 / (1.0 + volatility * 0.3))
        let kellyAmount = balance * max(0.0, min(kellyFraction, 0.6))
        return min(volatilityAdjusted, kellyAmount)
    }

    static func rebalanceExchanges() {
        let balanceDifferenceThreshold = 0.08
        let totalBalance = kucoinBalance + bybitBalance
        
        guard totalBalance > 0 else { return }
        
        let kucoinBalanceRatio = kucoinBalance / totalBalance
        let bybitBalanceRatio = bybitBalance / totalBalance
        
        if abs(kucoinBalanceRatio - bybitBalanceRatio) > balanceDifferenceThreshold {
            let targetBalance = totalBalance / 2
            let transferAmount = abs(kucoinBalance - targetBalance)
            
            if kucoinBalance > bybitBalance {
                ExchangeWebSocket.kucoinBalance -= transferAmount
                ExchangeWebSocket.bybitBalance += transferAmount
            } else {
                ExchangeWebSocket.bybitBalance -= transferAmount
                ExchangeWebSocket.kucoinBalance += transferAmount
            }
        }
    }

    static func fetchExchangeFees(exchange: String, completion: @escaping @Sendable (Double?, Double?) -> Void) {
        if exchange == "kucoin" {
            completion(0.0001, 0.0004)
        } else if exchange == "bybit" {
            completion(0.0001, 0.0004)
        } else {
            completion(nil, nil)
        }
    }

    static func printPeriodicSummary() {
        print("üìä Performance Summary:")
        print("üìä Total Profit: \(totalProfit), Total Fees: \(totalFees)")
        for (pair, metrics) in tradeMetrics {
            print("\(pair): Wins: \(metrics.wins), Losses: \(metrics.losses), Profit: \(metrics.totalProfit), Fees: \(metrics.totalFees)")
        }
    }

    static func executeHFTTrade(exchange: String, pair: String, side: String, price: Double, amount: Double) {
        print("üí∏ Trade: \(side) \(amount) of \(pair) on \(exchange) at \(price)")
        let fee = amount * price * (exchange == "kucoin" ? kucoinTakerFee : bybitTakerFee)
        totalFees += fee
        if exchange == "kucoin" {
            kucoinBalance -= side == "buy" ? (amount * price + fee) : -fee
            kucoinPositions[pair] = (kucoinPositions[pair] ?? 0.0) + (side == "buy" ? amount : -amount)
        } else {
            bybitBalance -= side == "buy" ? (amount * price + fee) : -fee
            bybitPositions[pair] = (bybitPositions[pair] ?? 0.0) + (side == "buy" ? amount : -amount)
        }
    }

    static func connectWebSocket(exchange: String, pair: String, marketType: String) {
        print("üì° Connecting WebSocket for \(exchange), pair: \(pair), marketType: \(marketType)")
    }

    static func checkCircuitBreaker(pair: String) {
        let prices = ExchangeWebSocket.kucoinPrices[pair] ?? []
        guard prices.count >= 60 else { return }
        let recentPrices = prices.suffix(60)
        let volatility = (recentPrices.max()! - recentPrices.min()!) / Double(recentPrices.count)
        if volatility > ExchangeWebSocket.volatilitySpikeThreshold {
            isTradingPaused[pair] = true
            lastVolatilityPause = Date()
            print("‚öñÔ∏è Circuit breaker triggered for \(pair): Volatility: \(String(format: "%.4f", volatility))")
            Task { @MainActor in
                logAlert(event: "Circuit breaker triggered for \(pair): Volatility: \(String(format: "%.4f", volatility))")
            }
        }
    }

    static func marketMaker(pair: String, exchange: String) {
        let spread = getDouble("MARKET_MAKING_SPREAD", defaultValue: 0.001)
        let price = exchange == "kucoin" ? kucoinCurrentPrice[pair] ?? 0.0 : bybitCurrentPrice[pair] ?? 0.0
        print("üìà Market-making for \(pair) on \(exchange): Bid: \(String(format: "%.4f", price * (1 - spread))), Ask: \(String(format: "%.4f", price * (1 + spread)))")
    }

    static func executeScalpingTrade(pair: String, exchange: String, entryPrice: Double, targetPrice: Double, stopPrice: Double, tradeAmount: Double, maxActiveTrades: Int) async -> Bool {
        let trailingProfitPercent = getDouble("TRAILING_PROFIT_PERCENT", defaultValue: 0.03)
        let feeRate = exchange == "kucoin" ? kucoinTakerFee : bybitTakerFee
        let quantity = tradeAmount / entryPrice
        var highestPrice = entryPrice
        var trailingTargetPrice = entryPrice * (1 + trailingProfitPercent)
        var exitPrice: Double = 0.0
        let startTime = Date()
        let dashboardJSONURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/dashboard.json")

        // Copy balance to avoid inout capture
        var localKucoinBalance = kucoinBalance
        var localBybitBalance = bybitBalance

        while Date().timeIntervalSince(startTime) < 60 {
            if let currentPrice = await MainActor.run(body: { exchange == "bybit" ? bybitCurrentPrice[pair] : kucoinCurrentPrice[pair] }) {
                if currentPrice > highestPrice {
                    highestPrice = currentPrice
                    trailingTargetPrice = highestPrice * (1 - trailingProfitPercent)
                }
                if currentPrice >= targetPrice || currentPrice <= stopPrice || currentPrice <= trailingTargetPrice {
                    exitPrice = currentPrice
                    break
                }
            }
            try? await Task.sleep(nanoseconds: 1_00_000_000) // 100ms
        }

        if exitPrice == 0.0 {
            exitPrice = await MainActor.run { exchange == "bybit" ? bybitCurrentPrice[pair] : kucoinCurrentPrice[pair] } ?? entryPrice
        }

        let profit = quantity * (exitPrice - entryPrice)
        let fees = tradeAmount * feeRate * 2
        if exchange == "kucoin" {
            localKucoinBalance += profit - fees
        } else {
            localBybitBalance += profit - fees
        }
        print("üìä Scalping trade for \(pair) on \(exchange): Profit: \(profit), Fees: \(fees)")
        await MainActor.run {
            // Update global balances after Task
            if exchange == "kucoin" {
                kucoinBalance = localKucoinBalance
            } else {
                bybitBalance = localBybitBalance
            }
            updateTradeMetrics(
                pair: pair,
                profit: profit,
                fees: fees,
                isWin: profit > 0,
                dashboardJSONURL: dashboardJSONURL,
                totalProfit: &ExchangeWebSocket.totalProfit,
                totalFees: &ExchangeWebSocket.totalFees
            )
            logTradeToCSV(
                pair: pair,
                strategy: "HFT Scalping",
                profit: profit,
                fees: fees,
                tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trade_log.csv")
            )
            sendTradeToFlaskServer(strategy: "HFT Scalping", pair: pair, exchange: exchange, spotPrice: 0.0, futuresPrice: 0.0, tradeAmount: 0.0, profit: profit)
        }
        return profit > 0
    }

    static func executeFuturesTrade(pair: String, exchange: String, entryPrice: Double, targetPrice: Double, stopPrice: Double, tradeAmount: Double) {
        let feeRate = exchange == "bybit" ? bybitTakerFee : kucoinTakerFee
        let quantity = tradeAmount / entryPrice
        let leverage = exchange == "bybit" ? getDouble("BYBIT_LEVERAGE", defaultValue: 3.0) : getDouble("KUCOIN_LEVERAGE", defaultValue: 3.0)
        let effectiveTradeAmount = tradeAmount * leverage
        var exitPrice: Double = 0.0
        let startTime = Date()
        let dashboardJSONURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/dashboard.json")
        
        // Copy balance to avoid inout capture
        var localKucoinBalance = kucoinBalance
        var localBybitBalance = bybitBalance

        while Date().timeIntervalSince(startTime) < 60 {
            if let price = (exchange == "bybit" ? bybitCurrentFuturesPrice[pair] : kucoinCurrentFuturesPrice[pair]) {
                if price >= targetPrice || price <= stopPrice {
                    exitPrice = price
                    break
                }
            }
            Thread.sleep(forTimeInterval: 0.1)
        }
        
        if exitPrice == 0.0 {
            exitPrice = (exchange == "bybit" ? bybitCurrentFuturesPrice[pair] : kucoinCurrentFuturesPrice[pair]) ?? entryPrice
        }
        
        let grossProfit = (exitPrice - entryPrice) * quantity * leverage
        let fees = effectiveTradeAmount * feeRate * 2
        let profit = grossProfit - fees
        
        if exchange == "bybit" {
            localBybitBalance += profit
        } else {
            localKucoinBalance += profit
        }
        print("üìä Futures trade for \(pair) on \(exchange): Profit: \(profit), Fees: \(fees)")
        Task { @MainActor in
            // Update global balances after Task
            if exchange == "bybit" {
                bybitBalance = localBybitBalance
            } else {
                kucoinBalance = localKucoinBalance
            }
            updateTradeMetrics(
                pair: pair,
                profit: profit,
                fees: fees,
                isWin: profit > 0,
                dashboardJSONURL: dashboardJSONURL,
                totalProfit: &ExchangeWebSocket.totalProfit,
                totalFees: &ExchangeWebSocket.totalFees
            )
            logTradeToCSV(
                pair: pair,
                strategy: "Funding Rate Momentum",
                profit: profit,
                fees: fees,
                tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trade_log.csv")
            )
            sendTradeToFlaskServer(strategy: "Funding Rate Momentum", pair: pair, exchange: exchange, spotPrice: 0.0, futuresPrice: 0.0, tradeAmount: 0.0, profit: profit)
        }
    }

    static func updateDashboardJSON(dashboardJSONURL: URL, totalProfit: Double, totalFees: Double) {
        Task { @MainActor in
            let timestamp = ISO8601DateFormatter().string(from: Date())
            do {
                let fileManager = FileManager.default
                let directoryURL = dashboardJSONURL.deletingLastPathComponent()
                if !fileManager.fileExists(atPath: directoryURL.path) {
                    try fileManager.createDirectory(at: directoryURL, withIntermediateDirectories: true, attributes: nil)
                }
                var perPairMetrics: [[String: Any]] = []
                for pair in tradingPairs {
                    let metrics = tradeMetrics[pair] ?? (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)
                    let trades = metrics.wins + metrics.losses
                    let winRate = trades > 0 ? Double(metrics.wins) / Double(trades) * 100.0 : 0.0
                    let sentiment = sentimentScores[pair] ?? 0.0
                    let pairData: [String: Any] = [
                        "pair": pair,
                        "trades": trades,
                        "wins": metrics.wins,
                        "losses": metrics.losses,
                        "winRate": winRate,
                        "profit": metrics.totalProfit,
                        "fees": metrics.totalFees,
                        "sentiment": sentiment
                    ]
                    perPairMetrics.append(pairData)
                }
                
                let dashboardData: [String: Any] = [
                    "timestamp": timestamp,
                    "totalProfit": totalProfit,
                    "totalFees": totalFees,
                    "totalTrades": tradeMetrics.values.reduce(0) { $0 + $1.wins + $1.losses },
                    "kucoinBalance": kucoinBalance,
                    "bybitBalance": bybitBalance,
                    "perPairMetrics": perPairMetrics,
                    "livePrices": tradingPairs.map { pair in
                        [
                            "pair": pair,
                            "kucoinSpot": kucoinCurrentPrice[pair] ?? 0.0,
                            "kucoinFutures": kucoinCurrentFuturesPrice[pair] ?? 0.0,
                            "bybitSpot": bybitCurrentPrice[pair] ?? 0.0,
                            "bybitFutures": bybitCurrentFuturesPrice[pair] ?? 0.0
                        ]
                    }
                ]
                
                let jsonData = try JSONSerialization.data(withJSONObject: dashboardData, options: [.prettyPrinted])
                try jsonData.write(to: dashboardJSONURL, options: .atomic)
                print("üìà Updated dashboard JSON at \(dashboardJSONURL.path)")
            } catch {
                print("‚ö†Ô∏è Failed to update dashboard JSON: \(error.localizedDescription)")
                logAlert(event: "Failed to update dashboard JSON: \(error.localizedDescription)")
            }
        }
    }

    static func calculateKellyCriterion(pair: String) async -> Double {
        // Use empirical win probability from tradeMetrics, fallback to default
        let metrics = tradeMetrics[pair] ?? (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)
        let totalTrades = metrics.wins + metrics.losses
        let winProbability = totalTrades > 0 ? Double(metrics.wins) / Double(totalTrades) : kellyWinProbability
        
        // Adjust reward-to-risk based on ATR for volatility
        let atr = kucoinFuturesATR[pair] ?? 0.01
        let currentPrice = kucoinCurrentPrice[pair] ?? 1.0
        let volatilityAdjustment = atr / currentPrice
        let rewardToRisk = kellyRewardToRisk * (1 + volatilityAdjustment * 0.5) // Scale by volatility
        
        // Calculate Kelly fraction
        let kelly = (winProbability * (rewardToRisk + 1) - 1) / rewardToRisk
        
        // Apply bounds and validation
        guard rewardToRisk > 0 else {
            Task { @MainActor in
                logAlert(event: "üü° Invalid reward-to-risk ratio for \(pair): \(rewardToRisk)")
            }
            return 0.01 // Minimum safe fraction
        }
        
        // Clamp between 0.01 and 0.5 for safety
        let clampedKelly = max(min(kelly, 0.5), 0.01)
        
        // Store in kellySizes for pair-specific sizing
        await MainActor.run {
            kellySizes[pair] = clampedKelly
            logAlert(event: "üü° Calculated Kelly fraction for \(pair): \(clampedKelly), p=\(winProbability), r=\(rewardToRisk)")
        }
        
        return clampedKelly
    }

    static func calculateOrderBookVWAP(pair: String, exchange: String, priceRange: Double, currentPrice: Double) -> Double? {
        let orderBook = exchange == "kucoin" ? kucoinOrderBooks[pair] : bybitOrderBooks[pair]
        guard let book = orderBook, !book.bids.isEmpty, !book.asks.isEmpty else {
            print("DEBUG: Order book unavailable for \(pair) on \(exchange)")
            Task { @MainActor in
                logAlert(event: "Order book unavailable for \(pair) on \(exchange)")
            }
            return nil
        }

        let minPrice = currentPrice * (1 - priceRange)
        let maxPrice = currentPrice * (1 + priceRange)

        var totalVolume: Double = 0.0
        var totalPriceVolume: Double = 0.0

        for bid in book.bids {
            if bid.price >= minPrice && bid.price <= maxPrice {
                totalPriceVolume += bid.price * bid.quantity
                totalVolume += bid.quantity
            }
        }

        for ask in book.asks {
            if ask.price >= minPrice && ask.price <= maxPrice {
                totalPriceVolume += ask.price * ask.quantity
                totalVolume += ask.quantity
            }
        }

        guard totalVolume > 0 else {
            print("DEBUG: Zero total volume in VWAP calculation for \(pair) on \(exchange)")
            Task { @MainActor in
                logAlert(event: "Zero total volume in VWAP calculation for \(pair) on \(exchange)")
            }
            return nil
        }

        let vwap = totalPriceVolume / totalVolume
        print("DEBUG: Calculated VWAP for \(pair) on \(exchange): \(vwap)")
        return vwap
    }

    static func checkDailyLossLimit(exchange: String, pair: String, potentialLoss: Double) async -> Bool {
        let dailyLossLimit = getDouble("DAILY_LOSS_LIMIT", defaultValue: 100.0)
        let currentLoss = await MainActor.run { dailyLoss[exchange] ?? 0.0 }
        let newTotalLoss = currentLoss + potentialLoss
        let exceedsLimit = newTotalLoss > dailyLossLimit
        
        if exceedsLimit {
            print("DEBUG: Daily loss limit exceeded for \(exchange)-\(pair): Current \(currentLoss), Potential \(potentialLoss), Limit \(dailyLossLimit)")
            await MainActor.run {
                logAlert(event: "Daily loss limit exceeded for \(exchange)-\(pair): Current \(currentLoss), Potential \(potentialLoss)")
            }
        }
        return !exceedsLimit
    }

    // ===== ADDED: NEW FUNCTIONS FROM FIXES =====
    
    static func fetchCurrentPrices() async {
        for pair in tradingPairs {
            if let kucoinPrice = await fetchKuCoinPrice(pair: pair) {
                await MainActor.run {
                    kucoinCurrentPrice[pair] = kucoinPrice
                    updatePrice(pair: pair, exchange: "kucoin", price: kucoinPrice)
                }
            }
            
            if let bybitPrice = await fetchBybitPrice(pair: pair) {
                await MainActor.run {
                    bybitCurrentPrice[pair] = bybitPrice
                    updatePrice(pair: pair, exchange: "bybit", price: bybitPrice)
                }
            }
            
            try? await Task.sleep(nanoseconds: 100_000_000)
        }
    }

    static func fetchKuCoinPrice(pair: String) async -> Double? {
        let symbol = pair
        guard let url = URL(string: "https://api.kucoin.com/api/v1/market/orderbook/level1?symbol=\(symbol)") else {
            return nil
        }
        
        do {
            let (data, response) = try await URLSession.shared.data(from: url)
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                return nil
            }
            
            guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let dataDict = json["data"] as? [String: Any],
                  let priceString = dataDict["price"] as? String,
                  let price = Double(priceString) else {
                return nil
            }
            
            return price
        } catch {
            return nil
        }
    }

    static func fetchBybitPrice(pair: String) async -> Double? {
        let symbol = pair.replacingOccurrences(of: "-", with: "")
        guard let url = URL(string: "https://api.bybit.com/v5/market/tickers?category=spot&symbol=\(symbol)") else {
            return nil
        }
        
        do {
            let (data, response) = try await URLSession.shared.data(from: url)
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                return nil
            }
            
            guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let result = json["result"] as? [String: Any],
                  let list = result["list"] as? [[String: Any]],
                  let firstTicker = list.first,
                  let priceString = firstTicker["lastPrice"] as? String,
                  let price = Double(priceString) else {
                return nil
            }
            
            return price
        } catch {
            return nil
        }
    }

    static func runComprehensiveDiagnostic() async {
        await MainActor.run {
            print("\nüîç ===== BEVAIXBOT COMPREHENSIVE DIAGNOSTIC =====")
            logAlert(event: "üîç Starting comprehensive diagnostic")
        }
        
        await diagnoseEnvironment()
        await diagnoseAPIConnectivity()
        await diagnosePriceData()
        await diagnoseTradingLogic()
        
        await MainActor.run {
            print("üîç ===== DIAGNOSTIC COMPLETE =====\n")
            logAlert(event: "üîç Comprehensive diagnostic complete")
        }
    }
    
    static func diagnoseEnvironment() async {
        await MainActor.run {
            print("\nüîß Environment Diagnostic:")
            let workingDir = FileManager.default.currentDirectoryPath
            print("Working Directory: \(workingDir)")
            
            let envPath = URL(fileURLWithPath: workingDir).appendingPathComponent(".env").path
            let envExists = FileManager.default.fileExists(atPath: envPath)
            print("‚úÖ .env file exists: \(envExists ? "YES" : "‚ùå NO")")
            
            let criticalKeys = ["KUCOIN_API_KEY", "BYBIT_API_KEY", "ACTIVE_PAIRS", "SIMULATION_TRADE_LOGGING"]
            for key in criticalKeys {
                let value = environment[key] ?? "NOT_FOUND"
                let status = value == "NOT_FOUND" ? "‚ùå" : "‚úÖ"
                let displayValue = key.contains("KEY") ? 
                    (value == "NOT_FOUND" ? value : "\(value.prefix(8))...") : value
                print("\(status) \(key): \(displayValue)")
            }
            
            print("‚úÖ Trading Pairs: \(tradingPairs.count) pairs loaded")
            print("Pairs: \(tradingPairs.joined(separator: ", "))")
            
            logAlert(event: "Environment diagnostic complete - \(tradingPairs.count) pairs, env exists: \(envExists)")
        }
    }
    
    static func startRealTimeMonitoring() {
        Task {
            while tradingActive {
                await logRealTimeMetrics()
                try? await Task.sleep(nanoseconds: 30_000_000_000)
            }
        }
    }
    
    static func logRealTimeMetrics() async {
        await MainActor.run {
            let totalTrades = performanceMetrics.values.reduce(0) { $0 + $1.trades }
            let totalProfit = performanceMetrics.values.reduce(0.0) { $0 + $1.profit }
            let avgLatency = lastLatency.values.reduce(0.0, +) / Double(max(lastLatency.count, 1))
            
            let metrics = """
            üìä REAL-TIME METRICS:
            Trades: \(totalTrades) | Profit: $\(String(format: "%.4f", totalProfit)) | 
            Balances: KuCoin $\(String(format: "%.2f", kucoinBalance)), Bybit $\(String(format: "%.2f", bybitBalance)) | 
            Avg Latency: \(String(format: "%.0f", avgLatency))ms
            """
            
            print(metrics)
            logAlert(event: metrics)
        }
    }
}
