// --------------------------------------------------------- Block 1 - Core Data Structures and Utilities
//--------------- Block 1 - Core Data Structures and Utilities
// VARIABLES TO ADD: Add isEmpty property to BevaixOrderBook struct

@preconcurrency import Starscream
import Foundation
import SwiftDotenv
import CryptoKit

// BevaixOrderBook struct definition to avoid conflicts
struct BevaixOrderBook {
    var bids: [(price: Double, quantity: Double)]
    var asks: [(price: Double, quantity: Double)]
    
    // FIX: Add isEmpty property to resolve compilation errors in other blocks
    var isEmpty: Bool {
        return bids.isEmpty && asks.isEmpty
    }
}

// Enhanced Structures for Advanced Trading
struct AdvancedSignal {
    let type: String
    let strength: Double
    let confidence: Double
    let timestamp: Date
    let pair: String
    let exchange: String
}

struct MLPrediction {
    let prediction: Double
    let confidence: Double
    let features: [String: Double]
    let timestamp: Date
    let model: String
}

struct PerformanceMetrics {
    var totalTrades: Int
    var winningTrades: Int
    var totalProfit: Double
    var totalFees: Double
    var averageLatency: Double
    var maxDrawdown: Double
    var sharpeRatio: Double
    var lastTradeTime: Date
}

struct RiskMetrics {
    var var95: Double // Value at Risk 95%
    var var99: Double // Value at Risk 99%
    var expectedShortfall: Double
    var maxDrawdown: Double
    var volatility: Double
    var correlation: Double
    var beta: Double
}

struct MarketCondition {
    let volatility: Double
    let trend: String
    let volume: Double
    let momentum: Double
    let timestamp: Date
}

struct TradingOpportunity {
    let pair: String
    let strategy: String
    let expectedProfit: Double
    let riskLevel: Double
    let confidence: Double
    let timeHorizon: TimeInterval
}

// Global Helper Methods for Type Conversion
func getDouble(_ key: String, defaultValue: Double) -> Double {
    guard let value = ProcessInfo.processInfo.environment[key], !value.isEmpty else {
        print("Environment variable \(key) not found or empty")
        return defaultValue
    }
    let cleanedValue = value.components(separatedBy: "#")[0].trimmingCharacters(in: .whitespaces)
    if let doubleValue = Double(cleanedValue) {
        return doubleValue
    } else {
        print("Could not parse \(key) as Double: \(cleanedValue)")
        return defaultValue
    }
}

func getInt(_ key: String, defaultValue: Int) -> Int {
    guard let value = ProcessInfo.processInfo.environment[key], !value.isEmpty else {
        print("Environment variable \(key) not found or empty")
        return defaultValue
    }
    let cleanedValue = value.components(separatedBy: "#")[0].trimmingCharacters(in: .whitespaces)
    if let intValue = Int(cleanedValue) {
        return intValue
    } else {
        print("Could not parse \(key) as Int: \(cleanedValue)")
        return defaultValue
    }
}

func getBool(_ key: String, defaultValue: Bool) async -> Bool {
    guard let stringValue = ProcessInfo.processInfo.environment[key] else {
        print("Warning: Could not parse \(key) as Bool, using default: \(defaultValue)")
        await MainActor.run {
            logAlert(event: "Could not parse \(key) as Bool, using default: \(defaultValue)")
        }
        return defaultValue
    }
    let cleanedValue = stringValue.components(separatedBy: "#")[0].trimmingCharacters(in: .whitespaces).lowercased()
    if cleanedValue == "true" || cleanedValue == "1" || cleanedValue == "yes" {
        return true
    } else if cleanedValue == "false" || cleanedValue == "0" || cleanedValue == "no" {
        return false
    } else {
        print("Warning: Could not parse \(key) as Bool: \(cleanedValue), using default: \(defaultValue)")
        await MainActor.run {
            logAlert(event: "Could not parse \(key) as Bool: \(cleanedValue), using default: \(defaultValue)")
        }
        return defaultValue
    }
}

func getString(_ key: String, defaultValue: String) -> String {
    guard let value = ProcessInfo.processInfo.environment[key], !value.isEmpty else {
        print("Environment variable \(key) not found or empty")
        return defaultValue
    }
    return value.components(separatedBy: "#")[0].trimmingCharacters(in: .whitespaces)
}

// Global Environment Variable Storage
var hasValidKuCoinCredentials: Bool = true // New flag to track KuCoin credential validity
var environment: [String: String] = {
    do {
        let fileManager = FileManager.default
        let currentDirectory = fileManager.currentDirectoryPath
        let envPath = URL(fileURLWithPath: currentDirectory).appendingPathComponent(".env").path
        print("Loading .env from \(envPath)")
        if fileManager.fileExists(atPath: envPath) {
            print("Found .env file at \(envPath)")
        } else {
            print("No .env file found at \(envPath)")
            Task { @MainActor in
                logAlert(event: "No .env file found at \(envPath)")
            }
        }
        
        try Dotenv.configure()
        var envDict: [String: String] = [:]
        let keys = [
            "ACTIVE_PAIRS", "BYBIT_API_KEY", "BYBIT_API_SECRET", "KUCOIN_API_KEY",
            "KUCOIN_API_SECRET", "KUCOIN_API_PASSPHRASE", "BYBIT_RATE_WINDOW",
            "KUCOIN_LEVERAGE", "BYBIT_LEVERAGE", "LIQUIDITY_FEE_MULTIPLIER",
            "LIQUIDITY_PRICE_IMPACT_THRESHOLD", "ORDER_BOOK_PRICE_RANGE",
            "ORDER_BOOK_IMBALANCE_THRESHOLD", "MIN_LIQUIDITY_THRESHOLD",
            "MAX_ORDER_BOOK_IMBALANCE", "VOLATILITY_SPIKE_THRESHOLD",
            "VOLATILITY_SPIKE_WINDOW_MINUTES", "VOLATILITY_SPIKE_COOLDOWN_SECONDS",
            "VOLUME_ANOMALY_MULTIPLIER", "VOLUME_ANOMALY_WINDOW_HOURS",
            "VOLUME_ANOMALY_COOLDOWN_SECONDS", "FUTURES_TRADE_AMOUNT",
            "FUTURES_MIN_PROFIT_PERCENTAGE", "FUTURES_STOP_LOSS_PERCENTAGE",
            "FUTURES_TRAILING_STOP_PERCENTAGE", "FUTURES_SPIKE_RATE_STOP_PERCENTAGE",
            "MAX_ACTIVE_FUTURES_TRADES", "DAILY_LOSS_LIMIT_PERCENTAGE", "ATR_MULTIPLIER",
            "ARBITRAGE_MIN_BALANCE", "ARBITRAGE_TRADE_AMOUNT",
            "ARBITRAGE_MIN_SPREAD_THRESHOLD", "ARBITRAGE_HIGH_SPREAD_THRESHOLD",
            "CROSS_EXCHANGE_MIN_BALANCE", "CROSS_EXCHANGE_TRADE_AMOUNT",
            "CROSS_EXCHANGE_MIN_SPREAD_THRESHOLD",
            "CROSS_EXCHANGE_MIN_FUNDING_RATE_THRESHOLD",
            "CROSS_EXCHANGE_COOLDOWN_SECONDS", "VOLATILITY_PAUSE_SECONDS",
            "SPOT_TRADE_AMOUNT", "SPOT_FEE_RATE", "SPOT_MINUTE_PROFIT_PERCENTAGE",
            "SPOT_STOP_LOSS_PERCENTAGE", "SPOT_TRAILING_STOP_PERCENTAGE",
            "SPOT_EMA_SHORT_PERIOD", "SPOT_EMA_MEDIUM_PERIOD", "SPOT_EMA_LONG_PERIOD",
            "SPOT_RSI_PERIOD", "SPOT_RSI_UPPER_THRESHOLD", "SPOT_RSI_LOWER_THRESHOLD",
            "MAX_ACTIVE_SPOT_TRADES", "FUTURES_EMA_SHORT_PERIOD",
            "FUTURES_EMA_MEDIUM_PERIOD", "FUTURES_EMA_LONG_PERIOD",
            "BYBIT_FUTURES_FEE_RATE", "KUCOIN_FUTURES_FEE_RATE",
            "BYBIT_FALLBACK_BALANCE", "KUCOIN_FALLBACK_BALANCE",
            "PRICE_HISTORY_RETENTION", "WEBSOCKET_TIMEOUT_SECONDS",
            "BALANCE_FETCH_TIMEOUT", "MAX_FUNDING_RATE", "SCALP_ENTRY_THRESHOLD",
            "SCALP_PROFIT_TARGET", "SCALP_STOP_LOSS", "MACD_SHORT_PERIOD",
            "MACD_LONG_PERIOD", "MACD_SIGNAL_PERIOD", "MACD_CONFIRMATION_THRESHOLD",
            "MAX_SLIPPAGE", "LIQUIDITY_CHECK_INTERVAL", "MIN_ORDERBOOK_REFRESH_RATE",
            "SIMULATION_TRADE_LOGGING", "HFT_SPREAD_THRESHOLD", "HFT_TRADE_AMOUNT",
            "SPOOFING_VOLUME_THRESHOLD", "SPOOFING_PROFIT_TARGET",
            "SLIPPAGE_TRADE_AMOUNT", "FUNDING_MOMENTUM_THRESHOLD",
            "LATENCY_SPIKE_THRESHOLD", "HFT_COOLDOWN_SECONDS",
            "PRICE_REVERSAL_THRESHOLD", "PRICE_REVERSAL_WINDOW_MINUTES",
            "SLIPPAGE_DEPTH_THRESHOLD", "SLIPPAGE_PERCENTAGE",
            "ATR_FALLBACK_PERCENTAGE", "VOLUME_TRACKING_VALUE",
            "FUNDING_RATE_COST_MULTIPLIER", "TRADE_HOLD_DURATION_MINUTES",
            "MIN_PRICE_DATA_POINTS", "VOLUME_ANOMALY_THRESHOLD",
            "SPREAD_RETENTION_HOURS", "ORDER_BOOK_IMBALANCE_FALLBACK",
            "LIQUIDITY_CHECK_FALLBACK", "MARKET_MAKING_SPREAD", "HFT_ORDER_TYPE"
        ]
        for key in keys {
            if let value = Dotenv[key] {
                envDict[key] = value.stringValue
            }
        }
        // Validate KuCoin API credentials
        let requiredKuCoinKeys = ["KUCOIN_API_KEY", "KUCOIN_API_SECRET", "KUCOIN_API_PASSPHRASE"]
        var missingKeys = [String]()
        for key in requiredKuCoinKeys {
            if envDict[key] == nil || envDict[key]!.isEmpty {
                missingKeys.append(key)
            }
        }
        if !missingKeys.isEmpty {
            let missingMessage = "Missing or empty KuCoin API credentials: \(missingKeys.joined(separator: ", ")). Disabling KuCoin functionality."
            print("WARNING: \(missingMessage)")
            Task { @MainActor in
                logAlert(event: missingMessage)
            }
            hasValidKuCoinCredentials = false // Disable KuCoin operations
        }
        // Debug: Log all loaded environment variables
        print("DEBUG: Loaded environment variables: \(envDict)")
        print("Successfully loaded .env file using SwiftDotenv")
        print("SwiftDotenv version: \(Dotenv.version?.stringValue ?? "unknown")")
        print("DEBUG: ACTIVE_PAIRS from env: \(envDict["ACTIVE_PAIRS"] ?? "not found")")
        print("DEBUG: BYBIT_API_KEY from env: \(envDict["BYBIT_API_KEY"] ?? "not found")")
        print("DEBUG: KUCOIN_API_KEY from env: \(envDict["KUCOIN_API_KEY"] ?? "not found")")
        return envDict
    } catch {
        print("Failed to load .env file: \(error)")
        Task { @MainActor in
            logAlert(event: "Failed to load .env file: \(error)")
        }
        return [:] // Return empty dictionary to allow bot to continue
    }
}()

// Global Alert Logging Function
func logAlert(event: String, completion: @escaping @Sendable () -> Void = {}) {
    let alertsCSVURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/alerts.csv")
    Task {
        await MainActor.run {
            let timestamp = ISO8601DateFormatter().string(from: Date())
            let logEntry = "\(timestamp),\(event)\n"
            do {
                let fileManager = FileManager.default
                if !fileManager.fileExists(atPath: alertsCSVURL.path) {
                    try "timestamp,event\n".write(to: alertsCSVURL, atomically: true, encoding: .utf8)
                    try fileManager.setAttributes([.posixPermissions: 0o644], ofItemAtPath: alertsCSVURL.path)
                }
                if let fileHandle = try? FileHandle(forWritingTo: alertsCSVURL) {
                    defer { fileHandle.closeFile() }
                    if let data = logEntry.data(using: .utf8) {
                        fileHandle.seekToEndOfFile()
                        fileHandle.write(data)
                    }
                } else {
                    let fileHandle = try FileHandle(forWritingTo: alertsCSVURL)
                    defer { fileHandle.closeFile() }
                    if let data = logEntry.data(using: .utf8) {
                        fileHandle.seekToEndOfFile()
                        fileHandle.write(data)
                    }
                }
                print("DEBUG: Logged alert to alerts.csv: \(logEntry.trimmingCharacters(in: .whitespacesAndNewlines))")
            } catch {
                print("DEBUG: Failed to log alert to alerts.csv: \(error.localizedDescription)")
            }
            completion()
        }
    }
}

@MainActor
class ExchangeWebSocket {
    // Starscream WebSockets
    static var kucoinSocket: WebSocket?
    static var kucoinFuturesSocket: WebSocket?
    static var bybitSocket: WebSocket?
    static var bybitSpotSocket: WebSocket?
    
    static var tradeMetrics: [String: (wins: Int, losses: Int, totalProfit: Double, totalFees: Double)] = [:]
    
    // Connection States
    static var kucoinIsConnected: Bool = false
    static var kucoinFuturesIsConnected: Bool = false
    static var bybitIsConnected: Bool = false
    static var bybitFuturesIsConnected: Bool = false
    
    // WebSocket Tokens
    static var kucoinToken: String?
    static var kucoinFuturesToken: String?
    
    // WebSocket Reconnection Tracking
    static var kucoinReconnectAttempts: Int = 0
    static var kucoinFuturesReconnectAttempts: Int = 0
    static var bybitReconnectAttempts: Int = 0
    static var bybitSpotReconnectAttempts: Int = 0
    static var maxReconnectAttempts: Int = 10
    static var lastHeartbeat: [String: Date] = [:]
    static var messageQueue: [[String: Any]] = []
    static var isProcessingQueue: Bool = false
    
    // Add to ExchangeWebSocket class (around line 180)
    static var emergencyStopActive: Bool = false
    static var consecutiveLosses: [String: Int] = [:]
    static var tradingActive: Bool = true
    static var executionLatencies: [String: [Double]] = [:]
    static var realtimeMetrics: [String: Double] = [:]
    static var strategyAllocations: [String: Double] = [:]
    static var strategyReturns: [String: [Double]] = [:]
    
    
    // Price Storage
    static var kucoinPrices: [String: [Double]] = [:]
    static var kucoinFuturesPrices: [String: [Double]] = [:]
    static var bybitPrices: [String: [Double]] = [:]
    static var bybitFuturesPrices: [String: [Double]] = [:]
    
    // Current Prices
    static var kucoinCurrentPrice: [String: Double] = [:]
    static var kucoinCurrentFuturesPrice: [String: Double] = [:]
    static var bybitCurrentPrice: [String: Double] = [:]
    static var bybitCurrentFuturesPrice: [String: Double] = [:]
    
    // Volume Storage
    static var kucoinSpotVolume: [String: [Double]] = [:]
    static var kucoinFuturesVolume: [String: [Double]] = [:]
    static var bybitSpotVolume: [String: [Double]] = [:]
    static var bybitFuturesVolume: [String: [Double]] = [:]
    
    // Order Book Storage
    static var kucoinFuturesOrderBook: [String: [(price: Double, volume: Double, side: String)]] = [:]
    static var bybitFuturesOrderBook: [String: [(price: Double, volume: Double, side: String)]] = [:]
    static var kucoinOrderBooks: [String: BevaixOrderBook] = [:]
    static var bybitOrderBooks: [String: BevaixOrderBook] = [:]
    
    // ATR Storage
    static var kucoinFuturesATR: [String: Double] = [:]
    static var bybitFuturesATR: [String: Double] = [:]
    
    // Trading States
    static var kucoinInSpotTrade: [String: Bool] = [:]
    static var bybitInSpotTrade: [String: Bool] = [:]
    static var kucoinSpotEntryPrice: [String: Double] = [:]
    static var bybitSpotEntryPrice: [String: Double] = [:]
    static var kucoinFuturesEntryPrice: [String: Double] = [:]
    static var bybitFuturesEntryPrice: [String: Double] = [:]
    static var kucoinSpotTrailingStop: [String: Double] = [:]
    static var bybitSpotTrailingStop: [String: Double] = [:]
    static var activeSpotTrades: [String: Int] = [:]
    
    // Arbitrage States
    static var arbitrageExecuted: [String: (Bool, Date)] = [:]
    static var crossExchangeArbitrageExecuted: [String: (Bool, Date)] = [:]
    
    // Funding Rates
    static var bybitFundingRates: [String: Double] = [:]
    static var kucoinFundingRates: [String: Double] = [:]
    static var bybitFundingRateHistory: [String: [Double]] = [:]
    static var kucoinFundingRateHistory: [String: [Double]] = [:]
    
    // Balances
    static var kucoinBalance: Double = 0.0
    static var bybitBalance: Double = 0.0
    static var kucoinBalances: [String: Double] = [:]
    static var bybitBalances: [String: Double] = [:]
    static var kucoinLiveBalance: Double?
    static var bybitLiveBalance: Double?
    
    // Daily Loss Tracking
    static var dailyLoss: [String: Double] = ["bybit": 0.0, "kucoin": 0.0]
    static var lastDailyReset: Date = Date()
    static var portfolioDrawdown: Double = 0.0
    
    // Historical Spreads Storage
    static var historicalSpreads: [String: [Double]] = [:]
    
    // Sentiment Scores
    static var sentimentScores: [String: Double] = [:]
    
    // Multi-Timeframe EMA Storage
    static var kucoinSpotEMA1Min: [String: (short: Double, medium: Double, long: Double)] = [:]
    static var kucoinSpotEMA5Min: [String: (short: Double, medium: Double, long: Double)] = [:]
    static var kucoinSpotEMA15Min: [String: (short: Double, medium: Double, long: Double)] = [:]
    static var bybitSpotEMA1Min: [String: (short: Double, medium: Double, long: Double)] = [:]
    static var bybitSpotEMA5Min: [String: (short: Double, medium: Double, long: Double)] = [:]
    static var bybitSpotEMA15Min: [String: (short: Double, medium: Double, long: Double)] = [:]
    
    // Latency Monitoring
    static var lastLatency: [String: Double] = [:]
    static fileprivate var lastKucoinFetchTime: [String: Date] = [:]
    static fileprivate var lastBybitFetchTime: [String: Date] = [:]
    
    // Order Book Spoofing Detection
    static var orderCancellationEvents: [String: [(timestamp: Date, level: Int, volume: Double)]] = [:]
    static var kucoinOrderBookEvents: [String: [(timestamp: Date, level: Int, volume: Double)]] = [:]
    
    // VaR and Kelly Sizing
    static var varEstimates: [String: Double] = [:]
    static var kellySizes: [String: Double] = [:]
    
    // Performance Dashboard
    static var performanceMetrics: [String: (profit: Double, fees: Double, trades: Int, wins: Int)] = [:]
    
    // Enhanced Trading Variables for Advanced Features
    static var strategyPerformance: [String: PerformanceMetrics] = [:]
    static var mlPredictions: [String: MLPrediction] = [:]
    static var riskMetrics: [String: RiskMetrics] = [:]
    static var advancedSignals: [String: [AdvancedSignal]] = [:]
    static var marketConditions: [String: MarketCondition] = [:]
    static var tradingOpportunities: [TradingOpportunity] = []
    
    // Technical Indicators
    static var emaShort: [String: [Double]] = [:]
    static var emaMedium: [String: [Double]] = [:]
    static var emaLong: [String: [Double]] = [:]
    static var rsiValues: [String: [Double]] = [:]
    static var macdValues: [String: [(macd: Double, signal: Double, histogram: Double)]] = [:]
    static var bollingerBands: [String: [(upper: Double, middle: Double, lower: Double)]] = [:]
    static var atrValues: [String: [Double]] = [:]
    static var vwapValues: [String: [Double]] = [:]
    static var stochasticValues: [String: [(k: Double, d: Double)]] = [:]
    static var williamsR: [String: [Double]] = [:]
    static var cciValues: [String: [Double]] = [:]
    static var mfiValues: [String: [Double]] = [:]
    static var obvValues: [String: [Double]] = [:]
    static var adxValues: [String: [Double]] = [:]
    static var parValues: [String: [Double]] = [:]
    static var ichiValues: [String: [(tenkan: Double, kijun: Double, chikou: Double)]] = [:]
    static var pivotPoints: [String: [(pivot: Double, r1: Double, r2: Double, s1: Double, s2: Double)]] = [:]
    static var fibonacciLevels: [String: [Double]] = [:]
    
    // Sentiment and ML
    static var newsImpact: [String: Double] = [:]
    static var socialSentiment: [String: Double] = [:]
    static var whaleActivity: [String: Double] = [:]
    static var institutionalFlow: [String: Double] = [:]
    
    // Risk Management
    static var correlationMatrix: [String: [String: Double]] = [:]
    static var volatilityScores: [String: Double] = [:]
    static var liquidityScores: [String: Double] = [:]
    static var exposureByPair: [String: Double] = [:]
    static var exposureByStrategy: [String: Double] = [:]
    static var dailyLossByPair: [String: Double] = [:]
    static var dailyLossByExchange: [String: Double] = [:]
    static var maxDrawdownByStrategy: [String: Double] = [:]
    
    // Strategy-Specific Variables
    static var arbitrageOpportunities: [String: Double] = [:]
    static var momentumSignals: [String: Double] = [:]
    static var meanReversionSignals: [String: Double] = [:]
    static var marketMakingSignals: [String: Double] = [:]
    static var hftSignals: [String: Double] = [:]
    
    // Execution Tracking
    static var lastTradeTime: [String: Date] = [:]
    static var cooldownPeriods: [String: TimeInterval] = [:]
    static var executionLatency: [String: [Double]] = [:]
    static var slippageTracking: [String: [Double]] = [:]
    static var fillRates: [String: Double] = [:]
    
    // Position Management
    static var activePositions: [String: Double] = [:]
    static var entryPrices: [String: Double] = [:]
    static var stopLossPrices: [String: Double] = [:]
    static var takeProfitPrices: [String: Double] = [:]
    static var trailingStopPrices: [String: Double] = [:]
    static var positionSizes: [String: Double] = [:]
    static var leverageUsed: [String: Double] = [:]
    
    // Performance Optimization
    static var cpuUsage: Double = 0.0
    static var memoryUsage: Double = 0.0
    static var networkLatency: [String: Double] = [:]
    static var apiCallCounts: [String: Int] = [:]
    static var errorCounts: [String: Int] = [:]
    static var reconnectionCounts: [String: Int] = [:]
    
    // Real-time Monitoring
    static var lastDataUpdate: [String: Date] = [:]
    static var healthStatus: [String: String] = [:]
    static var alertThresholds: [String: Double] = [:]
    static var performanceAlerts: [String] = []
    
    // Missing Variables for Trading Logic
    static var futuresArbitrageExecuted: [String: (profit: Double, timestamp: Date)] = [:]
    static var hftArbitrageExecuted: [String: (profit: Double, timestamp: Date)] = [:]
    static var activeFuturesTrades: [String: Int] = [:]
    static var runningProfitLoss: [String: Double] = [:]
    static var kucoinFuturesBalance: Double = 0.0
    static var bybitFuturesBalance: Double = 0.0
    static var kucoinFuturesPositions: [String: Double] = [:]
    static var bybitFuturesPositions: [String: Double] = [:]
    static var kucoinSymbols: [String: String] = [:]
    static var bybitSymbols: [String: String] = [:]
    static var bybitFuturesSymbols: [String: String] = [:]
    
    // Helper for dynamic spread threshold
    static func adjustSpreadThreshold(pair: String, baseThreshold: Double) -> Double {
        let atr = kucoinFuturesATR[pair] ?? 0.01
        let volatility = atr / (kucoinCurrentPrice[pair] ?? 1.0)
        return baseThreshold * (1 + volatility)
    }
    
    // Parameters (will be loaded from .env)
    static var tradingPairs: [String] = []
    static var kucoinFuturesSymbols: [String: String] = [:]
    static var liquidityDepthMultiplier: Double = 0.0
    static var liquidityPriceImpactThreshold: Double = 0.0
    static var orderBookPriceRange: Double = 0.0
    static var orderBookImbalanceThreshold: Double = 0.0
    static var futuresTradeAmount: Double = 0.0
    static var futuresMinProfitPercentage: Double = 0.0
    static var futuresStopLossPercentage: Double = 0.0
    static var futuresTrailingStopPercentage: Double = 0.0
    static var futuresSpikeTrailingStopPercentage: Double = 0.0
    static var maxActiveFuturesTrades: Int = 0
    static var dailyLossLimitPercentage: Double = 0.0
    static var atrMultiplier: Double = 0.0
    static var arbitrageMinBalance: Double = 0.0
    static var arbitrageTradeAmount: Double = 0.0
    static var arbitrageMinSpreadThreshold: Double = 0.001
    static var arbitrageHighSpreadThreshold: Double = 0.005
    static var crossExchangeMinBalance: Double = 0.0
    static var crossExchangeTradeAmount: Double = 0.0
    static var crossExchangeMinSpreadThreshold: Double = 0.002
    static var crossExchangeMinFundingRateThreshold: Double = 0.0
    static var crossExchangeCooldownSeconds: Double = 0.0
    static var volatilityPauseSeconds: Double = 0.0
    static var spotTradeAmount: Double = 0.0
    static var spotFeeRate: Double = 0.0
    static var spotMinProfitPercentage: Double = 0.0
    static var spotStopLossPercentage: Double = 0.0
    static var spotTrailingStopPercentage: Double = 0.0
    static var spotEmaShortPeriod: Int = 0
    static var spotEmaMediumPeriod: Int = 0
    static var spotEmaLongPeriod: Int = 0
    static var spotRsiPeriod: Int = 0
    static var spotRsiUpperThreshold: Double = 0.0
    static var spotRsiLowerThreshold: Double = 0.0
    static var maxActiveSpotTrades: Int = 0
    static var futuresEmaShortPeriod: Int = 0
    static var futuresEmaMediumPeriod: Int = 0
    static var futuresEmaLongPeriod: Int = 0
    static var bybitFuturesFeeRate: Double = 0.0
    static var kucoinFuturesFeeRate: Double = 0.0
    static var bybitFallbackBalance: Double = 0.0
    static var kucoinFallbackBalance: Double = 0.0
    static var bybitRecvWindow: String = ""
    static var kucoinLeverage: String = ""
    static var bybitLeverage: String = ""
    static var priceHistoryRetention: Int = 0
    static var volatilitySpikeThreshold: Double = 0.0
    static var volatilitySpikeWindowMinutes: Int = 0
    static var volatilitySpikeCooldownSeconds: Int = 0
    static var volumeAnomalyMultiplier: Double = 0.0
    static var volumeAnomalyWindowHours: Int = 0
    static var volumeAnomalyCooldownSeconds: Int = 0
    static var minLiquidityThreshold: Double = 0.0
    static var maxOrderBookImbalance: Double = 0.0
    static var websocketTimeoutSeconds: Int = 0
    static var balanceFetchTimeout: Int = 0
    static var arbitrageThreshold: Double = 0.001
    static var maxFundingRate: Double = 0.0
    static var crossExchangeArbitrageThreshold: Double = 0.002
    static var hftSpreadThreshold: Double = 0.003
    static var hftTradeAmount: Double = 200.0
    static var macdShortPeriod: Int = 0
    static var macdLongPeriod: Int = 0
    static var macdSignalPeriod: Int = 0
    static var macdConfirmationThreshold: Double = 0.0
    static var maxSlippage: Double = 0.0
    static var liquidityCheckInterval: Int = 0
    static var minOrderbookRefreshRate: Int = 0
    
    // HFT parameters (will be loaded from .env)
    static var scalpEntryThreshold: Double = 0.0
    static var scalpProfitTarget: Double = 0.0
    static var scalpStopLoss: Double = 0.0
    static var spoofingVolumeThreshold: Double = 0.0
    static var spoofingProfitTarget: Double = 0.0
    static var slippageTradeAmount: Double = 0.0
    static var fundingMomentumThreshold: Double = 0.0
    static var latencySpikeThreshold: Double = 0.0
    static var hftCooldownSeconds: Double = 0.0

    // Added variables for trading strategy and arbitrage
    static var shortSMAPeriod: Int = 10
    static var longSMAPeriod: Int = 20
    static var bybitPositions: [String: Double] = [:]
    static var kucoinPositions: [String: Double] = [:]
    static var tradeAmountPercentage: Double = 0.1
    static var stopLossPercentage: Double = 0.02
    static var bybitEntryPrices: [String: Double] = [:]
    static var kucoinEntryPrices: [String: Double] = [:]
    static var takeProfitPercentage: Double = 0.05
    static var fundingRateAdjustmentFactor: Double = 0.01

    // New variables for enhanced features
    static var kucoinMakerFee: Double = 0.0002
    static var kucoinTakerFee: Double = 0.0005
    static var bybitMakerFee: Double = 0.0001
    static var bybitTakerFee: Double = 0.0004
    static var lastFeeUpdate: Date = .distantPast
    static var kellyWinProbability: Double = 0.6
    static var kellyRewardToRisk: Double = 2.0
    static var volatilityPauseActive: Bool = false
    static var lastVolatilityPause: Date = .distantPast
    static var lastSummaryTime: Date = .distantPast
    
    // New variables for performance optimization
    static var lastPriceUpdate: [String: (price: Double, timestamp: Date)] = [:]
    static var isTradingPaused: [String: Bool] = [:]

    // Helper for order book imbalance calculation
    static func calculateOrderBookImbalance(book: BevaixOrderBook) -> Double {
        let bidVolume = book.bids.reduce(0.0) { $0 + $1.quantity }
        let askVolume = book.asks.reduce(0.0) { $0 + $1.quantity }
        return bidVolume > 0 && askVolume > 0 ? max(bidVolume, askVolume) / min(bidVolume, askVolume) : 0.0
    }
    
    static func calculateOrderBookImbalanceFutures(book: [(price: Double, volume: Double, side: String)]) -> Double {
        let bidVolume = book.filter { $0.side == "buy" }.reduce(0.0) { $0 + $1.volume }
        let askVolume = book.filter { $0.side == "sell" }.reduce(0.0) { $0 + $1.volume }
        return bidVolume > 0 && askVolume > 0 ? max(bidVolume, askVolume) / min(bidVolume, askVolume) : 0.0
    }

    // WebSocket order book update with validation
    static func updateOrderBook(pair: String, exchange: String, message: [String: Any]) {
        let startTime = Date()
        Task { @MainActor in
            let latency = Date().timeIntervalSince(startTime) * 1000
            if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 80.0) {
                logAlert(event: "High latency detected for order book fetch for \(exchange)-\(pair): \(latency)ms")
            }

            guard let data = message["data"] as? [String: Any],
                  let bids = data["bids"] as? [[String]], let asks = data["asks"] as? [[String]] else {
                logAlert(event: "Invalid order book response for \(exchange)-\(pair)-spot")
                return
            }

            var parsedBids: [(price: Double, quantity: Double)] = []
            var parsedAsks: [(price: Double, quantity: Double)] = []
            var parseError = false

            for bid in bids {
                if bid.count >= 2, let price = Double(bid[0]), let quantity = Double(bid[1]), price > 0, quantity > 0 {
                    parsedBids.append((price: price, quantity: quantity))
                } else {
                    parseError = true
                    break
                }
            }
            for ask in asks {
                if ask.count >= 2, let price = Double(ask[0]), let quantity = Double(ask[1]), price > 0, quantity > 0 {
                    parsedAsks.append((price: price, quantity: quantity))
                } else {
                    parseError = true
                    break
                }
            }

            if parseError || parsedBids.isEmpty || parsedAsks.isEmpty {
                logAlert(event: "Invalid order book response for \(exchange)-\(pair)-spot: Parse error or empty data")
                return
            }

            let orderBook = BevaixOrderBook(bids: parsedBids, asks: parsedAsks)
            if exchange == "kucoin" {
                kucoinOrderBooks[pair] = orderBook
            } else {
                bybitOrderBooks[pair] = orderBook
            }

            // Check for imbalance
            let imbalance = calculateOrderBookImbalance(book: orderBook)
            if imbalance > getDouble("MAX_ORDER_BOOK_IMBALANCE", defaultValue: 20.0) {
                logAlert(event: "Order book imbalance for \(exchange)-\(pair)-spot: Imbalance \(imbalance)")
            }
        }
    }

    // Price update with zero-price validation
    static func updatePrice(pair: String, exchange: String, price: Double) {
        Task { @MainActor in
            if price <= 0 {
                logAlert(event: "Zero price detected for \(exchange)-\(pair)")
                return
            }
            if exchange == "kucoin" {
                kucoinCurrentPrice[pair] = price
                kucoinPrices[pair, default: []].append(price)
                if kucoinPrices[pair]!.count > getInt("PRICE_HISTORY_RETENTION", defaultValue: 1440) {
                    kucoinPrices[pair]?.removeFirst()
                }
            } else {
                bybitCurrentPrice[pair] = price
                bybitPrices[pair, default: []].append(price)
                if bybitPrices[pair]!.count > getInt("PRICE_HISTORY_RETENTION", defaultValue: 1440) {
                    bybitPrices[pair]?.removeFirst()
                }
            }
            lastPriceUpdate[pair] = (price: price, timestamp: Date())
        }
    }

    // WebSocket message handling with retry logic
    static func handleWebSocketMessage(socket: WebSocket, message: [String: Any], exchange: String) async {
        let startTime = Date()
        guard let topic = message["topic"] as? String else {
            await MainActor.run {
                logAlert(event: "Invalid WebSocket message format for \(exchange): Missing topic")
            }
            return
        }

        let maxRetries = getInt("MAX_RECONNECT_ATTEMPTS", defaultValue: 10)
        if topic.contains("level2") || topic.contains("orderbook") {
            if let pair = extractPairFromTopic(topic) {
                var retries = 0
                while retries < maxRetries {
                    updateOrderBook(pair: pair, exchange: exchange, message: message)
                    // Check if update was successful by verifying order book data
                    let orderBook = exchange == "kucoin" ? kucoinOrderBooks[pair] : bybitOrderBooks[pair]
                    if orderBook != nil && !orderBook!.bids.isEmpty && !orderBook!.asks.isEmpty {
                        break
                    }
                    retries += 1
                    await MainActor.run {
                        logAlert(event: "Failed to update order book for \(exchange)-\(pair), retry \(retries)/\(maxRetries)")
                    }
                    if retries == maxRetries {
                        await MainActor.run {
                            logAlert(event: "Max retries reached for order book fetch: \(exchange)-\(pair)-spot")
                        }
                    }
                    try? await Task.sleep(nanoseconds: UInt64(1_000_000_000)) // 1-second delay
                }
            }
        } else if topic.contains("ticker") {
            if let pair = extractPairFromTopic(topic), let data = message["data"] as? [String: Any], let price = data["bestAskPrice"] as? String, let priceDouble = Double(price), priceDouble > 0 {
                updatePrice(pair: pair, exchange: exchange, price: priceDouble)
            } else {
                await MainActor.run {
                    logAlert(event: "Invalid ticker response for \(exchange): \(message)")
                }
            }
        }

        let latency = Date().timeIntervalSince(startTime) * 1000
        if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 80.0) {
            await MainActor.run {
                logAlert(event: "High latency detected for WebSocket message processing for \(exchange): \(latency)ms")
            }
        }
    }

    static func extractPairFromTopic(_ topic: String) -> String? {
        let components = topic.split(separator: ":")
        if components.count > 1 {
            let pair = String(components[1]).replacingOccurrences(of: "USDTM", with: "-USDT")
            return tradingPairs.contains(pair) ? pair : nil
        }
        return nil
    }

    // Dashboard metrics logging
    static func logDashboardMetrics() {
        Task { @MainActor in
            let timestamp = ISO8601DateFormatter().string(from: Date())
            let metrics = """
            [\(timestamp)] Dashboard Metrics:
            KuCoin Balance: \(kucoinBalance) USDT
            Bybit Balance: \(bybitBalance) USDT
            Total Trades: \(performanceMetrics.values.reduce(0) { $0 + $1.trades })
            Total Profit: \(performanceMetrics.values.reduce(0.0) { $0 + $1.profit }) USDT
            Total Fees: \(performanceMetrics.values.reduce(0.0) { $0 + $1.fees }) USDT
            """
            print(metrics)
            logAlert(event: metrics)
        }
    }

    static func initializeParameters(completion: @escaping () -> Void) {
        let rawPairs = environment["ACTIVE_PAIRS"] ?? "BTC-USDT,ETH-USDT"
        print("DEBUG: Raw ACTIVE_PAIRS from .env: \(rawPairs)")
        tradingPairs = rawPairs.split(separator: ",").map { String($0).trimmingCharacters(in: .whitespaces) }
        print("DEBUG: Loaded tradingPairs: \(tradingPairs)")
        print("DEBUG: Number of pairs loaded: \(tradingPairs.count)")

        // Allocate capital proportionally
        let kucoinInitialBalance = getDouble("KUCOIN_FALLBACK_BALANCE", defaultValue: 500.0)
        let bybitInitialBalance = getDouble("BYBIT_FALLBACK_BALANCE", defaultValue: 700.0)
        kucoinBalance = kucoinInitialBalance
        bybitBalance = bybitInitialBalance
        
        tradingPairs.forEach { pair in
            let kucoinAllocation = kucoinInitialBalance / Double(tradingPairs.count)
            let bybitAllocation = bybitInitialBalance / Double(tradingPairs.count)
            kucoinBalances[pair] = kucoinAllocation
            bybitBalances[pair] = bybitAllocation
        }

        fetchKuCoinFuturesSymbols {
            Task { @MainActor in
                if kucoinFuturesSymbols.isEmpty {
                    for pair in tradingPairs {
                        let components = pair.components(separatedBy: "-")
                        if components.count == 2 {
                            let base = components[0]
                            let quote = components[1]
                            let adjustedBase = base == "BTC" ? "XBT" : base
                            kucoinFuturesSymbols[pair] = "\(adjustedBase)\(quote)M"
                        } else {
                            print("DEBUG: Invalid trading pair format: \(pair)")
                            Task { @MainActor in
                                logAlert(event: "Invalid trading pair format: \(pair)")
                            }
                        }
                    }
                }
                print("DEBUG: Initialized kucoinFuturesSymbols: \(kucoinFuturesSymbols)")
                
                // Initialize storage dictionaries for all pairs
                tradingPairs.forEach { pair in
                    kucoinPrices[pair] = kucoinPrices[pair] ?? []
                    kucoinFuturesPrices[pair] = kucoinFuturesPrices[pair] ?? []
                    bybitPrices[pair] = bybitPrices[pair] ?? []
                    bybitFuturesPrices[pair] = bybitFuturesPrices[pair] ?? []
                    kucoinCurrentPrice[pair] = kucoinCurrentPrice[pair] ?? 0.0
                    kucoinCurrentFuturesPrice[pair] = kucoinCurrentFuturesPrice[pair] ?? 0.0
                    bybitCurrentPrice[pair] = bybitCurrentPrice[pair] ?? 0.0
                    bybitCurrentFuturesPrice[pair] = bybitCurrentFuturesPrice[pair] ?? 0.0
                    bybitPositions[pair] = bybitPositions[pair] ?? 0.0
                    kucoinPositions[pair] = kucoinPositions[pair] ?? 0.0
                    kucoinSpotVolume[pair] = kucoinSpotVolume[pair] ?? []
                    kucoinFuturesVolume[pair] = kucoinFuturesVolume[pair] ?? []
                    bybitSpotVolume[pair] = bybitSpotVolume[pair] ?? []
                    bybitFuturesVolume[pair] = bybitFuturesVolume[pair] ?? []
                    kucoinFuturesOrderBook[pair] = kucoinFuturesOrderBook[pair] ?? []
                    bybitFuturesOrderBook[pair] = bybitFuturesOrderBook[pair] ?? []
                    kucoinOrderBooks[pair] = kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
                    bybitOrderBooks[pair] = bybitOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
                    bybitFundingRateHistory[pair] = bybitFundingRateHistory[pair] ?? []
                    kucoinFundingRateHistory[pair] = kucoinFundingRateHistory[pair] ?? []
                    sentimentScores[pair] = sentimentScores[pair] ?? 0.0
                    kucoinSpotEMA1Min[pair] = kucoinSpotEMA1Min[pair] ?? (short: 0.0, medium: 0.0, long: 0.0)
                    kucoinSpotEMA5Min[pair] = kucoinSpotEMA5Min[pair] ?? (short: 0.0, medium: 0.0, long: 0.0)
                    kucoinSpotEMA15Min[pair] = kucoinSpotEMA15Min[pair] ?? (short: 0.0, medium: 0.0, long: 0.0)
                    bybitSpotEMA1Min[pair] = bybitSpotEMA1Min[pair] ?? (short: 0.0, medium: 0.0, long: 0.0)
                    bybitSpotEMA5Min[pair] = bybitSpotEMA5Min[pair] ?? (short: 0.0, medium: 0.0, long: 0.0)
                    bybitSpotEMA15Min[pair] = bybitSpotEMA15Min[pair] ?? (short: 0.0, medium: 0.0, long: 0.0)
                    lastLatency[pair] = lastLatency[pair] ?? 0.0
                    orderCancellationEvents[pair] = orderCancellationEvents[pair] ?? []
                    varEstimates[pair] = varEstimates[pair] ?? 0.0
                    kellySizes[pair] = kellySizes[pair] ?? 0.0
                    performanceMetrics[pair] = performanceMetrics[pair] ?? (profit: 0.0, fees: 0.0, trades: 0, wins: 0)
                    tradeMetrics[pair] = tradeMetrics[pair] ?? (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)
                    kucoinOrderBookEvents[pair] = kucoinOrderBookEvents[pair] ?? []
                    print("DEBUG: Initialized storage for pair: \(pair)")
                }

                // Load other parameters
                liquidityDepthMultiplier = getDouble("LIQUIDITY_DEPTH_MULTIPLIER", defaultValue: 7.0)
                liquidityPriceImpactThreshold = getDouble("LIQUIDITY_PRICE_IMPACT_THRESHOLD", defaultValue: 0.005)
                orderBookPriceRange = getDouble("ORDER_BOOK_PRICE_RANGE", defaultValue: 0.005)
                orderBookImbalanceThreshold = getDouble("ORDER_BOOK_IMBALANCE_THRESHOLD", defaultValue: 1.5)
                minLiquidityThreshold = getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 500.0)
                maxOrderBookImbalance = getDouble("MAX_ORDER_BOOK_IMBALANCE", defaultValue: 20.0)
                volatilitySpikeThreshold = getDouble("VOLATILITY_SPIKE_THRESHOLD", defaultValue: 0.05)
                volatilitySpikeWindowMinutes = getInt("VOLATILITY_SPIKE_WINDOW_MINUTES", defaultValue: 5)
                volatilitySpikeCooldownSeconds = getInt("VOLATILITY_SPIKE_COOLDOWN_SECONDS", defaultValue: 900)
                volumeAnomalyMultiplier = getDouble("VOLUME_ANOMALY_MULTIPLIER", defaultValue: 5.0)
                volumeAnomalyWindowHours = getInt("VOLUME_ANOMALY_WINDOW_HOURS", defaultValue: 1)
                volumeAnomalyCooldownSeconds = getInt("VOLUME_ANOMALY_COOLDOWN_SECONDS", defaultValue: 1800)
                futuresTradeAmount = getDouble("FUTURES_TRADE_AMOUNT", defaultValue: 150.0)
                futuresMinProfitPercentage = getDouble("FUTURES_MIN_PROFIT_PERCENTAGE", defaultValue: 0.01)
                futuresStopLossPercentage = getDouble("FUTURES_STOP_LOSS_PERCENTAGE", defaultValue: 0.02)
                futuresTrailingStopPercentage = getDouble("FUTURES_TRAILING_STOP_PERCENTAGE", defaultValue: 0.01)
                futuresSpikeTrailingStopPercentage = getDouble("FUTURES_SPIKE_TRAILING_STOP_PERCENTAGE", defaultValue: 0.02)
                maxActiveFuturesTrades = getInt("MAX_ACTIVE_FUTURES_TRADES", defaultValue: 5)
                dailyLossLimitPercentage = getDouble("DAILY_LOSS_LIMIT_PERCENTAGE", defaultValue: 0.05)
                atrMultiplier = getDouble("ATR_MULTIPLIER", defaultValue: 1.5)
                arbitrageMinBalance = getDouble("ARBITRAGE_MIN_BALANCE", defaultValue: 300.0)
                arbitrageTradeAmount = getDouble("ARBITRAGE_TRADE_AMOUNT", defaultValue: 500.0)
                arbitrageMinSpreadThreshold = getDouble("ARBITRAGE_MIN_SPREAD_THRESHOLD", defaultValue: 0.001)
                arbitrageHighSpreadThreshold = getDouble("ARBITRAGE_HIGH_SPREAD_THRESHOLD", defaultValue: 0.005)
                crossExchangeMinBalance = getDouble("CROSS_EXCHANGE_MIN_BALANCE", defaultValue: 500.0)
                crossExchangeTradeAmount = getDouble("CROSS_EXCHANGE_TRADE_AMOUNT", defaultValue: 150.0)
                crossExchangeMinSpreadThreshold = getDouble("CROSS_EXCHANGE_MIN_SPREAD_THRESHOLD", defaultValue: 0.002)
                crossExchangeMinFundingRateThreshold = getDouble("CROSS_EXCHANGE_MIN_FUNDING_RATE_THRESHOLD", defaultValue: 0.00005)
                crossExchangeCooldownSeconds = getDouble("CROSS_EXCHANGE_COOLDOWN_SECONDS", defaultValue: 300)
                volatilityPauseSeconds = getDouble("VOLATILITY_PAUSE_SECONDS", defaultValue: 300)
                spotTradeAmount = getDouble("SPOT_TRADE_AMOUNT", defaultValue: 30.0)
                spotFeeRate = getDouble("SPOT_FEE_RATE", defaultValue: 0.001)
                spotMinProfitPercentage = getDouble("SPOT_MINUTE_PROFIT_PERCENTAGE", defaultValue: 0.004)
                spotStopLossPercentage = getDouble("SPOT_STOP_LOSS_PERCENTAGE", defaultValue: 0.02)
                spotTrailingStopPercentage = getDouble("SPOT_TRAILING_STOP_PERCENTAGE", defaultValue: 0.003)
                spotEmaShortPeriod = getInt("SPOT_EMA_SHORT_PERIOD", defaultValue: 3)
                spotEmaMediumPeriod = getInt("SPOT_EMA_MEDIUM_PERIOD", defaultValue: 6)
                spotEmaLongPeriod = getInt("SPOT_EMA_LONG_PERIOD", defaultValue: 20)
                spotRsiPeriod = getInt("SPOT_RSI_PERIOD", defaultValue: 14)
                spotRsiUpperThreshold = getDouble("SPOT_RSI_UPPER_THRESHOLD", defaultValue: 70.0)
                spotRsiLowerThreshold = getDouble("SPOT_RSI_LOWER_THRESHOLD", defaultValue: 30.0)
                maxActiveSpotTrades = getInt("MAX_ACTIVE_SPOT_TRADES", defaultValue: 2)
                futuresEmaShortPeriod = getInt("FUTURES_EMA_SHORT_PERIOD", defaultValue: 3)
                futuresEmaMediumPeriod = getInt("FUTURES_EMA_MEDIUM_PERIOD", defaultValue: 6)
                futuresEmaLongPeriod = getInt("FUTURES_EMA_LONG_PERIOD", defaultValue: 20)
                bybitFuturesFeeRate = getDouble("BYBIT_FUTURES_FEE_RATE", defaultValue: 0.0004)
                kucoinFuturesFeeRate = getDouble("KUCOIN_FUTURES_FEE_RATE", defaultValue: 0.0005)
                bybitFallbackBalance = getDouble("BYBIT_FALLBACK_BALANCE", defaultValue: 700.0)
                kucoinFallbackBalance = getDouble("KUCOIN_FALLBACK_BALANCE", defaultValue: 500.0)
                bybitRecvWindow = environment["BYBIT_RECV_WINDOW"] ?? "5000"
                kucoinLeverage = environment["KUCOIN_LEVERAGE"] ?? "1"
                bybitLeverage = environment["BYBIT_LEVERAGE"] ?? "1"
                priceHistoryRetention = getInt("PRICE_HISTORY_RETENTION", defaultValue: 1440)
                websocketTimeoutSeconds = getInt("WEBSOCKET_TIMEOUT_SECONDS", defaultValue: 15)
                balanceFetchTimeout = getInt("BALANCE_FETCH_TIMEOUT", defaultValue: 20)
                maxFundingRate = getDouble("MAX_FUNDING_RATE", defaultValue: 0.001)
                macdShortPeriod = getInt("MACD_SHORT_PERIOD", defaultValue: 12)
                macdLongPeriod = getInt("MACD_LONG_PERIOD", defaultValue: 26)
                macdSignalPeriod = getInt("MACD_SIGNAL_PERIOD", defaultValue: 9)
                macdConfirmationThreshold = getDouble("MACD_CONFIRMATION_THRESHOLD", defaultValue: 0.0003)
                maxSlippage = getDouble("MAX_SLIPPAGE", defaultValue: 0.005)
                liquidityCheckInterval = getInt("LIQUIDITY_CHECK_INTERVAL", defaultValue: 15)
                minOrderbookRefreshRate = getInt("MIN_ORDERBOOK_REFRESH_RATE", defaultValue: 5)
                scalpEntryThreshold = getDouble("SCALP_ENTRY_THRESHOLD", defaultValue: 0.0006)
                scalpProfitTarget = getDouble("SCALP_PROFIT_TARGET", defaultValue: 0.0012)
                scalpStopLoss = getDouble("SCALP_STOP_LOSS", defaultValue: 0.0015)
                spoofingVolumeThreshold = getDouble("SPOOFING_VOLUME_THRESHOLD", defaultValue: 1.5)
                spoofingProfitTarget = getDouble("SPOOFING_PROFIT_TARGET", defaultValue: 0.008)
                slippageTradeAmount = getDouble("SLIPPAGE_TRADE_AMOUNT", defaultValue: 100.0)
                fundingMomentumThreshold = getDouble("FUNDING_MOMENTUM_THRESHOLD", defaultValue: 0.00008)
                latencySpikeThreshold = getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 80.0)
                hftCooldownSeconds = getDouble("HFT_COOLDOWN_SECONDS", defaultValue: 1.5)
                
                print("DEBUG: Initialized kucoinBalance: \(kucoinBalance), bybitBalance: \(bybitBalance)")

                // Fetch initial sentiment scores
                for pair in tradingPairs {
                    fetchSentimentScore(pair: pair) { score in
                        Task { @MainActor in
                            sentimentScores[pair] = score ?? 0.0
                            print("DEBUG: Initialized sentiment score for \(pair): \(sentimentScores[pair] ?? 0.0)")
                        }
                    }
                }

                // Schedule periodic dashboard updates
                Task {
                    while true {
                        do {
                            try await Task.sleep(nanoseconds: 10_000_000_000) // Every 10 seconds
                            logDashboardMetrics()
                        } catch {
                            print("DEBUG: Dashboard update sleep interrupted: \(error.localizedDescription)")
                            Task { @MainActor in
                                logAlert(event: "Dashboard update sleep interrupted: \(error.localizedDescription)")
                            }
                        }
                    }
                }

                completion()
            }
        }
    }
    
    static func fetchSentimentScore(pair: String, completion: @escaping @Sendable (Double?) -> Void) {
        let url = URL(string: environment["SENTIMENT_SERVER_URL"] ?? "http://127.0.0.1:5001/sentiment")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.timeoutInterval = Double(getInt("BALANCE_FETCH_TIMEOUT", defaultValue: 20))

        let payload: [String: Any] = ["pair": pair]
        do {
            let jsonData = try JSONSerialization.data(withJSONObject: payload, options: [])
            request.httpBody = jsonData
        } catch {
            print("DEBUG: Failed to serialize sentiment payload for \(pair): \(error.localizedDescription)")
            Task { @MainActor in
                logAlert(event: "Failed to serialize sentiment payload for \(pair): \(error.localizedDescription)")
            }
            completion(nil)
            return
        }

        let startTime = Date()
        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            let latency = Date().timeIntervalSince(startTime) * 1000
            Task { @MainActor in
                lastLatency["sentiment-\(pair)"] = latency
                if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 80.0) {
                    logAlert(event: " High latency detected for sentiment score fetch for \(pair): \(latency)ms")
                }
            }

            if let error = error {
                print("DEBUG: Failed to fetch sentiment for \(pair): \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: " Failed to fetch sentiment for \(pair): \(error.localizedDescription)")
                }
                completion(nil)
                return
            }

            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200,
                  let data = data,
                  let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let sentimentScore = json["sentiment_score"] as? Double else {
                let responseBody = data != nil ? String(data: data!, encoding: .utf8) ?? "Invalid data" : "No data"
                print("DEBUG: Invalid sentiment response for \(pair): \(responseBody)")
                Task { @MainActor in
                    logAlert(event: " Invalid sentiment response for \(pair): \(responseBody)")
                }
                completion(nil)
                return
            }

            // Validate sentiment score range (-1 to 1)
            if sentimentScore < -1.0 || sentimentScore > 1.0 {
                print("DEBUG: Invalid sentiment score \(sentimentScore) for \(pair), expected range -1.0 to 1.0")
                Task { @MainActor in
                    logAlert(event: " Invalid sentiment score \(sentimentScore) for \(pair), expected range -1.0 to 1.0")
                }
                completion(nil)
                return
            }

            Task { @MainActor in
                sentimentScores[pair] = sentimentScore
                print("DEBUG: Fetched sentiment score for \(pair): \(sentimentScore)")
                logAlert(event: " SUCCESS: Fetched sentiment score for \(pair): \(sentimentScore)")
            }
            completion(sentimentScore)
        }
        task.resume()
    }

    static func fetchKuCoinFuturesSymbols(completion: @escaping () -> Void) {
        if kucoinFuturesSymbols.isEmpty {
            for pair in tradingPairs {
                let components = pair.components(separatedBy: "-")
                if components.count == 2 {
                    let base = components[0]
                    let quote = components[1]
                    let adjustedBase = base == "BTC" ? "XBT" : base
                    kucoinFuturesSymbols[pair] = "\(adjustedBase)\(quote)M"
                } else {
                    print("DEBUG: Invalid trading pair format: \(pair)")
                    logAlert(event: "Invalid trading pair format: \(pair)")
                }
            }
        }
        print("DEBUG: Initialized kucoinFuturesSymbols: \(kucoinFuturesSymbols)")
        completion()
    }
}
//-----------------------------------------------------------------------------------------------------------------------------Block 2 - Environment Setup and Logging


struct OrderBookEntry {
    let price: Double
    let size: Double
}

struct OrderBook {
    var bids: [OrderBookEntry]
    var asks: [OrderBookEntry]
}

struct FuturesOrderBookEntry {
    let price: Double
    let volume: Double
    let side: String
}

// Enhanced Market Signal Detection
struct SignalGenerator {
    static func generateMomentumSignal(prices: [Double], volume: [Double]) -> AdvancedSignal? {
        guard prices.count >= 20, volume.count >= 20 else { return nil }
        
        let recentPrices = Array(prices.suffix(20))
        let recentVolume = Array(volume.suffix(20))
        
        // Calculate momentum strength
        let priceChange = (recentPrices.last! - recentPrices.first!) / recentPrices.first!
        let avgVolume = recentVolume.reduce(0, +) / Double(recentVolume.count)
        let currentVolume = recentVolume.last!
        
        let volumeBoost = currentVolume / avgVolume
        let momentumStrength = abs(priceChange) * volumeBoost
        
        let signalType = priceChange > 0 ? "momentum_bullish" : "momentum_bearish"
        let confidence = min(momentumStrength * 100, 100.0)
        
        return AdvancedSignal(
            type: signalType,
            strength: momentumStrength,
            confidence: confidence,
            timestamp: Date(),
            pair: "",
            exchange: ""
        )
    }
    
    static func generateArbitrageSignal(kucoinPrice: Double, bybitPrice: Double, threshold: Double) -> AdvancedSignal? {
        let spread = abs(kucoinPrice - bybitPrice) / min(kucoinPrice, bybitPrice)
        
        guard spread > threshold else { return nil }
        
        let direction = kucoinPrice > bybitPrice ? "kucoin_premium" : "bybit_premium"
        let confidence = min(spread / threshold * 100, 100.0)
        
        return AdvancedSignal(
            type: "arbitrage_\(direction)",
            strength: spread,
            confidence: confidence,
            timestamp: Date(),
            pair: "",
            exchange: "cross"
        )
    }
    
    static func generateScalpingSignal(rsi: Double, price: Double, vwap: Double, orderBookImbalance: Double) -> AdvancedSignal? {
        var signals: [Double] = []
        
        // RSI signals
        if rsi < 30 { signals.append(0.7) } // Oversold
        else if rsi > 70 { signals.append(-0.7) } // Overbought
        
        // Price vs VWAP
        let vwapDivergence = (price - vwap) / vwap
        if abs(vwapDivergence) > 0.002 {
            signals.append(vwapDivergence > 0 ? -0.5 : 0.5)
        }
        
        // Order book imbalance
        if orderBookImbalance > 2.0 {
            signals.append(0.6)
        } else if orderBookImbalance < 0.5 {
            signals.append(-0.6)
        }
        
        guard !signals.isEmpty else { return nil }
        
        let averageSignal = signals.reduce(0, +) / Double(signals.count)
        let signalType = averageSignal > 0 ? "scalp_buy" : "scalp_sell"
        
        return AdvancedSignal(
            type: signalType,
            strength: abs(averageSignal),
            confidence: min(abs(averageSignal) * 150, 100.0),
            timestamp: Date(),
            pair: "",
            exchange: ""
        )
    }
}

// Enhanced Market Condition Analysis
struct MarketAnalyzer {
    static func analyzeMarketCondition(prices: [Double], volumes: [Double]) -> MarketCondition {
        guard prices.count >= 50, volumes.count >= 50 else {
            return MarketCondition(volatility: 0.02, trend: "unknown", volume: 0, momentum: 0, timestamp: Date())
        }
        
        let recentPrices = Array(prices.suffix(50))
        let recentVolumes = Array(volumes.suffix(50))
        
        // Calculate volatility
        let returns = zip(recentPrices.dropFirst(), recentPrices.dropLast()).map { (current, previous) in
            (current - previous) / previous
        }
        let meanReturn = returns.reduce(0, +) / Double(returns.count)
        let variance = returns.map { pow($0 - meanReturn, 2) }.reduce(0, +) / Double(returns.count)
        let volatility = sqrt(variance)
        
        // Determine trend
        let sma20 = recentPrices.suffix(20).reduce(0, +) / 20.0
        let sma50 = recentPrices.reduce(0, +) / Double(recentPrices.count)
        let currentPrice = recentPrices.last!
        
        var trend = "sideways"
        if currentPrice > sma20 && sma20 > sma50 {
            trend = "bullish"
        } else if currentPrice < sma20 && sma20 < sma50 {
            trend = "bearish"
        }
        
        // Calculate momentum
        let momentum = (currentPrice - recentPrices.first!) / recentPrices.first!
        
        // Average volume
        let avgVolume = recentVolumes.reduce(0, +) / Double(recentVolumes.count)
        
        return MarketCondition(
            volatility: volatility,
            trend: trend,
            volume: avgVolume,
            momentum: momentum,
            timestamp: Date()
        )
    }
    
    static func calculateCorrelation(prices1: [Double], prices2: [Double]) -> Double {
        guard prices1.count == prices2.count, prices1.count > 1 else { return 0.0 }
        
        let mean1 = prices1.reduce(0, +) / Double(prices1.count)
        let mean2 = prices2.reduce(0, +) / Double(prices2.count)
        
        let numerator = zip(prices1, prices2).map { (x1, x2) in
            (x1 - mean1) * (x2 - mean2)
        }.reduce(0, +)
        
        let denominator1 = prices1.map { pow($0 - mean1, 2) }.reduce(0, +)
        let denominator2 = prices2.map { pow($0 - mean2, 2) }.reduce(0, +)
        let denominator = sqrt(denominator1 * denominator2)
        
        return denominator != 0 ? numerator / denominator : 0.0
    }
}

// Enhanced Risk Calculator
struct RiskCalculator {
    static func calculateVaR(returns: [Double], confidence: Double = 0.95) -> Double {
        guard !returns.isEmpty else { return 0.0 }
        
        let sortedReturns = returns.sorted()
        let index = Int((1.0 - confidence) * Double(sortedReturns.count))
        return index < sortedReturns.count ? abs(sortedReturns[index]) : 0.0
    }
    
    static func calculateExpectedShortfall(returns: [Double], confidence: Double = 0.95) -> Double {
        guard !returns.isEmpty else { return 0.0 }
        
        let var95 = calculateVaR(returns: returns, confidence: confidence)
        let tailReturns = returns.filter { $0 <= -var95 }
        return tailReturns.isEmpty ? 0.0 : abs(tailReturns.reduce(0, +) / Double(tailReturns.count))
    }
    
    static func calculateMaxDrawdown(prices: [Double]) -> Double {
        guard prices.count > 1 else { return 0.0 }
        
        var maxDrawdown = 0.0
        var peak = prices[0]
        
        for price in prices {
            if price > peak {
                peak = price
            }
            let drawdown = (peak - price) / peak
            maxDrawdown = max(maxDrawdown, drawdown)
        }
        
        return maxDrawdown
    }
    
    static func calculateKellyFraction(winRate: Double, avgWin: Double, avgLoss: Double) -> Double {
        guard avgLoss > 0 else { return 0.0 }
        let b = avgWin / avgLoss
        return (winRate * (b + 1) - 1) / b
    }
}

// Dedicated struct to hold environment variables with enhanced validation
struct AppConfig {
    static let environment: [String: String] = {
        let env = loadEnv()
        print("DEBUG: Loaded environment keys: \(env.keys)")
        validateCriticalEnvironmentVariables(env)
        return env
    }()
    
    static func validateCriticalEnvironmentVariables(_ env: [String: String]) {
        let criticalKeys = [
            "BYBIT_API_KEY", "BYBIT_API_SECRET",
            "KUCOIN_API_KEY", "KUCOIN_API_SECRET", "KUCOIN_API_PASSPHRASE",
            "ACTIVE_PAIRS"
        ]
        
        var missingKeys: [String] = []
        for key in criticalKeys {
            if env[key]?.isEmpty != false {
                missingKeys.append(key)
            }
        }
        
        if !missingKeys.isEmpty {
            print(" CRITICAL: Missing environment variables: \(missingKeys.joined(separator: ", "))")
            print("  Bot may not function properly without these credentials!")
        } else {
            print(" All critical environment variables loaded successfully")
        }
    }
}

func findProjectRoot(from directory: URL) -> URL? {
    var currentDirectory = directory
    while currentDirectory.path != "/" {
        let packageFile = currentDirectory.appendingPathComponent("Package.swift")
        if FileManager.default.fileExists(atPath: packageFile.path) {
            return currentDirectory
        }
        currentDirectory = currentDirectory.deletingLastPathComponent()
    }
    return nil
}

func loadEnv() -> [String: String] {
    var env: [String: String] = [:]
    let fileManager = FileManager.default
    
    let currentDirectory = fileManager.currentDirectoryPath
    let currentEnvPath = URL(fileURLWithPath: currentDirectory).appendingPathComponent(".env").path
    
    print("Current working directory: \(currentDirectory)")
    print("Looking for .env file at: \(currentEnvPath)")
    
    if fileManager.fileExists(atPath: currentEnvPath) {
        do {
            let contents = try String(contentsOfFile: currentEnvPath, encoding: .utf8)
            print("Successfully read .env file contents: \(contents)")
            let lines = contents.components(separatedBy: .newlines)
            for line in lines {
                let trimmed = line.trimmingCharacters(in: .whitespacesAndNewlines)
                print("Processing line: '\(trimmed)'")
                if trimmed.isEmpty || trimmed.hasPrefix("#") { continue }
                let parts = trimmed.components(separatedBy: "=")
                if parts.count >= 2 {
                    let key = parts[0].trimmingCharacters(in: .whitespaces)
                    let value = parts.dropFirst().joined(separator: "=").trimmingCharacters(in: .whitespaces)
                    print("Parsed key: '\(key)', value: '\(value)'")
                    env[key] = value
                } else {
                    print("Skipping invalid line (expected key=value format): '\(trimmed)'")
                    Task { @MainActor in
                        logAlert(event: "Skipping invalid .env line: '\(trimmed)'")
                    }
                }
            }
        } catch {
            print("Error loading .env file: \(error)")
            Task { @MainActor in
                logAlert(event: "Error loading .env file: \(error)")
            }
        }
    } else {
        print("Could not find .env file at path: \(currentEnvPath)")
        Task { @MainActor in
            logAlert(event: "Could not find .env file at path: \(currentEnvPath)")
        }
        
        let binaryURL = URL(fileURLWithPath: CommandLine.arguments[0])
        if let projectRoot = findProjectRoot(from: binaryURL.deletingLastPathComponent()) {
            let rootEnvPath = projectRoot.appendingPathComponent(".env").path
            print("Falling back to project root: \(projectRoot.path)")
            print("Looking for .env file at: \(rootEnvPath)")
            if fileManager.fileExists(atPath: rootEnvPath) {
                do {
                    let contents = try String(contentsOfFile: rootEnvPath, encoding: .utf8)
                    print("Successfully read .env file contents: \(contents)")
                    let lines = contents.components(separatedBy: .newlines)
                    for line in lines {
                        let trimmed = line.trimmingCharacters(in: .whitespacesAndNewlines)
                        print("Processing line: '\(trimmed)'")
                        if trimmed.isEmpty || trimmed.hasPrefix("#") { continue }
                        let parts = trimmed.components(separatedBy: "=")
                        if parts.count >= 2 {
                            let key = parts[0].trimmingCharacters(in: .whitespaces)
                            let value = parts.dropFirst().joined(separator: "=").trimmingCharacters(in: .whitespaces)
                            print("Parsed key: '\(key)', value: '\(value)'")
                            env[key] = value
                        } else {
                            print("Skipping invalid line (expected key=value format): '\(trimmed)'")
                            Task { @MainActor in
                                logAlert(event: "Skipping invalid .env line: '\(trimmed)'")
                            }
                        }
                    }
                } catch {
                    print("Error loading .env file: \(error)")
                    Task { @MainActor in
                        logAlert(event: "Error loading .env file: \(error)")
                    }
                }
            } else {
                print("Could not find .env file at fallback path: \(rootEnvPath)")
                Task { @MainActor in
                    logAlert(event: "Could not find .env file at fallback path: \(rootEnvPath)")
                }
            }
        } else {
            print("Could not locate project root for fallback .env loading")
            Task { @MainActor in
                logAlert(event: "Could not locate project root for fallback .env loading")
            }
        }
    }
    
    print("DEBUG: Final loaded environment variables: \(env)")
    return env
}




//-------------------------------------------------------------------------------------------------------------------------Block 3 - Order Book and Liquidity Management

//--------------- Block 3 - Order Book and Liquidity Management
// VARIABLES TO ADD: Fixed isEmpty usage on BevaixOrderBook (now using isEmpty property from Block 1)

extension ExchangeWebSocket {
    static func checkLiquidity(exchange: String, pair: String, completion: @escaping @Sendable (Double?) -> Void) {
        let tradeAmount = getDouble("SPOT_TRADE_AMOUNT", defaultValue: 50.0)
        let currentPrice = exchange == "bybit" ? (bybitCurrentPrice[pair] ?? lastPriceUpdate[pair]?.price ?? 1.0) : (kucoinCurrentPrice[pair] ?? lastPriceUpdate[pair]?.price ?? 1.0)
        let requiredLiquidity = tradeAmount * currentPrice * liquidityDepthMultiplier
        let minLiquidityThresholdValue = minLiquidityThreshold
        
        Task { @MainActor in
            // Fix: Use async/await to handle MainActor-isolated fetchOrderBookDepth
            let spotDepth = await withCheckedContinuation { continuation in
                fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: "spot") { depth in
                    continuation.resume(returning: depth)
                }
            }
            let futuresDepth = await withCheckedContinuation { continuation in
                fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: "futures") { depth in
                    continuation.resume(returning: depth)
                }
            }
            
            let spotDepthValue = spotDepth ?? minLiquidityThresholdValue
            let futuresDepthValue = futuresDepth ?? minLiquidityThresholdValue
            let totalLiquidity = spotDepthValue + futuresDepthValue
            
            // ENHANCED: Basic liquidity analysis using existing variables
            let liquidityScore = calculateBasicLiquidityScore(totalLiquidity: totalLiquidity)
            print("DEBUG: Liquidity score for \(exchange)-\(pair): \(liquidityScore)")
            
            if totalLiquidity < requiredLiquidity {
                print("Insufficient liquidity for \(exchange)-\(pair): Depth \(totalLiquidity), Required \(requiredLiquidity)")
                logAlert(event: "Insufficient liquidity for \(exchange)-\(pair): Depth \(totalLiquidity), Required \(requiredLiquidity), Score: \(liquidityScore)")
                completion(nil)
            } else {
                print("DEBUG: Liquidity check passed for \(exchange)-\(pair): Depth \(totalLiquidity), Score: \(liquidityScore)")
                completion(totalLiquidity)
            }
        }
    }

    static func fetchOrderBookDepth(exchange: String, pair: String, marketType: String, retryCount: Int = 0, completion: @escaping @Sendable (Double?) -> Void) {
        let maxRetries = getInt("API_MAX_RETRIES", defaultValue: 3)
        let localRetryCountCopy = retryCount // Local copy to avoid mutation
        guard localRetryCountCopy < maxRetries else {
            print("Max retries reached for order book fetch: \(exchange)-\(pair)-\(marketType)")
            Task { @MainActor in
                logAlert(event: "Max retries reached for order book fetch: \(exchange)-\(pair)-\(marketType)")
            }
            // Fallback to cached order book data
            let book = exchange == "bybit" ?
                bybitOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: []) :
                kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
            completion(calculateOrderBookDepth(book))
            return
        }
        
        // Original URL building logic
        var url: URL?
        let symbol = pair.replacingOccurrences(of: "-USDT", with: "USDT")
        
        if exchange == "bybit" {
            let category = marketType == "spot" ? "spot" : "linear"
            url = URL(string: "https://api.bybit.com/v5/market/orderbook?category=\(category)&symbol=\(symbol)&limit=50")
        } else {
            let endpoint = marketType == "spot" ? "/api/v1/market/orderbook/level2_50?symbol=\(symbol)" : "/api/v1/contractMarket/level2?symbol=\(symbol)M"
            url = URL(string: "https://api\(marketType == "spot" ? "" : "-futures").kucoin.com\(endpoint)")
        }

        guard let requestUrl = url else {
            print("Invalid order book URL for \(exchange)-\(pair)-\(marketType)")
            Task { @MainActor in
                logAlert(event: "Invalid order book URL for \(exchange)-\(pair)-\(marketType)")
            }
            let attemptFetch: @Sendable () -> Void = {
                let newRetryCount = localRetryCountCopy + 1
                DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                    fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                }
            }
            attemptFetch()
            return
        }

        var request = URLRequest(url: requestUrl)
        request.httpMethod = "GET"
        request.timeoutInterval = getDouble("API_TIMEOUT_SECONDS", defaultValue: 10.0)

        let startTime = Date()
        URLSession.shared.dataTask(with: request) { data, response, error in
            let latency = Date().timeIntervalSince(startTime) * 1000
            Task { @MainActor in
                lastLatency[pair] = latency
                if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 300.0) {
                    print("High latency detected for order book fetch: \(latency)ms")
                    logAlert(event: "High latency detected for order book fetch: \(latency)ms")
                }
            }

            if let error = error {
                print("Failed to fetch order book for \(exchange)-\(pair)-\(marketType): \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to fetch order book for \(exchange)-\(pair)-\(marketType): \(error.localizedDescription)")
                }
                let attemptFetch: @Sendable () -> Void = {
                    let newRetryCount = localRetryCountCopy + 1
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                        fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                    }
                }
                attemptFetch()
                return
            }

            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200, let data = data else {
                print("Invalid order book response for \(exchange)-\(pair)-\(marketType)")
                Task { @MainActor in
                    logAlert(event: "Invalid order book response for \(exchange)-\(pair)-\(marketType)")
                }
                let attemptFetch: @Sendable () -> Void = {
                    let newRetryCount = localRetryCountCopy + 1
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                        fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                    }
                }
                attemptFetch()
                return
            }

            do {
                guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
                    print("Failed to parse JSON for \(exchange)-\(pair)-\(marketType)")
                    Task { @MainActor in
                        logAlert(event: "Failed to parse JSON for \(exchange)-\(pair)-\(marketType)")
                    }
                    let attemptFetch: @Sendable () -> Void = {
                        let newRetryCount = localRetryCountCopy + 1
                        DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                            fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                        }
                    }
                    attemptFetch()
                    return
                }

                if exchange == "bybit" {
                    guard let result = json["result"] as? [String: Any],
                          let bids = result["b"] as? [[String]],
                          let asks = result["a"] as? [[String]],
                          !bids.isEmpty, !asks.isEmpty else {
                        print("Failed to parse Bybit order book data for \(pair)-\(marketType)")
                        Task { @MainActor in
                            logAlert(event: "Failed to parse Bybit order book data for \(pair)-\(marketType)")
                        }
                        let attemptFetch: @Sendable () -> Void = {
                            let newRetryCount = localRetryCountCopy + 1
                            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                            }
                        }
                        attemptFetch()
                        return
                    }

                    var bidDepth: Double = 0.0
                    var askDepth: Double = 0.0
                    for bid in bids.prefix(10) {
                        if let price = Double(bid[0]), let quantity = Double(bid[1]) {
                            bidDepth += price * quantity
                        }
                    }
                    for ask in asks.prefix(10) {
                        if let price = Double(ask[0]), let quantity = Double(ask[1]) {
                            askDepth += price * quantity
                        }
                    }
                    let totalDepth = bidDepth + askDepth
                    Task { @MainActor in
                        if marketType == "spot" {
                            bybitOrderBooks[pair] = BevaixOrderBook(
                                bids: bids.prefix(10).compactMap { b in
                                    if let price = Double(b[0]), let quantity = Double(b[1]) {
                                        return (price: price, quantity: quantity)
                                    }
                                    return nil
                                },
                                asks: asks.prefix(10).compactMap { a in
                                    if let price = Double(a[0]), let quantity = Double(a[1]) {
                                        return (price: price, quantity: quantity)
                                    }
                                    return nil
                                }
                            )
                        } else {
                            bybitFuturesOrderBook[pair] = bids.prefix(10).compactMap { b in
                                if let price = Double(b[0]), let volume = Double(b[1]) {
                                    return (price: price, volume: volume, side: "buy")
                                }
                                return nil
                            } + asks.prefix(10).compactMap { a in
                                if let price = Double(a[0]), let volume = Double(a[1]) {
                                    return (price: price, volume: volume, side: "sell")
                                }
                                return nil
                            }
                        }
                        
                        // ENHANCED: Basic order book analysis
                        analyzeOrderBookBasic(exchange: exchange, pair: pair, marketType: marketType)
                    }
                    completion(totalDepth)
                } else {
                    guard let data = json["data"] as? [String: Any],
                          let bids = data["bids"] as? [[String]],
                          let asks = data["asks"] as? [[String]],
                          !bids.isEmpty, !asks.isEmpty else {
                        print("Failed to parse KuCoin order book data for \(pair)-\(marketType)")
                        Task { @MainActor in
                            logAlert(event: "Failed to parse KuCoin order book data for \(pair)-\(marketType)")
                        }
                        let attemptFetch: @Sendable () -> Void = {
                            let newRetryCount = localRetryCountCopy + 1
                            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                            }
                        }
                        attemptFetch()
                        return
                    }

                    var bidDepth: Double = 0.0
                    var askDepth: Double = 0.0
                    for bid in bids.prefix(10) {
                        if let price = Double(bid[0]), let quantity = Double(bid[1]) {
                            bidDepth += price * quantity
                        }
                    }
                    for ask in asks.prefix(10) {
                        if let price = Double(ask[0]), let quantity = Double(ask[1]) {
                            askDepth += price * quantity
                        }
                    }
                    let totalDepth = bidDepth + askDepth
                    Task { @MainActor in
                        if marketType == "spot" {
                            kucoinOrderBooks[pair] = BevaixOrderBook(
                                bids: bids.prefix(10).compactMap { b in
                                    if let price = Double(b[0]), let quantity = Double(b[1]) {
                                        return (price: price, quantity: quantity)
                                    }
                                    return nil
                                },
                                asks: asks.prefix(10).compactMap { a in
                                    if let price = Double(a[0]), let quantity = Double(a[1]) {
                                        return (price: price, quantity: quantity)
                                    }
                                    return nil
                                }
                            )
                        } else {
                            kucoinFuturesOrderBook[pair] = bids.prefix(10).compactMap { b in
                                if let price = Double(b[0]), let volume = Double(b[1]) {
                                    return (price: price, volume: volume, side: "buy")
                                }
                                return nil
                            } + asks.prefix(10).compactMap { a in
                                if let price = Double(a[0]), let volume = Double(a[1]) {
                                    return (price: price, volume: volume, side: "sell")
                                }
                                return nil
                            }
                        }
                        
                        // ENHANCED: Basic order book analysis
                        analyzeOrderBookBasic(exchange: exchange, pair: pair, marketType: marketType)
                    }
                    completion(totalDepth)
                }
            } catch {
                print("Error parsing order book data: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Error parsing order book data: \(error.localizedDescription)")
                }
                let attemptFetch: @Sendable () -> Void = {
                    let newRetryCount = localRetryCountCopy + 1
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                        fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                    }
                }
                attemptFetch()
            }
        }.resume()
    }

    static func checkLiquidityAsync(exchange: String, pair: String, marketType: String, tradeAmount: Double, price: Double) async -> Double? {
        await withCheckedContinuation { continuation in
            checkLiquidity(exchange: exchange, pair: pair) { liquidity in
                continuation.resume(returning: liquidity)
            }
        }
    }
    
    // ENHANCED FEATURES: Using only existing variables
    
    static func calculateBasicLiquidityScore(totalLiquidity: Double) -> Double {
        let baseThreshold = minLiquidityThreshold
        let ratio = totalLiquidity / baseThreshold
        
        if ratio >= 10 { return 100 }
        else if ratio >= 5 { return 85 }
        else if ratio >= 3 { return 70 }
        else if ratio >= 2 { return 55 }
        else if ratio >= 1 { return 40 }
        else { return 20 }
    }
    
    @MainActor
    static func analyzeOrderBookBasic(exchange: String, pair: String, marketType: String) {
        let orderBook = exchange == "bybit" ?
            bybitOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: []) :
            kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
        
        // FIX: Use isEmpty property instead of accessing non-existent member
        guard !orderBook.isEmpty else { return }
        
        // Calculate basic spread metrics
        let bestBid = orderBook.bids.first?.price ?? 0
        let bestAsk = orderBook.asks.first?.price ?? 0
        let spread = bestAsk - bestBid
        let midPrice = (bestBid + bestAsk) / 2
        let spreadPercent = midPrice > 0 ? (spread / midPrice) * 100 : 0
        
        // Analyze basic order book imbalance
        let bidVolume = orderBook.bids.prefix(5).reduce(0) { $0 + $1.quantity }
        let askVolume = orderBook.asks.prefix(5).reduce(0) { $0 + $1.quantity }
        let totalVolume = bidVolume + askVolume
        let imbalance = totalVolume > 0 ? abs(bidVolume - askVolume) / totalVolume : 0
        
        // Log significant findings using existing logging
        if spreadPercent > 0.2 {
            logAlert(event: "Wide spread detected for \(exchange)-\(pair): \(String(format: "%.3f", spreadPercent))%")
        }
        
        if imbalance > 0.4 {
            logAlert(event: "Order book imbalance detected for \(exchange)-\(pair): \(String(format: "%.1f", imbalance * 100))%")
        }
        
        // Basic large order detection
        detectBasicLargeOrders(exchange: exchange, pair: pair, orderBook: orderBook)
    }
    
    @MainActor
    static func detectBasicLargeOrders(exchange: String, pair: String, orderBook: BevaixOrderBook) {
        // FIX: Use isEmpty property instead of accessing non-existent member
        guard !orderBook.isEmpty else { return }
        
        let avgBidSize = orderBook.bids.reduce(0) { $0 + $1.quantity } / Double(orderBook.bids.count)
        let avgAskSize = orderBook.asks.reduce(0) { $0 + $1.quantity } / Double(orderBook.asks.count)
        let avgSize = (avgBidSize + avgAskSize) / 2
        let largeOrderThreshold = avgSize * 5 // 5x average size
        
        var largeOrderCount = 0
        
        // Count large bids
        for bid in orderBook.bids {
            if bid.quantity > largeOrderThreshold {
                largeOrderCount += 1
            }
        }
        
        // Count large asks
        for ask in orderBook.asks {
            if ask.quantity > largeOrderThreshold {
                largeOrderCount += 1
            }
        }
        
        // Log if significant large orders found
        if largeOrderCount >= 3 {
            logAlert(event: "Multiple large orders detected in \(exchange)-\(pair): \(largeOrderCount) orders > \(String(format: "%.1f", largeOrderThreshold))")
        }
    }
    
    // Helper function for order book depth calculation
    static func calculateOrderBookDepth(_ orderBook: BevaixOrderBook) -> Double {
        let bidDepth = orderBook.bids.prefix(10).reduce(0) { $0 + ($1.price * $1.quantity) }
        let askDepth = orderBook.asks.prefix(10).reduce(0) { $0 + ($1.price * $1.quantity) }
        return bidDepth + askDepth
    }
    
    // ENHANCED: Cross-exchange liquidity comparison using existing variables
    @MainActor
    static func compareExchangeLiquidity(pair: String) -> String {
        let bybitBook = bybitOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
        let kucoinBook = kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
        
        let bybitDepth = calculateOrderBookDepth(bybitBook)
        let kucoinDepth = calculateOrderBookDepth(kucoinBook)
        
        let result = bybitDepth > kucoinDepth ? "bybit" : "kucoin"
        let diff = abs(bybitDepth - kucoinDepth)
        
        print("DEBUG: Liquidity comparison for \(pair) - Bybit: \(bybitDepth), KuCoin: \(kucoinDepth), Best: \(result)")
        
        if diff > 1000 { // Significant difference
            logAlert(event: "Significant liquidity difference for \(pair): \(result) has \(String(format: "%.0f", diff)) more depth")
        }
        
        return result
    }
    
    // ENHANCED: Real-time order book health check
    @MainActor
    static func checkOrderBookHealth(exchange: String, pair: String) -> Bool {
        let orderBook = exchange == "bybit" ?
            bybitOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: []) :
            kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
        
        // Basic health checks
        let hasSufficientLevels = orderBook.bids.count >= 5 && orderBook.asks.count >= 5
        let hasValidSpread = orderBook.bids.first?.price ?? 0 < (orderBook.asks.first?.price ?? Double.infinity)
        
        if !hasSufficientLevels {
            logAlert(event: "Insufficient order book levels for \(exchange)-\(pair): bids=\(orderBook.bids.count), asks=\(orderBook.asks.count)")
        }
        
        if !hasValidSpread {
            logAlert(event: "Invalid spread detected for \(exchange)-\(pair) - possible data issue")
        }
        
        return hasSufficientLevels && hasValidSpread
    }
}
//----------------------------------------------------------------------------------------------------------------------Block 4 - Technical Indicator Computations





extension ExchangeWebSocket {
    static func checkLiquidity(exchange: String, pair: String, marketType: String, tradeAmount: Double, price: Double) async -> Double? {
        let requiredLiquidity = tradeAmount * price * liquidityDepthMultiplier
        
        async let spotDepth = marketType == "spot" ? await fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: "spot") : nil
        async let futuresDepth = marketType == "futures" ? await fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: "futures") : nil
        
        do {
            let depth = try await (marketType == "spot" ? spotDepth : futuresDepth) ?? minLiquidityThreshold
            let totalLiquidity = depth
            
            if totalLiquidity < requiredLiquidity {
                print("Insufficient liquidity for \(exchange)-\(pair)-\(marketType): Depth \(totalLiquidity), Required \(requiredLiquidity)")
                await MainActor.run {
                    logAlert(event: "Insufficient liquidity for \(exchange)-\(pair)-\(marketType): Depth \(totalLiquidity), Required \(requiredLiquidity)")
                }
                return nil
            } else {
                print("DEBUG: Liquidity check passed for \(exchange)-\(pair)-\(marketType): Depth \(totalLiquidity)")
                return totalLiquidity
            }
        } catch {
            print("DEBUG: Error fetching order book depth for \(exchange)-\(pair)-\(marketType): \(error.localizedDescription)")
            await MainActor.run {
                logAlert(event: "Error fetching order book depth for \(exchange)-\(pair)-\(marketType): \(error.localizedDescription)")
            }
            return nil
        }
    }

    static func fetchOrderBookDepth(exchange: String, pair: String, marketType: String, retryCount: Int = 0) async throws -> Double? {
        let maxRetries = getInt("API_MAX_RETRIES", defaultValue: 3)
        guard retryCount < maxRetries else {
            print("Max retries reached for order book fetch: \(exchange)-\(pair)-\(marketType)")
            await MainActor.run {
                logAlert(event: "Max retries reached for order book fetch: \(exchange)-\(pair)-\(marketType)")
            }
            let book = exchange == "bybit" ? bybitOrderBooks[pair] : kucoinOrderBooks[pair]
            let cachedDepth = book.map { book in
                let bidDepth = book.bids.prefix(10).reduce(0.0) { $0 + $1.price * $1.quantity }
                let askDepth = book.asks.prefix(10).reduce(0.0) { $0 + $1.price * $1.quantity }
                return bidDepth + askDepth
            } ?? getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 500.0)
            print("DEBUG: Using cached depth for \(exchange)-\(pair)-\(marketType): \(cachedDepth)")
            return cachedDepth
        }

        var url: URL?
        let symbol = pair.replacingOccurrences(of: "-USDT", with: "USDT")
        
        if exchange == "bybit" {
            let category = marketType == "spot" ? "spot" : "linear"
            url = URL(string: "https://api.bybit.com/v5/market/orderbook?category=\(category)&symbol=\(symbol)&limit=50")
        } else {
            let endpoint = marketType == "spot" ? "/api/v1/market/orderbook/level2_50?symbol=\(symbol)" : "/api/v1/contractMarket/level2?symbol=\(symbol)M"
            url = URL(string: "https://api\(marketType == "spot" ? "" : "-futures").kucoin.com\(endpoint)")
        }

        guard let requestUrl = url else {
            print("Invalid order book URL for \(exchange)-\(pair)-\(marketType)")
            await MainActor.run {
                logAlert(event: "Invalid order book URL for \(exchange)-\(pair)-\(marketType)")
            }
            try await Task.sleep(nanoseconds: 2_000_000_000)
            return try await fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1)
        }

        var request = URLRequest(url: requestUrl)
        request.httpMethod = "GET"
        request.timeoutInterval = getDouble("API_TIMEOUT_SECONDS", defaultValue: 10.0)

        let startTime = Date()
        do {
            let (data, response) = try await URLSession.shared.data(for: request)
            let latency = Date().timeIntervalSince(startTime) * 1000
            await MainActor.run {
                lastLatency[pair] = latency
                if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 300.0) {
                    print("High latency detected for order book fetch: \(latency)ms")
                    logAlert(event: "High latency detected for order book fetch: \(latency)ms")
                }
            }

            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                print("Invalid order book response for \(exchange)-\(pair)-\(marketType)")
                await MainActor.run {
                    logAlert(event: "Invalid order book response for \(exchange)-\(pair)-\(marketType)")
                }
                try await Task.sleep(nanoseconds: 2_000_000_000)
                return try await fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1)
            }

            let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
            if exchange == "bybit" {
                guard let result = json?["result"] as? [String: Any],
                      let bids = result["b"] as? [[String]],
                      let asks = result["a"] as? [[String]],
                      !bids.isEmpty, !asks.isEmpty else {
                    print("Failed to parse Bybit order book data for \(pair)-\(marketType)")
                    await MainActor.run {
                        logAlert(event: "Failed to parse Bybit order book data for \(pair)-\(marketType)")
                    }
                    try await Task.sleep(nanoseconds: 2_000_000_000)
                    return try await fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1)
                }

                var bidDepth: Double = 0.0
                var askDepth: Double = 0.0

                for bid in bids.prefix(10) {
                    if let priceStr = bid.first, let qtyStr = bid.last,
                       let price = Double(priceStr), let qty = Double(qtyStr) {
                        bidDepth += price * qty
                    }
                }

                for ask in asks.prefix(10) {
                    if let priceStr = ask.first, let qtyStr = ask.last,
                       let price = Double(priceStr), let qty = Double(qtyStr) {
                        askDepth += price * qty
                    }
                }

                let totalDepth = bidDepth + askDepth
                print("DEBUG: Bybit order book depth for \(pair)-\(marketType): \(totalDepth)")
                return totalDepth
            } else {
                guard let dataDict = json?["data"] as? [String: Any],
                      let bids = dataDict["bids"] as? [[String]],
                      let asks = dataDict["asks"] as? [[String]],
                      !bids.isEmpty, !asks.isEmpty else {
                    print("Failed to parse KuCoin order book data for \(pair)-\(marketType)")
                    await MainActor.run {
                        logAlert(event: "Failed to parse KuCoin order book data for \(pair)-\(marketType)")
                    }
                    try await Task.sleep(nanoseconds: 2_000_000_000)
                    return try await fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1)
                }

                var bidDepth: Double = 0.0
                var askDepth: Double = 0.0

                for bid in bids.prefix(10) {
                    if let priceStr = bid.first, let qtyStr = bid.last,
                       let price = Double(priceStr), let qty = Double(qtyStr) {
                        bidDepth += price * qty
                    }
                }

                for ask in asks.prefix(10) {
                    if let priceStr = ask.first, let qtyStr = ask.last,
                       let price = Double(priceStr), let qty = Double(qtyStr) {
                        askDepth += price * qty
                    }
                }

                let totalDepth = bidDepth + askDepth
                print("DEBUG: KuCoin order book depth for \(pair)-\(marketType): \(totalDepth)")
                return totalDepth
            }
        } catch {
            print("Failed to fetch order book for \(exchange)-\(pair)-\(marketType): \(error.localizedDescription)")
            await MainActor.run {
                logAlert(event: "Failed to fetch order book for \(exchange)-\(pair)-\(marketType): \(error.localizedDescription)")
            }
            try await Task.sleep(nanoseconds: 2_000_000_000)
            return try await fetchOrderBookDepth(exchange: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1)
        }
    }
}




//------------------------------------------------------------------------------------------------------------------------------Block 5 - Risk Assessment and Management





extension ExchangeWebSocket {
    static func calculateEMA(prices: [Double], period: Int) -> Double? {
        guard prices.count >= period else { return nil }
        let k = 2.0 / Double(period + 1)
        var ema = prices[0]
        for i in 1..<prices.count {
            ema = prices[i] * k + ema * (1 - k)
        }
        return ema
    }

    static func calculateMultiTimeframeEMAs(pair: String, exchange: String, prices: [Double]) {
        let minPrices1 = Array(prices.suffix(60)) // 1-minute timeframe
        let minPrices5 = Array(prices.suffix(300)) // 5-minute timeframe
        let minPrices15 = Array(prices.suffix(900)) // 15-minute timeframe

        let shortPeriod = spotEmaShortPeriod
        let mediumPeriod = spotEmaMediumPeriod
        let longPeriod = spotEmaLongPeriod

        if let emaShort1 = calculateEMA(prices: minPrices1, period: shortPeriod),
           let emaMedium1 = calculateEMA(prices: minPrices1, period: mediumPeriod),
           let emaLong1 = calculateEMA(prices: minPrices1, period: longPeriod),
           let emaShort5 = calculateEMA(prices: minPrices5, period: shortPeriod),
           let emaMedium5 = calculateEMA(prices: minPrices5, period: mediumPeriod),
           let emaLong5 = calculateEMA(prices: minPrices5, period: longPeriod),
           let emaShort15 = calculateEMA(prices: minPrices15, period: shortPeriod),
           let emaMedium15 = calculateEMA(prices: minPrices15, period: mediumPeriod),
           let emaLong15 = calculateEMA(prices: minPrices15, period: longPeriod) {
            Task { @MainActor in
                if exchange == "kucoin" {
                    kucoinSpotEMA1Min[pair] = (emaShort1, emaMedium1, emaLong1)
                    kucoinSpotEMA5Min[pair] = (emaShort5, emaMedium5, emaLong5)
                    kucoinSpotEMA15Min[pair] = (emaShort15, emaMedium15, emaLong15)
                } else {
                    bybitSpotEMA1Min[pair] = (emaShort1, emaMedium1, emaLong1)
                    bybitSpotEMA5Min[pair] = (emaShort5, emaMedium5, emaLong5)
                    bybitSpotEMA15Min[pair] = (emaShort15, emaMedium15, emaLong15)
                }
            }
        }
    }

    static func calculateMACD(prices: [Double], shortPeriod: Int, longPeriod: Int, signalPeriod: Int) -> (macd: Double, signal: Double, histogram: Double)? {
        guard prices.count >= max(longPeriod, signalPeriod) else { return nil }
        
        guard let shortEMA = calculateEMA(prices: prices, period: shortPeriod),
              let longEMA = calculateEMA(prices: prices, period: longPeriod) else {
            return nil
        }
        
        let macd = shortEMA - longEMA
        let macdSeries = prices.suffix(signalPeriod).enumerated().map { _ in
            shortEMA - longEMA // Simplified, assumes recent prices for signal
        }
        
        guard let signal = calculateEMA(prices: macdSeries, period: signalPeriod) else {
            return nil
        }
        
        let histogram = macd - signal
        return (macd: macd, signal: signal, histogram: histogram)
    }

    static func calculateRSI(prices: [Double], period: Int) -> Double? {
        guard prices.count >= period + 1 else { return nil }
        var gains: [Double] = []
        var losses: [Double] = []
        for i in 1..<prices.count {
            let diff = prices[i] - prices[i - 1]
            if diff > 0 {
                gains.append(diff)
                losses.append(0)
            } else {
                gains.append(0)
                losses.append(abs(diff))
            }
        }
        guard gains.count >= period else { return nil }
        let avgGain = gains.suffix(period).reduce(0.0, +) / Double(period)
        let avgLoss = losses.suffix(period).reduce(0.0, +) / Double(period)
        guard avgLoss != 0 else { return 100 }
        let rs = avgGain / avgLoss
        return 100 - (100 / (1 + rs))
    }

    static func calculateATR(prices: [Double]) -> Double? {
        guard prices.count > 1 else { return nil }
        var trs: [Double] = []
        for i in 1..<prices.count {
            let highLow = abs(prices[i] - prices[i - 1])
            trs.append(highLow)
        }
        guard !trs.isEmpty else { return nil }
        return trs.reduce(0, +) / Double(trs.count)
    }

    static func calculateVaR(pair: String, tradeAmount: Double, prices: [Double]) -> Double? {
        guard prices.count >= 1440 else { return nil } // 24 hours of data
        let returns = prices.enumerated().dropFirst().map { (i, price) in
            log(price / prices[i - 1])
        }
        guard !returns.isEmpty else { return nil }
        let meanReturn = returns.reduce(0, +) / Double(returns.count)
        let variance = returns.reduce(0.0) { $0 + pow($1 - meanReturn, 2) } / Double(returns.count)
        let stdDev = sqrt(variance)
        let zScore = -1.645 // 95% confidence level
        let varValue = tradeAmount * (meanReturn + zScore * stdDev)
        Task { @MainActor in
            varEstimates[pair] = varValue
        }
        return varValue
    }

    static func calculateKellySize(pair: String, balance: Double, sentimentScore: Double) -> Double {
        let winProb = kellyWinProbability
        let rewardToRisk = kellyRewardToRisk
        let sentimentAdjustment = sentimentScore < 0 ? 0.5 : 1.0
        let kellyFraction = (winProb * (rewardToRisk + 1) - 1) / rewardToRisk
        let adjustedFraction = kellyFraction * sentimentAdjustment
        let positionSize = balance * max(0.01, min(0.3, adjustedFraction))
        Task { @MainActor in
            kellySizes[pair] = positionSize
        }
        return positionSize
    }

    static func checkVolatility(exchange: String, pair: String, atr: Double) -> Bool {
        let currentPrice = exchange == "bybit" ? bybitCurrentFuturesPrice[pair] ?? 0.0 : kucoinCurrentFuturesPrice[pair] ?? 0.0
        guard currentPrice > 0 else { return false }
        let atrPercentage = atr / currentPrice
        return atrPercentage >= atrMultiplier
    }

    static func detectVolatilitySpike(exchange: String, pair: String) -> Bool {
        let prices = exchange == "bybit" ? bybitFuturesPrices[pair] ?? [] : kucoinFuturesPrices[pair] ?? []
        guard prices.count >= volatilitySpikeWindowMinutes else { return false }
        let recentPrices = prices.suffix(volatilitySpikeWindowMinutes)
        guard let minPrice = recentPrices.min(), let maxPrice = recentPrices.max() else { return false }
        let priceRange = (maxPrice - minPrice) / minPrice
        return priceRange >= volatilitySpikeThreshold
    }

    static func checkVolumeAnomaly(exchange: String, pair: String, marketType: String) -> Bool {
        let volumes: [Double]
        switch (exchange, marketType) {
        case ("kucoin", "spot"):
            volumes = kucoinSpotVolume[pair] ?? []
        case ("kucoin", "futures"):
            volumes = kucoinFuturesVolume[pair] ?? []
        case ("bybit", "spot"):
            volumes = bybitSpotVolume[pair] ?? []
        case ("bybit", "futures"):
            volumes = bybitFuturesVolume[pair] ?? []
        default:
            return false
        }
        guard volumes.count >= volumeAnomalyWindowHours * 60 else { return false }
        let recentVolumes = volumes.suffix(volumeAnomalyWindowHours * 60)
        let avgVolume = recentVolumes.reduce(0, +) / Double(recentVolumes.count)
        guard let maxVolume = recentVolumes.max() else { return false }
        return maxVolume >= avgVolume * volumeAnomalyMultiplier
    }

    static func isPrimeTradingTime() -> Bool {
        let calendar = Calendar(identifier: .gregorian)
        let now = Date()
        guard let gmtZone = TimeZone(identifier: "GMT") else { return false }
        let components = calendar.dateComponents(in: gmtZone, from: now)
        guard let currentHour = components.hour else { return false }
        let londonHours = 8...17
        let nyHours = 13...22
        return londonHours.contains(currentHour) || nyHours.contains(currentHour)
    }

    static func dynamicCooldown(volatility: Double) -> Double {
        return max(2, min(10, 10 * (1 - volatility)))
    }

    static func calculateBollingerBands(prices: [Double], period: Int, multiplier: Double = 2.0) -> (upper: Double, middle: Double, lower: Double)? {
        guard prices.count >= period else { return nil }
        let recentPrices = prices.suffix(period)
        let sma = recentPrices.reduce(0, +) / Double(period)
        let variance = recentPrices.reduce(0.0) { $0 + pow($1 - sma, 2) } / Double(period)
        let stdDev = sqrt(variance)
        let upperBand = sma + multiplier * stdDev
        let lowerBand = sma - multiplier * stdDev
        return (upper: upperBand, middle: sma, lower: lowerBand)
    }

    static func calculateFundingRateTrend(pair: String, exchange: String) -> Double? {
        let history = exchange == "bybit" ? bybitFundingRateHistory[pair] ?? [] : kucoinFundingRateHistory[pair] ?? []
        guard history.count >= 3 else { return nil }
        let recentRates = history.suffix(3)
        let trend = recentRates.enumerated().reduce(0.0) { (sum, item) in
            sum + (item.element - (recentRates[recentRates.count - 1] / Double(recentRates.count)))
        } / Double(recentRates.count)
        return trend
    }
}



//-----------------------------------------------------------------------------------------------------------------------Block 6 - Account Balance and API Initialization

//--------------- Block 6 - Account Balance and API Initialization
// VARIABLES TO ADD: Fixed MainActor isolation issues by using await MainActor.run for fallback balance access

extension ExchangeWebSocket {
    static func monitorFundingRateArbitrage() {
        Task {
            await withTaskGroup(of: Void.self) { group in
                let tradingPairsValue = await MainActor.run(body: { tradingPairs })
                for pair in tradingPairsValue {
                    group.addTask { @MainActor @Sendable in
                        let kucoinFundingRate = kucoinFundingRates[pair] ?? 0.0
                        let bybitFundingRate = bybitFundingRates[pair] ?? 0.0
                        let kucoinSpotPrice = kucoinCurrentPrice[pair] ?? 0.0
                        let bybitSpotPrice = bybitCurrentPrice[pair] ?? 0.0
                        let maxFundingRateValue = maxFundingRate
                        
                        guard kucoinSpotPrice > 0, bybitSpotPrice > 0 else {
                            print("DEBUG: Invalid prices for funding rate arbitrage - \(pair): KuCoin=\(kucoinSpotPrice), Bybit=\(bybitSpotPrice)")
                            return
                        }
                        
                        if kucoinFundingRate > maxFundingRateValue || bybitFundingRate > maxFundingRateValue {
                            print("DEBUG: Funding rate too high for \(pair): KuCoin=\(kucoinFundingRate), Bybit=\(bybitFundingRate)")
                            logAlert(event: "Funding rate too high for \(pair): KuCoin=\(kucoinFundingRate), Bybit=\(bybitFundingRate)")
                            return
                        }
                        
                        let tradeAmount = futuresTradeAmount
                        let kucoinLiquidity = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "futures", tradeAmount: tradeAmount, price: kucoinSpotPrice)
                        let bybitLiquidity = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "futures", tradeAmount: tradeAmount, price: bybitSpotPrice)
                        
                        // Use liquidity variables to validate before proceeding
                        guard let kucoinLiquidity = kucoinLiquidity, let bybitLiquidity = bybitLiquidity, kucoinLiquidity >= minLiquidityThreshold, bybitLiquidity >= minLiquidityThreshold else {
                            print("DEBUG: Insufficient liquidity for funding rate arbitrage - \(pair): KuCoin=\(kucoinLiquidity ?? 0.0), Bybit=\(bybitLiquidity ?? 0.0)")
                            logAlert(event: "Insufficient liquidity for funding rate arbitrage - \(pair): KuCoin=\(kucoinLiquidity ?? 0.0), Bybit=\(bybitLiquidity ?? 0.0)")
                            return
                        }
                        
                        let kucoinTradeAmount = await dynamicTradeAmount(balance: kucoinBalance, riskPercent: tradeAmountPercentage, volatility: 0.01)
                        let bybitTradeAmount = await dynamicTradeAmount(balance: bybitBalance, riskPercent: tradeAmountPercentage, volatility: 0.01)
                        
                        // Use trade amount variables to validate before proceeding
                        guard kucoinTradeAmount > 0, bybitTradeAmount > 0 else {
                            print("DEBUG: Invalid trade amounts for funding rate arbitrage - \(pair): KuCoin=\(kucoinTradeAmount), Bybit=\(bybitTradeAmount)")
                            logAlert(event: "Invalid trade amounts for funding rate arbitrage - \(pair): KuCoin=\(kucoinTradeAmount), Bybit=\(bybitTradeAmount)")
                            return
                        }
                        
                        await evaluateFundingRateMomentum(pair: pair, kucoinFundingRate: kucoinFundingRate, bybitFundingRate: bybitFundingRate)
                    }
                }
            }
            
            // Schedule the next check
            try? await Task.sleep(nanoseconds: UInt64(getDouble("ARBITRAGE_CHECK_INTERVAL_SECONDS", defaultValue: 0.5) * 1_000_000_000))
            monitorFundingRateArbitrage()
        }
    }

    static func fetchKuCoinWsToken(completion: @escaping @Sendable (String?) -> Void) {
        let url = URL(string: "https://api.kucoin.com/api/v1/bullet-public")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.timeoutInterval = getDouble("API_TIMEOUT_SECONDS", defaultValue: 10.0)
        
        let startTime = Date()
        URLSession.shared.dataTask(with: request) { data, response, error in
            let latency = Date().timeIntervalSince(startTime) * 1000
            Task { @MainActor in
                lastLatency["kucoin-ws-token"] = latency
                if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 300.0) {
                    print("High latency detected for KuCoin WebSocket token fetch: \(latency)ms")
                    logAlert(event: "High latency detected for KuCoin WebSocket token fetch: \(latency)ms")
                }
            }
            
            if let error = error {
                print("Failed to fetch KuCoin WebSocket token: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to fetch KuCoin WebSocket token: \(error.localizedDescription)")
                }
                completion(nil)
                return
            }
            
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200, let data = data else {
                print("Invalid KuCoin WebSocket token response")
                Task { @MainActor in
                    logAlert(event: "Invalid KuCoin WebSocket token response")
                }
                completion(nil)
                return
            }
            
            do {
                guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                      let dataDict = json["data"] as? [String: Any],
                      let token = dataDict["token"] as? String else {
                    print("Failed to parse KuCoin WebSocket token")
                    Task { @MainActor in
                        logAlert(event: "Failed to parse KuCoin WebSocket token")
                    }
                    completion(nil)
                    return
                }
                
                Task { @MainActor in
                    kucoinToken = token
                    print("DEBUG: Fetched KuCoin WebSocket token: \(token)")
                    kucoinSocket = WebSocket(request: URLRequest(url: URL(string: "wss://ws-api.kucoin.com/endpoint?token=\(token)")!))
                    kucoinSocket?.delegate = kucoinDelegate
                    kucoinSocket?.connect()
                    print("DEBUG: KuCoin WebSocket connected for token: \(token)")
                }
                completion(token)
            } catch {
                print("Failed to parse JSON for KuCoin WebSocket token: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to parse JSON for KuCoin WebSocket token: \(error.localizedDescription)")
                }
                completion(nil)
            }
        }.resume()
    }

    static func fetchKucoinFuturesWsToken(completion: @escaping @Sendable (String?) -> Void) {
        let url = URL(string: "https://api-futures.kucoin.com/api/v1/bullet-public")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.timeoutInterval = getDouble("API_TIMEOUT_SECONDS", defaultValue: 10.0)
        
        let startTime = Date()
        URLSession.shared.dataTask(with: request) { data, response, error in
            let latency = Date().timeIntervalSince(startTime) * 1000
            Task { @MainActor in
                lastLatency["kucoin-futures-ws-token"] = latency
                if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 300.0) {
                    print("High latency detected for KuCoin Futures WebSocket token fetch: \(latency)ms")
                    logAlert(event: "High latency detected for KuCoin Futures WebSocket token fetch: \(latency)ms")
                }
            }
            
            if let error = error {
                print("Failed to fetch KuCoin Futures WebSocket token: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to fetch KuCoin Futures WebSocket token: \(error.localizedDescription)")
                }
                completion(nil)
                return
            }
            
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200, let data = data else {
                print("Invalid KuCoin Futures WebSocket token response")
                Task { @MainActor in
                    logAlert(event: "Invalid KuCoin Futures WebSocket token response")
                }
                completion(nil)
                return
            }
            
            do {
                guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                      let dataDict = json["data"] as? [String: Any],
                      let token = dataDict["token"] as? String else {
                    print("Failed to parse KuCoin Futures WebSocket token")
                    Task { @MainActor in
                        logAlert(event: "Failed to parse KuCoin Futures WebSocket token")
                    }
                    completion(nil)
                    return
                }
                
                Task { @MainActor in
                    kucoinFuturesToken = token
                    print("DEBUG: Fetched KuCoin Futures WebSocket token: \(token)")
                    kucoinFuturesSocket = WebSocket(request: URLRequest(url: URL(string: "wss://ws-api-futures.kucoin.com/endpoint?token=\(token)")!))
                    kucoinFuturesSocket?.delegate = kucoinFuturesDelegate
                    kucoinFuturesSocket?.connect()
                    print("DEBUG: KuCoin Futures WebSocket connected for token: \(token)")
                }
                completion(token)
            } catch {
                print("Failed to parse JSON for KuCoin Futures WebSocket token: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to parse JSON for KuCoin Futures WebSocket token: \(error.localizedDescription)")
                }
                completion(nil)
            }
        }.resume()
    }

    static func fetchKucoinBalance(completion: @escaping @Sendable (Double?) -> Void) {
        guard let apiKey = environment["KUCOIN_API_KEY"],
              let apiSecret = environment["KUCOIN_API_SECRET"],
              let apiPassphrase = environment["KUCOIN_API_PASSPHRASE"] else {
            print("Missing KuCoin API credentials")
            Task { @MainActor in
                logAlert(event: "Missing KuCoin API credentials")
            }
            Task { @MainActor in
                // FIX: Access fallback balance within MainActor context
                let fallbackValue = await MainActor.run { kucoinFallbackBalance }
                completion(fallbackValue)
            }
            return
        }
        
        let url = URL(string: "https://api.kucoin.com/api/v1/accounts")!
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = getDouble("BALANCE_FETCH_TIMEOUT", defaultValue: 20.0)
        
        let timestamp = String(Int(Date().timeIntervalSince1970 * 1000))
        let strToSign = timestamp + "GET" + "/api/v1/accounts"
        let signature = HMAC<SHA256>.authenticationCode(for: strToSign.data(using: .utf8)!, using: SymmetricKey(data: apiSecret.data(using: .utf8)!)).map { String(format: "%02x", $0) }.joined()
        let passphrase = HMAC<SHA256>.authenticationCode(for: apiPassphrase.data(using: .utf8)!, using: SymmetricKey(data: apiSecret.data(using: .utf8)!)).map { String(format: "%02x", $0) }.joined()
        
        request.addValue(apiKey, forHTTPHeaderField: "KC-API-KEY")
        request.addValue(timestamp, forHTTPHeaderField: "KC-API-TIMESTAMP")
        request.addValue(signature, forHTTPHeaderField: "KC-API-SIGN")
        request.addValue(passphrase, forHTTPHeaderField: "KC-API-PASSPHRASE")
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        
        let startTime = Date()
        URLSession.shared.dataTask(with: request) { data, response, error in
            let latency = Date().timeIntervalSince(startTime) * 1000
            Task { @MainActor in
                lastLatency["kucoin-balance"] = latency
                if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 300.0) {
                    print("High latency detected for KuCoin balance fetch: \(latency)ms")
                    logAlert(event: "High latency detected for KuCoin balance fetch: \(latency)ms")
                }
            }
            
            if let error = error {
                print("Failed to fetch KuCoin balance: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to fetch KuCoin balance: \(error.localizedDescription)")
                }
                Task { @MainActor in
                    // FIX: Access fallback balance within MainActor context
                    let fallbackValue = await MainActor.run { kucoinFallbackBalance }
                    completion(fallbackValue)
                }
                return
            }
            
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200, let data = data else {
                print("Invalid KuCoin balance response")
                Task { @MainActor in
                    logAlert(event: "Invalid KuCoin balance response")
                }
                Task { @MainActor in
                    // FIX: Access fallback balance within MainActor context
                    let fallbackValue = await MainActor.run { kucoinFallbackBalance }
                    completion(fallbackValue)
                }
                return
            }
            
            do {
                guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                      let dataArray = json["data"] as? [[String: Any]],
                      let usdtAccount = dataArray.first(where: { ($0["currency"] as? String) == "USDT" }),
                      let balanceStr = usdtAccount["balance"] as? String,
                      let balance = Double(balanceStr) else {
                    print("Failed to parse KuCoin balance")
                    Task { @MainActor in
                        logAlert(event: "Failed to parse KuCoin balance")
                    }
                    Task { @MainActor in
                        // FIX: Access fallback balance within MainActor context
                        let fallbackValue = await MainActor.run { kucoinFallbackBalance }
                        completion(fallbackValue)
                    }
                    return
                }
                
                Task { @MainActor in
                    kucoinBalance = balance
                    print("DEBUG: Fetched KuCoin balance: \(balance)")
                    completion(balance)
                }
            } catch {
                print("Failed to parse JSON for KuCoin balance: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to parse JSON for KuCoin balance: \(error.localizedDescription)")
                }
                Task { @MainActor in
                    // FIX: Access fallback balance within MainActor context
                    let fallbackValue = await MainActor.run { kucoinFallbackBalance }
                    completion(fallbackValue)
                }
            }
        }.resume()
    }

    static func fetchBybitBalance(completion: @escaping @Sendable (Double?) -> Void) {
        guard let apiKey = environment["BYBIT_API_KEY"],
              let apiSecret = environment["BYBIT_API_SECRET"] else {
            print("Missing Bybit API credentials")
            Task { @MainActor in
                logAlert(event: "Missing Bybit API credentials")
            }
            Task { @MainActor in
                // FIX: Access fallback balance within MainActor context
                let fallbackValue = await MainActor.run { bybitFallbackBalance }
                completion(fallbackValue)
            }
            return
        }
        
        let url = URL(string: "https://api.bybit.com/v5/account/wallet-balance?accountType=UNIFIED")!
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = getDouble("BALANCE_FETCH_TIMEOUT", defaultValue: 20.0)
        
        let timestamp = String(Int(Date().timeIntervalSince1970 * 1000))
        let recvWindow = bybitRecvWindow
        let queryString = "api_key=\(apiKey)tamp=\(timestamp)&recv_window=\(recvWindow)"
        let signature = HMAC<SHA256>.authenticationCode(for: queryString.data(using: .utf8)!, using: SymmetricKey(data: apiSecret.data(using: .utf8)!)).map { String(format: "%02x", $0) }.joined()
        
        request.addValue(apiKey, forHTTPHeaderField: "X-BAPI-API-KEY")
        request.addValue(timestamp, forHTTPHeaderField: "X-BAPI-TIMESTAMP")
        request.addValue(signature, forHTTPHeaderField: "X-BAPI-SIGN")
        request.addValue(recvWindow, forHTTPHeaderField: "X-BAPI-RECV-WINDOW")
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        
        let startTime = Date()
        URLSession.shared.dataTask(with: request) { data, response, error in
            let latency = Date().timeIntervalSince(startTime) * 1000
            Task { @MainActor in
                lastLatency["bybit-balance"] = latency
                if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 300.0) {
                    print("High latency detected for Bybit balance fetch: \(latency)ms")
                    logAlert(event: "High latency detected for Bybit balance fetch: \(latency)ms")
                }
            }
            
            if let error = error {
                print("Failed to fetch Bybit balance: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to fetch Bybit balance: \(error.localizedDescription)")
                }
                Task { @MainActor in
                    // FIX: Access fallback balance within MainActor context
                    let fallbackValue = await MainActor.run { bybitFallbackBalance }
                    completion(fallbackValue)
                }
                return
            }
            
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200, let data = data else {
                print("Invalid Bybit balance response")
                Task { @MainActor in
                    logAlert(event: "Invalid Bybit balance response")
                }
                Task { @MainActor in
                    // FIX: Access fallback balance within MainActor context
                    let fallbackValue = await MainActor.run { bybitFallbackBalance }
                    completion(fallbackValue)
                }
                return
            }
            
            do {
                guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                      let result = json["result"] as? [String: Any],
                      let list = result["list"] as? [[String: Any]],
                      let unifiedAccount = list.first,
                      let coinArray = unifiedAccount["coin"] as? [[String: Any]],
                      let usdtCoin = coinArray.first(where: { ($0["coin"] as? String) == "USDT" }),
                      let balanceStr = usdtCoin["equity"] as? String,
                      let balance = Double(balanceStr) else {
                    print("Failed to parse Bybit balance")
                    Task { @MainActor in
                        logAlert(event: "Failed to parse Bybit balance")
                    }
                    Task { @MainActor in
                        // FIX: Access fallback balance within MainActor context
                        let fallbackValue = await MainActor.run { bybitFallbackBalance }
                        completion(fallbackValue)
                    }
                    return
                }
                
                Task { @MainActor in
                    bybitBalance = balance
                    print("DEBUG: Fetched Bybit balance: \(balance)")
                    completion(balance)
                }
            } catch {
                print("Failed to parse JSON for Bybit balance: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to parse JSON for Bybit balance: \(error.localizedDescription)")
                }
                Task { @MainActor in
                    // FIX: Access fallback balance within MainActor context
                    let fallbackValue = await MainActor.run { bybitFallbackBalance }
                    completion(fallbackValue)
                }
            }
        }.resume()
    }
}

//-------------------------------------------------------------------------------------------------------------------Block 7 - WebSocket Connection Handling





extension ExchangeWebSocket {
    static func connectKucoinWebSocket(completion: @escaping () -> Void) {
        guard !kucoinIsConnected else {
            print("KuCoin WebSocket already connected")
            completion()
            return
        }

        guard let token = kucoinToken else {
            print("KuCoin WebSocket token not available")
            Task { @MainActor in
                logAlert(event: "KuCoin WebSocket token not available")
            }
            completion()
            return
        }

        let url = URL(string: "wss://ws-api.kucoin.com/endpoint?token=\(token)")!
        var request = URLRequest(url: url)
        request.timeoutInterval = Double(websocketTimeoutSeconds)
        kucoinSocket = WebSocket(request: request)
        
        kucoinSocket?.onEvent = { event in
            switch event {
            case .connected(_):
                Task { @MainActor in
                    kucoinIsConnected = true
                    kucoinReconnectAttempts = 0
                    print("KuCoin WebSocket connected")
                    logAlert(event: "KuCoin WebSocket connected")
                }
                completion()
            case .disconnected(let reason, let code):
                Task { @MainActor in
                    kucoinIsConnected = false
                    print("KuCoin WebSocket disconnected: \(reason), code: \(code)")
                    logAlert(event: "KuCoin WebSocket disconnected: \(reason), code: \(code)")
                    if kucoinReconnectAttempts < maxReconnectAttempts {
                        kucoinReconnectAttempts += 1
                        DispatchQueue.main.asyncAfter(deadline: .now() + 5.0) {
                            connectKucoinWebSocket(completion: completion)
                        }
                    }
                }
            case .text(let string):
                do {
                    guard let json = try JSONSerialization.jsonObject(with: string.data(using: .utf8)!) as? [String: Any],
                          let type = json["type"] as? String else { return }
                    
                    if type == "message", let data = json["data"] as? [String: Any], let topic = json["topic"] as? String {
                        let components = topic.components(separatedBy: ":")
                        guard components.count > 1 else { return }
                        let pair = components[1].replacingOccurrences(of: "USDTM", with: "-USDT")
                        
                        if topic.contains("/market/ticker") {
                            if let priceStr = data["price"] as? String, let price = Double(priceStr) {
                                Task { @MainActor in
                                    kucoinCurrentPrice[pair] = price
                                    kucoinPrices[pair, default: []].append(price)
                                    if kucoinPrices[pair]!.count > priceHistoryRetention {
                                        kucoinPrices[pair]!.removeFirst()
                                    }
                                    lastPriceUpdate[pair] = (price: price, timestamp: Date())
                                    print("DEBUG: KuCoin \(pair) price updated: \(price)")
                                }
                            }
                        } else if topic.contains("/market/level2") {
                            if let dataDict = data["data"] as? [String: Any],
                               let bids = dataDict["bids"] as? [[String]],
                               let asks = dataDict["asks"] as? [[String]] {
                                let bidBook = bids.compactMap { arr -> (price: Double, quantity: Double)? in
                                    guard let priceStr = arr.first, let qtyStr = arr.last,
                                          let price = Double(priceStr), let qty = Double(qtyStr) else { return nil }
                                    return (price: price, quantity: qty)
                                }
                                let askBook = asks.compactMap { arr -> (price: Double, quantity: Double)? in
                                    guard let priceStr = arr.first, let qtyStr = arr.last,
                                          let price = Double(priceStr), let qty = Double(qtyStr) else { return nil }
                                    return (price: price, quantity: qty)
                                }
                                Task { @MainActor in
                                    kucoinOrderBooks[pair] = BevaixOrderBook(bids: bidBook, asks: askBook)
                                    print("DEBUG: Updated KuCoin order book for \(pair): bids=\(bidBook.count), asks=\(askBook.count)")
                                }
                            }
                        }
                    } else if type == "pong" {
                        Task { @MainActor in
                            lastHeartbeat["kucoin"] = Date()
                        }
                    }
                } catch {
                    print("DEBUG: Failed to parse KuCoin WebSocket message: \(error.localizedDescription)")
                    Task { @MainActor in
                        logAlert(event: "Failed to parse KuCoin WebSocket message: \(error.localizedDescription)")
                    }
                }
            case .error(let error):
                print("KuCoin WebSocket error: \(error?.localizedDescription ?? "Unknown error")")
                Task { @MainActor in
                    logAlert(event: "KuCoin WebSocket error: \(error?.localizedDescription ?? "Unknown error")")
                }
            default:
                break
            }
        }
        
        kucoinSocket?.connect()
        Task {
            try await Task.sleep(nanoseconds: 10_000_000_000) // 10 seconds
            if !kucoinIsConnected {
                print("KuCoin WebSocket connection timed out")
                Task { @MainActor in
                    logAlert(event: "KuCoin WebSocket connection timed out")
                }
                kucoinSocket?.disconnect()
                if kucoinReconnectAttempts < maxReconnectAttempts {
                    kucoinReconnectAttempts += 1
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5.0) {
                        connectKucoinWebSocket(completion: completion)
                    }
                }
            }
        }
    }

    static func connectBybitWebSocket(completion: @escaping () -> Void) {
        guard !bybitIsConnected else {
            print("Bybit WebSocket already connected")
            completion()
            return
        }

        let url = URL(string: "wss://stream.bybit.com/v5/public/linear")!
        var request = URLRequest(url: url)
        request.timeoutInterval = Double(websocketTimeoutSeconds)
        bybitSocket = WebSocket(request: request)
        
        bybitSocket?.onEvent = { event in
            switch event {
            case .connected(_):
                Task { @MainActor in
                    bybitIsConnected = true
                    bybitReconnectAttempts = 0
                    print("Bybit WebSocket connected")
                    logAlert(event: "Bybit WebSocket connected")
                    let subscribeMessage: [String: Any] = [
                        "op": "subscribe",
                        "args": tradingPairs.map { "orderBook_50.\($0.replacingOccurrences(of: "-USDT", with: "USDT"))" } +
                                tradingPairs.map { "tickers.\($0.replacingOccurrences(of: "-USDT", with: "USDT"))" }
                    ]
                    do {
                        let jsonData = try JSONSerialization.data(withJSONObject: subscribeMessage)
                        bybitSocket?.write(data: jsonData)
                        print("DEBUG: Sent Bybit WebSocket subscription: \(subscribeMessage)")
                    } catch {
                        print("DEBUG: Failed to send Bybit WebSocket subscription: \(error.localizedDescription)")
                        Task { @MainActor in
                            logAlert(event: "Failed to send Bybit WebSocket subscription: \(error.localizedDescription)")
                        }
                    }
                }
                completion()
            case .disconnected(let reason, let code):
                Task { @MainActor in
                    bybitIsConnected = false
                    print("Bybit WebSocket disconnected: \(reason), code: \(code)")
                    logAlert(event: "Bybit WebSocket disconnected: \(reason), code: \(code)")
                    if bybitReconnectAttempts < maxReconnectAttempts {
                        bybitReconnectAttempts += 1
                        DispatchQueue.main.asyncAfter(deadline: .now() + 5.0) {
                            connectBybitWebSocket(completion: completion)
                        }
                    }
                }
            case .text(let string):
                do {
                    guard let json = try JSONSerialization.jsonObject(with: string.data(using: .utf8)!) as? [String: Any],
                          let topic = json["topic"] as? String else { return }
                    
                    let pair = topic.components(separatedBy: ".").last!.replacingOccurrences(of: "USDT", with: "-USDT")
                    if topic.contains("orderBook") {
                        if let data = json["data"] as? [String: Any],
                           let bids = data["b"] as? [[String]],
                           let asks = data["a"] as? [[String]] {
                            let bidBook = bids.compactMap { arr -> (price: Double, quantity: Double)? in
                                guard let priceStr = arr.first, let qtyStr = arr.last,
                                      let price = Double(priceStr), let qty = Double(qtyStr) else { return nil }
                                return (price: price, quantity: qty)
                            }
                            let askBook = asks.compactMap { arr -> (price: Double, quantity: Double)? in
                                guard let priceStr = arr.first, let qtyStr = arr.last,
                                      let price = Double(priceStr), let qty = Double(qtyStr) else { return nil }
                                return (price: price, quantity: qty)
                            }
                            Task { @MainActor in
                                bybitOrderBooks[pair] = BevaixOrderBook(bids: bidBook, asks: askBook)
                                print("DEBUG: Updated Bybit order book for \(pair): bids=\(bidBook.count), asks=\(askBook.count)")
                            }
                        }
                    } else if topic.contains("tickers") {
                        if let data = json["data"] as? [String: Any],
                           let priceStr = data["lastPrice"] as? String,
                           let price = Double(priceStr) {
                            Task { @MainActor in
                                bybitCurrentPrice[pair] = price
                                bybitPrices[pair, default: []].append(price)
                                if bybitPrices[pair]!.count > priceHistoryRetention {
                                    bybitPrices[pair]!.removeFirst()
                                }
                                lastPriceUpdate[pair] = (price: price, timestamp: Date())
                                print("DEBUG: Bybit \(pair) price updated: \(price)")
                            }
                        }
                    }
                } catch {
                    print("DEBUG: Failed to parse Bybit WebSocket message: \(error.localizedDescription)")
                    Task { @MainActor in
                        logAlert(event: "Failed to parse Bybit WebSocket message: \(error.localizedDescription)")
                    }
                }
            case .error(let error):
                print("Bybit WebSocket error: \(error?.localizedDescription ?? "Unknown error")")
                Task { @MainActor in
                    logAlert(event: "Bybit WebSocket error: \(error?.localizedDescription ?? "Unknown error")")
                }
            default:
                break
            }
        }
        
        bybitSocket?.connect()
        Task {
            try await Task.sleep(nanoseconds: 10_000_000_000) // 10 seconds
            if !bybitIsConnected {
                print("Bybit WebSocket connection timed out")
                Task { @MainActor in
                    logAlert(event: "Bybit WebSocket connection timed out")
                }
                bybitSocket?.disconnect()
                if bybitReconnectAttempts < maxReconnectAttempts {
                    bybitReconnectAttempts += 1
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5.0) {
                        connectBybitWebSocket(completion: completion)
                    }
                }
            }
        }
    }
}


//---------------------------------------------------------------------------------------------------------------------Block 8 - WebSocket Delegate Operations


import Foundation
import CryptoKit // Added for HMAC-SHA256

extension ExchangeWebSocket {
    static func fetchBybitFundingRate(pair: String, retryCount: Int = 0, completion: @escaping @Sendable (Double?) -> Void) {
        let maxRetries = getInt("API_MAX_RETRIES", defaultValue: 3)
        let localRetryCountCopy = retryCount // Local copy to avoid mutation
        guard localRetryCountCopy < maxRetries else {
            print("Max retries reached for Bybit funding rate fetch: \(pair)")
            Task { @MainActor in
                logAlert(event: "Max retries reached for Bybit funding rate fetch: \(pair)")
            }
            Task { @MainActor in
                completion(bybitFundingRates[pair])
            }
            return
        }

        let symbol = pair.replacingOccurrences(of: "-USDT", with: "USDT")
        let url = URL(string: "https://api.bybit.com/v5/market/tickers?category=linear&symbol=\(symbol)")!
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = getDouble("API_TIMEOUT_SECONDS", defaultValue: 15.0)

        let startTime = Date()
        URLSession.shared.dataTask(with: request) { data, response, error in
            let latency = Date().timeIntervalSince(startTime) * 1000
            Task { @MainActor in
                lastLatency[pair] = latency
                if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 200.0) {
                    print("High latency detected for Bybit funding rate fetch: \(pair) - \(latency)ms")
                    logAlert(event: "High latency detected for Bybit funding rate fetch: \(pair) - \(latency)ms")
                }
            }

            if let error = error {
                print("Failed to fetch Bybit funding rate for \(pair): \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to fetch Bybit funding rate for \(pair): \(error.localizedDescription)")
                }
                let attemptFetch: @Sendable (_: Int) -> Void = { _ in
                    let newRetryCount = localRetryCountCopy + 1
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                        fetchBybitFundingRate(pair: pair, retryCount: newRetryCount, completion: completion)
                    }
                }
                attemptFetch(localRetryCountCopy)
                return
            }

            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200, let data = data else {
                print("Invalid Bybit funding rate response for \(pair)")
                Task { @MainActor in
                    logAlert(event: "Invalid Bybit funding rate response for \(pair)")
                }
                let attemptFetch: @Sendable (_: Int) -> Void = { _ in
                    let newRetryCount = localRetryCountCopy + 1
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                        fetchBybitFundingRate(pair: pair, retryCount: newRetryCount, completion: completion)
                    }
                }
                attemptFetch(localRetryCountCopy)
                return
            }

            do {
                guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                      let result = json["result"] as? [String: Any],
                      let list = result["list"] as? [[String: Any]],
                      let fundingRateStr = list.first?["fundingRate"] as? String,
                      let fundingRate = Double(fundingRateStr) else {
                    print("Failed to parse Bybit funding rate for \(pair)")
                    Task { @MainActor in
                        logAlert(event: "Failed to parse Bybit funding rate for \(pair)")
                    }
                    let attemptFetch: @Sendable (_: Int) -> Void = { _ in
                        let newRetryCount = localRetryCountCopy + 1
                        DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                            fetchBybitFundingRate(pair: pair, retryCount: newRetryCount, completion: completion)
                        }
                    }
                    attemptFetch(localRetryCountCopy)
                    return
                }

                Task { @MainActor in
                    bybitFundingRates[pair] = fundingRate
                    bybitFundingRateHistory[pair, default: []].append(fundingRate)
                    if bybitFundingRateHistory[pair]!.count > priceHistoryRetention {
                        bybitFundingRateHistory[pair]!.removeFirst()
                    }
                    print("DEBUG: Fetched Bybit funding rate for \(pair): \(fundingRate)")
                    completion(fundingRate)
                }
            } catch {
                print("DEBUG: JSON parsing error for Bybit funding rate \(pair): \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "JSON parsing error for Bybit funding rate \(pair): \(error.localizedDescription)")
                }
                let attemptFetch: @Sendable (_: Int) -> Void = { _ in
                    let newRetryCount = localRetryCountCopy + 1
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                        fetchBybitFundingRate(pair: pair, retryCount: newRetryCount, completion: completion)
                    }
                }
                attemptFetch(localRetryCountCopy)
            }
        }.resume()
    }

    static func fetchKucoinOrderBookDepth(pair: String, marketType: String, retryCount: Int = 0, completion: @escaping @Sendable (Double?) -> Void) {
        let maxRetries = getInt("API_MAX_RETRIES", defaultValue: 3)
        let localRetryCountCopy = retryCount // Local copy to avoid mutation
        guard localRetryCountCopy < maxRetries else {
            print("Max retries reached for KuCoin order book fetch: \(pair)-\(marketType)")
            Task { @MainActor in
                logAlert(event: "Max retries reached for KuCoin order book fetch: \(pair)-\(marketType)")
                let book = kucoinOrderBooks[pair]
                let cachedDepth = book.map { book in
                    let bidDepth = book.bids.prefix(10).reduce(0.0) { $0 + $1.price * $1.quantity }
                    let askDepth = book.asks.prefix(10).reduce(0.0) { $0 + $1.price * $1.quantity }
                    return bidDepth + askDepth
                } ?? getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 20000.0)
                print("DEBUG: Using cached depth for KuCoin \(pair)-\(marketType): \(cachedDepth)")
                if cachedDepth < getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 20000.0) {
                    logAlert(event: "Insufficient cached depth for KuCoin \(pair)-\(marketType): Depth \(cachedDepth), Required \(getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 20000.0))")
                }
                completion(cachedDepth)
            }
            return
        }

        // Rate limit check
        let refreshRate = getDouble("MIN_ORDERBOOK_REFRESH_RATE", defaultValue: marketType == "spot" ? 3.0 : 1.0)
        let lastFetchTime = ExchangeWebSocket.lastKucoinFetchTime[pair, default: .distantPast]
        let timeSinceLastFetch = Date().timeIntervalSince(lastFetchTime)
        guard timeSinceLastFetch >= refreshRate else {
            print("Rate limit: Skipping KuCoin order book fetch for \(pair)-\(marketType), time since last fetch: \(timeSinceLastFetch)s, required: \(refreshRate)s")
            Task { @MainActor in
                logAlert(event: "Rate limit: Skipping KuCoin order book fetch for \(pair)-\(marketType), time since last fetch: \(timeSinceLastFetch)s, required: \(refreshRate)s")
            }
            completion(nil)
            return
        }

        let symbol = pair.replacingOccurrences(of: "-USDT", with: "USDT")
        let endpoint = marketType == "spot" ? "/api/v1/market/orderbook/level2_50?symbol=\(symbol)" : "/api/v1/contractMarket/level2?symbol=\(symbol)M"
        guard let url = URL(string: "https://api\(marketType == "spot" ? "" : "-futures").kucoin.com\(endpoint)") else {
            print("Invalid KuCoin order book URL for \(pair)-\(marketType)")
            Task { @MainActor in
                logAlert(event: "Invalid KuCoin order book URL for \(pair)-\(marketType)")
            }
            let attemptFetch: @Sendable () -> Void = {
                let newRetryCount = localRetryCountCopy + 1
                DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                    fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                }
            }
            attemptFetch()
            return
        }

        // Load and validate API credentials with detailed logging
        let env = ProcessInfo.processInfo.environment
        let apiKey = env["KUCOIN_API_KEY"]
        let apiSecret = env["KUCOIN_API_SECRET"]
        let passphrase = env["KUCOIN_API_PASSPHRASE"]
        print("DEBUG: Loaded env variables - KUCOIN_API_KEY=\(apiKey != nil ? "present" : "missing"), KUCOIN_API_SECRET=\(apiSecret != nil ? "present" : "missing"), KUCOIN_API_PASSPHRASE=\(passphrase != nil ? "present" : "missing")")
        guard let apiKey = apiKey, !apiKey.isEmpty,
              let apiSecret = apiSecret, !apiSecret.isEmpty else {
            print("Missing or empty KuCoin API credentials for \(pair)-\(marketType): API_KEY=\(apiKey != nil ? "present" : "missing"), API_SECRET=\(apiSecret != nil ? "present" : "missing")")
            Task { @MainActor in
                logAlert(event: "Missing or empty KuCoin API credentials for \(pair)-\(marketType): API_KEY=\(apiKey != nil ? "present" : "missing"), API_SECRET=\(apiSecret != nil ? "present" : "missing")")
            }
            let attemptFetch: @Sendable () -> Void = {
                let newRetryCount = localRetryCountCopy + 1
                DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                    fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                }
            }
            attemptFetch()
            return
        }

        // HMAC-SHA256 function for KuCoin API signature
        @Sendable func hmacSHA256(_ data: String, key: String) -> String {
            let keyData = key.data(using: .utf8)!
            let dataToSign = data.data(using: .utf8)!
            let hmac = HMAC<SHA256>.authenticationCode(for: dataToSign, using: SymmetricKey(data: keyData))
            return Data(hmac).base64EncodedString()
        }

        // Compute passphrase if provided
        let computedPassphrase = passphrase.map { hmacSHA256($0, key: apiSecret) }

        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = getDouble("API_TIMEOUT_SECONDS", defaultValue: 15.0)
        let timestamp = String(Int(Date().timeIntervalSince1970 * 1000)) // Initial timestamp

        // Sync timestamp with KuCoin server
        let serverTimeUrl = URL(string: "https://api.kucoin.com/api/v1/timestamp")!
        var serverTimeRequest = URLRequest(url: serverTimeUrl)
        serverTimeRequest.httpMethod = "GET"
        serverTimeRequest.timeoutInterval = 15.0
        URLSession.shared.dataTask(with: serverTimeRequest) { data, response, error in
            if let data = data, let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
               let serverTime = json["data"] as? Int {
                let adjustedTimestamp = String(serverTime)
                var syncedRequest = URLRequest(url: url)
                syncedRequest.httpMethod = "GET"
                syncedRequest.timeoutInterval = getDouble("API_TIMEOUT_SECONDS", defaultValue: 15.0)
                let signature = hmacSHA256(adjustedTimestamp + "GET" + endpoint, key: apiSecret)
                syncedRequest.addValue(apiKey, forHTTPHeaderField: "KC-API-KEY")
                syncedRequest.addValue(adjustedTimestamp, forHTTPHeaderField: "KC-API-TIMESTAMP")
                syncedRequest.addValue(signature, forHTTPHeaderField: "KC-API-SIGN")
                syncedRequest.addValue("2", forHTTPHeaderField: "KC-API-KEY-VERSION")
                syncedRequest.addValue("application/json", forHTTPHeaderField: "Content-Type")
                if let passphrase = computedPassphrase {
                    syncedRequest.addValue(passphrase, forHTTPHeaderField: "KC-API-PASSPHRASE")
                }
                print("DEBUG: Synced KuCoin request for \(pair)-\(marketType): Timestamp \(adjustedTimestamp), Signature \(signature), Passphrase \(passphrase != nil ? "present" : "missing")")
                Task { @MainActor in
                    logAlert(event: "DEBUG: Synced KuCoin request for \(pair)-\(marketType): Timestamp \(adjustedTimestamp), Signature \(signature), Passphrase \(passphrase != nil ? "present" : "missing")")
                }
                let startTime = Date()
                URLSession.shared.dataTask(with: syncedRequest) { data, response, error in
                    let latency = Date().timeIntervalSince(startTime) * 1000
                    Task { @MainActor in
                        lastLatency[pair] = latency
                        ExchangeWebSocket.lastKucoinFetchTime[pair] = Date()
                        if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 200.0) {
                            print("High latency detected for KuCoin order book fetch: \(pair)-\(marketType) - \(latency)ms")
                            logAlert(event: "High latency detected for KuCoin order book fetch: \(pair)-\(marketType) - \(latency)ms")
                        }
                    }
                    if let error = error {
                        print("Failed to fetch KuCoin order book for \(pair)-\(marketType): \(error.localizedDescription)")
                        Task { @MainActor in
                            logAlert(event: "Failed to fetch KuCoin order book for \(pair)-\(marketType): \(error.localizedDescription)")
                        }
                        let attemptFetch: @Sendable () -> Void = {
                            let newRetryCount = localRetryCountCopy + 1
                            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                            }
                        }
                        attemptFetch()
                        return
                    }
                    guard let httpResponse = response as? HTTPURLResponse, let data = data else {
                        print("Invalid KuCoin order book response for \(pair)-\(marketType): No HTTP response or data")
                        Task { @MainActor in
                            logAlert(event: "Invalid KuCoin order book response for \(pair)-\(marketType): No HTTP response or data")
                        }
                        let attemptFetch: @Sendable () -> Void = {
                            let newRetryCount = localRetryCountCopy + 1
                            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                            }
                        }
                        attemptFetch()
                        return
                    }
                    guard httpResponse.statusCode == 200 else {
                        let statusCode = httpResponse.statusCode
                        let responseBody = String(data: data, encoding: .utf8) ?? "No response body"
                        let errorMessage: String
                        let delay: Double
                        switch statusCode {
                        case 401, 403:
                            errorMessage = "Authentication failed (\(statusCode)) for \(pair)-\(marketType): Invalid API key, signature, or timestamp, Body: \(responseBody)"
                            delay = pow(2.0, Double(localRetryCountCopy + 1))
                        case 429:
                            errorMessage = "Rate limit exceeded (429) for \(pair)-\(marketType): Body: \(responseBody)"
                            delay = 60.0
                        default:
                            errorMessage = "Invalid KuCoin order book response for \(pair)-\(marketType): Status code \(statusCode), Body: \(responseBody)"
                            delay = 2.0
                        }
                        print(errorMessage)
                        Task { @MainActor in
                            logAlert(event: errorMessage)
                        }
                        let attemptFetch: @Sendable () -> Void = {
                            let newRetryCount = localRetryCountCopy + 1
                            DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
                                fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                            }
                        }
                        attemptFetch()
                        return
                    }
                    do {
                        guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
                            let responseBody = String(data: data, encoding: .utf8) ?? "No response body"
                            print("Failed to parse KuCoin order book JSON for \(pair)-\(marketType): \(responseBody)")
                            Task { @MainActor in
                                logAlert(event: "Failed to parse KuCoin order book JSON for \(pair)-\(marketType): \(responseBody)")
                            }
                            let attemptFetch: @Sendable () -> Void = {
                                let newRetryCount = localRetryCountCopy + 1
                                DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                    fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                                }
                            }
                            attemptFetch()
                            return
                        }
                        guard let dataDict = json["data"] as? [String: Any],
                              let bids = dataDict["bids"] as? [[String]] ?? (dataDict["bids"] as? String == "null" ? [] : nil),
                              let asks = dataDict["asks"] as? [[String]] ?? (dataDict["asks"] as? String == "null" ? [] : nil) else {
                            let responseBody = String(data: data, encoding: .utf8) ?? "No response body"
                            print("Failed to parse KuCoin order book data for \(pair)-\(marketType): Body: \(responseBody)")
                            Task { @MainActor in
                                logAlert(event: "Failed to parse KuCoin order book data for \(pair)-\(marketType): Body: \(responseBody)")
                            }
                            let attemptFetch: @Sendable () -> Void = {
                                let newRetryCount = localRetryCountCopy + 1
                                DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                    fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                                }
                            }
                            attemptFetch()
                            return
                        }
                        var bidDepth: Double = 0.0
                        var askDepth: Double = 0.0
                        var bestBidPrice: Double = 0.0
                        var bestAskPrice: Double = 0.0
                        for bidEntry in bids.prefix(10) {
                            guard bidEntry.count >= 2,
                                  let priceStr = bidEntry.first,
                                  let qtyStr = bidEntry.last,
                                  let price = Double(priceStr),
                                  let qty = Double(qtyStr) else {
                                print("DEBUG: Skipping invalid bid entry for \(pair)-\(marketType): \(bidEntry)")
                                continue
                            }
                            bidDepth += price * qty
                            if price > bestBidPrice { bestBidPrice = price }
                        }
                        for ask in asks.prefix(10) {
                            guard ask.count >= 2,
                                  let priceStr = ask.first,
                                  let qtyStr = ask.last,
                                  let price = Double(priceStr),
                                  let qty = Double(qtyStr) else {
                                print("DEBUG: Skipping invalid ask entry for \(pair)-\(marketType): \(ask)")
                                continue
                            }
                            askDepth += price * qty
                            if bestAskPrice == 0.0 || price < bestAskPrice { bestAskPrice = price }
                        }
                        guard bidDepth > 0 || askDepth > 0 else {
                            print("Failed to parse KuCoin order book data for \(pair)-\(marketType): Empty depth")
                            Task { @MainActor in
                                logAlert(event: "Failed to parse KuCoin order book data for \(pair)-\(marketType): Empty depth")
                            }
                            let attemptFetch: @Sendable () -> Void = {
                                let newRetryCount = localRetryCountCopy + 1
                                DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                    fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                                }
                            }
                            attemptFetch()
                            return
                        }
                        let totalDepth = bidDepth + askDepth
                        let spread = bestAskPrice > 0 && bestBidPrice > 0 ? bestAskPrice - bestBidPrice : nil
                        Task { @MainActor in
                            if let spread = spread {
                                let timestamp = ISO8601DateFormatter().string(from: Date())
                                let spreadEntry = "\(timestamp),\(pair),\(marketType),\(bestBidPrice),\(bestAskPrice),\(spread)\n"
                                do {
                                    let fileURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/historical_spreads.csv")
                                    if !FileManager.default.fileExists(atPath: fileURL.path) {
                                        FileManager.default.createFile(atPath: fileURL.path, contents: "timestamp,pair,market_type,bid_price,ask_price,spread\n".data(using: .utf8))
                                    }
                                    let fileHandle = try FileHandle(forWritingTo: fileURL)
                                    fileHandle.seekToEndOfFile()
                                    if let data = spreadEntry.data(using: .utf8) {
                                        fileHandle.write(data)
                                    }
                                    fileHandle.closeFile()
                                } catch {
                                    print("DEBUG: Failed to write to historical_spreads.csv for \(pair)-\(marketType): \(error.localizedDescription)")
                                    logAlert(event: "Failed to write to historical_spreads.csv for \(pair)-\(marketType): \(error.localizedDescription)")
                                }
                            }
                            let orderBook = BevaixOrderBook(bids: bids.compactMap { entry in
                                guard entry.count >= 2, let price = Double(entry[0]), let quantity = Double(entry[1]) else { return nil }
                                return (price: price, quantity: quantity)
                            }, asks: asks.compactMap { entry in
                                guard entry.count >= 2, let price = Double(entry[0]), let quantity = Double(entry[1]) else { return nil }
                                return (price: price, quantity: quantity)
                            })
                            kucoinOrderBooks[pair] = orderBook
                            kucoinCurrentPrice[pair] = bestBidPrice > 0 ? bestBidPrice : kucoinCurrentPrice[pair] ?? 0.0
                            print("DEBUG: KuCoin order book depth for \(pair)-\(marketType): \(totalDepth), Spread: \(spread ?? 0)")
                            if totalDepth < getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 20000.0) {
                                logAlert(event: "Insufficient depth for KuCoin \(pair)-\(marketType): Depth \(totalDepth), Required \(getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 20000.0))")
                            }
                            completion(totalDepth)
                        }
                    } catch {
                        let responseBody = String(data: data, encoding: .utf8) ?? "No response body"
                        print("DEBUG: JSON parsing error for KuCoin order book \(pair)-\(marketType): \(error.localizedDescription), Body: \(responseBody)")
                        Task { @MainActor in
                            logAlert(event: "JSON parsing error for KuCoin order book \(pair)-\(marketType): \(error.localizedDescription), Body: \(responseBody)")
                        }
                        let attemptFetch: @Sendable () -> Void = {
                            let newRetryCount = localRetryCountCopy + 1
                            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                            }
                        }
                        attemptFetch()
                    }
                }.resume()
            } else {
                // Fallback to local timestamp if server sync fails
                var fallbackRequest = URLRequest(url: url)
                fallbackRequest.httpMethod = "GET"
                fallbackRequest.timeoutInterval = getDouble("API_TIMEOUT_SECONDS", defaultValue: 15.0)
                let signature = hmacSHA256(timestamp + "GET" + endpoint, key: apiSecret)
                fallbackRequest.addValue(apiKey, forHTTPHeaderField: "KC-API-KEY")
                fallbackRequest.addValue(timestamp, forHTTPHeaderField: "KC-API-TIMESTAMP")
                fallbackRequest.addValue(signature, forHTTPHeaderField: "KC-API-SIGN")
                fallbackRequest.addValue("2", forHTTPHeaderField: "KC-API-KEY-VERSION")
                fallbackRequest.addValue("application/json", forHTTPHeaderField: "Content-Type")
                if let passphrase = computedPassphrase {
                    fallbackRequest.addValue(passphrase, forHTTPHeaderField: "KC-API-PASSPHRASE")
                }
                print("DEBUG: Fallback KuCoin request for \(pair)-\(marketType): Timestamp \(timestamp), Signature \(signature), Passphrase \(passphrase != nil ? "present" : "missing")")
                Task { @MainActor in
                    logAlert(event: "DEBUG: Fallback KuCoin request for \(pair)-\(marketType): Timestamp \(timestamp), Signature \(signature), Passphrase \(passphrase != nil ? "present" : "missing")")
                }
                let startTime = Date()
                URLSession.shared.dataTask(with: fallbackRequest) { data, response, error in
                    let latency = Date().timeIntervalSince(startTime) * 1000
                    Task { @MainActor in
                        lastLatency[pair] = latency
                        ExchangeWebSocket.lastKucoinFetchTime[pair] = Date()
                        if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 200.0) {
                            print("High latency detected for KuCoin order book fetch: \(pair)-\(marketType) - \(latency)ms")
                            logAlert(event: "High latency detected for KuCoin order book fetch: \(pair)-\(marketType) - \(latency)ms")
                        }
                    }
                    if let error = error {
                        print("Failed to fetch KuCoin order book for \(pair)-\(marketType): \(error.localizedDescription)")
                        Task { @MainActor in
                            logAlert(event: "Failed to fetch KuCoin order book for \(pair)-\(marketType): \(error.localizedDescription)")
                        }
                        let attemptFetch: @Sendable () -> Void = {
                            let newRetryCount = localRetryCountCopy + 1
                            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                            }
                        }
                        attemptFetch()
                        return
                    }
                    guard let httpResponse = response as? HTTPURLResponse, let data = data else {
                        print("Invalid KuCoin order book response for \(pair)-\(marketType): No HTTP response or data")
                        Task { @MainActor in
                            logAlert(event: "Invalid KuCoin order book response for \(pair)-\(marketType): No HTTP response or data")
                        }
                        let attemptFetch: @Sendable () -> Void = {
                            let newRetryCount = localRetryCountCopy + 1
                            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                            }
                        }
                        attemptFetch()
                        return
                    }
                    guard httpResponse.statusCode == 200 else {
                        let statusCode = httpResponse.statusCode
                        let responseBody = String(data: data, encoding: .utf8) ?? "No response body"
                        let errorMessage: String
                        let delay: Double
                        switch statusCode {
                        case 401, 403:
                            errorMessage = "Authentication failed (\(statusCode)) for \(pair)-\(marketType): Invalid API key, signature, or timestamp, Body: \(responseBody)"
                            delay = pow(2.0, Double(localRetryCountCopy + 1))
                        case 429:
                            errorMessage = "Rate limit exceeded (429) for \(pair)-\(marketType): Body: \(responseBody)"
                            delay = 60.0
                        default:
                            errorMessage = "Invalid KuCoin order book response for \(pair)-\(marketType): Status code \(statusCode), Body: \(responseBody)"
                            delay = 2.0
                        }
                        print(errorMessage)
                        Task { @MainActor in
                            logAlert(event: errorMessage)
                        }
                        let attemptFetch: @Sendable () -> Void = {
                            let newRetryCount = localRetryCountCopy + 1
                            DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
                                fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                            }
                        }
                        attemptFetch()
                        return
                    }
                    do {
                        guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
                            let responseBody = String(data: data, encoding: .utf8) ?? "No response body"
                            print("Failed to parse KuCoin order book JSON for \(pair)-\(marketType): \(responseBody)")
                            Task { @MainActor in
                                logAlert(event: "Failed to parse KuCoin order book JSON for \(pair)-\(marketType): \(responseBody)")
                            }
                            let attemptFetch: @Sendable () -> Void = {
                                let newRetryCount = localRetryCountCopy + 1
                                DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                    fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                                }
                            }
                            attemptFetch()
                            return
                        }
                        guard let dataDict = json["data"] as? [String: Any],
                              let bids = dataDict["bids"] as? [[String]] ?? (dataDict["bids"] as? String == "null" ? [] : nil),
                              let asks = dataDict["asks"] as? [[String]] ?? (dataDict["asks"] as? String == "null" ? [] : nil) else {
                            let responseBody = String(data: data, encoding: .utf8) ?? "No response body"
                            print("Failed to parse KuCoin order book data for \(pair)-\(marketType): Body: \(responseBody)")
                            Task { @MainActor in
                                logAlert(event: "Failed to parse KuCoin order book data for \(pair)-\(marketType): Body: \(responseBody)")
                            }
                            let attemptFetch: @Sendable () -> Void = {
                                let newRetryCount = localRetryCountCopy + 1
                                DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                    fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                                }
                            }
                            attemptFetch()
                            return
                        }
                        var bidDepth: Double = 0.0
                        var askDepth: Double = 0.0
                        var bestBidPrice: Double = 0.0
                        var bestAskPrice: Double = 0.0
                        for bidEntry in bids.prefix(10) {
                            guard bidEntry.count >= 2,
                                  let priceStr = bidEntry.first,
                                  let qtyStr = bidEntry.last,
                                  let price = Double(priceStr),
                                  let qty = Double(qtyStr) else {
                                print("DEBUG: Skipping invalid bid entry for \(pair)-\(marketType): \(bidEntry)")
                                continue
                            }
                            bidDepth += price * qty
                            if price > bestBidPrice { bestBidPrice = price }
                        }
                        for ask in asks.prefix(10) {
                            guard ask.count >= 2,
                                  let priceStr = ask.first,
                                  let qtyStr = ask.last,
                                  let price = Double(priceStr),
                                  let qty = Double(qtyStr) else {
                                print("DEBUG: Skipping invalid ask entry for \(pair)-\(marketType): \(ask)")
                                continue
                            }
                            askDepth += price * qty
                            if bestAskPrice == 0.0 || price < bestAskPrice { bestAskPrice = price }
                        }
                        guard bidDepth > 0 || askDepth > 0 else {
                            print("Failed to parse KuCoin order book data for \(pair)-\(marketType): Empty depth")
                            Task { @MainActor in
                                logAlert(event: "Failed to parse KuCoin order book data for \(pair)-\(marketType): Empty depth")
                            }
                            let attemptFetch: @Sendable () -> Void = {
                                let newRetryCount = localRetryCountCopy + 1
                                DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                    fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                                }
                            }
                            attemptFetch()
                            return
                        }
                        let totalDepth = bidDepth + askDepth
                        let spread = bestAskPrice > 0 && bestBidPrice > 0 ? bestAskPrice - bestBidPrice : nil
                        Task { @MainActor in
                            if let spread = spread {
                                let timestamp = ISO8601DateFormatter().string(from: Date())
                                let spreadEntry = "\(timestamp),\(pair),\(marketType),\(bestBidPrice),\(bestAskPrice),\(spread)\n"
                                do {
                                    let fileURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/historical_spreads.csv")
                                    if !FileManager.default.fileExists(atPath: fileURL.path) {
                                        FileManager.default.createFile(atPath: fileURL.path, contents: "timestamp,pair,market_type,bid_price,ask_price,spread\n".data(using: .utf8))
                                    }
                                    let fileHandle = try FileHandle(forWritingTo: fileURL)
                                    fileHandle.seekToEndOfFile()
                                    if let data = spreadEntry.data(using: .utf8) {
                                        fileHandle.write(data)
                                    }
                                    fileHandle.closeFile()
                                } catch {
                                    print("DEBUG: Failed to write to historical_spreads.csv for \(pair)-\(marketType): \(error.localizedDescription)")
                                    logAlert(event: "Failed to write to historical_spreads.csv for \(pair)-\(marketType): \(error.localizedDescription)")
                                }
                            }
                            let orderBook = BevaixOrderBook(bids: bids.compactMap { entry in
                                guard entry.count >= 2, let price = Double(entry[0]), let quantity = Double(entry[1]) else { return nil }
                                return (price: price, quantity: quantity)
                            }, asks: asks.compactMap { entry in
                                guard entry.count >= 2, let price = Double(entry[0]), let quantity = Double(entry[1]) else { return nil }
                                return (price: price, quantity: quantity)
                            })
                            kucoinOrderBooks[pair] = orderBook
                            kucoinCurrentPrice[pair] = bestBidPrice > 0 ? bestBidPrice : kucoinCurrentPrice[pair] ?? 0.0
                            print("DEBUG: KuCoin order book depth for \(pair)-\(marketType): \(totalDepth), Spread: \(spread ?? 0)")
                            if totalDepth < getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 20000.0) {
                                logAlert(event: "Insufficient depth for KuCoin \(pair)-\(marketType): Depth \(totalDepth), Required \(getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 20000.0))")
                            }
                            completion(totalDepth)
                        }
                    } catch {
                        let responseBody = String(data: data, encoding: .utf8) ?? "No response body"
                        print("DEBUG: JSON parsing error for KuCoin order book \(pair)-\(marketType): \(error.localizedDescription), Body: \(responseBody)")
                        Task { @MainActor in
                            logAlert(event: "JSON parsing error for KuCoin order book \(pair)-\(marketType): \(error.localizedDescription), Body: \(responseBody)")
                        }
                        let attemptFetch: @Sendable () -> Void = {
                            let newRetryCount = localRetryCountCopy + 1
                            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                fetchKucoinOrderBookDepth(pair: pair, marketType: marketType, retryCount: newRetryCount, completion: completion)
                            }
                        }
                        attemptFetch()
                    }
                }.resume()
            }
        }.resume()

        print("DEBUG: Initial KuCoin request for \(pair)-\(marketType): Timestamp \(timestamp)")
        Task { @MainActor in
            logAlert(event: "DEBUG: Initial KuCoin request for \(pair)-\(marketType): Timestamp \(timestamp)")
        }
    }
}


//---------------------------------------------------------------------------------------------------------------------Block 9 - KuCoin WebSocket Processing






class KucoinWebSocketDelegate: WebSocketDelegate {
    private static let numberFormatter: NumberFormatter = {
        let formatter = NumberFormatter()
        formatter.locale = Locale(identifier: "en_US")
        formatter.numberStyle = .decimal
        formatter.minimumFractionDigits = 0
        formatter.maximumFractionDigits = 8
        return formatter
    }()

    func didReceive(event: WebSocketEvent, client: WebSocketClient) {
        Task { @MainActor in
            switch event {
            case .connected(let headers):
                print("KuCoin Spot WebSocket connected with headers: \(headers)")
                ExchangeWebSocket.kucoinIsConnected = true
            case .disconnected(let reason, let code):
                print("KuCoin Spot WebSocket disconnected: \(reason), code: \(code)")
                ExchangeWebSocket.kucoinIsConnected = false
            case .text(let string):
                print("DEBUG: KuCoin Spot WebSocket received message: \(string)")
                if let data = string.data(using: .utf8),
                   let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                    if let type = json["type"] as? String, type == "message",
                       let topic = json["topic"] as? String {
                        if topic.hasPrefix("/market/ticker:"),
                           let dataDict = json["data"] as? [String: Any] {
                            let priceKeys = ["price", "last", "bestAsk", "bestBid"]
                            var priceStr: String?
                            for key in priceKeys {
                                if let value = dataDict[key] as? String {
                                    priceStr = value
                                    break
                                }
                            }
                            guard let priceStr = priceStr else {
                                print("Failed to find price in KuCoin Spot message. Available keys: \(dataDict.keys), Full message: \(dataDict)")
                                return
                            }
                            var price: Double?
                            if let priceNum = Self.numberFormatter.number(from: priceStr) {
                                price = Double(priceNum.description)
                            } else if let parsedPrice = Double(priceStr) {
                                price = parsedPrice
                            }
                            guard let price = price else {
                                print("Failed to parse price '\(priceStr)' from KuCoin Spot message. Full message: \(dataDict)")
                                return
                            }
                            let spotSymbol = topic.components(separatedBy: ":").last ?? ""
                            let pair = spotSymbol
                            ExchangeWebSocket.kucoinCurrentPrice[pair] = price
                            ExchangeWebSocket.kucoinPrices[pair, default: []].append(price)
                            if ExchangeWebSocket.kucoinPrices[pair]!.count > (Int(AppConfig.environment["PRICE_HISTORY_RETENTION"] ?? "1440") ?? 1440) {
                                ExchangeWebSocket.kucoinPrices[pair]!.removeFirst()
                            }
                            let volStr = dataDict["size"] as? String ?? dataDict["volume"] as? String
                            if let volStr = volStr {
                                var vol: Double?
                                if let volNum = Self.numberFormatter.number(from: volStr) {
                                    vol = Double(volNum.description)
                                } else if let parsedVol = Double(volStr) {
                                    vol = parsedVol
                                }
                                if let vol = vol {
                                    ExchangeWebSocket.kucoinSpotVolume[pair, default: []].append(vol)
                                    if ExchangeWebSocket.kucoinSpotVolume[pair]!.count > (Int(AppConfig.environment["PRICE_HISTORY_RETENTION"] ?? "1440") ?? 1440) {
                                        ExchangeWebSocket.kucoinSpotVolume[pair]!.removeFirst()
                                    }
                                } else {
                                    print("Failed to parse volume '\(volStr)' from KuCoin Spot message. Full message: \(dataDict)")
                                }
                            }
                            print("Updated KuCoin spot price for \(pair): \(price)")
                        }
                    }
                }
            case .error(let error):
                print("KuCoin WebSocket error: \(error?.localizedDescription ?? "Unknown error")")
                ExchangeWebSocket.kucoinIsConnected = false
            case .pong(_):
                print("Received pong from KuCoin WebSocket")
            default:
                break
            }
        }
    }
}

class KucoinFuturesWebSocketDelegate: WebSocketDelegate {
    private static let numberFormatter: NumberFormatter = {
        let formatter = NumberFormatter()
        formatter.locale = Locale(identifier: "en_US")
        formatter.numberStyle = .decimal
        formatter.minimumFractionDigits = 0
        formatter.maximumFractionDigits = 8
        return formatter
    }()

    func didReceive(event: WebSocketEvent, client: WebSocketClient) {
        Task { @MainActor in
            switch event {
            case .connected(let headers):
                print("KuCoin Futures WebSocket connected with headers: \(headers)")
                ExchangeWebSocket.kucoinFuturesIsConnected = true
            case .disconnected(let reason, let code):
                print("KuCoin Futures WebSocket disconnected: \(reason), code: \(code)")
                ExchangeWebSocket.kucoinFuturesIsConnected = false
            case .text(let string):
                print("DEBUG: KuCoin Futures WebSocket received message: \(string)")
                if let data = string.data(using: .utf8),
                   let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                    if let type = json["type"] as? String, type == "message",
                       let topic = json["topic"] as? String {
                        if topic.hasPrefix("/contractMarket/tickerV2:"),
                           let dataDict = json["data"] as? [String: Any] {
                            let priceKeys = ["bestAskPrice", "bestBidPrice", "lastPrice", "indexPrice"]
                            var priceStr: String?
                            for key in priceKeys {
                                if let value = dataDict[key] as? String {
                                    priceStr = value
                                    break
                                }
                            }
                            guard let priceStr = priceStr else {
                                print("Failed to find price in KuCoin Futures message. Available keys: \(dataDict.keys), Full message: \(dataDict)")
                                return
                            }
                            var price: Double?
                            if let priceNum = Self.numberFormatter.number(from: priceStr) {
                                price = priceNum.doubleValue
                            } else if let parsedPrice = Double(priceStr) {
                                price = parsedPrice
                            }
                            guard let price = price else {
                                print("Failed to parse price '\(priceStr)' from KuCoin Futures message. Full message: \(dataDict)")
                                return
                            }
                            let futuresSymbol = topic.components(separatedBy: ":").last ?? ""
                            guard let pair = ExchangeWebSocket.kucoinFuturesSymbols.first(where: { $0.value == futuresSymbol })?.key else {
                                print("No pair found for futures symbol: \(futuresSymbol)")
                                return
                            }
                            ExchangeWebSocket.kucoinCurrentFuturesPrice[pair] = price
                            ExchangeWebSocket.kucoinFuturesPrices[pair, default: []].append(price)
                            if ExchangeWebSocket.kucoinFuturesPrices[pair]!.count > (Int(AppConfig.environment["PRICE_HISTORY_RETENTION"] ?? "1440") ?? 1440) {
                                ExchangeWebSocket.kucoinFuturesPrices[pair]!.removeFirst()
                            }
                            let volStr = dataDict["volume"] as? String ?? dataDict["size"] as? String
                            if let volStr = volStr {
                                var vol: Double?
                                if let volNum = Self.numberFormatter.number(from: volStr) {
                                    vol = volNum.doubleValue
                                } else if let parsedVol = Double(volStr) {
                                    vol = parsedVol
                                }
                                if let vol = vol {
                                    ExchangeWebSocket.kucoinFuturesVolume[pair, default: []].append(vol)
                                    if ExchangeWebSocket.kucoinFuturesVolume[pair]!.count > (Int(AppConfig.environment["PRICE_HISTORY_RETENTION"] ?? "1440") ?? 1440) {
                                        ExchangeWebSocket.kucoinFuturesVolume[pair]!.removeFirst()
                                    }
                                } else {
                                    print("Failed to parse volume '\(volStr)' from KuCoin Futures message. Full message: \(dataDict)")
                                }
                            }
                            print("Updated KuCoin futures price for \(pair): \(price)")
                        } else if topic.hasPrefix("/contractMarket/level2:"),
                                  let dataDict = json["data"] as? [String: Any] {
                            print("DEBUG: Processing KuCoin Futures order book for topic \(topic)")

                            let futuresSymbol = topic.components(separatedBy: ":").last ?? ""
                            guard let pair = ExchangeWebSocket.kucoinFuturesSymbols.first(where: { $0.value == futuresSymbol })?.key else {
                                print("No pair found for futures symbol: \(futuresSymbol)")
                                return
                            }

                            var orderBook: [(price: Double, volume: Double, side: String)] = []

                            if let bids = dataDict["bids"] as? [[String]],
                               let asks = dataDict["asks"] as? [[String]] {
                                print("DEBUG: Snapshot received - Bids: \(bids.count), Asks: \(asks.count)")
                                for bid in bids {
                                    if let priceStr = bid.first, let qtyStr = bid.last,
                                       let price = Double(priceStr), let qty = Double(qtyStr), qty > 0 {
                                        orderBook.append((price: price, volume: qty, side: "buy"))
                                    } else {
                                        print("Failed to parse bid entry: \(bid)")
                                    }
                                }
                                for ask in asks {
                                    if let priceStr = ask.first, let qtyStr = ask.last,
                                       let price = Double(priceStr), let qty = Double(qtyStr), qty > 0 {
                                        orderBook.append((price: price, volume: qty, side: "sell"))
                                    } else {
                                        print("Failed to parse ask entry: \(ask)")
                                    }
                                }
                            } else if let change = dataDict["change"] as? String {
                                print("DEBUG: Incremental update received - Change: \(change)")
                                orderBook = ExchangeWebSocket.kucoinFuturesOrderBook[pair] ?? []
                                let components = change.components(separatedBy: ",")
                                if components.count == 3,
                                   let price = Double(components[0]),
                                   let size = Double(components[2]) {
                                    let side = components[1].lowercased() == "buy" ? "buy" : "sell"
                                    orderBook.removeAll { $0.price == price && $0.side == side }
                                    if size > 0 {
                                        orderBook.append((price: price, volume: size, side: side))
                                    }
                                } else {
                                    print("Failed to parse change field: \(change)")
                                    return
                                }
                            } else {
                                print("Failed to parse order book data: \(dataDict)")
                                return
                            }

                            ExchangeWebSocket.kucoinFuturesOrderBook[pair] = orderBook
                            print("DEBUG: Updated KuCoin futures order book for \(pair): \(orderBook.count) entries")
                        } else if topic.hasPrefix("/contract/instrument:"),
                                  let dataDict = json["data"] as? [String: Any],
                                  let fundingRateStr = dataDict["fundingRate"] as? String,
                                  let fundingRateNum = Self.numberFormatter.number(from: fundingRateStr),
                                  let fundingRate = Double(fundingRateNum.description),
                                  let futuresSymbol = topic.components(separatedBy: ":").last,
                                  let pair = ExchangeWebSocket.kucoinFuturesSymbols.first(where: { $0.value == futuresSymbol })?.key {
                            ExchangeWebSocket.kucoinFundingRates[pair] = fundingRate
                            print("Updated KuCoin funding rate for \(pair): \(fundingRate)")
                        }
                    }
                }
            case .error(let error):
                print("KuCoin Futures WebSocket error: \(error?.localizedDescription ?? "Unknown error")")
                ExchangeWebSocket.kucoinFuturesIsConnected = false
            case .pong(_):
                print("Received pong from KuCoin Futures WebSocket")
            default:
                break
            }
        }
    }
}

class BybitWebSocketDelegate: WebSocketDelegate {
    private static let numberFormatter: NumberFormatter = {
        let formatter = NumberFormatter()
        formatter.locale = Locale(identifier: "en_US")
        formatter.numberStyle = .decimal
        formatter.minimumFractionDigits = 0
        formatter.maximumFractionDigits = 8
        return formatter
    }()

    func didReceive(event: WebSocketEvent, client: WebSocketClient) {
        Task { @MainActor in
            switch event {
            case .connected(let headers):
                print("Bybit Spot WebSocket connected with headers: \(headers)")
                ExchangeWebSocket.bybitIsConnected = true
            case .disconnected(let reason, let code):
                print("Bybit Spot WebSocket disconnected: \(reason), code: \(code)")
                ExchangeWebSocket.bybitIsConnected = false
            case .text(let string):
                print("DEBUG: Bybit Spot WebSocket received message: \(string)")
                if let data = string.data(using: .utf8),
                   let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                    if let success = json["success"] as? Bool {
                        if success, let retMsg = json["ret_msg"] as? String, retMsg == "subscribe" {
                            print("Bybit Spot subscription confirmed")
                        } else if !success {
                            print("Bybit Spot WebSocket error: \(json)")
                        }
                    } else if let topic = json["topic"] as? String {
                        if topic.hasPrefix("tickers."),
                           let dataDict = json["data"] as? [String: Any],
                           let symbol = dataDict["symbol"] as? String {
                            let priceKeys = ["lastPrice", "bestAskPrice", "ask1Price", "indexPrice"]
                            var priceStr: String?
                            for key in priceKeys {
                                if let value = dataDict[key] as? String {
                                    priceStr = value
                                    break
                                }
                            }
                            guard let priceStr = priceStr else {
                                print("Failed to find price in Bybit Spot message. Available keys: \(dataDict.keys), Full message: \(dataDict)")
                                return
                            }
                            var price: Double?
                            if let priceNum = Self.numberFormatter.number(from: priceStr) {
                                price = Double(priceNum.description)
                            } else if let parsedPrice = Double(priceStr) {
                                price = parsedPrice
                            }
                            guard let price = price else {
                                print("Failed to parse price '\(priceStr)' from Bybit Spot message. Full message: \(dataDict)")
                                return
                            }
                            let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
                            ExchangeWebSocket.bybitCurrentPrice[pair] = price
                            ExchangeWebSocket.bybitPrices[pair, default: []].append(price)
                            if ExchangeWebSocket.bybitPrices[pair]!.count > (Int(AppConfig.environment["PRICE_HISTORY_RETENTION"] ?? "1440") ?? 1440) {
                                ExchangeWebSocket.bybitPrices[pair]!.removeFirst()
                            }
                            let volStr = dataDict["volume24h"] as? String
                            if let volStr = volStr {
                                var vol: Double?
                                if let volNum = Self.numberFormatter.number(from: volStr) {
                                    vol = Double(volNum.description)
                                } else if let parsedVol = Double(volStr) {
                                    vol = parsedVol
                                }
                                if let vol = vol {
                                    ExchangeWebSocket.bybitSpotVolume[pair, default: []].append(vol)
                                    if ExchangeWebSocket.bybitSpotVolume[pair]!.count > (Int(AppConfig.environment["PRICE_HISTORY_RETENTION"] ?? "1440") ?? 1440) {
                                        ExchangeWebSocket.bybitSpotVolume[pair]!.removeFirst()
                                    }
                                } else {
                                    print("Failed to parse volume '\(volStr)' from Bybit Spot message. Full message: \(dataDict)")
                                }
                            }
                            print("Updated Bybit spot price for \(pair): \(price)")
                        } else if topic.hasPrefix("orderbook.50."),
                                  let dataDict = json["data"] as? [String: Any],
                                  let symbol = dataDict["s"] as? String,
                                  let asks = dataDict["a"] as? [[String]],
                                  let bids = dataDict["b"] as? [[String]] {
                            let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
                            var orderBook: [(price: Double, volume: Double, side: String)] = []
                            for ask in asks {
                                if let priceStr = ask.first, let volStr = ask.last,
                                   let priceNum = Self.numberFormatter.number(from: priceStr),
                                   let volNum = Self.numberFormatter.number(from: volStr),
                                   let price = Double(priceNum.description),
                                   let vol = Double(volNum.description) {
                                    orderBook.append((price: price, volume: vol, side: "sell"))
                                }
                            }
                            for bid in bids {
                                if let priceStr = bid.first, let volStr = bid.last,
                                   let priceNum = Self.numberFormatter.number(from: priceStr),
                                   let volNum = Self.numberFormatter.number(from: volStr),
                                   let price = Double(priceNum.description),
                                   let vol = Double(volNum.description) {
                                    orderBook.append((price: price, volume: vol, side: "buy"))
                                }
                            }
                            ExchangeWebSocket.bybitFuturesOrderBook[pair] = orderBook
                            print("Updated Bybit spot order book for \(pair): \(orderBook.count) entries")
                        } else if topic.hasPrefix("publicTrade."),
                                  let dataArray = json["data"] as? [[String: Any]],
                                  let firstTrade = dataArray.first,
                                  let priceStr = firstTrade["p"] as? String,
                                  let priceNum = Self.numberFormatter.number(from: priceStr),
                                  let price = Double(priceNum.description),
                                  let symbol = firstTrade["s"] as? String {
                            let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
                            ExchangeWebSocket.bybitCurrentPrice[pair] = price
                            ExchangeWebSocket.bybitPrices[pair, default: []].append(price)
                            if ExchangeWebSocket.bybitPrices[pair]!.count > (Int(AppConfig.environment["PRICE_HISTORY_RETENTION"] ?? "1440") ?? 1440) {
                                ExchangeWebSocket.bybitPrices[pair]!.removeFirst()
                            }
                            print("Updated Bybit spot price from trade for \(pair): \(price)")
                        }
                    }
                }
            case .error(let error):
                print("Bybit Spot WebSocket error: \(error?.localizedDescription ?? "Unknown error")")
                ExchangeWebSocket.bybitIsConnected = false
            case .pong(_):
                print("Received pong from Bybit Spot WebSocket")
            default:
                break
            }
        }
    }
}

class BybitFuturesWebSocketDelegate: WebSocketDelegate {
    private static let numberFormatter: NumberFormatter = {
        let formatter = NumberFormatter()
        formatter.locale = Locale(identifier: "en_US")
        formatter.numberStyle = .decimal
        formatter.minimumFractionDigits = 0
        formatter.maximumFractionDigits = 8
        return formatter
    }()

    func didReceive(event: WebSocketEvent, client: WebSocketClient) {
        Task { @MainActor in
            switch event {
            case .connected(let headers):
                print("Bybit Futures WebSocket connected with headers: \(headers)")
                ExchangeWebSocket.bybitFuturesIsConnected = true
            case .disconnected(let reason, let code):
                print("Bybit Futures WebSocket disconnected: \(reason), code: \(code)")
                ExchangeWebSocket.bybitFuturesIsConnected = false
            case .text(let string):
                print("DEBUG: Bybit Futures WebSocket received message: \(string)")
                if let data = string.data(using: .utf8),
                   let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                    if let success = json["success"] as? Bool {
                        if success, let retMsg = json["ret_msg"] as? String, retMsg == "subscribe" {
                            print("Bybit Futures subscription confirmed")
                        } else if !success {
                            print("Bybit Futures WebSocket error: \(json)")
                        }
                    } else if let topic = json["topic"] as? String {
                        if topic.hasPrefix("tickers."),
                           let dataDict = json["data"] as? [String: Any],
                           let symbol = dataDict["symbol"] as? String {
                            let priceKeys = ["lastPrice", "bestAskPrice", "ask1Price", "bid1Price", "indexPrice", "markPrice"]
                            var priceStr: String?
                            for key in priceKeys {
                                if let value = dataDict[key] as? String {
                                    priceStr = value
                                    break
                                }
                            }
                            guard let priceStr = priceStr else {
                                print("Failed to find price in Bybit Futures message. Available keys: \(dataDict.keys), Full message: \(dataDict)")
                                return
                            }
                            var price: Double?
                            if let priceNum = Self.numberFormatter.number(from: priceStr) {
                                price = Double(priceNum.description)
                            } else if let parsedPrice = Double(priceStr) {
                                price = parsedPrice
                            }
                            guard let price = price else {
                                print("Failed to parse price '\(priceStr)' from Bybit Futures message. Full message: \(dataDict)")
                                return
                            }
                            let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
                            ExchangeWebSocket.bybitCurrentFuturesPrice[pair] = price
                            ExchangeWebSocket.bybitFuturesPrices[pair, default: []].append(price)
                            if ExchangeWebSocket.bybitFuturesPrices[pair]!.count > (Int(AppConfig.environment["PRICE_HISTORY_RETENTION"] ?? "1440") ?? 1440) {
                                ExchangeWebSocket.bybitFuturesPrices[pair]!.removeFirst()
                            }
                            let volStr = dataDict["volume24h"] as? String
                            if let volStr = volStr {
                                var vol: Double?
                                if let volNum = Self.numberFormatter.number(from: volStr) {
                                    vol = Double(volNum.description)
                                } else if let parsedVol = Double(volStr) {
                                    vol = parsedVol
                                }
                                if let vol = vol {
                                    ExchangeWebSocket.bybitFuturesVolume[pair, default: []].append(vol)
                                    if ExchangeWebSocket.bybitFuturesVolume[pair]!.count > (Int(AppConfig.environment["PRICE_HISTORY_RETENTION"] ?? "1440") ?? 1440) {
                                        ExchangeWebSocket.bybitFuturesVolume[pair]!.removeFirst()
                                    }
                                } else {
                                    print("Failed to parse volume '\(volStr)' from Bybit Futures message. Full message: \(dataDict)")
                                }
                            }
                            let fundingRateStr = dataDict["fundingRate"] as? String
                            if let fundingRateStr = fundingRateStr {
                                var fundingRate: Double?
                                if let fundingRateNum = Self.numberFormatter.number(from: fundingRateStr) {
                                    fundingRate = Double(fundingRateNum.description)
                                } else if let parsedFundingRate = Double(fundingRateStr) {
                                    fundingRate = parsedFundingRate
                                }
                                if let fundingRate = fundingRate {
                                    ExchangeWebSocket.bybitFundingRates[pair] = fundingRate
                                    print("Updated Bybit funding rate for \(pair): \(fundingRate)")
                                } else {
                                    print("Failed to parse funding rate '\(fundingRateStr)' from Bybit Futures message. Full message: \(dataDict)")
                                }
                            }
                            print("Updated Bybit futures price for \(pair): \(price)")
                        } else if topic.hasPrefix("orderbook.50."),
                                  let dataDict = json["data"] as? [String: Any],
                                  let symbol = dataDict["s"] as? String,
                                  let updateType = dataDict["type"] as? String {
                            let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
                            var orderBook: [(price: Double, volume: Double, side: String)]
                            
                            if updateType == "snapshot" {
                                orderBook = []
                            } else {
                                orderBook = ExchangeWebSocket.bybitFuturesOrderBook[pair] ?? []
                            }
                            
                            if let asks = dataDict["a"] as? [[String]] {
                                for ask in asks {
                                    if let priceStr = ask.first, let volStr = ask.last,
                                       let priceNum = Self.numberFormatter.number(from: priceStr),
                                       let volNum = Self.numberFormatter.number(from: volStr),
                                       let price = Double(priceNum.description),
                                       let vol = Double(volNum.description) {
                                        orderBook.removeAll { $0.price == price && $0.side == "sell" }
                                        if vol > 0 {
                                            orderBook.append((price: price, volume: vol, side: "sell"))
                                        }
                                    } else {
                                        print("Failed to parse ask entry: \(ask)")
                                    }
                                }
                            }
                            if let bids = dataDict["b"] as? [[String]] {
                                for bid in bids {
                                    if let priceStr = bid.first, let volStr = bid.last,
                                       let priceNum = Self.numberFormatter.number(from: priceStr),
                                       let volNum = Self.numberFormatter.number(from: volStr),
                                       let price = Double(priceNum.description),
                                       let vol = Double(volNum.description) {
                                        orderBook.removeAll { $0.price == price && $0.side == "buy" }
                                        if vol > 0 {
                                            orderBook.append((price: price, volume: vol, side: "buy"))
                                        }
                                    } else {
                                        print("Failed to parse bid entry: \(bid)")
                                    }
                                }
                            }
                            ExchangeWebSocket.bybitFuturesOrderBook[pair] = orderBook
                            print("DEBUG: Updated Bybit futures order book for \(pair): \(orderBook.count) entries (Type: \(updateType))")
                        } else if topic.hasPrefix("publicTrade."),
                                  let dataArray = json["data"] as? [[String: Any]],
                                  let firstTrade = dataArray.first,
                                  let priceStr = firstTrade["p"] as? String,
                                  let priceNum = Self.numberFormatter.number(from: priceStr),
                                  let price = Double(priceNum.description),
                                  let symbol = firstTrade["s"] as? String {
                            let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
                            ExchangeWebSocket.bybitCurrentFuturesPrice[pair] = price
                            ExchangeWebSocket.bybitFuturesPrices[pair, default: []].append(price)
                            if ExchangeWebSocket.bybitFuturesPrices[pair]!.count > (Int(AppConfig.environment["PRICE_HISTORY_RETENTION"] ?? "1440") ?? 1440) {
                                ExchangeWebSocket.bybitFuturesPrices[pair]!.removeFirst()
                            }
                            print("Updated Bybit futures price from trade for \(pair): \(price)")
                        }
                    }
                }
            case .error(let error):
                print("Bybit Futures WebSocket error: \(error?.localizedDescription ?? "Unknown error")")
                ExchangeWebSocket.bybitFuturesIsConnected = false
            case .pong(_):
                print("Received pong from Bybit Futures WebSocket")
            default:
                break
            }
        }
    }
}




//------------------------------------------------------------------------------------------------------------------------Block 10 - Bybit WebSocket Processing


extension ExchangeWebSocket {
    @MainActor
    static var kucoinDailyLoss: Double = 0.0
    @MainActor
    static var bybitDailyLoss: Double = 0.0

    static func monitorCrossExchangeArbitrage() {
        let localKucoinCurrentPrice = kucoinCurrentPrice
        let localBybitCurrentPrice = bybitCurrentPrice
        let localKucoinPrices = kucoinPrices
        let localBybitPrices = bybitPrices

        Task {
            await withTaskGroup(of: Void.self) { group in
                let tradingPairsValue = await MainActor.run(body: { tradingPairs })
                for pair in tradingPairsValue {
                    group.addTask {
                        let kucoinSpotPrice = await MainActor.run(body: { localKucoinCurrentPrice[pair] ?? 0.0 })
                        let bybitSpotPrice = await MainActor.run(body: { localBybitCurrentPrice[pair] ?? 0.0 })
                        let kucoinSpotPrices = await MainActor.run(body: { localKucoinPrices[pair] ?? [] })
                        let bybitSpotPrices = await MainActor.run(body: { localBybitPrices[pair] ?? [] })
                        // Suppress unused warnings for kucoinSpotPrices and bybitSpotPrices (Lines 3097, 3098)
                        print("DEBUG: KuCoin spot prices count for \(pair): \(kucoinSpotPrices.count)")
                        print("DEBUG: Bybit spot prices count for \(pair): \(bybitSpotPrices.count)")

                        guard kucoinSpotPrice > 0 && bybitSpotPrice > 0 else {
                            print("DEBUG: Invalid prices for cross-exchange arbitrage - \(pair): KuCoin=\(kucoinSpotPrice), Bybit=\(bybitSpotPrice)")
                            return
                        }

                        let lastExecution = await MainActor.run(body: { crossExchangeArbitrageExecuted[pair] })
                        let cooldownSeconds = await MainActor.run(body: { crossExchangeCooldownSeconds })
                        if lastExecution == nil || Date().timeIntervalSince(lastExecution!.1) > cooldownSeconds {
                            let kucoinEvents = await MainActor.run(body: { kucoinOrderBookEvents[pair] ?? [] })
                            let spoofingThreshold = await MainActor.run(body: { spoofingVolumeThreshold })
                            let spoofingDetected = kucoinEvents.filter { Date().timeIntervalSince($0.timestamp) < 60 }.count > 2 && kucoinEvents.contains(where: { $0.volume > spoofingThreshold })
                            if spoofingDetected {
                                print("DEBUG: Order book spoofing detected for \(pair)")
                                await MainActor.run(body: {
                                    logAlert(event: "Order book spoofing detected for \(pair)")
                                })
                                return
                            }

                            let tradeAmount = await MainActor.run(body: { crossExchangeTradeAmount })
                            await checkCrossExchangeArbitrage(
                                pair: pair,
                                strategy: "momentum",
                                amount: tradeAmount,
                                completion: { success in
                                    if success {
                                        print("DEBUG: Cross-exchange arbitrage executed for \(pair)")
                                    } else {
                                        print("DEBUG: Cross-exchange arbitrage failed for \(pair)")
                                    }
                                }
                            )
                        } else {
                            print("DEBUG: Cross-exchange arbitrage for \(pair) on cooldown")
                        }
                    }
                }
            }
            try? await Task.sleep(nanoseconds: UInt64(getDouble("ARBITRAGE_CHECK_INTERVAL_SECONDS", defaultValue: 0.5) * 1_000_000_000))
            monitorCrossExchangeArbitrage()
        }
    }
    
    // ENHANCED: Better WebSocket connection management for Bybit
    static func connectBybitWebSocket() {
        Task { @MainActor in
            guard validateAPICredentials(exchange: "bybit") else {
                logAlert(event: "Invalid Bybit credentials, skipping WebSocket connection")
                return
            }
            
            let baseUrl = "wss://stream.bybit.com/v5/public/spot"
            guard let url = URL(string: baseUrl) else {
                logAlert(event: "Invalid Bybit WebSocket URL: \(baseUrl)")
                return
            }
            
            bybitSocket = WebSocket(request: URLRequest(url: url))
            bybitSocket?.delegate = bybitDelegate
            bybitSocket?.connect()
            
            // ENHANCED: Connection timeout handling
            DispatchQueue.main.asyncAfter(deadline: .now() + Double(websocketTimeoutSeconds)) {
                if !bybitIsConnected {
                    logAlert(event: "Bybit WebSocket connection timeout after \(websocketTimeoutSeconds) seconds")
                    reconnectBybitWebSocket()
                }
            }
            
            print("DEBUG: Attempting Bybit WebSocket connection to \(baseUrl)")
            logAlert(event: "Attempting Bybit WebSocket connection")
        }
    }
    
    // ENHANCED: Bybit WebSocket reconnection with exponential backoff
    static func reconnectBybitWebSocket() {
        Task { @MainActor in
            bybitReconnectAttempts += 1
            
            if bybitReconnectAttempts > maxReconnectAttempts {
                logAlert(event: "Max Bybit WebSocket reconnection attempts reached (\(maxReconnectAttempts))")
                return
            }
            
            let delay = min(pow(2.0, Double(bybitReconnectAttempts - 1)), 60.0) // Exponential backoff, max 60s
            logAlert(event: "Reconnecting Bybit WebSocket in \(delay) seconds (attempt \(bybitReconnectAttempts)/\(maxReconnectAttempts))")
            
            DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
                connectBybitWebSocket()
            }
        }
    }
    
    // ENHANCED: Bybit WebSocket message processing with better error handling
    static func processBybitWebSocketMessage(_ message: [String: Any]) async {
        let startTime = Date()
        
        guard let topic = message["topic"] as? String else {
            await MainActor.run {
                logAlert(event: "Bybit WebSocket message missing topic: \(message)")
            }
            return
        }
        
        await MainActor.run {
            let latency = Date().timeIntervalSince(startTime) * 1000
            if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 80.0) {
                logAlert(event: "High latency detected for Bybit WebSocket processing: \(latency)ms")
            }
        }
        
        // ENHANCED: Better topic handling
        if topic.contains("orderbook") {
            await processOrderBookUpdate(message: message, exchange: "bybit")
        } else if topic.contains("publicTrade") {
            await processTradeUpdate(message: message, exchange: "bybit")
        } else if topic.contains("tickers") {
            await processTickerUpdate(message: message, exchange: "bybit")
        } else {
            await MainActor.run {
                print("DEBUG: Unhandled Bybit WebSocket topic: \(topic)")
            }
        }
    }
    
    // ENHANCED: Order book update processing with validation
    static func processOrderBookUpdate(message: [String: Any], exchange: String) async {
        guard let data = message["data"] as? [String: Any],
              let symbol = data["s"] as? String else {
            await MainActor.run {
                logAlert(event: "Invalid \(exchange) order book update: missing data or symbol")
            }
            return
        }
        
        // Convert Bybit symbol format to our pair format
        let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
        
        guard await MainActor.run(body: { tradingPairs.contains(pair) }) else {
            return // Skip pairs we're not trading
        }
        
        guard let bids = data["b"] as? [[String]],
              let asks = data["a"] as? [[String]] else {
            await MainActor.run {
                logAlert(event: "Invalid \(exchange) order book data for \(pair): missing bids/asks")
            }
            return
        }
        
        // ENHANCED: Validate order book data quality
        let validation = await MainActor.run {
            validateOrderBookData(exchange: exchange, pair: pair, bids: bids, asks: asks)
        }
        
        guard validation.isValid else {
            await MainActor.run {
                logAlert(event: validation.errorMessage ?? "Unknown order book validation error")
            }
            return
        }
        
        await MainActor.run {
            // Update order book with validated data
            let parsedBids = bids.prefix(20).compactMap { bid -> (price: Double, quantity: Double)? in
                guard bid.count >= 2,
                      let price = Double(bid[0]),
                      let quantity = Double(bid[1]),
                      price > 0, quantity > 0 else { return nil }
                return (price: price, quantity: quantity)
            }
            
            let parsedAsks = asks.prefix(20).compactMap { ask -> (price: Double, quantity: Double)? in
                guard ask.count >= 2,
                      let price = Double(ask[0]),
                      let quantity = Double(ask[1]),
                      price > 0, quantity > 0 else { return nil }
                return (price: price, quantity: quantity)
            }
            
            if !parsedBids.isEmpty && !parsedAsks.isEmpty {
                if exchange == "bybit" {
                    bybitOrderBooks[pair] = BevaixOrderBook(bids: parsedBids, asks: parsedAsks)
                } else {
                    kucoinOrderBooks[pair] = BevaixOrderBook(bids: parsedBids, asks: parsedAsks)
                }
                
                // ENHANCED: Real-time order book health monitoring
                if !checkOrderBookHealth(exchange: exchange, pair: pair) {
                    logAlert(event: "Order book health check failed for \(exchange)-\(pair)")
                }
                
                // ENHANCED: Advanced order book analysis
                analyzeOrderBookBasic(exchange: exchange, pair: pair, marketType: "spot")
            } else {
                logAlert(event: "No valid orders parsed for \(exchange)-\(pair)")
            }
        }
    }
    
    // ENHANCED: Trade update processing
    static func processTradeUpdate(message: [String: Any], exchange: String) async {
        guard let data = message["data"] as? [[String: Any]] else {
            await MainActor.run {
                logAlert(event: "Invalid \(exchange) trade update: missing data array")
            }
            return
        }
        
        for trade in data {
            guard let symbol = trade["s"] as? String,
                  let priceStr = trade["p"] as? String,
                  let price = Double(priceStr),
                  let volumeStr = trade["v"] as? String,
                  let volume = Double(volumeStr),
                  price > 0, volume > 0 else {
                continue
            }
            
            let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
            
            guard await MainActor.run(body: { tradingPairs.contains(pair) }) else {
                continue
            }
            
            await MainActor.run {
                // Update current price
                if exchange == "bybit" {
                    bybitCurrentPrice[pair] = price
                    bybitSpotVolume[pair, default: []].append(volume)
                    
                    // Keep volume history manageable
                    if bybitSpotVolume[pair]!.count > 1000 {
                        bybitSpotVolume[pair]?.removeFirst(100)
                    }
                } else {
                    kucoinCurrentPrice[pair] = price
                    kucoinSpotVolume[pair, default: []].append(volume)
                    
                    if kucoinSpotVolume[pair]!.count > 1000 {
                        kucoinSpotVolume[pair]?.removeFirst(100)
                    }
                }
                
                // Update price history
                updatePrice(pair: pair, exchange: exchange, price: price)
                
                print("DEBUG: \(exchange.capitalized) trade update - \(pair): \(price) (volume: \(volume))")
            }
        }
    }
    
    // ENHANCED: Ticker update processing
    static func processTickerUpdate(message: [String: Any], exchange: String) async {
        guard let data = message["data"] as? [String: Any],
              let symbol = data["symbol"] as? String else {
            await MainActor.run {
                logAlert(event: "Invalid \(exchange) ticker update: missing data or symbol")
            }
            return
        }
        
        let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
        
        guard await MainActor.run(body: { tradingPairs.contains(pair) }) else {
            return
        }
        
        // Extract price from various possible fields
        var price: Double = 0.0
        
        if let lastPriceStr = data["lastPrice"] as? String,
           let lastPrice = Double(lastPriceStr) {
            price = lastPrice
        } else if let midPriceStr = data["midPrice"] as? String,
                  let midPrice = Double(midPriceStr) {
            price = midPrice
        } else if let markPriceStr = data["markPrice"] as? String,
                  let markPrice = Double(markPriceStr) {
            price = markPrice
        }
        
        guard price > 0 else {
            await MainActor.run {
                logAlert(event: "Invalid price in \(exchange) ticker for \(pair): \(data)")
            }
            return
        }
        
        await MainActor.run {
            if exchange == "bybit" {
                bybitCurrentPrice[pair] = price
            } else {
                kucoinCurrentPrice[pair] = price
            }
            
            updatePrice(pair: pair, exchange: exchange, price: price)
            print("DEBUG: \(exchange.capitalized) ticker update - \(pair): \(price)")
        }
    }
    
    // ENHANCED: WebSocket heartbeat monitoring
    static func monitorWebSocketHeartbeat() {
        Task {
            while true {
                await MainActor.run {
                    let currentTime = Date()
                    let heartbeatTimeout = Double(websocketTimeoutSeconds)
                    
                    // Check Bybit heartbeat
                    if let lastBybitHeartbeat = lastHeartbeat["bybit"],
                       currentTime.timeIntervalSince(lastBybitHeartbeat) > heartbeatTimeout {
                        logAlert(event: "Bybit WebSocket heartbeat timeout - reconnecting")
                        reconnectBybitWebSocket()
                    }
                    
                    // Check KuCoin heartbeat
                    if let lastKucoinHeartbeat = lastHeartbeat["kucoin"],
                       currentTime.timeIntervalSince(lastKucoinHeartbeat) > heartbeatTimeout {
                        logAlert(event: "KuCoin WebSocket heartbeat timeout - reconnecting")
                        // Call KuCoin reconnection function when available
                    }
                }
                
                try? await Task.sleep(nanoseconds: UInt64(30_000_000_000)) // Check every 30 seconds
            }
        }
    }
    
    // ENHANCED: WebSocket message queue processing
    static func processMessageQueue() async {
        await MainActor.run {
            guard !isProcessingQueue, !messageQueue.isEmpty else { return }
            
            isProcessingQueue = true
            let messagesToProcess = Array(messageQueue.prefix(10)) // Process in batches
            
            if messageQueue.count > 10 {
                messageQueue.removeFirst(10)
            } else {
                messageQueue.removeAll()
            }
        }
        
        let messagesToProcess = await MainActor.run { messageQueue.isEmpty ? [] : Array(messageQueue.prefix(10)) }
        
        for message in messagesToProcess {
            if let exchange = message["exchange"] as? String {
                if exchange == "bybit" {
                    await processBybitWebSocketMessage(message)
                }
                // Add KuCoin processing when needed
            }
        }
        
        await MainActor.run {
            isProcessingQueue = false
        }
        
        // Continue processing if more messages exist
        if await MainActor.run(body: { !messageQueue.isEmpty }) {
            await processMessageQueue()
        }
    }
    
    // ENHANCED: Helper function for cross-exchange arbitrage checking
    static func checkCrossExchangeArbitrage(pair: String, strategy: String, amount: Double, completion: @escaping @Sendable (Bool) -> Void) async {
        let kucoinPrice = await MainActor.run { kucoinCurrentPrice[pair] ?? 0.0 }
        let bybitPrice = await MainActor.run { bybitCurrentPrice[pair] ?? 0.0 }
        
        guard kucoinPrice > 0 && bybitPrice > 0 else {
            print("DEBUG: Invalid prices for arbitrage check - \(pair): KuCoin=\(kucoinPrice), Bybit=\(bybitPrice)")
            completion(false)
            return
        }
        
        let spread = abs(kucoinPrice - bybitPrice) / min(kucoinPrice, bybitPrice)
        let minSpread = await MainActor.run { crossExchangeMinSpreadThreshold }
        
        guard spread >= minSpread else {
            print("DEBUG: Spread too small for \(pair): \(spread) < \(minSpread)")
            completion(false)
            return
        }
        
        // ENHANCED: Check liquidity before proceeding
        let kucoinLiquidity = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "spot", tradeAmount: amount, price: kucoinPrice)
        let bybitLiquidity = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "spot", tradeAmount: amount, price: bybitPrice)
        
        let minLiquidity = await MainActor.run { minLiquidityThreshold }
        guard let kucoinLiq = kucoinLiquidity, let bybitLiq = bybitLiquidity,
              kucoinLiq >= minLiquidity, bybitLiq >= minLiquidity else {
            print("DEBUG: Insufficient liquidity for \(pair): KuCoin=\(kucoinLiquidity ?? 0), Bybit=\(bybitLiquidity ?? 0)")
            completion(false)
            return
        }
        
        // ENHANCED: Execute the arbitrage
        let success = await executeArbitrageStrategy(pair: pair, strategy: strategy, amount: amount, kucoinPrice: kucoinPrice, bybitPrice: bybitPrice)
        
        await MainActor.run {
            if success {
                crossExchangeArbitrageExecuted[pair] = (true, Date())
                logAlert(event: "Cross-exchange arbitrage executed for \(pair): KuCoin=\(kucoinPrice), Bybit=\(bybitPrice), Spread=\(spread)")
            }
        }
        
        completion(success)
    }
    
    // ENHANCED: Arbitrage strategy execution
    static func executeArbitrageStrategy(pair: String, strategy: String, amount: Double, kucoinPrice: Double, bybitPrice: Double) async -> Bool {
        let buyExchange = kucoinPrice < bybitPrice ? "kucoin" : "bybit"
        let sellExchange = kucoinPrice < bybitPrice ? "bybit" : "kucoin"
        let buyPrice = min(kucoinPrice, bybitPrice)
        let sellPrice = max(kucoinPrice, bybitPrice)
        
        // Calculate expected profit
        let grossProfit = amount * (sellPrice - buyPrice)
        let buyFee = amount * buyPrice * (buyExchange == "kucoin" ? await MainActor.run { kucoinTakerFee } : await MainActor.run { bybitTakerFee })
        let sellFee = amount * sellPrice * (sellExchange == "kucoin" ? await MainActor.run { kucoinTakerFee } : await MainActor.run { bybitTakerFee })
        let netProfit = grossProfit - buyFee - sellFee
        
        let minProfit = await MainActor.run { getDouble("TARGET_NET_PROFIT", defaultValue: 0.20) }
        guard netProfit >= minProfit else {
            print("DEBUG: Profit too low for \(pair): \(netProfit) < \(minProfit)")
            return false
        }
        
        // ENHANCED: Simulate trade execution (replace with actual API calls)
        print("DEBUG: Executing arbitrage for \(pair):")
        print("  - Buy \(amount) on \(buyExchange) at \(buyPrice)")
        print("  - Sell \(amount) on \(sellExchange) at \(sellPrice)")
        print("  - Expected profit: \(netProfit) USDT")
        
        await MainActor.run {
            // Update metrics
            let metrics = performanceMetrics[pair] ?? (profit: 0.0, fees: 0.0, trades: 0, wins: 0)
            performanceMetrics[pair] = (
                profit: metrics.profit + netProfit,
                fees: metrics.fees + buyFee + sellFee,
                trades: metrics.trades + 1,
                wins: metrics.wins + (netProfit > 0 ? 1 : 0)
            )
            
            // Log the trade
            logAlert(event: "Arbitrage trade executed for \(pair): profit=\(netProfit), fees=\(buyFee + sellFee)")
        }
        
        return true
    }
}


//-------------------------------------------------------------------------------------------------------------------------Block 11 - WebSocket Data Handling


extension ExchangeWebSocket {
    private static var kucoinDelegate: KucoinWebSocketDelegate?
    private static var kucoinFuturesDelegate: KucoinFuturesWebSocketDelegate?
    private static var bybitDelegate: BybitWebSocketDelegate?
    private static var bybitFuturesDelegate: BybitFuturesWebSocketDelegate?

    @MainActor
    static func connectKucoin() {
        guard hasValidKuCoinCredentials else {
            print("Skipping KuCoin WebSocket connection due to missing credentials")
            Task { @MainActor in
                logAlert(event: "Skipping KuCoin WebSocket connection due to missing credentials")
            }
            return
        }
        print("Attempting to connect to KuCoin WebSocket...")
        fetchKuCoinWsToken { token in
            guard let token = token else {
                print("Failed to fetch KuCoin WebSocket token, retrying in 5 seconds...")
                DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                    connectKucoin()
                }
                return
            }
            Task { @MainActor in
                kucoinToken = token
                let wsURLString = "wss://ws-api.kucoin.com/endpoint?token=\(token)&acceptUserMessage=true"
                guard let wsURL = URL(string: wsURLString) else {
                    print("Invalid KuCoin WebSocket URL: \(wsURLString), retrying in 5 seconds...")
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectKucoin()
                    }
                    return
                }
                var request = URLRequest(url: wsURL)
                request.timeoutInterval = 10
                kucoinSocket = WebSocket(request: request)
                kucoinDelegate = KucoinWebSocketDelegate()
                kucoinSocket?.delegate = kucoinDelegate
                kucoinSocket?.connect()
                
                weak var ws = kucoinSocket
                ws?.onEvent = { event in
                    Task { @MainActor in
                        switch event {
                        case .connected(_):
                            for (index, pair) in tradingPairs.enumerated() {
                                // Fixed symbol formatting for KuCoin spot
                                let formattedPair = pair.replacingOccurrences(of: "-", with: "")
                                let spotTopic = "/market/ticker:\(formattedPair)"
                                let spotSubscribeMessage: [String: Any] = [
                                    "id": Int(Date().timeIntervalSince1970 * 1000) + index,
                                    "type": "subscribe",
                                    "topic": spotTopic,
                                    "privateChannel": false,
                                    "response": true
                                ]
                                if let spotData = try? JSONSerialization.data(withJSONObject: spotSubscribeMessage),
                                   let spotMessage = String(data: spotData, encoding: .utf8) {
                                    ws?.write(string: spotMessage)
                                    print("Subscribed to KuCoin spot topic: \(spotTopic) for pair: \(pair)")
                                } else {
                                    print("Failed to subscribe to KuCoin spot topic: \(spotTopic) for pair: \(pair)")
                                }
                            }
                            Timer.scheduledTimer(withTimeInterval: 15.0, repeats: true) { _ in
                                Task { @MainActor in
                                    let pingMessage = "{\"id\": \"ping_\(Int(Date().timeIntervalSince1970))\", \"type\": \"ping\"}"
                                    ws?.write(string: pingMessage)
                                    print("Sent ping to KuCoin Spot WebSocket")
                                }
                            }
                        case .disconnected(_, _):
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectKucoin()
                            }
                        case .error(_):
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectKucoin()
                            }
                        case .text(let string):
                            if let data = string.data(using: .utf8),
                               let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                               let type = json["type"] as? String, type == "welcome" {
                                print("KuCoin Spot WebSocket subscription confirmed")
                            }
                        default:
                            break
                        }
                    }
                }
            }
        }
    }

    @MainActor
    static func connectKucoinFutures() {
        guard hasValidKuCoinCredentials else {
            print("Skipping KuCoin Futures WebSocket connection due to missing credentials")
            Task { @MainActor in
                logAlert(event: "Skipping KuCoin Futures WebSocket connection due to missing credentials")
            }
            return
        }
        print("Attempting to connect to KuCoin Futures WebSocket...")
        fetchKucoinFuturesWsToken { token in
            guard let token = token else {
                print("Failed to fetch KuCoin Futures WebSocket token, retrying in 5 seconds...")
                DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                    connectKucoinFutures()
                }
                return
            }
            Task { @MainActor in
                kucoinFuturesToken = token
                let connectId = UUID().uuidString
                let wsURLString = "wss://ws-api-futures.kucoin.com/?token=\(token)&connectId=\(connectId)"
                guard let wsURL = URL(string: wsURLString) else {
                    print("Invalid KuCoin Futures WebSocket URL: \(wsURLString), retrying in 5 seconds...")
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectKucoinFutures()
                    }
                    return
                }
                var request = URLRequest(url: wsURL)
                request.timeoutInterval = 10
                kucoinFuturesSocket = WebSocket(request: request)
                kucoinFuturesDelegate = KucoinFuturesWebSocketDelegate()
                kucoinFuturesSocket?.delegate = kucoinFuturesDelegate
                kucoinFuturesSocket?.connect()
                
                weak var ws = kucoinFuturesSocket
                ws?.onEvent = { event in
                    Task { @MainActor in
                        switch event {
                        case .connected(_):
                            for (index, pair) in tradingPairs.enumerated() {
                                guard let futuresSymbol = kucoinFuturesSymbols[pair] else {
                                    print("No futures symbol found for pair: \(pair), skipping subscription")
                                    continue
                                }
                                let priceTopic = "/contractMarket/tickerV2:\(futuresSymbol)"
                                let priceSubscription: [String: Any] = [
                                    "id": Int(Date().timeIntervalSince1970 * 1000) + index,
                                    "type": "subscribe",
                                    "topic": priceTopic,
                                    "privateChannel": false,
                                    "response": true
                                ]
                                if let priceData = try? JSONSerialization.data(withJSONObject: priceSubscription),
                                   let priceMessage = String(data: priceData, encoding: .utf8) {
                                    ws?.write(string: priceMessage)
                                    print("Subscribed to KuCoin Futures price topic: \(priceTopic) for pair: \(pair)")
                                } else {
                                    print("Failed to subscribe to KuCoin Futures price topic: \(priceTopic) for pair: \(pair)")
                                }
                                let orderBookTopic = "/contractMarket/level2:\(futuresSymbol)"
                                let orderBookSubscription: [String: Any] = [
                                    "id": Int(Date().timeIntervalSince1970 * 1000) + index + 2000,
                                    "type": "subscribe",
                                    "topic": orderBookTopic,
                                    "privateChannel": false,
                                    "response": true
                                ]
                                if let orderBookData = try? JSONSerialization.data(withJSONObject: orderBookSubscription),
                                   let orderBookMessage = String(data: orderBookData, encoding: .utf8) {
                                    ws?.write(string: orderBookMessage)
                                    print("Subscribed to KuCoin Futures order book topic: \(orderBookTopic) for pair: \(pair)")
                                } else {
                                    print("Failed to subscribe to KuCoin Futures order book topic: \(orderBookTopic) for pair: \(pair)")
                                }
                                let fundingTopic = "/contract/instrument:\(futuresSymbol)"
                                let fundingSubscription: [String: Any] = [
                                    "id": Int(Date().timeIntervalSince1970 * 1000) + index + 1000,
                                    "type": "subscribe",
                                    "topic": fundingTopic,
                                    "privateChannel": false,
                                    "response": true
                                ]
                                if let fundingData = try? JSONSerialization.data(withJSONObject: fundingSubscription),
                                   let fundingMessage = String(data: fundingData, encoding: .utf8) {
                                    ws?.write(string: fundingMessage)
                                    print("Subscribed to KuCoin Futures funding rate topic: \(fundingTopic) for pair: \(pair)")
                                } else {
                                    print("Failed to subscribe to KuCoin Futures funding rate topic: \(fundingTopic) for pair: \(pair)")
                                }
                            }
                            Timer.scheduledTimer(withTimeInterval: 15.0, repeats: true) { _ in
                                Task { @MainActor in
                                    let pingMessage = "{\"id\": \"ping_\(Int(Date().timeIntervalSince1970))\", \"type\": \"ping\"}"
                                    ws?.write(string: pingMessage)
                                    print("Sent ping to KuCoin Futures WebSocket")
                                }
                            }
                        case .disconnected(_, _):
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectKucoinFutures()
                            }
                        case .error(_):
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectKucoinFutures()
                            }
                        case .text(let string):
                            if let data = string.data(using: .utf8),
                               let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                               let type = json["type"] as? String, type == "welcome" {
                                print("KuCoin Futures WebSocket subscription confirmed")
                            }
                        default:
                            break
                        }
                    }
                }
            }
        }
    }

    @MainActor
    static func connectBybit() {
        print("Attempting to connect to Bybit WebSocket...")
        bybitSocket = WebSocket(request: URLRequest(url: URL(string: "wss://stream.bybit.com/v5/public/spot")!))
        bybitDelegate = BybitWebSocketDelegate()
        bybitSocket?.delegate = bybitDelegate
        bybitSocket?.connect()
        
        weak var spotWs = bybitSocket
        spotWs?.onEvent = { event in
            Task { @MainActor in
                switch event {
                case .connected(_):
                    for pair in tradingPairs {
                        // Fixed symbol formatting for Bybit
                        let symbol = pair.replacingOccurrences(of: "-", with: "")
                        let subscribeMessage: [String: Any] = [
                            "req_id": "bybit_spot_\(Int(Date().timeIntervalSince1970 * 1000))",
                            "op": "subscribe",
                            "args": [
                                "tickers.\(symbol)",
                                "orderbook.50.\(symbol)",
                                "publicTrade.\(symbol)"
                            ]
                        ]
                        if let data = try? JSONSerialization.data(withJSONObject: subscribeMessage),
                           let message = String(data: data, encoding: .utf8) {
                            spotWs?.write(string: message)
                            print("Subscribed to Bybit spot topics: tickers.\(symbol), orderbook.50.\(symbol), publicTrade.\(symbol) for pair: \(pair)")
                        } else {
                            print("Failed to subscribe to Bybit spot topics for pair: \(pair)")
                        }
                    }
                    Timer.scheduledTimer(withTimeInterval: 20.0, repeats: true) { _ in
                        Task { @MainActor in
                            let pingMessage = "{\"op\": \"ping\", \"req_id\": \"bybit_spot_\(Int(Date().timeIntervalSince1970 * 1000))\"}"
                            spotWs?.write(string: pingMessage)
                            print("Sent ping to Bybit Spot WebSocket")
                        }
                    }
                case .disconnected(_, _):
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectBybit()
                    }
                case .error(_):
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectBybit()
                    }
                case .text(let string):
                    if let data = string.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                       let success = json["success"] as? Bool, success,
                       let retMsg = json["ret_msg"] as? String, retMsg == "subscribe" {
                        print("Bybit Spot subscription confirmed")
                    }
                default:
                    break
                }
            }
        }
        
        bybitSpotSocket = WebSocket(request: URLRequest(url: URL(string: "wss://stream.bybit.com/v5/public/linear")!))
        bybitFuturesDelegate = BybitFuturesWebSocketDelegate()
        bybitSpotSocket?.delegate = bybitFuturesDelegate
        bybitSpotSocket?.connect()
        
        weak var futuresWs = bybitSpotSocket
        futuresWs?.onEvent = { event in
            Task { @MainActor in
                switch event {
                case .connected(_):
                    for pair in tradingPairs {
                        // Fixed symbol formatting for Bybit futures
                        let symbol = pair.replacingOccurrences(of: "-", with: "")
                        let subscribeMessage: [String: Any] = [
                            "req_id": "bybit_futures_\(Int(Date().timeIntervalSince1970 * 1000))",
                            "op": "subscribe",
                            "args": [
                                "tickers.\(symbol)",
                                "orderbook.50.\(symbol)",
                                "publicTrade.\(symbol)"
                            ]
                        ]
                        if let data = try? JSONSerialization.data(withJSONObject: subscribeMessage),
                           let message = String(data: data, encoding: .utf8) {
                            futuresWs?.write(string: message)
                            print("Subscribed to Bybit futures topics: tickers.\(symbol), orderbook.50.\(symbol), publicTrade.\(symbol) for pair: \(pair)")
                        } else {
                            print("Failed to subscribe to Bybit futures topics for pair: \(pair)")
                        }
                    }
                    Timer.scheduledTimer(withTimeInterval: 20.0, repeats: true) { _ in
                        Task { @MainActor in
                            let pingMessage = "{\"op\": \"ping\", \"req_id\": \"bybit_futures_\(Int(Date().timeIntervalSince1970 * 1000))\"}"
                            futuresWs?.write(string: pingMessage)
                            print("Sent ping to Bybit Futures WebSocket")
                        }
                    }
                case .disconnected(_, _):
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectBybit()
                    }
                case .error(_):
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectBybit()
                    }
                case .text(let string):
                    if let data = string.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                       let success = json["success"] as? Bool, success,
                       let retMsg = json["ret_msg"] as? String, retMsg == "subscribe" {
                        print("Bybit Futures subscription confirmed")
                    }
                default:
                    break
                }
            }
        }
    }
}


//--------------------------------------------------------------------------------------------------------------------------Block 12 - Trading Loop Monitoring and Support

//--------------- Block 12 - Trading Loop Monitoring and Support
// VARIABLES TO ADD: Fixed Sendable conformance issues and MainActor isolation

import Foundation // Added for String.Encoding and other Foundation types

extension ExchangeWebSocket {
    static var totalProfit: Double = 0.0
    static var totalFees: Double = 0.0
    static var kellyCreditRatio: Double = getDouble("KELLY_CREDIT_RATIO", defaultValue: 2.0)

    static func checkLiquidityAsyncUnique(exchange: String, pair: String, marketType: String, tradeAmount: Double, price: Double) async -> Double? {
        let minLiquidity = getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 500.0)
        let requiredLiquidity = tradeAmount * price * liquidityDepthMultiplier

        do {
            let depth = try await fetchOrderBookDepth(for: exchange, pair: pair, marketType: marketType, retryCount: 0)
            guard let unwrappedDepth = depth, unwrappedDepth >= max(minLiquidity, requiredLiquidity) else {
                print(" DEBUG: Insufficient liquidity for \(exchange)-\(pair)-\(marketType): Depth \(String(describing: depth)), Required \(requiredLiquidity)")
                await MainActor.run(body: {
                    logAlert(event: "Insufficient liquidity for \(exchange)-\(pair)-\(marketType): Depth \(String(describing: depth))")
                })
                return nil
            }
            print("DEBUG: Liquidity check passed for \(exchange)-\(pair)-\(marketType): Depth \(unwrappedDepth)")
            return unwrappedDepth
        } catch {
            print("DEBUG: Error fetching order book depth for \(exchange)-\(pair)-\(marketType): \(error.localizedDescription)")
            await MainActor.run(body: {
                logAlert(event: "Error fetching order book depth for \(exchange)-\(pair)-\(marketType): \(error.localizedDescription)")
            })
            return nil
        }
    }

    static func fetchOrderBookDepth(for exchange: String, pair: String, marketType: String, retryCount: Int = 0) async throws -> Double? {
        let maxRetries = getInt("API_MAX_RETRIES", defaultValue: 3)
        guard retryCount < maxRetries else {
            let book = exchange == "bybit" ? bybitOrderBooks[pair] : kucoinOrderBooks[pair]
            let cachedDepth = book.map { book in
                let bidDepth = book.bids.prefix(10).reduce(0.0) { $0 + $1.price * $1.quantity }
                let askDepth = book.asks.prefix(10).reduce(0.0) { $0 + $1.price * $1.quantity }
                return bidDepth + askDepth
            } ?? getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 500.0)
            print("DEBUG: Max retries reached, using cached depth for \(exchange)-\(pair)-\(marketType): \(cachedDepth)")
            await MainActor.run(body: {
                logAlert(event: "Max retries reached for order book fetch: \(exchange)-\(pair)-\(marketType)")
            })
            return cachedDepth
        }

        let symbol = pair.replacingOccurrences(of: "-USDT", with: "USDT")
        var url: URL?
        if exchange == "bybit" {
            let category = marketType == "spot" ? "spot" : "linear"
            url = URL(string: "https://api.bybit.com/v5/market/orderbook?category=\(category)&symbol=\(symbol)&limit=50")
        } else {
            let endpoint = marketType == "spot" ? "/api/v1/market/orderbook/level2_50?symbol=\(symbol)" : "/api/v1/contractMarket/level2?symbol=\(symbol)M"
            url = URL(string: "https://api\(marketType == "spot" ? "" : "-futures").kucoin.com\(endpoint)")
        }

        guard let requestUrl = url else {
            print("Invalid order book URL for \(exchange)-\(pair)-\(marketType)")
            await MainActor.run(body: {
                logAlert(event: "Invalid order book URL for \(exchange)-\(pair)-\(marketType)")
            })
            try await Task.sleep(nanoseconds: 2_000_000_000)
            return try await fetchOrderBookDepth(for: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1)
        }

        var request = URLRequest(url: requestUrl)
        request.httpMethod = "GET"
        request.timeoutInterval = getDouble("API_TIMEOUT_SECONDS", defaultValue: 10.0)

        let startTime = Date()
        let (data, response) = try await URLSession.shared.data(for: request)
        let latency = Date().timeIntervalSince(startTime) * 1000
        await MainActor.run(body: {
            lastLatency[pair] = latency
            if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 300.0) {
                print("High latency detected for order book fetch: \(latency)ms")
                logAlert(event: "High latency detected for order book fetch: \(latency)ms")
            }
        })

        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
            print("Invalid order book response for \(exchange)-\(pair)-\(marketType)")
            await MainActor.run(body: {
                logAlert(event: "Invalid order book response for \(exchange)-\(pair)-\(marketType)")
            })
            try await Task.sleep(nanoseconds: 2_000_000_000)
            return try await fetchOrderBookDepth(for: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1)
        }

        let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
        if exchange == "bybit" {
            guard let result = json?["result"] as? [String: Any],
                  let bids = result["b"] as? [[String]],
                  let asks = result["a"] as? [[String]],
                  !bids.isEmpty, !asks.isEmpty else {
                print("Failed to parse Bybit order book data for \(pair)-\(marketType)")
                await MainActor.run(body: {
                    logAlert(event: "Failed to parse Bybit order book data for \(pair)-\(marketType)")
                })
                try await Task.sleep(nanoseconds: 2_000_000_000)
                return try await fetchOrderBookDepth(for: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1)
            }

            var bidDepth: Double = 0.0
            var askDepth: Double = 0.0

            for bid in bids.prefix(10) {
                if let priceStr = bid.first, let qtyStr = bid.last,
                   let price = Double(priceStr), let qty = Double(qtyStr) {
                    bidDepth += price * qty
                }
            }

            for ask in asks.prefix(10) {
                if let priceStr = ask.first, let qtyStr = ask.last,
                   let price = Double(priceStr), let qty = Double(qtyStr) {
                    askDepth += price * qty
                }
            }

            let totalDepth = bidDepth + askDepth
            print("DEBUG: Bybit order book depth for \(pair)-\(marketType): \(totalDepth)")
            return totalDepth
        } else {
            guard let dataDict = json?["data"] as? [String: Any],
                  let bids = dataDict["bids"] as? [[String]],
                  let asks = dataDict["asks"] as? [[String]],
                  !bids.isEmpty, !asks.isEmpty else {
                print("Failed to parse KuCoin order book data for \(pair)-\(marketType)")
                await MainActor.run(body: {
                    logAlert(event: "Failed to parse KuCoin order book data for \(pair)-\(marketType)")
                })
                try await Task.sleep(nanoseconds: 2_000_000_000)
                return try await fetchOrderBookDepth(for: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1)
            }

            var bidDepth: Double = 0.0
            var askDepth: Double = 0.0

            for bid in bids.prefix(10) {
                if let priceStr = bid.first, let qtyStr = bid.last,
                   let price = Double(priceStr), let qty = Double(qtyStr) {
                    bidDepth += price * qty
                }
            }

            for ask in asks.prefix(10) {
                if let priceStr = ask.first, let qtyStr = ask.last,
                   let price = Double(priceStr), let qty = Double(qtyStr) {
                    askDepth += price * qty
                }
            }

            let totalDepth = bidDepth + askDepth
            print("DEBUG: KuCoin order book depth for \(pair)-\(marketType): \(totalDepth)")
            return totalDepth
        }
    }

    private static func fetchAndLogBalances(isInitial: Bool = false, completion: @escaping @Sendable () -> Void) {
        fetchKucoinBalance { _ in
            Task { @MainActor in
                fetchBybitBalance { _ in
                    Task { @MainActor in
                        if isInitial {
                            print(" Initial Balances: KuCoin: \(ExchangeWebSocket.kucoinBalance) | Bybit: \(ExchangeWebSocket.bybitBalance)")
                        }
                        completion()
                    }
                }
            }
        }
    }

    static func dynamicTradeAmount(balance: Double, riskPercent: Double, volatility: Double, pair: String = tradingPairs.first ?? "BTC-USDT") async -> Double {
        let kellyFraction = await calculateKellyCriterion(pair: pair)
        let baseAmount = min(balance * riskPercent, balance * 0.6)
        let volatilityAdjusted = baseAmount * (1.0 / (1.0 + volatility * 0.3))
        let kellyAmount = balance * max(0.0, min(kellyFraction, 0.6))
        return min(volatilityAdjusted, kellyAmount)
    }

    static func rebalanceExchanges() {
        let balanceDifferenceThreshold = 0.08
        let totalBalance = kucoinBalance + bybitBalance
        
        guard totalBalance > 0 else { return }
        
        let kucoinBalanceRatio = kucoinBalance / totalBalance
        let bybitBalanceRatio = bybitBalance / totalBalance
        
        if abs(kucoinBalanceRatio - bybitBalanceRatio) > balanceDifferenceThreshold {
            let targetBalance = totalBalance / 2
            let transferAmount = abs(kucoinBalance - targetBalance)
            
            if kucoinBalance > bybitBalance {
                ExchangeWebSocket.kucoinBalance -= transferAmount
                ExchangeWebSocket.bybitBalance += transferAmount
            } else {
                ExchangeWebSocket.bybitBalance -= transferAmount
                ExchangeWebSocket.kucoinBalance += transferAmount
            }
        }
    }

    static func fetchExchangeFees(exchange: String, completion: @escaping @Sendable (Double?, Double?) -> Void) {
        if exchange == "kucoin" {
            completion(0.0001, 0.0004)
        } else if exchange == "bybit" {
            completion(0.0001, 0.0004)
        } else {
            completion(nil, nil)
        }
    }

    @MainActor
    static func printPeriodicSummary() {
        print(" Performance Summary:")
        print(" Total Profit: \(totalProfit), Total Fees: \(totalFees)")
        for (pair, metrics) in tradeMetrics {
            print("\(pair): Wins: \(metrics.wins), Losses: \(metrics.losses), Profit: \(metrics.totalProfit), Fees: \(metrics.totalFees)")
        }
    }

    static func executeHFTTrade(exchange: String, pair: String, side: String, price: Double, amount: Double) {
        print(" Trade: \(side) \(amount) of \(pair) on \(exchange) at \(price)")
        let fee = amount * price * (exchange == "kucoin" ? kucoinTakerFee : bybitTakerFee)
        totalFees += fee
        if exchange == "kucoin" {
            kucoinBalance -= side == "buy" ? (amount * price + fee) : -fee
            kucoinPositions[pair] = (kucoinPositions[pair] ?? 0.0) + (side == "buy" ? amount : -amount)
        } else {
            bybitBalance -= side == "buy" ? (amount * price + fee) : -fee
            bybitPositions[pair] = (bybitPositions[pair] ?? 0.0) + (side == "buy" ? amount : -amount)
        }
    }

    static func connectWebSocket(exchange: String, pair: String, marketType: String) {
        print(" Connecting WebSocket for \(exchange), pair: \(pair), marketType: \(marketType)")
    }

    static func checkCircuitBreaker(pair: String) {
        let prices = ExchangeWebSocket.kucoinPrices[pair] ?? []
        guard prices.count >= 60 else { return }
        let recentPrices = prices.suffix(60)
        let volatility = (recentPrices.max()! - recentPrices.min()!) / Double(recentPrices.count)
        if volatility > ExchangeWebSocket.volatilitySpikeThreshold {
            isTradingPaused[pair] = true
            lastVolatilityPause = Date()
            print(" Circuit breaker triggered for \(pair): Volatility: \(String(format: "%.4f", volatility))")
            Task { @MainActor in
                logAlert(event: "Circuit breaker triggered for \(pair): Volatility: \(String(format: "%.4f", volatility))")
            }
        }
    }

    static func marketMaker(pair: String, exchange: String) {
        let spread = getDouble("MARKET_MAKING_SPREAD", defaultValue: 0.001)
        let price = exchange == "kucoin" ? kucoinCurrentPrice[pair] ?? 0.0 : bybitCurrentPrice[pair] ?? 0.0
        print(" Market-making for \(pair) on \(exchange): Bid: \(String(format: "%.4f", price * (1 - spread))), Ask: \(String(format: "%.4f", price * (1 + spread)))")
    }

    static func executeScalpingTrade(pair: String, exchange: String, entryPrice: Double, targetPrice: Double, stopPrice: Double, tradeAmount: Double, maxActiveTrades: Int) async -> Bool {
        let trailingProfitPercent = getDouble("TRAILING_PROFIT_PERCENT", defaultValue: 0.03)
        let feeRate = exchange == "kucoin" ? kucoinTakerFee : bybitTakerFee
        let quantity = tradeAmount / entryPrice
        var highestPrice = entryPrice
        var trailingTargetPrice = entryPrice * (1 + trailingProfitPercent)
        var exitPrice: Double = 0.0
        let startTime = Date()
        let dashboardJSONURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/dashboard.json")

        // Copy balance to avoid inout capture
        var localKucoinBalance = kucoinBalance
        var localBybitBalance = bybitBalance

        while Date().timeIntervalSince(startTime) < 60 {
            if let currentPrice = await MainActor.run(body: { exchange == "bybit" ? bybitCurrentPrice[pair] : kucoinCurrentPrice[pair] }) {
                if currentPrice > highestPrice {
                    highestPrice = currentPrice
                    trailingTargetPrice = highestPrice * (1 - trailingProfitPercent)
                }
                if currentPrice >= targetPrice || currentPrice <= stopPrice || currentPrice <= trailingTargetPrice {
                    exitPrice = currentPrice
                    break
                }
            }
            try? await Task.sleep(nanoseconds: 1_00_000_000) // 100ms
        }

        if exitPrice == 0.0 {
            exitPrice = await MainActor.run(body: { exchange == "bybit" ? bybitCurrentPrice[pair] : kucoinCurrentPrice[pair] }) ?? entryPrice
        }

        let profit = quantity * (exitPrice - entryPrice)
        let fees = tradeAmount * feeRate * 2
        if exchange == "kucoin" {
            localKucoinBalance += profit - fees
        } else {
            localBybitBalance += profit - fees
        }
        print(" Scalping trade for \(pair) on \(exchange): Profit: \(profit), Fees: \(fees)")
        await MainActor.run(body: {
            // Update global balances after Task
            if exchange == "kucoin" {
                kucoinBalance = localKucoinBalance
            } else {
                bybitBalance = localBybitBalance
            }
            updateTradeMetrics(
                pair: pair,
                profit: profit,
                fees: fees,
                isWin: profit > 0,
                dashboardJSONURL: dashboardJSONURL,
                totalProfit: &ExchangeWebSocket.totalProfit,
                totalFees: &ExchangeWebSocket.totalFees
            )
            logTradeToCSV(
                pair: pair,
                strategy: "HFT Scalping",
                profit: profit,
                fees: fees,
                tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trades.csv")
            )
            sendTradeToFlaskServer(strategy: "HFT Scalping", pair: pair, exchange: exchange, spotPrice: 0.0, futuresPrice: 0.0, tradeAmount: 0.0, profit: profit)
        })
        return profit > 0
    }

    static func executeFuturesTrade(pair: String, exchange: String, entryPrice: Double, targetPrice: Double, stopPrice: Double, tradeAmount: Double) {
        let feeRate = exchange == "bybit" ? bybitTakerFee : kucoinTakerFee
        let quantity = tradeAmount / entryPrice
        let leverage = exchange == "bybit" ? getDouble("BYBIT_LEVERAGE", defaultValue: 3.0) : getDouble("KUCOIN_LEVERAGE", defaultValue: 3.0)
        let effectiveTradeAmount = tradeAmount * leverage
        var exitPrice: Double = 0.0
        let startTime = Date()
        let dashboardJSONURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/dashboard.json")
        
        // Copy balance to avoid inout capture
        var localKucoinBalance = kucoinBalance
        var localBybitBalance = bybitBalance

        while Date().timeIntervalSince(startTime) < 60 {
            if let price = (exchange == "bybit" ? bybitCurrentFuturesPrice[pair] : kucoinCurrentFuturesPrice[pair]) {
                if price >= targetPrice || price <= stopPrice {
                    exitPrice = price
                    break
                }
            }
            Thread.sleep(forTimeInterval: 0.1)
        }
        
        if exitPrice == 0.0 {
            exitPrice = (exchange == "bybit" ? bybitCurrentFuturesPrice[pair] : kucoinCurrentFuturesPrice[pair]) ?? entryPrice
        }
        
        let grossProfit = (exitPrice - entryPrice) * quantity * leverage
        let fees = effectiveTradeAmount * feeRate * 2
        let profit = grossProfit - fees
        
        if exchange == "bybit" {
            localBybitBalance += profit
        } else {
            localKucoinBalance += profit
        }
        print(" Futures trade for \(pair) on \(exchange): Profit: \(profit), Fees: \(fees)")
        Task { @MainActor in
            // Update global balances after Task
            if exchange == "bybit" {
                bybitBalance = localBybitBalance
            } else {
                kucoinBalance = localKucoinBalance
            }
            updateTradeMetrics(
                pair: pair,
                profit: profit,
                fees: fees,
                isWin: profit > 0,
                dashboardJSONURL: dashboardJSONURL,
                totalProfit: &ExchangeWebSocket.totalProfit,
                totalFees: &ExchangeWebSocket.totalFees
            )
            logTradeToCSV(
                pair: pair,
                strategy: "Funding Rate Momentum",
                profit: profit,
                fees: fees,
                tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trades.csv")
            )
            sendTradeToFlaskServer(strategy: "Funding Rate Momentum", pair: pair, exchange: exchange, spotPrice: 0.0, futuresPrice: 0.0, tradeAmount: 0.0, profit: profit)
        }
    }

    @MainActor
    static func updateDashboardJSON(dashboardJSONURL: URL, totalProfit: Double, totalFees: Double) {
        let timestamp = ISO8601DateFormatter().string(from: Date())
        do {
            let fileManager = FileManager.default
            let directoryURL = dashboardJSONURL.deletingLastPathComponent()
            if !fileManager.fileExists(atPath: directoryURL.path) {
                try fileManager.createDirectory(at: directoryURL, withIntermediateDirectories: true, attributes: nil)
            }
            var perPairMetrics: [[String: Any]] = []
            for pair in tradingPairs {
                let metrics = tradeMetrics[pair] ?? (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)
                let trades = metrics.wins + metrics.losses
                let winRate = trades > 0 ? Double(metrics.wins) / Double(trades) * 100.0 : 0.0
                let sentiment = sentimentScores[pair] ?? 0.0
                let pairData: [String: Any] = [
                    "pair": pair,
                    "trades": trades,
                    "wins": metrics.wins,
                    "losses": metrics.losses,
                    "winRate": winRate,
                    "profit": metrics.totalProfit,
                    "fees": metrics.totalFees,
                    "sentiment": sentiment
                ]
                perPairMetrics.append(pairData)
            }
            
            let dashboardData: [String: Any] = [
                "timestamp": timestamp,
                "totalProfit": totalProfit,
                "totalFees": totalFees,
                "totalTrades": tradeMetrics.values.reduce(0) { $0 + $1.wins + $1.losses },
                "kucoinBalance": kucoinBalance,
                "bybitBalance": bybitBalance,
                "perPairMetrics": perPairMetrics,
                "livePrices": tradingPairs.map { pair in
                    [
                        "pair": pair,
                        "kucoinSpot": kucoinCurrentPrice[pair] ?? 0.0,
                        "kucoinFutures": kucoinCurrentFuturesPrice[pair] ?? 0.0,
                        "bybitSpot": bybitCurrentPrice[pair] ?? 0.0,
                        "bybitFutures": bybitCurrentFuturesPrice[pair] ?? 0.0
                    ]
                }
            ]
            
            let jsonData = try JSONSerialization.data(withJSONObject: dashboardData, options: [.prettyPrinted])
            try jsonData.write(to: dashboardJSONURL, options: .atomic)
            print(" Updated dashboard JSON at \(dashboardJSONURL.path)")
        } catch {
            print(" Failed to update dashboard JSON: \(error.localizedDescription)")
            logAlert(event: "Failed to update dashboard JSON: \(error.localizedDescription)")
        }
    }

    static func calculateKellyCriterion(pair: String) async -> Double {
        // Use empirical win probability from tradeMetrics, fallback to default
        let metrics = tradeMetrics[pair] ?? (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)
        let totalTrades = metrics.wins + metrics.losses
        let winProbability = totalTrades > 0 ? Double(metrics.wins) / Double(totalTrades) : kellyWinProbability
        
        // Adjust reward-to-risk based on ATR for volatility
        let atr = kucoinFuturesATR[pair] ?? 0.01
        let currentPrice = kucoinCurrentPrice[pair] ?? 1.0
        let volatilityAdjustment = atr / currentPrice
        let rewardToRisk = kellyRewardToRisk * (1 + volatilityAdjustment * 0.5) // Scale by volatility
        
        // Calculate Kelly fraction
        let kelly = (winProbability * (rewardToRisk + 1) - 1) / rewardToRisk
        
        // Apply bounds and validation
        guard rewardToRisk > 0 else {
            Task { @MainActor in
                logAlert(event: " Invalid reward-to-risk ratio for \(pair): \(rewardToRisk)")
            }
            return 0.01 // Minimum safe fraction
        }
        
        // Clamp between 0.01 and 0.5 for safety
        let clampedKelly = max(min(kelly, 0.5), 0.01)
        
        // Store in kellySizes for pair-specific sizing
        await MainActor.run {
            kellySizes[pair] = clampedKelly
            logAlert(event: " Calculated Kelly fraction for \(pair): \(clampedKelly), p=\(winProbability), r=\(rewardToRisk)")
        }
        
        return clampedKelly
    }

    static func calculateOrderBookVWAP(pair: String, exchange: String, priceRange: Double, currentPrice: Double) -> Double? {
        let orderBook = exchange == "kucoin" ? kucoinOrderBooks[pair] : bybitOrderBooks[pair]
        guard let book = orderBook, !book.bids.isEmpty, !book.asks.isEmpty else {
            print("DEBUG: Order book unavailable for \(pair) on \(exchange)")
            Task { @MainActor in
                logAlert(event: "Order book unavailable for \(pair) on \(exchange)")
            }
            return nil
        }

        let minPrice = currentPrice * (1 - priceRange)
        let maxPrice = currentPrice * (1 + priceRange)

        var totalVolume: Double = 0.0
        var totalPriceVolume: Double = 0.0

        for bid in book.bids {
            if bid.price >= minPrice && bid.price <= maxPrice {
                totalPriceVolume += bid.price * bid.quantity
                totalVolume += bid.quantity
            }
        }

        for ask in book.asks {
            if ask.price >= minPrice && ask.price <= maxPrice {
                totalPriceVolume += ask.price * ask.quantity
                totalVolume += ask.quantity
            }
        }

        guard totalVolume > 0 else {
            print("DEBUG: Zero total volume in VWAP calculation for \(pair) on \(exchange)")
            Task { @MainActor in
                logAlert(event: "Zero total volume in VWAP calculation for \(pair) on \(exchange)")
            }
            return nil
        }

        let vwap = totalPriceVolume / totalVolume
        print("DEBUG: Calculated VWAP for \(pair) on \(exchange): \(vwap)")
        return vwap
    }

    static func checkDailyLossLimit(exchange: String, pair: String, potentialLoss: Double) async -> Bool {
        let dailyLossLimit = getDouble("DAILY_LOSS_LIMIT", defaultValue: 100.0)
        let currentLoss = await MainActor.run(body: { dailyLoss[exchange] ?? 0.0 })
        let newTotalLoss = currentLoss + potentialLoss
        let exceedsLimit = newTotalLoss > dailyLossLimit
        
        if exceedsLimit {
            print("DEBUG: Daily loss limit exceeded for \(exchange)-\(pair): Current \(currentLoss), Potential \(potentialLoss), Limit \(dailyLossLimit)")
            await MainActor.run(body: {
                logAlert(event: "Daily loss limit exceeded for \(exchange)-\(pair): Current \(currentLoss), Potential \(potentialLoss)")
            })
        }
        return !exceedsLimit
    }
}

//---------------------------------------------------------------------------------------------------------Block 13 - Trade Performance and Logging

//--------------- Block 13 - Trade Performance and Logging
// VARIABLES TO ADD: Fixed async call issues by marking functions as async or using Task wrapper

import Foundation
import SwiftUI

extension ExchangeWebSocket {
    @MainActor
    static func updateTradeMetrics(pair: String, profit: Double, fees: Double, isWin: Bool, dashboardJSONURL: URL, totalProfit: inout Double, totalFees: inout Double) {
        var metrics = tradeMetrics[pair] ?? (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)
        metrics.totalProfit += profit
        metrics.totalFees += fees
        if isWin {
            metrics.wins += 1
        } else {
            metrics.losses += 1
        }
        tradeMetrics[pair] = metrics

        var performance = performanceMetrics[pair] ?? (profit: 0.0, fees: 0.0, trades: 0, wins: 0)
        performance.profit += profit
        performance.fees += fees
        performance.trades += 1
        if isWin {
            performance.wins += 1
        }
        performanceMetrics[pair] = performance

        totalProfit += profit
        totalFees += fees

        do {
            let tradeMetricData = tradeMetrics.mapValues { metric in
                ["totalProfit": metric.totalProfit, "totalFees": metric.totalFees, "wins": metric.wins, "losses": metric.losses]
            }
            let performanceMetricData = performanceMetrics.mapValues { metric in
                ["profit": metric.profit, "fees": metric.fees, "trades": metric.trades, "wins": metric.wins]
            }
            let dashboardData: [String: Any] = [
                "tradeMetrics": tradeMetricData,
                "performanceMetrics": performanceMetricData,
                "totalProfit": totalProfit,
                "totalFees": totalFees
            ]
            let jsonData = try JSONSerialization.data(withJSONObject: dashboardData, options: [.prettyPrinted, .sortedKeys])
            try jsonData.write(to: dashboardJSONURL)
            print("Dashboard updated at \(dashboardJSONURL.path)")
        } catch {
            print("Dashboard update failed: \(error.localizedDescription)")
            logAlert(event: "Dashboard update failed: \(error.localizedDescription)")
        }
    }

    @MainActor
    static func logTradeToCSV(pair: String, strategy: String, profit: Double, fees: Double, tradesCSVURL: URL) {
        let timestampFormatter = ISO8601DateFormatter()
        timestampFormatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        let timestamp = timestampFormatter.string(from: Date())
        let logEntry = "\(pair),\(timestamp),\(strategy),\(profit),\(fees)\n"

        do {
            let fileManager = FileManager.default
            let directoryPath = tradesCSVURL.deletingLastPathComponent().path
            if !fileManager.fileExists(atPath: directoryPath) {
                try fileManager.createDirectory(atPath: directoryPath, withIntermediateDirectories: true, attributes: [.posixPermissions: 0o755])
                print("FILE DEBUG: Created directory for trades.csv at \(directoryPath)")
            }

            if !fileManager.fileExists(atPath: tradesCSVURL.path) {
                try "pair,timestamp,strategy,profit,fees\n".write(to: tradesCSVURL, atomically: true, encoding: .utf8)
                try fileManager.setAttributes([.posixPermissions: 0o644], ofItemAtPath: tradesCSVURL.path)
                print("FILE DEBUG: Created trades.csv with header")
            }

            if let fileHandle = try? FileHandle(forWritingTo: tradesCSVURL) {
                defer { fileHandle.closeFile() }
                if let data = logEntry.data(using: .utf8) {
                    fileHandle.seekToEndOfFile()
                    fileHandle.write(data)
                    print("FILE DEBUG: Wrote trade to trades.csv: \(logEntry.trimmingCharacters(in: .whitespacesAndNewlines))")
                } else {
                    throw NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Failed to convert trade log entry to data"])
                }
            } else {
                let existingContent = try String(contentsOf: tradesCSVURL, encoding: .utf8)
                let newContent = existingContent + logEntry
                try newContent.write(to: tradesCSVURL, atomically: true, encoding: .utf8)
                print("FILE DEBUG: Fallback write to trades.csv: \(logEntry.trimmingCharacters(in: .whitespacesAndNewlines))")
            }
        } catch {
            print("FILE WRITE FAILURE: Failed to write to trades.csv: \(error.localizedDescription)")
            logAlert(event: "TRADES_CSV_ERROR: \(error.localizedDescription)")
        }
    }

    static func saveHistoricalSpreadsToCSV(pair: String, spread: Double, predictedSpreadChange: Double) {
        guard !spread.isZero else {
            print("DEBUG: Zero spread prevented logging for \(pair)")
            logAlert(event: "Zero spread prevented logging for \(pair)")
            return
        }
        let timestamp = ISO8601DateFormatter().string(from: Date())
        let logEntry = "\(timestamp),\(pair),\(spread),\(predictedSpreadChange)\n"
        let spreadsCSVURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/historical_spreads.csv")

        do {
            let fileManager = FileManager.default
            let directoryPath = spreadsCSVURL.deletingLastPathComponent().path
            if !fileManager.fileExists(atPath: directoryPath) {
                try fileManager.createDirectory(atPath: directoryPath, withIntermediateDirectories: true, attributes: [.posixPermissions: 0o755])
                print("FILE DEBUG: Created directory for historical_spreads.csv at \(directoryPath)")
            }
            if !fileManager.fileExists(atPath: spreadsCSVURL.path) {
                try "timestamp,pair,spread,predicted_change\n".write(to: spreadsCSVURL, atomically: true, encoding: .utf8)
                try fileManager.setAttributes([.posixPermissions: 0o644], ofItemAtPath: spreadsCSVURL.path)
                print("FILE DEBUG: Created historical_spreads.csv with header")
            }
            if let fileHandle = try? FileHandle(forWritingTo: spreadsCSVURL) {
                defer { fileHandle.closeFile() }
                if let data = logEntry.data(using: .utf8) {
                    fileHandle.seekToEndOfFile()
                    fileHandle.write(data)
                    print("FILE DEBUG: Wrote spread to historical_spreads.csv: \(logEntry.trimmingCharacters(in: .whitespacesAndNewlines))")
                } else {
                    throw NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Failed to convert spread log entry to data"])
                }
            } else {
                let existingContent = try String(contentsOf: spreadsCSVURL, encoding: .utf8)
                let newContent = existingContent + logEntry
                try newContent.write(to: spreadsCSVURL, atomically: true, encoding: .utf8)
                print("FILE DEBUG: Fallback write to historical_spreads.csv: \(logEntry.trimmingCharacters(in: .whitespacesAndNewlines))")
            }
        } catch {
            print("FILE WRITE FAILURE: Failed to write to historical_spreads.csv: \(error.localizedDescription)")
            logAlert(event: "SPREAD_CSV_ERROR: \(error.localizedDescription)")
        }
    }

    static func handleKucoinPriceUpdate(pair: String, price: Double) {
        print("DEBUG: KuCoin Price Update - \(pair): \(price)")
        kucoinCurrentPrice[pair] = price
    }

    static func handleKucoinFuturesPriceUpdate(pair: String, price: Double) {
        print("DEBUG: KuCoin Futures Price Update - \(pair): \(price)")
        kucoinCurrentFuturesPrice[pair] = price
    }

    static func handleBybitPriceUpdate(pair: String, price: Double) {
        print("DEBUG: Bybit Price Update - \(pair): \(price)")
        bybitCurrentPrice[pair] = price
    }

    static func handleBybitFuturesPriceUpdate(pair: String, price: Double) {
        print("DEBUG: Bybit Futures Price Update - \(pair): \(price)")
        bybitCurrentFuturesPrice[pair] = price
    }

    // FIX: Mark function as async to handle async calls properly
    static func executeSingleExchangeArbitrage(exchange: String, pair: String, spotPrice: Double, futuresPrice: Double, strategy: String, kucoinSpotPrices: [Double], bybitSpotPrices: [Double], tradeAmount: Double) async {
        let spread = abs(spotPrice - futuresPrice) / min(max(spotPrice, 0.0001), max(futuresPrice, 0.0001))
        let minSpreadThreshold = getDouble("ARBITRAGE_MIN_SPREAD_THRESHOLD", defaultValue: 0.001)
        saveHistoricalSpreadsToCSV(pair: pair, spread: spread, predictedSpreadChange: 0.0)

        print("""
TRADE CHECK: \(pair) (\(exchange))
Spread: \(spread) >= Threshold: \(minSpreadThreshold) -> \(spread >= minSpreadThreshold)
""")
        guard spread >= minSpreadThreshold else {
            print("DEBUG: Spread too low for \(exchange)-\(pair): \(spread)")
            logAlert(event: "Spread too low for \(exchange)-\(pair): \(spread)")
            return
        }

        let liquidity = await checkLiquidityAsync(exchange: exchange, pair: pair, marketType: "spot", tradeAmount: tradeAmount, price: spotPrice)
        let futuresLiquidity = await checkLiquidityAsync(exchange: exchange, pair: pair, marketType: "futures", tradeAmount: tradeAmount, price: futuresPrice)
        let minLiquidityThresholdValue = await MainActor.run { minLiquidityThreshold }
        print("TRADE CHECK: \(pair) Liquidity - Spot: \(liquidity ?? -1.0) >= \(minLiquidityThresholdValue), Futures: \(futuresLiquidity ?? -1.0) >= \(minLiquidityThresholdValue)")
        guard let liquidity = liquidity, let futuresLiquidity = futuresLiquidity,
              liquidity >= minLiquidityThresholdValue, futuresLiquidity >= minLiquidityThresholdValue else {
            print("DEBUG: Invalid liquidity for \(exchange)-\(pair): Spot=\(String(describing: liquidity)), Futures=\(String(describing: futuresLiquidity))")
            logAlert(event: "Invalid liquidity for \(exchange)-\(pair): Spot=\(String(describing: liquidity)), Futures=\(String(describing: futuresLiquidity))")
            return
        }

        let fundingRate = await MainActor.run { exchange == "kucoin" ? kucoinFundingRates[pair] ?? 0.0 : bybitFundingRates[pair] ?? 0.0 }
        let maxFundingRateValue = await MainActor.run { maxFundingRate }
        print("TRADE CHECK: \(pair) Funding: \(abs(fundingRate)) < \(maxFundingRateValue) -> \(abs(fundingRate) < maxFundingRateValue)")
        guard abs(fundingRate) < maxFundingRateValue else {
            print("DEBUG: Funding rate too high for \(exchange)-\(pair): \(fundingRate)")
            logAlert(event: "Funding rate too high for \(exchange)-\(pair): \(fundingRate)")
            return
        }

        let balance = exchange == "kucoin" ? kucoinBalance : bybitBalance
        print("TRADE CHECK: \(pair) Balance: \(balance) >= \(tradeAmount * spotPrice) -> \(balance >= tradeAmount * spotPrice)")
        guard balance >= tradeAmount * spotPrice else {
            print("DEBUG: Insufficient balance for \(exchange)-\(pair)")
            logAlert(event: "Insufficient balance for \(exchange)-\(pair)")
            return
        }

        let feeRate = exchange == "kucoin" ? kucoinTakerFee : bybitTakerFee
        let fees = tradeAmount * feeRate * 2
        let grossProfit = tradeAmount * spread
        let profit = grossProfit - fees
        let minProfitPercentage = await MainActor.run { spotMinProfitPercentage }
        print("TRADE CHECK: \(pair) Profit: \(profit) > Min: \(minProfitPercentage * tradeAmount * min(spotPrice, futuresPrice))")
        guard profit > minProfitPercentage * tradeAmount * min(spotPrice, futuresPrice) else {
            print("DEBUG: Expected profit too low for \(exchange)-\(pair): \(profit)")
            logAlert(event: "Expected profit too low for \(exchange)-\(pair): \(profit)")
            return
        }

        let success = await executeScalpingTrade(
            pair: pair,
            exchange: exchange,
            entryPrice: spotPrice,
            targetPrice: futuresPrice,
            stopPrice: spotPrice * (1 - scalpStopLoss),
            tradeAmount: tradeAmount,
            maxActiveTrades: maxActiveSpotTrades
        )

        if success {
            print("ARBITRAGE TRIGGERED: \(exchange) \(pair) at \(Date())")
            await MainActor.run {
                updateTradeMetrics(
                    pair: pair,
                    profit: profit,
                    fees: fees,
                    isWin: profit > 0,
                    dashboardJSONURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/dashboard.json"),
                    totalProfit: &ExchangeWebSocket.totalProfit,
                    totalFees: &ExchangeWebSocket.totalFees
                )
                logTradeToCSV(pair: pair, strategy: strategy, profit: profit, fees: fees, tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trades.csv"))
                print("DEBUG: Executed single-exchange arbitrage for \(exchange)-\(pair): Profit=\(profit), Fees=\(fees)")
                logAlert(event: "Executed single-exchange arbitrage for \(exchange)-\(pair): Profit=\(profit), Fees=\(fees)")
            }
        }
    }

    // FIX: Mark function as async to handle async calls properly
    static func executeEnhancedCrossExchangeArbitrage(pair: String, kucoinSpotPrice: Double, bybitSpotPrice: Double, strategy: String, kucoinSpotPrices: [Double], bybitSpotPrices: [Double], amount: Double, completion: @escaping (Bool) -> Void) async {
        let spread = abs(kucoinSpotPrice - bybitSpotPrice) / min(max(kucoinSpotPrice, 0.0001), max(bybitSpotPrice, 0.0001))
        let predictedSpread = await fetchSpreadPrediction(pair: pair, exchange: "cross", spotPrice: kucoinSpotPrice, futuresPrice: bybitSpotPrice) ?? 0.0
        saveHistoricalSpreadsToCSV(pair: pair, spread: spread, predictedSpreadChange: predictedSpread)

        let minSpreadThreshold = getDouble("ARBITRAGE_MIN_SPREAD_THRESHOLD", defaultValue: 0.001)
        print("""
TRADE CHECK: \(pair) (Cross-Exchange)
Spread: \(spread) >= Threshold: \(minSpreadThreshold) -> \(spread >= minSpreadThreshold)
""")
        guard spread >= minSpreadThreshold else {
            print("DEBUG: Spread too low for cross-exchange arbitrage: \(pair), Spread=\(spread)")
            logAlert(event: "Spread too low for cross-exchange arbitrage: \(pair), Spread=\(spread)")
            completion(false)
            return
        }

        let kucoinLiquidity = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "spot", tradeAmount: amount, price: kucoinSpotPrice)
        let bybitLiquidity = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "spot", tradeAmount: amount, price: bybitSpotPrice)
        let minLiquidityThresholdValue = await MainActor.run { minLiquidityThreshold }
        print("TRADE CHECK: \(pair) Liquidity - KuCoin: \(kucoinLiquidity ?? -1.0) >= \(minLiquidityThresholdValue), Bybit: \(bybitLiquidity ?? -1.0) >= \(minLiquidityThresholdValue)")
        guard let kucoinLiquidity = kucoinLiquidity, let bybitLiquidity = bybitLiquidity,
              kucoinLiquidity >= minLiquidityThresholdValue, bybitLiquidity >= minLiquidityThresholdValue else {
            print("DEBUG: Insufficient liquidity for cross-exchange arbitrage: \(pair)")
            logAlert(event: "Insufficient liquidity for cross-exchange arbitrage: \(pair)")
            completion(false)
            return
        }

        let feeRate = kucoinTakerFee + bybitTakerFee
        let fees = amount * feeRate * 2
        let grossProfit = amount * spread
        let profit = grossProfit - fees
        let minProfitPercentage = await MainActor.run { spotMinProfitPercentage }
        print("TRADE CHECK: \(pair) Profit: \(profit) > Min: \(minProfitPercentage * amount * min(kucoinSpotPrice, bybitSpotPrice))")
        guard profit > minProfitPercentage * amount * min(kucoinSpotPrice, bybitSpotPrice) else {
            print("DEBUG: Expected profit too low for cross-exchange arbitrage: \(pair), Profit=\(profit)")
            logAlert(event: "Expected profit too low for cross-exchange arbitrage: \(pair), Profit=\(profit)")
            completion(false)
            return
        }

        let success = await executeScalpingTrade(
            pair: pair,
            exchange: kucoinSpotPrice < bybitSpotPrice ? "kucoin" : "bybit",
            entryPrice: min(kucoinSpotPrice, bybitSpotPrice),
            targetPrice: max(kucoinSpotPrice, bybitSpotPrice),
            stopPrice: min(kucoinSpotPrice, bybitSpotPrice) * (1 - scalpStopLoss),
            tradeAmount: amount,
            maxActiveTrades: maxActiveSpotTrades
        )

        if success {
            print("ARBITRAGE TRIGGERED: Cross-Exchange \(pair) at \(Date())")
            await MainActor.run {
                if kucoinSpotPrice < bybitSpotPrice {
                    kucoinBalance += profit - fees
                    bybitBalance -= amount * bybitTakerFee
                } else {
                    bybitBalance += profit - fees
                    kucoinBalance -= amount * kucoinTakerFee
                }
                updateTradeMetrics(
                    pair: pair,
                    profit: profit,
                    fees: fees,
                    isWin: profit > 0,
                    dashboardJSONURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/dashboard.json"),
                    totalProfit: &ExchangeWebSocket.totalProfit,
                    totalFees: &ExchangeWebSocket.totalFees
                )
                logTradeToCSV(pair: pair, strategy: strategy, profit: profit, fees: fees, tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trades.csv"))
                print("DEBUG: Executed cross-exchange arbitrage for \(pair): Profit=\(profit), Fees=\(fees)")
                logAlert(event: "Executed cross-exchange arbitrage for \(pair): Profit=\(profit), Fees=\(fees)")
                completion(true)
            }
        } else {
            completion(false)
        }
    }

    static func startTrading() {
        print("Starting Trading Bot...")
        initializeParameters {
            connectKucoin()
            connectKucoinFutures()
            connectBybit()
            print("Initializing balances...")
            fetchAndLogBalances(isInitial: true) {
                Task { @MainActor in
                    print("Starting timers...")
                    print("Trading Bot Running...")
                    
                    let dashboardJSONURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/dashboard.json")
                    let tradesCSVURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trades.csv")
                    
                    Timer.scheduledTimer(withTimeInterval: 60, repeats: true) { _ in
                        Task { @MainActor in
                            fetchAndLogBalances(isInitial: false) {
                                Task { @MainActor in
                                    rebalanceExchanges()
                                }
                            }
                        }
                    }
                    
                    Timer.scheduledTimer(withTimeInterval: 3600, repeats: true) { timer in
                        let queue = DispatchQueue(label: "com.bevaixbot.feeUpdate")
                        queue.async {
                            let group = DispatchGroup()
                            group.enter()
                            Task { @MainActor in
                                fetchExchangeFees(exchange: "kucoin") { maker, taker in
                                    DispatchQueue.main.async {
                                        if let maker, let taker {
                                            kucoinMakerFee = maker
                                            kucoinTakerFee = taker
                                            lastFeeUpdate = Date()
                                        }
                                        group.leave()
                                    }
                                }
                            }
                            group.enter()
                            Task { @MainActor in
                                fetchExchangeFees(exchange: "bybit") { maker, taker in
                                    DispatchQueue.main.async {
                                        if let maker, let taker {
                                            bybitMakerFee = maker
                                            bybitTakerFee = taker
                                            lastFeeUpdate = Date()
                                        }
                                        group.leave()
                                    }
                                }
                            }
                            group.notify(queue: .main) {
                            }
                        }
                    }
                    
                    Timer.scheduledTimer(withTimeInterval: Double(await MainActor.run { liquidityCheckInterval }), repeats: true) { _ in
                        Task { @MainActor in
                            for pair in tradingPairs {
                                Task {
                                    let kucoinFuturesPrice = kucoinCurrentFuturesPrice[pair] ?? 0.0
                                    let bybitFuturesPrice = bybitCurrentFuturesPrice[pair] ?? 0.0
                                    let kucoinSpotPrice = kucoinCurrentPrice[pair] ?? 0.0
                                    let kucoinSpotLiquidity = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "spot", tradeAmount: spotTradeAmount, price: kucoinSpotPrice)
                                    let kucoinFuturesLiquidity = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "futures", tradeAmount: futuresTradeAmount, price: kucoinFuturesPrice)
                                    let bybitSpotLiquidity = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "spot", tradeAmount: spotTradeAmount, price: kucoinSpotPrice)
                                    let bybitFuturesLiquidity = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "futures", tradeAmount: futuresTradeAmount, price: bybitFuturesPrice)
                                    print("LIQUIDITY DEBUG: \(pair) - KuCoin Spot: \(kucoinSpotLiquidity ?? -1.0), KuCoin Futures: \(kucoinFuturesLiquidity ?? -1.0), Bybit Spot: \(bybitSpotLiquidity ?? -1.0), Bybit Futures: \(bybitFuturesLiquidity ?? -1.0)")
                                }
                            }
                        }
                    }
                    
                    Timer.scheduledTimer(withTimeInterval: 2, repeats: true) { _ in
                        Task { @MainActor in
                            let tradeCooldown = getDouble("TRADE_EXECUTION_COOLDOWN_SECONDS", defaultValue: 0.5)
                            let _ = 0.0001 // Line 4427: Suppress warning for debugThreshold
                            let _ = -100.0 // Line 4428: Suppress warning for debugMACDThreshold
                            do {
                                try await Task.sleep(nanoseconds: UInt64(tradeCooldown * 1_000_000_000))
                            } catch {
                                print("Trade execution sleep interrupted: \(error.localizedDescription)")
                                logAlert(event: "Trade execution sleep interrupted: \(error.localizedDescription)")
                            }
                            
                            print("DEBUG: Trading pairs: \(tradingPairs)")
                            for pair in tradingPairs {
                                if ExchangeWebSocket.detectVolatilitySpike(exchange: "kucoin", pair: pair) || ExchangeWebSocket.detectVolatilitySpike(exchange: "bybit", pair: pair) {
                                    print("Volatility spike detected for pair: \(pair)")
                                    logAlert(event: "Volatility spike detected for pair: \(pair)")
                                    continue
                                }
                                checkCircuitBreaker(pair: pair)
                                let kucoinSpotPrice = kucoinCurrentPrice[pair] ?? 0.0
                                let kucoinFuturesPrice = kucoinCurrentFuturesPrice[pair] ?? 0.0
                                let bybitSpotPrice = bybitCurrentPrice[pair] ?? 0.0
                                let bybitFuturesPrice = bybitCurrentFuturesPrice[pair] ?? 0.0
                                print("""
LIVE PRICE DEBUG: \(pair)
KC Spot: \(kucoinSpotPrice)
KC Futures: \(kucoinFuturesPrice)
BB Spot: \(bybitSpotPrice)
BB Futures: \(bybitFuturesPrice)
""")
                                
                                let kucoinSpotLiquidity = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "spot", tradeAmount: spotTradeAmount, price: kucoinSpotPrice)
                                let kucoinFuturesLiquidity = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "futures", tradeAmount: futuresTradeAmount, price: kucoinFuturesPrice)
                                let bybitSpotLiquidity = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "spot", tradeAmount: spotTradeAmount, price: bybitSpotPrice)
                                let bybitFuturesLiquidity = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "futures", tradeAmount: futuresTradeAmount, price: bybitFuturesPrice)
                                print("LIQUIDITY DEBUG: \(pair) - KuCoin Spot: \(kucoinSpotLiquidity ?? -1.0), KuCoin Futures: \(kucoinFuturesLiquidity ?? -1.0), Bybit Spot: \(bybitSpotLiquidity ?? -1.0), Bybit Futures: \(bybitFuturesLiquidity ?? -1.0)")
                                
                                print("Executing Trading Strategies...")
                                print("Checking Arbitrage profitability...")
                                
                                print("Live Prices:")
                                for pair in tradingPairs {
                                    let kucoinSpotPrice = kucoinCurrentPrice[pair] ?? 0.0
                                    let kucoinFuturesPrice = kucoinCurrentFuturesPrice[pair] ?? 0.0
                                    let bybitSpotPrice = bybitCurrentPrice[pair] ?? 0.0
                                    let bybitFuturesPrice = bybitCurrentFuturesPrice[pair] ?? 0.0
                                    print("\(pair) | KC: \(String(format: "%.4f", kucoinSpotPrice)) | KC-F: \(String(format: "%.4f", kucoinFuturesPrice)) | BB: \(String(format: "%.4f", bybitSpotPrice)) | BB-F: \(String(format: "%.4f", bybitFuturesPrice))")
                                }
                                
                                var tradeExecuted = false
                                
                                for pair in tradingPairs {
                                    let kucoinOrderBook = kucoinFuturesOrderBook[pair] ?? []
                                    let bybitOrderBook = bybitFuturesOrderBook[pair] ?? []

                                    let kucoinSpotPrice = kucoinCurrentPrice[pair] ?? 0.0
                                    let kucoinFuturesPrice = kucoinCurrentFuturesPrice[pair] ?? 0.0
                                    let bybitSpotPrice = bybitCurrentPrice[pair] ?? 0.0
                                    let bybitFuturesPrice = bybitCurrentFuturesPrice[pair] ?? 0.0

                                    let kucoinSpotPrices = ExchangeWebSocket.kucoinPrices[pair] ?? []
                                    let kucoinFuturesPrices = kucoinFuturesPrices[pair] ?? []
                                    let bybitSpotPrices = ExchangeWebSocket.bybitPrices[pair] ?? []
                                    let bybitFuturesPrices = bybitFuturesPrices[pair] ?? []

                                    let kucoinSpotEmaShort = ExchangeWebSocket.calculateEMA(prices: kucoinSpotPrices, period: spotEmaShortPeriod) ?? 0.0
                                    let kucoinSpotEmaLong = ExchangeWebSocket.calculateEMA(prices: kucoinSpotPrices, period: spotEmaLongPeriod) ?? 0.0
                                    let kucoinFuturesEmaShort = ExchangeWebSocket.calculateEMA(prices: kucoinFuturesPrices, period: futuresEmaShortPeriod) ?? 0.0
                                    let kucoinFuturesEmaLong = ExchangeWebSocket.calculateEMA(prices: kucoinFuturesPrices, period: futuresEmaLongPeriod) ?? 0.0
                                    let bybitSpotEmaShort = ExchangeWebSocket.calculateEMA(prices: bybitSpotPrices, period: spotEmaShortPeriod) ?? 0.0
                                    let bybitSpotEmaLong = ExchangeWebSocket.calculateEMA(prices: bybitSpotPrices, period: spotEmaLongPeriod) ?? 0.0
                                    let _ = ExchangeWebSocket.calculateEMA(prices: bybitFuturesPrices, period: futuresEmaShortPeriod) ?? 0.0 // Line 4496
                                    let _ = ExchangeWebSocket.calculateEMA(prices: bybitFuturesPrices, period: futuresEmaLongPeriod) ?? 0.0 // Line 4497

                                    let kucoinSpotMacd = ExchangeWebSocket.calculateMACD(prices: kucoinSpotPrices, shortPeriod: macdShortPeriod, longPeriod: macdLongPeriod, signalPeriod: macdSignalPeriod)
                                    let kucoinFuturesMacd = ExchangeWebSocket.calculateMACD(prices: kucoinFuturesPrices, shortPeriod: macdShortPeriod, longPeriod: macdLongPeriod, signalPeriod: macdSignalPeriod)
                                    let bybitSpotMacd = ExchangeWebSocket.calculateMACD(prices: bybitSpotPrices, shortPeriod: macdShortPeriod, longPeriod: macdLongPeriod, signalPeriod: macdSignalPeriod)
                                    let bybitFuturesMacd = ExchangeWebSocket.calculateMACD(prices: bybitFuturesPrices, shortPeriod: macdShortPeriod, longPeriod: macdLongPeriod, signalPeriod: macdSignalPeriod)

                                    let kucoinSpotRsi = ExchangeWebSocket.calculateRSI(prices: kucoinSpotPrices, period: spotRsiPeriod) ?? 50.0
                                    let bybitSpotRsi = ExchangeWebSocket.calculateRSI(prices: bybitSpotPrices, period: spotRsiPeriod) ?? 50.0
                                    print("DEBUG: RSI for \(pair) - KuCoin Spot: \(kucoinSpotRsi), Bybit Spot: \(bybitSpotRsi)")

                                    let kucoinSpotATR = ExchangeWebSocket.calculateATR(prices: kucoinSpotPrices) ?? 0.0
                                    let bybitSpotATR = ExchangeWebSocket.calculateATR(prices: bybitSpotPrices) ?? 0.0
                                    let volatility = max(kucoinSpotATR, bybitSpotATR) / max(kucoinSpotPrice, bybitSpotPrice, 1.0)

                                    let kucoinArbitrageTradeAmount = await Task { await dynamicTradeAmount(balance: kucoinBalance, riskPercent: 0.3, volatility: volatility) }.value
                                    let bybitArbitrageTradeAmount = await Task { await dynamicTradeAmount(balance: bybitBalance, riskPercent: 0.3, volatility: volatility) }.value
                                    let crossExchangeTradeAmount = await Task { await dynamicTradeAmount(balance: min(kucoinBalance, bybitBalance), riskPercent: 0.1, volatility: 0.5) }.value

                                    let kucoinPriceChange = kucoinSpotPrices.count >= 1800 ? (kucoinSpotPrice - kucoinSpotPrices[kucoinSpotPrices.count - 1800]) / kucoinSpotPrices[kucoinSpotPrices.count - 1800] : 0.0

                                    let kucoinOrderBookStruct = kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
                                    let volumeSpikeThreshold = getDouble("VOLUME_SPIKE_THRESHOLD", defaultValue: 1.5)
                                    let orderImbalanceThreshold = getDouble("ORDER_IMBALANCE_THRESHOLD", defaultValue: 1.5)
                                    let vwapPeriod = getInt("VWAP_PERIOD", defaultValue: 60)
                                    print("DEBUG: VWAP period for \(pair): \(vwapPeriod)")
                                    let volumes = kucoinSpotVolume[pair] ?? []
                                    let avgVolume = volumes.isEmpty ? 0.0 : volumes.reduce(0.0, +) / Double(volumes.count)
                                    let currentVolume = volumes.last ?? 0.0
                                    let volumeSpike = avgVolume > 0 ? currentVolume / avgVolume : 1.0
                                    let orderImbalance = calculateOrderBookImbalance(book: kucoinOrderBookStruct)
                                    let vwap = calculateOrderBookVWAP(pair: pair, exchange: "kucoin", priceRange: orderBookPriceRange, currentPrice: kucoinSpotPrice) ?? kucoinSpotPrice

                                    marketMaker(pair: pair, exchange: "kucoin")
                                    marketMaker(pair: pair, exchange: "bybit")

                                    if kucoinSpotPrice > 0 || kucoinFuturesPrice > 0 {
                                        let currentSpread = abs(kucoinSpotPrice - kucoinFuturesPrice) / min(max(kucoinSpotPrice, 0.0001), max(kucoinFuturesPrice, 0.0001))
                                        let predictedSpread = await fetchSpreadPrediction(pair: pair, exchange: "kucoin", spotPrice: kucoinSpotPrice, futuresPrice: kucoinFuturesPrice) ?? 0.0
                                        saveHistoricalSpreadsToCSV(pair: pair, spread: currentSpread, predictedSpreadChange: predictedSpread)
                                        let shouldTradeKucoin = predictedSpread > currentSpread && kucoinFuturesMacd != nil && kucoinFuturesMacd!.histogram > -100.0 && kucoinFuturesEmaShort > kucoinFuturesEmaLong && kucoinSpotRsi > 30 && kucoinSpotRsi < 70 && abs(kucoinSpotPrice - vwap) / kucoinSpotPrice < 0.01
                                        let macdConfirmed = kucoinSpotMacd != nil && kucoinSpotMacd!.histogram > -100.0
                                        let feeAdjustedThreshold = 0.0001
                                        let emaConfirmed = kucoinSpotPrice < kucoinFuturesPrice
                                            ? (kucoinSpotEmaShort > kucoinSpotEmaLong && (kucoinSpotEmaShort - kucoinSpotEmaLong) / kucoinSpotEmaLong > 0.0026)
                                            : (kucoinSpotEmaShort < kucoinSpotEmaLong && (kucoinSpotEmaLong - kucoinSpotEmaShort) / kucoinSpotEmaLong > 0.0026)
                                        let trendConfirmed = kucoinPriceChange > 0.001 && kucoinSpotEmaShort > kucoinSpotEmaLong || kucoinPriceChange < -0.001 && kucoinSpotEmaShort < kucoinSpotEmaLong
                                        let sentimentConfirmed = sentimentScores[pair] ?? 0.0 > 0.5
                                        let volumeConfirmed = volumeSpike >= volumeSpikeThreshold
                                        let imbalanceConfirmed = orderImbalance < orderImbalanceThreshold

                                        print("KuCoin Spot-to-Futures for \(pair): Spread: \(currentSpread), Threshold: \(feeAdjustedThreshold), ML: \(shouldTradeKucoin), MACD: \(macdConfirmed), EMA: \(emaConfirmed), Trend: \(trendConfirmed), Sentiment: \(sentimentConfirmed), Volume: \(volumeConfirmed), Imbalance: \(imbalanceConfirmed)")

                                        // FIX: Use isEmpty property from BevaixOrderBook
                                        if (shouldTradeKucoin || currentSpread >= feeAdjustedThreshold) && !kucoinOrderBook.isEmpty && emaConfirmed && trendConfirmed && sentimentConfirmed && volumeConfirmed && imbalanceConfirmed {
                                            if let lastArbitrage = arbitrageExecuted[pair], lastArbitrage.0 && Date().timeIntervalSince(lastArbitrage.1) < tradeCooldown {
                                                print("KuCoin Spot-to-Futures for \(pair): Skipped (Cooldown)")
                                                logAlert(event: "KuCoin Spot-to-Futures for \(pair): Skipped (Cooldown)")
                                            } else {
                                                let potentialLoss = kucoinArbitrageTradeAmount * kucoinSpotPrice * stopLossPercentage
                                                if !(await ExchangeWebSocket.checkDailyLossLimit(exchange: "kucoin", pair: pair, potentialLoss: potentialLoss)) {
                                                    print("Initiating KuCoin Spot-to-Futures Arbitrage for \(pair): Amount: \(kucoinArbitrageTradeAmount)")
                                                    // FIX: Use async version
                                                    await executeSingleExchangeArbitrage(exchange: "kucoin", pair: pair, spotPrice: kucoinSpotPrice, futuresPrice: kucoinFuturesPrice, strategy: "Spot-to-Futures", kucoinSpotPrices: kucoinSpotPrices, bybitSpotPrices: [], tradeAmount: kucoinArbitrageTradeAmount)
                                                    let spread = abs(kucoinSpotPrice - kucoinFuturesPrice)
                                                    let grossProfit = kucoinArbitrageTradeAmount * spread
                                                    let fees = kucoinArbitrageTradeAmount * (kucoinTakerFee + kucoinMakerFee) * 2
                                                    let profit = grossProfit - fees
                                                    tradeExecuted = true
                                                    arbitrageExecuted[pair] = (true, Date())
                                                    await MainActor.run {
                                                        updateTradeMetrics(
                                                            pair: pair,
                                                            profit: profit,
                                                            fees: fees,
                                                            isWin: profit > 0,
                                                            dashboardJSONURL: dashboardJSONURL,
                                                            totalProfit: &ExchangeWebSocket.totalProfit,
                                                            totalFees: &ExchangeWebSocket.totalFees
                                                        )
                                                        logTradeToCSV(pair: pair, strategy: "Spot-to-Futures", profit: profit, fees: fees, tradesCSVURL: tradesCSVURL)
                                                    }
                                                } else {
                                                    print("KuCoin Spot-to-Futures for \(pair): Skipped (Daily loss limit)")
                                                    logAlert(event: "KuCoin Spot-to-Futures for \(pair): Skipped (Daily loss limit)")
                                                }
                                            }
                                        }
                                    }

                                    if bybitSpotPrice > 0 || bybitFuturesPrice > 0 {
                                        let currentSpread = abs(bybitSpotPrice - bybitFuturesPrice) / min(max(bybitSpotPrice, 0.0001), max(bybitFuturesPrice, 0.0001))
                                        let predictedSpread = await fetchSpreadPrediction(pair: pair, exchange: "bybit", spotPrice: bybitSpotPrice, futuresPrice: bybitFuturesPrice) ?? 0.0
                                        saveHistoricalSpreadsToCSV(pair: pair, spread: currentSpread, predictedSpreadChange: predictedSpread)
                                        let shouldTradeBybit = predictedSpread > currentSpread && bybitFuturesMacd != nil && bybitFuturesMacd!.histogram > -100.0
                                        let macdConfirmed = bybitSpotMacd != nil && bybitSpotMacd!.histogram > -100.0
                                        let feeAdjustedThreshold = 0.0001
                                        let emaConfirmed = bybitSpotPrice < bybitFuturesPrice
                                            ? (bybitSpotEmaShort > bybitSpotEmaLong && (bybitSpotEmaShort - bybitSpotEmaLong) / bybitSpotEmaLong > 0.0016)
                                            : (bybitSpotEmaShort < bybitSpotEmaLong && (bybitSpotEmaLong - bybitSpotEmaShort) / bybitSpotEmaLong > 0.0016)
                                        let trendConfirmed = kucoinPriceChange > 0.0016 && kucoinSpotEmaShort > kucoinSpotEmaLong || kucoinPriceChange < -0.0016 && kucoinSpotEmaShort < kucoinSpotEmaLong
                                        let sentimentConfirmed = sentimentScores[pair] ?? 0.0 > 0.5
                                        let volumeConfirmed = volumeSpike >= volumeSpikeThreshold
                                        let imbalanceConfirmed = orderImbalance < orderImbalanceThreshold

                                        print("Bybit Spot-to-Futures for \(pair): Spread: \(currentSpread), Threshold: \(feeAdjustedThreshold), ML: \(shouldTradeBybit), MACD: \(macdConfirmed), EMA: \(emaConfirmed), Trend: \(trendConfirmed), Sentiment: \(sentimentConfirmed), Volume: \(volumeConfirmed), Imbalance: \(imbalanceConfirmed)")

                                        if (shouldTradeBybit || currentSpread >= feeAdjustedThreshold) && !bybitOrderBook.isEmpty && emaConfirmed && macdConfirmed && trendConfirmed && sentimentConfirmed && volumeConfirmed && imbalanceConfirmed {
                                            if let lastArbitrage = arbitrageExecuted[pair], lastArbitrage.0 && Date().timeIntervalSince(lastArbitrage.1) < tradeCooldown {
                                                print("Bybit Spot-to-Futures for \(pair): Skipped (Cooldown)")
                                                logAlert(event: "Bybit Spot-to-Futures for \(pair): Skipped (Cooldown)")
                                            } else {
                                                let potentialLoss = bybitArbitrageTradeAmount * bybitSpotPrice * stopLossPercentage
                                                if !(await ExchangeWebSocket.checkDailyLossLimit(exchange: "bybit", pair: pair, potentialLoss: potentialLoss)) {
                                                    print("Initiating Bybit Spot-to-Futures Arbitrage for \(pair): Amount: \(bybitArbitrageTradeAmount)")
                                                    // FIX: Use async version
                                                    await executeSingleExchangeArbitrage(
                                                        exchange: "bybit",
                                                        pair: pair,
                                                        spotPrice: bybitSpotPrice,
                                                        futuresPrice: bybitFuturesPrice,
                                                        strategy: "Spot-to-Futures",
                                                        kucoinSpotPrices: [],
                                                        bybitSpotPrices: bybitSpotPrices,
                                                        tradeAmount: bybitArbitrageTradeAmount
                                                    )
                                                    let spread = abs(bybitSpotPrice - bybitFuturesPrice)
                                                    let grossProfit = bybitArbitrageTradeAmount * spread
                                                    let fees = bybitArbitrageTradeAmount * (bybitTakerFee + bybitMakerFee) * 2
                                                    let profit = grossProfit - fees
                                                    tradeExecuted = true
                                                    arbitrageExecuted[pair] = (true, Date())
                                                    await MainActor.run {
                                                        updateTradeMetrics(
                                                            pair: pair,
                                                            profit: profit,
                                                            fees: fees,
                                                            isWin: profit > 0,
                                                            dashboardJSONURL: dashboardJSONURL,
                                                            totalProfit: &ExchangeWebSocket.totalProfit,
                                                            totalFees: &ExchangeWebSocket.totalFees
                                                        )
                                                        logTradeToCSV(pair: pair, strategy: "Spot-to-Futures", profit: profit, fees: fees, tradesCSVURL: tradesCSVURL)
                                                    }
                                                } else {
                                                    print("Bybit Spot-to-Futures for \(pair): Skipped (Daily loss limit)")
                                                    logAlert(event: "Bybit Spot-to-Futures for \(pair): Skipped (Daily loss limit)")
                                                }
                                            }
                                        }
                                    }

                                    if kucoinSpotPrice > 0 || bybitSpotPrice > 0 {
                                        let currentSpread = abs(kucoinSpotPrice - bybitSpotPrice) / min(max(kucoinSpotPrice, 0.0001), max(bybitSpotPrice, 0.0001))
                                        let predictedSpread = await fetchSpreadPrediction(pair: pair, exchange: "cross", spotPrice: kucoinSpotPrice, futuresPrice: bybitSpotPrice) ?? 0.0
                                        saveHistoricalSpreadsToCSV(pair: pair, spread: currentSpread, predictedSpreadChange: predictedSpread)
                                        let shouldTradeCross = predictedSpread > currentSpread && kucoinSpotRsi > 30 && kucoinSpotRsi < 70
                                        let macdConfirmed = kucoinSpotMacd != nil && bybitSpotMacd != nil && kucoinSpotMacd!.histogram > -100.0 && bybitSpotMacd!.histogram > -100.0
                                        let feeAdjustedThreshold = 0.0001
                                        let emaConfirmed = kucoinSpotPrice < bybitSpotPrice
                                            ? (kucoinSpotEmaShort > kucoinSpotEmaLong && (kucoinSpotEmaShort - kucoinSpotEmaLong) / kucoinSpotEmaLong > 0.0016 && bybitSpotEmaShort < bybitSpotEmaLong && (bybitSpotEmaLong - bybitSpotEmaShort) / bybitSpotEmaLong > 0.0016)
                                            : (kucoinSpotEmaShort < kucoinSpotEmaLong && (kucoinSpotEmaLong - kucoinSpotEmaShort) / kucoinSpotEmaLong > 0.0016 && bybitSpotEmaShort > bybitSpotEmaLong && (bybitSpotEmaShort - bybitSpotEmaLong) / bybitSpotEmaLong > 0.0016)
                                        let trendConfirmed = kucoinPriceChange > 0.0016 && kucoinSpotEmaShort > kucoinSpotEmaLong || kucoinPriceChange < -0.0016 && kucoinSpotEmaShort < kucoinSpotEmaLong
                                        let sentimentConfirmed = sentimentScores[pair] ?? 0.0 > 0.5
                                        let volumeConfirmed = volumeSpike >= volumeSpikeThreshold
                                        let imbalanceConfirmed = orderImbalance < orderImbalanceThreshold

                                        print("Cross-Exchange Spot for \(pair): Spread: \(currentSpread), Threshold: \(feeAdjustedThreshold), ML: \(shouldTradeCross), MACD: \(macdConfirmed), EMA: \(emaConfirmed), Trend: \(trendConfirmed), Sentiment: \(sentimentConfirmed), Volume: \(volumeConfirmed), Imbalance: \(imbalanceConfirmed)")

                                        // FIX: Use isEmpty property from BevaixOrderBook
                                        if (shouldTradeCross || currentSpread >= feeAdjustedThreshold) && !kucoinOrderBookStruct.isEmpty && !bybitOrderBook.isEmpty && emaConfirmed && macdConfirmed && trendConfirmed && sentimentConfirmed && volumeConfirmed && imbalanceConfirmed {
                                            if let lastCrossArbitrage = crossExchangeArbitrageExecuted[pair], lastCrossArbitrage.0 && Date().timeIntervalSince(lastCrossArbitrage.1) < tradeCooldown {
                                                print("Cross-Exchange Spot for \(pair): Skipped (Cooldown)")
                                                logAlert(event: "Cross-Exchange Spot for \(pair): Skipped (Cooldown)")
                                            } else {
                                                let potentialLoss = crossExchangeTradeAmount * kucoinSpotPrice * stopLossPercentage
                                                let kucoinLossLimitOk = !(await ExchangeWebSocket.checkDailyLossLimit(exchange: "kucoin", pair: pair, potentialLoss: potentialLoss))
                                                let bybitLossLimitOk = !(await ExchangeWebSocket.checkDailyLossLimit(exchange: "bybit", pair: pair, potentialLoss: potentialLoss))
                                                if kucoinLossLimitOk && bybitLossLimitOk {
                                                    print("Initiating Cross-Exchange for \(pair): Amount: \(crossExchangeTradeAmount)")
                                                    // FIX: Use async version
                                                    await executeEnhancedCrossExchangeArbitrage(
                                                        pair: pair,
                                                        kucoinSpotPrice: kucoinSpotPrice,
                                                        bybitSpotPrice: bybitSpotPrice,
                                                        strategy: "Cross-Exchange",
                                                        kucoinSpotPrices: kucoinSpotPrices,
                                                        bybitSpotPrices: bybitSpotPrices,
                                                        amount: crossExchangeTradeAmount,
                                                        completion: { success in
                                                            if success {
                                                                let spread = abs(kucoinSpotPrice - bybitSpotPrice)
                                                                let grossProfit = crossExchangeTradeAmount * spread
                                                                let fees = crossExchangeTradeAmount * (kucoinTakerFee + bybitTakerFee) * 2
                                                                let profit = grossProfit - fees
                                                                tradeExecuted = true
                                                                crossExchangeArbitrageExecuted[pair] = (true, Date())
                                                                Task { @MainActor in
                                                                    updateTradeMetrics(
                                                                        pair: pair,
                                                                        profit: profit,
                                                                        fees: fees,
                                                                        isWin: profit > 0,
                                                                        dashboardJSONURL: dashboardJSONURL,
                                                                        totalProfit: &ExchangeWebSocket.totalProfit,
                                                                        totalFees: &ExchangeWebSocket.totalFees
                                                                    )
                                                                    logTradeToCSV(pair: pair, strategy: "Cross-Exchange", profit: profit, fees: fees, tradesCSVURL: tradesCSVURL)
                                                                }
                                                            }
                                                        }
                                                    )
                                                } else {
                                                    print("Cross-Exchange Spot for \(pair): Skipped (Daily loss limit)")
                                                    logAlert(event: "Cross-Exchange Spot for \(pair): Skipped (Daily loss limit)")
                                                }
                                            }
                                        }
                                    }
                                }
                                
                                if !tradeExecuted {
                                    print("DEBUG: No trade executed in this cycle for \(pair)")
                                    logAlert(event: "No trade executed in this cycle for \(pair)")
                                }
                                
                                updateDashboardJSON(dashboardJSONURL: dashboardJSONURL, totalProfit: ExchangeWebSocket.totalProfit, totalFees: ExchangeWebSocket.totalFees)
                                printPeriodicSummary()
                            }
                        }
                    }
                }
            }
        }
    }
}


//------------------------------------------------------------------------------------------------------Block 14 - Core Trading Loop Execution

//--------------- Block 14 - Core Trading Loop Execution
// VARIABLES TO ADD: Fixed redeclaration of detectVolatilitySpike and isEmpty usage on BevaixOrderBook

import Foundation

extension ExchangeWebSocket {
    static func startTradingLoop() {
        Task { @MainActor in
            ExchangeWebSocket.connectKucoin()
            ExchangeWebSocket.connectBybit()
            await ExchangeWebSocket.startOrderBookPolling()
            
            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                ExchangeWebSocket.monitorHFTScalpingOpportunities()
                print(" TRADING ACTIVE")
            }
        }
    }

    static func executeTrade(exchange: String, pair: String, side: String, price: Double, amount: Double, strategy: String) async -> Bool {
        guard await checkDailyLossLimit(exchange: exchange, pair: pair, potentialLoss: amount * price * getDouble("STOP_LOSS_PERCENTAGE", defaultValue: 0.02)) else {
            print("DEBUG: Trade skipped for \(exchange)-\(pair): Daily loss limit exceeded")
            return false
        }

        guard let _ = await checkLiquidityAsyncUnique(exchange: exchange, pair: pair, marketType: "spot", tradeAmount: amount, price: price) else {
            print("DEBUG: Trade skipped for \(exchange)-\(pair): Insufficient liquidity")
            return false
        }

        let volatility = await calculateVolatility(pair: pair, exchange: exchange)
        let tradeAmount = await dynamicTradeAmount(balance: exchange == "kucoin" ? kucoinBalance : bybitBalance, riskPercent: getDouble("RISK_PERCENTAGE", defaultValue: 0.01), volatility: volatility, pair: pair)

        guard tradeAmount > 0 else {
            print("DEBUG: Trade skipped for \(exchange)-\(pair): Invalid trade amount (\(tradeAmount))")
            return false
        }

        let adjustedAmount = min(amount, tradeAmount)
        ExchangeWebSocket.executeHFTTrade(exchange: exchange, pair: pair, side: side, price: price, amount: adjustedAmount)

        let profit = side == "buy" ? -adjustedAmount * price : adjustedAmount * price
        let fees = adjustedAmount * price * (exchange == "kucoin" ? kucoinTakerFee : bybitTakerFee)
        let netProfit = profit - fees

        await MainActor.run {
            updateTradeMetrics(
                pair: pair,
                profit: netProfit,
                fees: fees,
                isWin: netProfit > 0,
                dashboardJSONURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/dashboard.json"),
                totalProfit: &ExchangeWebSocket.totalProfit,
                totalFees: &ExchangeWebSocket.totalFees
            )
            logTradeToCSV(
                pair: pair,
                strategy: strategy,
                profit: netProfit,
                fees: fees,
                tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trades.csv")
            )
            sendTradeToFlaskServer(strategy: strategy, pair: pair, exchange: exchange, spotPrice: price, futuresPrice: 0.0, tradeAmount: adjustedAmount, profit: netProfit)
        }

        return netProfit > 0
    }

    static func calculateVolatility(pair: String, exchange: String) async -> Double {
        let prices = exchange == "kucoin" ? kucoinPrices[pair] : bybitPrices[pair]
        guard let priceArray = prices, priceArray.count >= 60 else {
            return getDouble("DEFAULT_VOLATILITY", defaultValue: 0.01)
        }
        let recentPrices = priceArray.suffix(60)
        let mean = recentPrices.reduce(0.0, +) / Double(recentPrices.count)
        let variance = recentPrices.reduce(0.0) { $0 + pow($1 - mean, 2) } / Double(recentPrices.count)
        return sqrt(variance) / mean
    }

    static func startOrderBookPolling() async {
        while true {
            for pair in tradingPairs {
                for exchange in ["kucoin", "bybit"] {
                    for marketType in ["spot", "futures"] {
                        do {
                            let _ = try await fetchOrderBookDepth(for: exchange, pair: pair, marketType: marketType)
                            await MainActor.run {
                                let orderBook = exchange == "kucoin" ? kucoinOrderBooks[pair] : bybitOrderBooks[pair]
                                if orderBook != nil {
                                    logAlert(event: "Updated order book for \(exchange)-\(pair)-\(marketType)")
                                }
                            }
                        } catch {
                            await MainActor.run {
                                logAlert(event: "Failed to poll order book for \(exchange)-\(pair)-\(marketType): \(error)")
                            }
                        }
                    }
                }
            }
            try? await Task.sleep(nanoseconds: 10_000_000_000) // 10 seconds
        }
    }

    // FIX: Remove duplicate detectVolatilitySpike function to resolve redeclaration error
    // The original detectVolatilitySpike function should be defined elsewhere in the codebase
    // This comment replaces the duplicate function that was causing the redeclaration error
    
    static func monitorCrossExchangeArbitrageOpportunities() {
        Task { @MainActor in
            while tradingActive && !emergencyStopActive {
                for pair in tradingPairs {
                    guard !isTradingPaused[pair, default: false] else { continue }
                    
                    let kucoinSpotPrice = kucoinCurrentPrice[pair] ?? 0.0
                    let bybitSpotPrice = bybitCurrentPrice[pair] ?? 0.0
                    
                    guard kucoinSpotPrice > 0 && bybitSpotPrice > 0 else { continue }
                    
                    let spread = abs(kucoinSpotPrice - bybitSpotPrice) / max(kucoinSpotPrice, bybitSpotPrice)
                    let minSpread = getDouble("CROSS_EXCHANGE_MIN_SPREAD_THRESHOLD", defaultValue: 0.002)
                    
                    if spread >= minSpread {
                        let kucoinBook = kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
                        let bybitBook = bybitOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
                        
                        // FIX: Use isEmpty property instead of non-existent member
                        if !kucoinBook.isEmpty && !bybitBook.isEmpty {
                            let tradeAmount = min(crossExchangeTradeAmount, min(kucoinBalance, bybitBalance) * 0.1)
                            
                            if tradeAmount > 10.0 {
                                print("Cross-exchange arbitrage opportunity detected for \(pair): \(String(format: "%.4f", spread * 100))% spread")
                                
                                Task {
                                    await executeEnhancedCrossExchangeArbitrage(
                                        pair: pair,
                                        kucoinSpotPrice: kucoinSpotPrice,
                                        bybitSpotPrice: bybitSpotPrice,
                                        strategy: "Cross-Exchange Arbitrage",
                                        kucoinSpotPrices: kucoinPrices[pair] ?? [],
                                        bybitSpotPrices: bybitPrices[pair] ?? [],
                                        amount: tradeAmount
                                    ) { success in
                                        if success {
                                            Task { @MainActor in
                                                crossExchangeArbitrageExecuted[pair] = (true, Date())
                                                logAlert(event: "Cross-exchange arbitrage executed for \(pair)")
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                try? await Task.sleep(nanoseconds: UInt64(getDouble("ARBITRAGE_CHECK_INTERVAL_SECONDS", defaultValue: 0.5) * 1_000_000_000))
            }
        }
    }

    static func monitorHFTScalpingOpportunities() {
        Task { @MainActor in
            while tradingActive && !emergencyStopActive {
                for pair in tradingPairs {
                    guard !isTradingPaused[pair, default: false] else { continue }
                    
                    let exchanges = ["kucoin", "bybit"]
                    for exchange in exchanges {
                        let currentPrice = exchange == "kucoin" ?
                            kucoinCurrentPrice[pair] ?? 0.0 :
                            bybitCurrentPrice[pair] ?? 0.0
                        
                        guard currentPrice > 0 else { continue }
                        
                        let orderBook = exchange == "kucoin" ?
                            kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: []) :
                            bybitOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
                        
                        // FIX: Use isEmpty property instead of non-existent member
                        guard !orderBook.isEmpty else { continue }
                        
                        let spread = orderBook.asks.first?.price ?? 0.0 - (orderBook.bids.first?.price ?? 0.0)
                        let spreadPercent = spread / currentPrice
                        
                        if spreadPercent >= getDouble("HFT_SPREAD_THRESHOLD", defaultValue: 0.003) {
                            let balance = exchange == "kucoin" ? kucoinBalance : bybitBalance
                            let tradeAmount = min(balance * 0.02, getDouble("HFT_TRADE_AMOUNT", defaultValue: 200.0))
                            
                            if tradeAmount > 5.0 {
                                print("HFT scalping opportunity detected for \(pair) on \(exchange): \(String(format: "%.4f", spreadPercent * 100))% spread")
                                
                                Task {
                                    let success = await executeScalpingTrade(
                                        pair: pair,
                                        exchange: exchange,
                                        entryPrice: orderBook.bids.first?.price ?? currentPrice,
                                        targetPrice: orderBook.asks.first?.price ?? currentPrice,
                                        stopPrice: currentPrice * (1 - getDouble("SCALP_STOP_LOSS", defaultValue: 0.0015)),
                                        tradeAmount: tradeAmount,
                                        maxActiveTrades: getInt("MAX_ACTIVE_SPOT_TRADES", defaultValue: 2)
                                    )
                                    
                                    if success {
                                        await MainActor.run {
                                            hftArbitrageExecuted[pair] = (profit: spreadPercent * tradeAmount, timestamp: Date())
                                            logAlert(event: "HFT scalping trade executed for \(pair) on \(exchange)")
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                try? await Task.sleep(nanoseconds: UInt64(getDouble("HFT_COOLDOWN_SECONDS", defaultValue: 1.5) * 1_000_000_000))
            }
        }
    }

    static func monitorMarketMakingOpportunities() {
        Task { @MainActor in
            while tradingActive && !emergencyStopActive {
                for pair in tradingPairs {
                    guard !isTradingPaused[pair, default: false] else { continue }
                    
                    let exchanges = ["kucoin", "bybit"]
                    for exchange in exchanges {
                        let currentPrice = exchange == "kucoin" ?
                            kucoinCurrentPrice[pair] ?? 0.0 :
                            bybitCurrentPrice[pair] ?? 0.0
                        
                        guard currentPrice > 0 else { continue }
                        
                        let orderBook = exchange == "kucoin" ?
                            kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: []) :
                            bybitOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
                        
                        // FIX: Use isEmpty property instead of non-existent member
                        guard !orderBook.isEmpty else { continue }
                        
                        let spread = getDouble("MARKET_MAKING_SPREAD", defaultValue: 0.001)
                        let bidPrice = currentPrice * (1 - spread)
                        let askPrice = currentPrice * (1 + spread)
                        
                        let balance = exchange == "kucoin" ? kucoinBalance : bybitBalance
                        let orderSize = min(balance * 0.01, 50.0)
                        
                        if orderSize > 1.0 {
                            print("Market making opportunity for \(pair) on \(exchange): Bid \(String(format: "%.4f", bidPrice)), Ask \(String(format: "%.4f", askPrice))")
                            // Market making logic would be implemented here
                        }
                    }
                }
                
                try? await Task.sleep(nanoseconds: 5_000_000_000) // 5 seconds
            }
        }
    }

    static func monitorMomentumOpportunities() {
        Task { @MainActor in
            while tradingActive && !emergencyStopActive {
                for pair in tradingPairs {
                    guard !isTradingPaused[pair, default: false] else { continue }
                    
                    let exchanges = ["kucoin", "bybit"]
                    for exchange in exchanges {
                        let prices = exchange == "kucoin" ?
                            kucoinPrices[pair] ?? [] :
                            bybitPrices[pair] ?? []
                        
                        guard prices.count >= 20 else { continue }
                        
                        let recentPrices = Array(prices.suffix(20))
                        let shortEMA = calculateEMA(prices: recentPrices, period: 5) ?? 0.0
                        let longEMA = calculateEMA(prices: recentPrices, period: 10) ?? 0.0
                        
                        if shortEMA > longEMA * 1.002 { // 0.2% momentum threshold
                            let currentPrice = recentPrices.last ?? 0.0
                            let balance = exchange == "kucoin" ? kucoinBalance : bybitBalance
                            let tradeAmount = min(balance * 0.03, 100.0)
                            
                            if tradeAmount > 5.0 && currentPrice > 0 {
                                print("Momentum opportunity detected for \(pair) on \(exchange): Short EMA \(String(format: "%.4f", shortEMA)) > Long EMA \(String(format: "%.4f", longEMA))")
                                // Momentum trading logic would be implemented here
                            }
                        }
                    }
                }
                
                try? await Task.sleep(nanoseconds: 10_000_000_000) // 10 seconds
            }
        }
    }

    static func monitorMeanReversionOpportunities() {
        Task { @MainActor in
            while tradingActive && !emergencyStopActive {
                for pair in tradingPairs {
                    guard !isTradingPaused[pair, default: false] else { continue }
                    
                    let exchanges = ["kucoin", "bybit"]
                    for exchange in exchanges {
                        let prices = exchange == "kucoin" ?
                            kucoinPrices[pair] ?? [] :
                            bybitPrices[pair] ?? []
                        
                        guard prices.count >= 50 else { continue }
                        
                        let recentPrices = Array(prices.suffix(50))
                        let currentPrice = recentPrices.last ?? 0.0
                        let mean = recentPrices.reduce(0.0, +) / Double(recentPrices.count)
                        let stdDev = sqrt(recentPrices.reduce(0.0) { $0 + pow($1 - mean, 2) } / Double(recentPrices.count))
                        
                        let deviationFromMean = abs(currentPrice - mean) / stdDev
                        
                        if deviationFromMean > 2.0 { // 2 standard deviations
                            let balance = exchange == "kucoin" ? kucoinBalance : bybitBalance
                            let tradeAmount = min(balance * 0.02, 75.0)
                            
                            if tradeAmount > 5.0 && currentPrice > 0 {
                                print("Mean reversion opportunity detected for \(pair) on \(exchange): Price \(String(format: "%.4f", currentPrice)), Mean \(String(format: "%.4f", mean)), Deviation \(String(format: "%.2f", deviationFromMean))")
                                // Mean reversion trading logic would be implemented here
                            }
                        }
                    }
                }
                
                try? await Task.sleep(nanoseconds: 15_000_000_000) // 15 seconds
            }
        }
    }
}

// Main entry point
DispatchQueue.main.async {
    ExchangeWebSocket.initializeParameters {
        ExchangeWebSocket.startTradingLoop()
        ExchangeWebSocket.logDashboardMetrics()
    }
}

RunLoop.main.run()


//---------------------------------------------------------------------------------------------------------Block 15 - High-Frequency Trading Scalping

//--------------- Block 15 - High-Frequency Trading Scalping
// VARIABLES TO ADD: Fixed unnecessary await expressions, isEmpty usage, and MainActor isolation issues

import Foundation

extension ExchangeWebSocket {
    static func structureTradeData(strategy: String, pair: String, exchange: String, spotPrice: Double, futuresPrice: Double, tradeAmount: Double, profit: Double) -> [String: Any] {
        let timestampFormatter = ISO8601DateFormatter()
        timestampFormatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        let timestamp = timestampFormatter.string(from: Date())

        return [
            "strategy": strategy,
            "pair": pair,
            "exchange": exchange,
            "spot_price": spotPrice,
            "futures_price": futuresPrice,
            "trade_amount": tradeAmount,
            "profit": profit,
            "timestamp": timestamp
        ]
    }

    @MainActor
    static func logTradeLocally(strategy: String, pair: String, exchange: String, spotPrice: Double, futuresPrice: Double, tradeAmount: Double, profit: Double) {
        let tradeData = structureTradeData(strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit)
        let timestamp = tradeData["timestamp"] as? String ?? ISO8601DateFormatter().string(from: Date())
        let logEntry = "\(timestamp),\(strategy),\(pair),\(exchange),\(spotPrice),\(futuresPrice),\(tradeAmount),\(profit)\n"
        let logURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trade_log_fallback.csv")

        do {
            let fileManager = FileManager.default
            let directoryPath = logURL.deletingLastPathComponent().path
            if !fileManager.fileExists(atPath: directoryPath) {
                try fileManager.createDirectory(atPath: directoryPath, withIntermediateDirectories: true, attributes: nil)
                print("DEBUG: Created directory for trade_log_fallback.csv at \(directoryPath)")
            }

            if !fileManager.fileExists(atPath: logURL.path) {
                try "timestamp,strategy,pair,exchange,spot_price,futures_price,trade_amount,profit\n".write(to: logURL, atomically: true, encoding: .utf8)
            }

            if let fileHandle = try? FileHandle(forWritingTo: logURL) {
                defer { fileHandle.closeFile() }
                if let data = logEntry.data(using: .utf8) {
                    fileHandle.seekToEndOfFile()
                    fileHandle.write(data)
                }
            } else {
                try logEntry.write(to: logURL, atomically: true, encoding: .utf8)
            }
            print("DEBUG: Logged trade to fallback CSV: \(logEntry)")
        } catch {
            print("DEBUG: Failed to write to trade_log_fallback.csv: \(error.localizedDescription)")
        }
    }

    @Sendable static func attemptSend(attempt: Int, request: URLRequest, strategy: String, pair: String, exchange: String, spotPrice: Double, futuresPrice: Double, tradeAmount: Double, profit: Double, retries: Int) {
        let delay = pow(2.0, Double(attempt - 1))
        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                print("DEBUG: Failed to send trade to Flask server (attempt \(attempt)): \(error.localizedDescription)")
                if attempt < retries {
                    DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
                        ExchangeWebSocket.attemptSend(attempt: attempt + 1, request: request, strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit, retries: retries)
                    }
                } else {
                    Task { @MainActor in
                        logTradeLocally(strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit)
                    }
                }
                return
            }

            guard let httpResponse = response as? HTTPURLResponse else {
                print("DEBUG: Failed to send trade to Flask server (attempt \(attempt)): No HTTP response")
                if attempt < retries {
                    DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
                        ExchangeWebSocket.attemptSend(attempt: attempt + 1, request: request, strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit, retries: retries)
                    }
                } else {
                    Task { @MainActor in
                        logTradeLocally(strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit)
                    }
                }
                return
            }

            print("DEBUG: Flask server response status (attempt \(attempt)): \(httpResponse.statusCode)")
            if httpResponse.statusCode == 200 {
                print("DEBUG: Successfully sent trade to Flask server: \(strategy) for \(pair) on \(exchange)")
            } else {
                print("DEBUG: Failed to send trade to Flask server (attempt \(attempt)): Status code \(httpResponse.statusCode)")
                if let data = data, let responseBody = String(data: data, encoding: .utf8) {
                    print("DEBUG: Flask server response body: \(responseBody)")
                }
                if attempt < retries {
                    DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
                        ExchangeWebSocket.attemptSend(attempt: attempt + 1, request: request, strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit, retries: retries)
                    }
                } else {
                    Task { @MainActor in
                        logTradeLocally(strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit)
                    }
                }
            }
        }
        task.resume()
    }

    static func sendTradeToFlaskServer(strategy: String, pair: String, exchange: String, spotPrice: Double, futuresPrice: Double, tradeAmount: Double, profit: Double, retries: Int = 3) {
        let url = URL(string: "http://127.0.0.1:5001/trade")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.timeoutInterval = 30.0

        let tradeData = structureTradeData(strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit)

        print("DEBUG: Attempting to send trade to Flask server: \(tradeData)")

        do {
            let jsonData = try JSONSerialization.data(withJSONObject: tradeData, options: [])
            request.httpBody = jsonData
            attemptSend(attempt: 1, request: request, strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit, retries: retries)
        } catch {
            print("DEBUG: Failed to serialize trade data: \(error.localizedDescription)")
            Task { @MainActor in
                logTradeLocally(strategy: strategy, pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, tradeAmount: tradeAmount, profit: profit)
            }
        }
    }

    @MainActor
    static func saveHistoricalSpreadsToCSV(pair: String, spread: Double, predictedSpreadChange: Double?) {
        print("DEBUG: Entering saveHistoricalSpreadsToCSV for \(pair), spread: \(spread), predictedSpreadChange: \(predictedSpreadChange ?? 0.0) at \(ISO8601DateFormatter().string(from: Date()))")
        
        guard spread > 0 else {
            print("DEBUG: Skipping invalid spread for \(pair): \(spread)")
            logAlert(event: "Skipping invalid spread for \(pair): \(spread)")
            return
        }
        
        let timestampFormatter = ISO8601DateFormatter()
        timestampFormatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        let timestamp = timestampFormatter.string(from: Date())
        let predictedSpreadChangeValue = predictedSpreadChange ?? 0.0
        
        let kucoinSpotPrice = kucoinCurrentPrice[pair] ?? 0.0
        let kucoinFuturesPrice = kucoinCurrentFuturesPrice[pair] ?? 0.0
        let bybitSpotPrice = bybitCurrentPrice[pair] ?? 0.0
        let bybitFuturesPrice = bybitCurrentFuturesPrice[pair] ?? 0.0
        let kucoinSpotRsi = calculateRSI(prices: kucoinPrices[pair] ?? [], period: spotRsiPeriod) ?? 50.0
        let kucoinFuturesRsi = calculateRSI(prices: kucoinFuturesPrices[pair] ?? [], period: spotRsiPeriod) ?? 50.0
        let bybitSpotRsi = calculateRSI(prices: bybitPrices[pair] ?? [], period: spotRsiPeriod) ?? 50.0
        let bybitFuturesRsi = calculateRSI(prices: bybitFuturesPrices[pair] ?? [], period: spotRsiPeriod) ?? 50.0
        let kucoinSpotMacd = calculateMACD(prices: kucoinPrices[pair] ?? [], shortPeriod: macdShortPeriod, longPeriod: macdLongPeriod, signalPeriod: macdSignalPeriod) ?? (macd: 0.0, signal: 0.0, histogram: 0.0)
        let kucoinFuturesMacd = calculateMACD(prices: kucoinFuturesPrices[pair] ?? [], shortPeriod: macdShortPeriod, longPeriod: macdLongPeriod, signalPeriod: macdSignalPeriod) ?? (macd: 0.0, signal: 0.0, histogram: 0.0)
        let bybitSpotMacd = calculateMACD(prices: bybitPrices[pair] ?? [], shortPeriod: macdShortPeriod, longPeriod: macdLongPeriod, signalPeriod: macdSignalPeriod) ?? (macd: 0.0, signal: 0.0, histogram: 0.0)
        let bybitFuturesMacd = calculateMACD(prices: bybitFuturesPrices[pair] ?? [], shortPeriod: macdShortPeriod, longPeriod: macdLongPeriod, signalPeriod: macdSignalPeriod) ?? (macd: 0.0, signal: 0.0, histogram: 0.0)
        let kucoinSpotAtr = kucoinFuturesATR[pair] ?? 0.0
        let bybitSpotAtr = bybitFuturesATR[pair] ?? 0.0
        let kucoinFundingRate = kucoinFundingRates[pair] ?? 0.0
        let bybitFundingRate = bybitFundingRates[pair] ?? 0.0
        let sentimentScore = sentimentScores[pair] ?? 0.0
        
        print("DEBUG: Input prices for \(pair): kucoinSpotPrice=\(kucoinSpotPrice), kucoinFuturesPrice=\(kucoinFuturesPrice), bybitSpotPrice=\(bybitSpotPrice), bybitFuturesPrice=\(bybitFuturesPrice)")
        
        let minimalLogEntry = "\(timestamp),\(pair),\(spread),\(predictedSpreadChangeValue)\n"
        let spreadsCSVURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/historical_spreads.csv")
        
        let extendedLogEntry = "\(pair),\(timestamp),\(spread),\(predictedSpreadChangeValue),\(kucoinSpotPrice),\(kucoinFuturesPrice),\(bybitSpotPrice),\(bybitFuturesPrice),\(kucoinSpotRsi),\(kucoinFuturesRsi),\(bybitSpotRsi),\(bybitFuturesRsi),\(kucoinSpotMacd.histogram),\(kucoinFuturesMacd.histogram),\(bybitSpotMacd.histogram),\(bybitFuturesMacd.histogram),\(kucoinSpotAtr),\(bybitSpotAtr),\(kucoinFundingRate),\(bybitFundingRate),\(sentimentScore)\n"
        let extendedSpreadsCSVURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/historical_spreads_extended.csv")
        
        let fileManager = FileManager.default
        
        do {
            let directoryURL = spreadsCSVURL.deletingLastPathComponent()
            if !fileManager.fileExists(atPath: directoryURL.path) {
                try fileManager.createDirectory(at: directoryURL, withIntermediateDirectories: true, attributes: nil)
                print("DEBUG: Created directory for historical_spreads.csv at \(directoryURL.path)")
            }
            
            if !fileManager.fileExists(atPath: spreadsCSVURL.path) {
                let header = "timestamp,pair,spread,predictedSpreadChange\n"
                try header.write(to: spreadsCSVURL, atomically: true, encoding: .utf8)
                try fileManager.setAttributes([.posixPermissions: 0o644], ofItemAtPath: spreadsCSVURL.path)
                print("DEBUG: Created historical_spreads.csv with header")
            }
            
            guard let minimalData = minimalLogEntry.data(using: .utf8) else {
                print("DEBUG: Failed to convert minimal log entry to data for \(pair)")
                logAlert(event: "Failed to convert minimal log entry to data for \(pair)")
                return
            }
            
            var writeSuccess = false
            for attempt in 1...3 {
                do {
                    if let fileHandle = try? FileHandle(forWritingTo: spreadsCSVURL) {
                        defer { fileHandle.closeFile() }
                        fileHandle.seekToEndOfFile()
                        fileHandle.write(minimalData)
                        writeSuccess = true
                        print("DEBUG: Appended minimal historical spread to CSV for \(pair) (attempt \(attempt)): Spread=\(spread), PredictedChange=\(predictedSpreadChangeValue)")
                        break
                    } else {
                        try minimalLogEntry.write(to: spreadsCSVURL, atomically: true, encoding: .utf8)
                        writeSuccess = true
                        print("DEBUG: Wrote minimal historical spread to CSV for \(pair) (attempt \(attempt)): Spread=\(spread), PredictedChange=\(predictedSpreadChangeValue)")
                        break
                    }
                } catch {
                    print("DEBUG: Failed to write minimal historical spread to CSV for \(pair) (attempt \(attempt)): \(error.localizedDescription)")
                    if attempt < 3 {
                        Thread.sleep(forTimeInterval: 0.1 * Double(attempt))
                    }
                }
            }
            
            if !writeSuccess {
                print("DEBUG: Failed to save minimal historical spread to CSV for \(pair) after 3 attempts")
                logAlert(event: "Failed to save minimal historical spread to CSV for \(pair) after 3 attempts")
            }
            
            historicalSpreads[pair, default: []].append(spread)
        } catch {
            print("DEBUG: Failed to save minimal historical spread to CSV for \(pair): \(error.localizedDescription)")
            logAlert(event: "Failed to save minimal historical spread to CSV for \(pair): \(error.localizedDescription)")
        }
        
        do {
            let directoryURL = extendedSpreadsCSVURL.deletingLastPathComponent()
            if !fileManager.fileExists(atPath: directoryURL.path) {
                try fileManager.createDirectory(at: directoryURL, withIntermediateDirectories: true, attributes: nil)
                print("DEBUG: Created directory for historical_spreads_extended.csv at \(directoryURL.path)")
            }
            
            if !fileManager.fileExists(atPath: extendedSpreadsCSVURL.path) {
                let header = "pair,timestamp,spread,predicted_spread_change,kucoin_spot_price,kucoin_futures_price,bybit_spot_price,bybit_futures_price,kucoin_spot_rsi,kucoin_futures_rsi,bybit_spot_rsi,bybit_futures_rsi,kucoin_spot_macd_histogram,kucoin_futures_macd_histogram,bybit_spot_macd_histogram,bybit_futures_macd_histogram,kucoin_spot_atr,bybit_spot_atr,kucoin_funding_rate,bybit_funding_rate,sentiment_score\n"
                try header.write(to: extendedSpreadsCSVURL, atomically: true, encoding: .utf8)
                try fileManager.setAttributes([.posixPermissions: 0o644], ofItemAtPath: extendedSpreadsCSVURL.path)
                print("DEBUG: Created historical_spreads_extended.csv with header")
            }
            
            guard let extendedData = extendedLogEntry.data(using: .utf8) else {
                print("DEBUG: Failed to convert extended log entry to data for \(pair)")
                logAlert(event: "Failed to convert extended log entry to data for \(pair)")
                return
            }
            
            var extendedWriteSuccess = false
            for attempt in 1...3 {
                do {
                    if let fileHandle = try? FileHandle(forWritingTo: extendedSpreadsCSVURL) {
                        defer { fileHandle.closeFile() }
                        fileHandle.seekToEndOfFile()
                        fileHandle.write(extendedData)
                        extendedWriteSuccess = true
                        print("DEBUG: Appended extended historical spread to CSV for \(pair) (attempt \(attempt)): Spread=\(spread), PredictedChange=\(predictedSpreadChangeValue)")
                        break
                    } else {
                        try extendedLogEntry.write(to: extendedSpreadsCSVURL, atomically: true, encoding: .utf8)
                        extendedWriteSuccess = true
                        print("DEBUG: Wrote extended historical spread to CSV for \(pair) (attempt \(attempt)): Spread=\(spread), PredictedChange=\(predictedSpreadChangeValue)")
                        break
                    }
                } catch {
                    print("DEBUG: Failed to write extended historical spread to CSV for \(pair) (attempt \(attempt)): \(error.localizedDescription)")
                    if attempt < 3 {
                        Thread.sleep(forTimeInterval: 0.1 * Double(attempt))
                    }
                }
            }
            
            if !extendedWriteSuccess {
                print("DEBUG: Failed to save extended historical spread to CSV for \(pair) after 3 attempts")
                logAlert(event: "Failed to save extended historical spread to CSV for \(pair) after 3 attempts")
            }
        } catch {
            print("DEBUG: Failed to save extended historical spread to CSV for \(pair): \(error.localizedDescription)")
            logAlert(event: "Failed to save extended historical spread to CSV for \(pair): \(error.localizedDescription)")
        }
    }

    @MainActor
    static func logHistoricalTradeToCSV(pair: String, strategy: String, profit: Double, fees: Double) {
        let timestampFormatter = ISO8601DateFormatter()
        timestampFormatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        let timestamp = timestampFormatter.string(from: Date())
        let tradesCSVURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/historical_trades.csv")
        let logEntry = "\(timestamp),\(pair),\(strategy),\(profit),\(fees)\n"
        
        do {
            let fileManager = FileManager.default
            let directoryURL = tradesCSVURL.deletingLastPathComponent()
            if !fileManager.fileExists(atPath: directoryURL.path) {
                try fileManager.createDirectory(at: directoryURL, withIntermediateDirectories: true, attributes: nil)
                print("DEBUG: Created directory for historical_trades.csv at \(directoryURL.path)")
            }
            
            if !fileManager.fileExists(atPath: tradesCSVURL.path) {
                let header = "timestamp,pair,strategy,profit,fees\n"
                try header.write(to: tradesCSVURL, atomically: true, encoding: .utf8)
                try fileManager.setAttributes([.posixPermissions: 0o644], ofItemAtPath: tradesCSVURL.path)
                print("DEBUG: Created historical_trades.csv with header")
            }
            
            guard let data = logEntry.data(using: .utf8) else {
                print("DEBUG: Failed to convert trade log entry to data for \(pair)")
                logAlert(event: "Failed to convert trade log entry to data for \(pair)")
                return
            }
            
            var writeSuccess = false
            for attempt in 1...3 {
                do {
                    if let fileHandle = try? FileHandle(forWritingTo: tradesCSVURL) {
                        defer { fileHandle.closeFile() }
                        fileHandle.seekToEndOfFile()
                        fileHandle.write(data)
                        writeSuccess = true
                        print("DEBUG: Appended trade to historical_trades.csv for \(pair) (attempt \(attempt)): Profit=\(profit), Fees=\(fees)")
                        break
                    } else {
                        try logEntry.write(to: tradesCSVURL, atomically: true, encoding: .utf8)
                        writeSuccess = true
                        print("DEBUG: Wrote trade to historical_trades.csv for \(pair) (attempt \(attempt)): Profit=\(profit), Fees=\(fees)")
                        break
                    }
                } catch {
                    print("DEBUG: Failed to write trade to historical_trades.csv for \(pair) (attempt \(attempt)): \(error.localizedDescription)")
                    if attempt < 3 {
                        Thread.sleep(forTimeInterval: 0.1 * Double(attempt))
                    }
                }
            }
            
            if !writeSuccess {
                print("DEBUG: Failed to save trade to historical_trades.csv for \(pair) after 3 attempts")
                logAlert(event: "Failed to save trade to historical_trades.csv for \(pair) after 3 attempts")
            }
        } catch {
            print("DEBUG: Failed to save trade to historical_trades.csv for \(pair): \(error.localizedDescription)")
            logAlert(event: "Failed to save trade to historical_trades.csv for \(pair): \(error.localizedDescription)")
        }
    }

    static func fetchSpreadPrediction(pair: String, exchange: String, spotPrice: Double, futuresPrice: Double, retryCount: Int = 0) async -> Double? {
        let maxRetries = 3
        guard retryCount < maxRetries else {
            print("DEBUG: Max retries reached for spread prediction for \(pair) on \(exchange)")
            Task { @MainActor in
                logAlert(event: "Max retries reached for spread prediction for \(pair) on \(exchange)")
            }
            return arbitrageMinSpreadThreshold
        }

        let url = URL(string: "http://127.0.0.1:5001/predict_spread")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.timeoutInterval = 30.0

        let payload: [String: Any] = [
            "pair": pair,
            "exchange": exchange,
            "spot_price": spotPrice,
            "futures_price": futuresPrice,
            "kucoin_spot_rsi": calculateRSI(prices: kucoinPrices[pair] ?? [], period: spotRsiPeriod) ?? 50.0,
            "bybit_spot_rsi": calculateRSI(prices: bybitPrices[pair] ?? [], period: spotRsiPeriod) ?? 50.0,
            "kucoin_funding_rate": kucoinFundingRates[pair] ?? 0.0,
            "bybit_funding_rate": bybitFundingRates[pair] ?? 0.0,
            "sentiment_score": sentimentScores[pair] ?? 0.0
        ]

        do {
            let jsonData = try JSONSerialization.data(withJSONObject: payload, options: [])
            request.httpBody = jsonData
        } catch {
            print("DEBUG: Failed to serialize spread prediction payload for \(pair): \(error.localizedDescription)")
            Task { @MainActor in
                logAlert(event: "Failed to serialize spread prediction payload for \(pair): \(error.localizedDescription)")
            }
            return arbitrageMinSpreadThreshold
        }

        var data: Data?
        var response: URLResponse?
        do {
            (data, response) = try await URLSession.shared.data(for: request)
            print("DEBUG: Fetch spread prediction response for \(pair): Status code \((response as? HTTPURLResponse)?.statusCode ?? -1)")
            if let data = data, let responseBody = String(data: data, encoding: .utf8) {
                print("DEBUG: Fetch spread prediction response body: \(responseBody)")
            }
        } catch {
            print("DEBUG: Failed to fetch spread prediction for \(pair): \(error.localizedDescription)")
            Task { @MainActor in
                logAlert(event: "Failed to fetch spread prediction for \(pair): \(error.localizedDescription)")
            }
            let delay = pow(2.0, Double(retryCount))
            do {
                try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
                return await fetchSpreadPrediction(pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, retryCount: retryCount + 1)
            } catch {
                print("DEBUG: Failed to sleep during retry for spread prediction: \(error.localizedDescription)")
                return arbitrageMinSpreadThreshold
            }
        }

        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
            print("DEBUG: Invalid spread prediction response for \(pair): Status code \((response as? HTTPURLResponse)?.statusCode ?? -1)")
            Task { @MainActor in
                logAlert(event: "Invalid spread prediction response for \(pair)")
            }
            let delay = pow(2.0, Double(retryCount))
            do {
                try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
                return await fetchSpreadPrediction(pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, retryCount: retryCount + 1)
            } catch {
                print("DEBUG: Failed to sleep during retry for spread prediction: \(error.localizedDescription)")
                return arbitrageMinSpreadThreshold
            }
        }

        guard let fetchedData = data,
              let json = try? JSONSerialization.jsonObject(with: fetchedData) as? [String: Any],
              let predictedSpread = json["predicted_spread"] as? Double else {
            print("DEBUG: Failed to parse spread prediction for \(pair)")
            Task { @MainActor in
                logAlert(event: "Failed to parse spread prediction for \(pair)")
            }
            let delay = pow(2.0, Double(retryCount))
            do {
                try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
                return await fetchSpreadPrediction(pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: futuresPrice, retryCount: retryCount + 1)
            } catch {
                print("DEBUG: Failed to sleep during retry for spread prediction: \(error.localizedDescription)")
                return arbitrageMinSpreadThreshold
            }
        }

        print("DEBUG: Successfully fetched spread prediction for \(pair): \(predictedSpread)")
        return predictedSpread
    }

    // Enhanced HFT monitoring with proper MainActor isolation
    static func enhancedHFTMonitoring() {
        Task { @MainActor in
            while tradingActive && !emergencyStopActive {
                for pair in tradingPairs {
                    guard !isTradingPaused[pair, default: false] else { continue }
                    
                    let kucoinOrderBook = kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
                    let bybitOrderBook = bybitOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
                    
                    // FIX: Use isEmpty property instead of non-existent member
                    if !kucoinOrderBook.isEmpty {
                        let kucoinSpread = (kucoinOrderBook.asks.first?.price ?? 0.0) - (kucoinOrderBook.bids.first?.price ?? 0.0)
                        let kucoinPrice = (kucoinOrderBook.bids.first?.price ?? 0.0 + kucoinOrderBook.asks.first?.price ?? 0.0) / 2
                        
                        if kucoinPrice > 0 {
                            let spreadPercent = kucoinSpread / kucoinPrice
                            if spreadPercent >= getDouble("HFT_SPREAD_THRESHOLD", defaultValue: 0.003) {
                                print("HFT opportunity on KuCoin for \(pair): \(String(format: "%.4f", spreadPercent * 100))%")
                                
                                // Execute HFT trade logic
                                let tradeAmount = min(kucoinBalance * 0.02, getDouble("HFT_TRADE_AMOUNT", defaultValue: 200.0))
                                if tradeAmount > 5.0 {
                                    Task {
                                        let success = await executeScalpingTrade(
                                            pair: pair,
                                            exchange: "kucoin",
                                            entryPrice: kucoinOrderBook.bids.first?.price ?? kucoinPrice,
                                            targetPrice: kucoinOrderBook.asks.first?.price ?? kucoinPrice,
                                            stopPrice: kucoinPrice * (1 - getDouble("SCALP_STOP_LOSS", defaultValue: 0.0015)),
                                            tradeAmount: tradeAmount,
                                            maxActiveTrades: getInt("MAX_ACTIVE_SPOT_TRADES", defaultValue: 2)
                                        )
                                        
                                        if success {
                                            await MainActor.run {
                                                hftArbitrageExecuted[pair] = (profit: spreadPercent * tradeAmount, timestamp: Date())
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    // FIX: Use isEmpty property instead of non-existent member
                    if !bybitOrderBook.isEmpty {
                        let bybitSpread = (bybitOrderBook.asks.first?.price ?? 0.0) - (bybitOrderBook.bids.first?.price ?? 0.0)
                        let bybitPrice = (bybitOrderBook.bids.first?.price ?? 0.0 + bybitOrderBook.asks.first?.price ?? 0.0) / 2
                        
                        if bybitPrice > 0 {
                            let spreadPercent = bybitSpread / bybitPrice
                            if spreadPercent >= getDouble("HFT_SPREAD_THRESHOLD", defaultValue: 0.003) {
                                print("HFT opportunity on Bybit for \(pair): \(String(format: "%.4f", spreadPercent * 100))%")
                                
                                // Execute HFT trade logic
                                let tradeAmount = min(bybitBalance * 0.02, getDouble("HFT_TRADE_AMOUNT", defaultValue: 200.0))
                                if tradeAmount > 5.0 {
                                    Task {
                                        let success = await executeScalpingTrade(
                                            pair: pair,
                                            exchange: "bybit",
                                            entryPrice: bybitOrderBook.bids.first?.price ?? bybitPrice,
                                            targetPrice: bybitOrderBook.asks.first?.price ?? bybitPrice,
                                            stopPrice: bybitPrice * (1 - getDouble("SCALP_STOP_LOSS", defaultValue: 0.0015)),
                                            tradeAmount: tradeAmount,
                                            maxActiveTrades: getInt("MAX_ACTIVE_SPOT_TRADES", defaultValue: 2)
                                        )
                                        
                                        if success {
                                            await MainActor.run {
                                                hftArbitrageExecuted[pair] = (profit: spreadPercent * tradeAmount, timestamp: Date())
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                // FIX: Wrap MainActor-isolated calls in await MainActor.run
                await MainActor.run {
                    printPeriodicSummary()
                }
                
                await MainActor.run {
                    updateDashboardJSON(
                        dashboardJSONURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/dashboard.json"),
                        totalProfit: totalProfit,
                        totalFees: totalFees
                    )
                }
                
                try? await Task.sleep(nanoseconds: UInt64(getDouble("HFT_COOLDOWN_SECONDS", defaultValue: 1.5) * 1_000_000_000))
            }
        }
    }
}

//--------------------------------------------------------------------------------------------------------------Block 16 - Spot-Futures Arbitrage Execution




extension ExchangeWebSocket {
    static func executeSpotFuturesArbitrage(pair: String, kucoinSpotPrice: Double, kucoinFuturesPrice: Double, bybitSpotPrice: Double, bybitFuturesPrice: Double, amount: Double, completion: @escaping (Bool) -> Void) {
        Task {
            let minSpreadThreshold = getDouble("ARBITRAGE_MIN_SPREAD_THRESHOLD", defaultValue: 0.002)
            let kucoinSpread = abs(kucoinSpotPrice - kucoinFuturesPrice) / min(kucoinSpotPrice, kucoinFuturesPrice)
            let bybitSpread = abs(bybitSpotPrice - bybitFuturesPrice) / min(bybitSpotPrice, bybitFuturesPrice)
            
            guard kucoinSpread >= minSpreadThreshold || bybitSpread >= minSpreadThreshold else {
                print("DEBUG: Spread too low for spot-futures arbitrage: KuCoin=\(kucoinSpread), Bybit=\(bybitSpread)")
                await MainActor.run {
                    logAlert(event: "Spread too low for spot-futures arbitrage: KuCoin=\(kucoinSpread), Bybit=\(bybitSpread)")
                }
                completion(false)
                return
            }
            
            let kucoinLiquidity = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "spot", tradeAmount: amount, price: kucoinSpotPrice)
            let kucoinFuturesLiquidity = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "futures", tradeAmount: amount, price: kucoinFuturesPrice)
            let bybitLiquidity = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "spot", tradeAmount: amount, price: bybitSpotPrice)
            let bybitFuturesLiquidity = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "futures", tradeAmount: amount, price: bybitFuturesPrice)
            
            guard let kucoinLiquidity = kucoinLiquidity, let kucoinFuturesLiquidity = kucoinFuturesLiquidity,
                  let bybitLiquidity = bybitLiquidity, let bybitFuturesLiquidity = bybitFuturesLiquidity else {
                print("DEBUG: Insufficient liquidity for spot-futures arbitrage: \(pair)")
                await MainActor.run {
                    logAlert(event: "Insufficient liquidity for spot-futures arbitrage: \(pair)")
                }
                completion(false)
                return
            }
            
            // Integrate liquidity into weighted trade amount calculation
            let kucoinLiquidityFactor = min(kucoinLiquidity, kucoinFuturesLiquidity) / (kucoinLiquidity + kucoinFuturesLiquidity)
            let bybitLiquidityFactor = min(bybitLiquidity, bybitFuturesLiquidity) / (bybitLiquidity + bybitFuturesLiquidity)
            
            let kucoinFundingRate = kucoinFundingRates[pair] ?? 0.0
            let bybitFundingRate = bybitFundingRates[pair] ?? 0.0
            let maxFundingRateValue = await MainActor.run { maxFundingRate }
            
            guard abs(kucoinFundingRate) < maxFundingRateValue && abs(bybitFundingRate) < maxFundingRateValue else {
                print("DEBUG: Funding rate too high for \(pair): KuCoin=\(kucoinFundingRate), Bybit=\(bybitFundingRate)")
                await MainActor.run {
                    logAlert(event: "Funding rate too high for \(pair): KuCoin=\(kucoinFundingRate), Bybit=\(bybitFundingRate)")
                }
                completion(false)
                return
            }
            
            let kucoinProfit = kucoinSpread * amount - amount * (kucoinTakerFee + kucoinMakerFee) * 2
            let bybitProfit = bybitSpread * amount - amount * (bybitTakerFee + bybitMakerFee) * 2
            let minProfitThreshold = await MainActor.run { spotMinProfitPercentage }
            
            guard kucoinProfit > minProfitThreshold * amount * min(kucoinSpotPrice, kucoinFuturesPrice) ||
                  bybitProfit > minProfitThreshold * amount * min(bybitSpotPrice, bybitFuturesPrice) else {
                print("DEBUG: Expected profit too low for spot-futures arbitrage: KuCoin=\(kucoinProfit), Bybit=\(bybitProfit)")
                await MainActor.run {
                    logAlert(event: "Expected profit too low for spot-futures arbitrage: KuCoin=\(kucoinProfit), Bybit=\(bybitProfit)")
                }
                completion(false)
                return
            }
            
            let kucoinTradeAmount = await dynamicTradeAmount(balance: kucoinBalance, riskPercent: 0.3, volatility: 0.5) * kucoinLiquidityFactor
            let bybitTradeAmount = await dynamicTradeAmount(balance: bybitBalance, riskPercent: 0.3, volatility: 0.5) * bybitLiquidityFactor
            
            if kucoinSpread > bybitSpread && kucoinProfit > bybitProfit {
                let potentialLoss = kucoinTradeAmount * kucoinSpotPrice * stopLossPercentage
                if await checkDailyLossLimit(exchange: "kucoin", pair: pair, potentialLoss: potentialLoss) {
                    print("DEBUG: Daily loss limit exceeded for KuCoin-\(pair)")
                    completion(false)
                    return
                }
                
                executeSingleExchangeArbitrage(
                    exchange: "kucoin",
                    pair: pair,
                    spotPrice: kucoinSpotPrice,
                    futuresPrice: kucoinFuturesPrice,
                    strategy: "Spot-to-Futures",
                    kucoinSpotPrices: kucoinPrices[pair] ?? [],
                    bybitSpotPrices: [],
                    tradeAmount: kucoinTradeAmount
                )
                await MainActor.run {
                    tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].totalProfit += kucoinProfit
                    tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].totalFees += amount * (kucoinTakerFee + kucoinMakerFee) * 2
                    tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].wins += kucoinProfit > 0 ? 1 : 0
                    performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].profit += kucoinProfit
                    performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].fees += amount * (kucoinTakerFee + kucoinMakerFee) * 2
                    performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].trades += 1
                    performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].wins += kucoinProfit > 0 ? 1 : 0
                    kucoinBalance += kucoinProfit - amount * (kucoinTakerFee + kucoinMakerFee) * 2
                    logTradeToCSV(pair: pair, strategy: "Spot-to-Futures", profit: kucoinProfit, fees: amount * (kucoinTakerFee + kucoinMakerFee) * 2, tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/trades.csv"))
                    print("DEBUG: Executed spot-futures arbitrage on KuCoin for \(pair): Profit=\(kucoinProfit)")
                    logAlert(event: "Executed spot-futures arbitrage on KuCoin for \(pair): Profit=\(kucoinProfit)")
                }
                completion(true)
            } else {
                let potentialLoss = bybitTradeAmount * bybitSpotPrice * stopLossPercentage
                if await checkDailyLossLimit(exchange: "bybit", pair: pair, potentialLoss: potentialLoss) {
                    print("DEBUG: Daily loss limit exceeded for Bybit-\(pair)")
                    completion(false)
                    return
                }
                
                executeSingleExchangeArbitrage(
                    exchange: "bybit",
                    pair: pair,
                    spotPrice: bybitSpotPrice,
                    futuresPrice: bybitFuturesPrice,
                    strategy: "Spot-to-Futures",
                    kucoinSpotPrices: [],
                    bybitSpotPrices: bybitPrices[pair] ?? [],
                    tradeAmount: bybitTradeAmount
                )
                await MainActor.run {
                    tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].totalProfit += bybitProfit
                    tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].totalFees += amount * (bybitTakerFee + bybitMakerFee) * 2
                    tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].wins += bybitProfit > 0 ? 1 : 0
                    performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].profit += bybitProfit
                    performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].fees += amount * (bybitTakerFee + bybitMakerFee) * 2
                    performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].trades += 1
                    performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].wins += bybitProfit > 0 ? 1 : 0
                    bybitBalance += bybitProfit - amount * (bybitTakerFee + bybitMakerFee) * 2
                    logTradeToCSV(pair: pair, strategy: "Spot-to-Futures", profit: bybitProfit, fees: amount * (bybitTakerFee + bybitMakerFee) * 2, tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trades.csv"))
                    print("DEBUG: Executed spot-futures arbitrage on Bybit for \(pair): Profit=\(bybitProfit)")
                    logAlert(event: "Executed spot-futures arbitrage on Bybit for \(pair): Profit=\(bybitProfit)")
                }
                completion(true)
            }
        }
    }
}





//-------------------------------------------------------------------------------------------------------------------------Block 17 - Cross-Exchange Arbitrage Execution


import Foundation

extension ExchangeWebSocket {
    static func checkCrossExchangeArbitrage(pair: String, strategy: String, amount: Double, completion: @escaping @Sendable (Bool) -> Void) async {
        let kucoinSpotPrice = await MainActor.run(body: { kucoinCurrentPrice[pair] }) ?? 0.0
        let bybitSpotPrice = await MainActor.run(body: { bybitCurrentPrice[pair] }) ?? 0.0
        let spread = abs(kucoinSpotPrice - bybitSpotPrice) / min(kucoinSpotPrice, bybitSpotPrice)
        let crossExchangeMinSpreadThresholdValue = await MainActor.run(body: { crossExchangeMinSpreadThreshold })
        let crossExchangeCooldownSecondsValue = await MainActor.run(body: { crossExchangeCooldownSeconds })
        
        guard spread >= crossExchangeMinSpreadThresholdValue else {
            print("DEBUG: Spread too low for cross-exchange arbitrage: \(pair), Spread: \(spread)")
            await MainActor.run(body: {
                logAlert(event: "Spread too low for cross-exchange arbitrage: \(pair), Spread: \(spread)")
            })
            completion(false)
            return
        }

        if let lastArb = await MainActor.run(body: { crossExchangeArbitrageExecuted[pair] }),
           Date().timeIntervalSince(lastArb.1) < crossExchangeCooldownSecondsValue {
            print("DEBUG: Cross-exchange arbitrage on cooldown for \(pair)")
            completion(false)
            return
        }

        let _ = await checkLiquidityAsyncUnique(exchange: "kucoin", pair: pair, marketType: "spot", tradeAmount: amount, price: kucoinSpotPrice) // Updated to checkLiquidityAsyncUnique
        let _ = await checkLiquidityAsyncUnique(exchange: "bybit", pair: pair, marketType: "spot", tradeAmount: amount, price: bybitSpotPrice) // Updated to checkLiquidityAsyncUnique
        
        let kucoinTradeAmount = await dynamicTradeAmount(balance: kucoinBalance, riskPercent: tradeAmountPercentage, volatility: 0.01, pair: pair) // Added pair
        let bybitTradeAmount = await dynamicTradeAmount(balance: bybitBalance, riskPercent: tradeAmountPercentage, volatility: 0.01, pair: pair) // Added pair
        let kellySize = await calculateKellyCriterion(pair: pair) // Added await and pair
        let baseTradeAmount = min(kucoinBalance, bybitBalance) * kellySize
        
        let _ = await checkLiquidityAsyncUnique(exchange: "kucoin", pair: pair, marketType: "spot", tradeAmount: baseTradeAmount, price: kucoinSpotPrice) ?? 0.0 // Updated to checkLiquidityAsyncUnique
        let _ = await checkLiquidityAsyncUnique(exchange: "bybit", pair: pair, marketType: "spot", tradeAmount: baseTradeAmount, price: bybitSpotPrice) ?? 0.0 // Updated to checkLiquidityAsyncUnique

        let kucoinFundingRate = await MainActor.run(body: { kucoinFundingRates[pair] }) ?? 0.0
        let bybitFundingRate = await MainActor.run(body: { bybitFundingRates[pair] }) ?? 0.0
        let maxFundingRateValue = await MainActor.run(body: { maxFundingRate })
        guard abs(kucoinFundingRate) < maxFundingRateValue && abs(bybitFundingRate) < maxFundingRateValue else {
            print("DEBUG: Funding rate too high for \(pair): KuCoin=\(kucoinFundingRate), Bybit=\(bybitFundingRate)")
            await MainActor.run(body: {
                logAlert(event: "Funding rate too high for \(pair): KuCoin=\(kucoinFundingRate), Bybit=\(bybitFundingRate)")
            })
            completion(false)
            return
        }

        let bybitDailyLossOk = await checkDailyLossLimit(exchange: "bybit", pair: pair, potentialLoss: bybitTradeAmount * bybitSpotPrice * spotStopLossPercentage)
        if !bybitDailyLossOk {
            print("DEBUG: Insufficient balance for cross-exchange arbitrage: \(pair)")
            await MainActor.run(body: {
                logAlert(event: "Insufficient balance for cross-exchange arbitrage: \(pair)")
            })
            completion(false)
            return
        }

        guard kucoinBalance >= kucoinTradeAmount * kucoinSpotPrice && bybitBalance >= bybitTradeAmount * bybitSpotPrice else {
            print("DEBUG: Insufficient balance for cross-exchange arbitrage: \(pair)")
            await MainActor.run(body: {
                logAlert(event: "Insufficient balance for cross-exchange arbitrage: \(pair)")
            })
            completion(false)
            return
        }

        let _ = await fetchSpreadPrediction(pair: pair, exchange: "kucoin", spotPrice: kucoinSpotPrice, futuresPrice: bybitSpotPrice) ?? 0.0

        await MainActor.run(body: {
            logTradeToCSV(pair: pair, strategy: strategy, profit: 0.0, fees: 0.0, tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trade_log.csv"))
        })

        let adjustedAmount = min(kucoinTradeAmount, bybitTradeAmount, amount)
        let kucoinFee = kucoinTradeAmount * kucoinSpotPrice * spotFeeRate
        let bybitFee = bybitTradeAmount * bybitSpotPrice * spotFeeRate
        let expectedProfit = spread * adjustedAmount * min(kucoinSpotPrice, bybitSpotPrice) - kucoinFee - bybitFee

        let spotMinProfitPercentageValue = await MainActor.run(body: { spotMinProfitPercentage })
        guard expectedProfit > spotMinProfitPercentageValue * adjustedAmount * min(kucoinSpotPrice, bybitSpotPrice) else {
            print("DEBUG: Expected profit too low for \(pair): \(expectedProfit)")
            await MainActor.run(body: {
                logAlert(event: "Expected profit too low for \(pair): \(expectedProfit)")
            })
            completion(false)
            return
        }

        let buyExchange = kucoinSpotPrice < bybitSpotPrice ? "kucoin" : "bybit"
        let sellExchange = kucoinSpotPrice < bybitSpotPrice ? "bybit" : "kucoin"
        let buyPrice = kucoinSpotPrice < bybitSpotPrice ? kucoinSpotPrice : bybitSpotPrice
        let sellPrice = kucoinSpotPrice < bybitSpotPrice ? bybitSpotPrice : kucoinSpotPrice

        let buyDailyLossOk = await checkDailyLossLimit(exchange: buyExchange, pair: pair, potentialLoss: adjustedAmount * buyPrice * spotStopLossPercentage)
        if !buyDailyLossOk {
            print("DEBUG: Buy order failed on \(buyExchange) for \(pair)")
            await MainActor.run(body: {
                logAlert(event: "Buy order failed on \(buyExchange) for \(pair)")
            })
            completion(false)
            return
        }

        let maxSlippageValue = await MainActor.run(body: { maxSlippage })
        let scalpStopLossValue = await MainActor.run(body: { scalpStopLoss })
        let maxActiveSpotTradesValue = await MainActor.run(body: { maxActiveSpotTrades })

        let buySuccess = await executeScalpingTrade(
            pair: pair,
            exchange: buyExchange,
            entryPrice: buyPrice * (1 + maxSlippageValue),
            targetPrice: sellPrice,
            stopPrice: buyPrice * (1 - scalpStopLossValue),
            tradeAmount: adjustedAmount,
            maxActiveTrades: maxActiveSpotTradesValue
        )
        guard buySuccess else {
            print("DEBUG: Buy order failed on \(buyExchange) for \(pair)")
            await MainActor.run(body: {
                logAlert(event: "Buy order failed on \(buyExchange) for \(pair)")
            })
            completion(false)
            return
        }

        let sellSuccess = await executeScalpingTrade(
            pair: pair,
            exchange: sellExchange,
            entryPrice: sellPrice * (1 - maxSlippageValue),
            targetPrice: buyPrice,
            stopPrice: sellPrice * (1 + scalpStopLossValue),
            tradeAmount: adjustedAmount,
            maxActiveTrades: maxActiveSpotTradesValue
        )
        guard sellSuccess else {
            print("DEBUG: Sell order failed on \(sellExchange) for \(pair)")
            await MainActor.run(body: {
                logAlert(event: "Sell order failed on \(sellExchange) for \(pair)")
            })
            completion(false)
            return
        }

        let profit = (sellPrice - buyPrice) * adjustedAmount - kucoinFee - bybitFee
        await MainActor.run(body: {
            tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].totalProfit += profit
            tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].totalFees += (kucoinFee + bybitFee)
            if profit > 0 {
                tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].wins += 1
            } else {
                tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].losses += 1
            }
            performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].profit += profit
            performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].fees += (kucoinFee + bybitFee)
            performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].trades += 1
            if profit > 0 {
                performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].wins += 1
            }

            kucoinBalance -= kucoinFee
            bybitBalance -= bybitFee
            if buyExchange == "kucoin" {
                kucoinBalance -= buyPrice * adjustedAmount
                bybitBalance += sellPrice * adjustedAmount
            } else {
                bybitBalance -= buyPrice * adjustedAmount
                kucoinBalance += sellPrice * adjustedAmount
            }

            crossExchangeArbitrageExecuted[pair] = (true, Date())
        })

        let timestamp = ISO8601DateFormatter().string(from: Date())
        let logEntry = "\(timestamp),\(pair),\(buyExchange),buy,\(buyPrice),\(sellExchange),sell,\(sellPrice),\(adjustedAmount),\(profit),\(kucoinFee + bybitFee)\n"
        let tradeLogURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trade_log.csv")
        do {
            let fileManager = FileManager.default
            if !fileManager.fileExists(atPath: tradeLogURL.path) {
                try "timestamp,pair,buyExchange,buySide,buyPrice,sellExchange,sellSide,sellPrice,amount,profit,fees\n".write(to: tradeLogURL, atomically: true, encoding: .utf8)
                try fileManager.setAttributes([.posixPermissions: 0o644], ofItemAtPath: tradeLogURL.path)
            }
            if let fileHandle = try? FileHandle(forWritingTo: tradeLogURL) {
                defer { fileHandle.closeFile() }
                if let data = logEntry.data(using: .utf8) {
                    fileHandle.seekToEndOfFile()
                    fileHandle.write(data)
                }
            } else {
                let fileHandle = try FileHandle(forWritingTo: tradeLogURL)
                defer { fileHandle.closeFile() }
                if let data = logEntry.data(using: .utf8) {
                    fileHandle.seekToEndOfFile()
                    fileHandle.write(data)
                }
            }
            print("DEBUG: Logged cross-exchange arbitrage trade to trade_log.csv: \(logEntry.trimmingCharacters(in: .whitespacesAndNewlines))")
        } catch {
            print("DEBUG: Failed to log cross-exchange arbitrage trade: \(error.localizedDescription)")
            await MainActor.run(body: {
                logAlert(event: "Failed to log cross-exchange arbitrage trade: \(error.localizedDescription)")
            })
        }

        print("DEBUG: Executed cross-exchange arbitrage for \(pair): Profit=\(profit), Fees=\(kucoinFee + bybitFee)")
        await MainActor.run(body: {
            logAlert(event: "Executed cross-exchange arbitrage for \(pair): Profit=\(profit), Fees=\(kucoinFee + bybitFee)")
        })
        completion(true)
    }
}




//---------------------------------------------------------------------------------------------------------------Block 18 - Market Making Operations

extension ExchangeWebSocket {
    static func monitorHFTScalpingOpportunities() {
        let localKucoinOrderBooks = kucoinOrderBooks
        let localBybitOrderBooks = bybitOrderBooks
        let localTradingPairs = tradingPairs

        print("DEBUG: Compiling monitorHFTScalpingOpportunities at \(ISO8601DateFormatter().string(from: Date()))")

        // Helper function to fetch market data
        func fetchMarketData(pair: String) async -> (
            kucoinSpotPrice: Double, bybitSpotPrice: Double,
            kucoinSpotPrices: [Double], bybitSpotPrices: [Double],
            kucoinVolumes: [Double], bybitVolumes: [Double],
            kucoinEvents: [(timestamp: Date, level: Int, volume: Double)],
            bybitEvents: [(timestamp: Date, level: Int, volume: Double)],
            sentiment: Double, activeTrades: Int
        ) {
            let kucoinCurrentPriceValue = await MainActor.run { kucoinCurrentPrice }
            let bybitCurrentPriceValue = await MainActor.run { bybitCurrentPrice }
            let kucoinPricesValue = await MainActor.run { kucoinPrices }
            let bybitPricesValue = await MainActor.run { bybitPrices }
            let kucoinSpotVolumeValue = await MainActor.run { kucoinSpotVolume }
            let bybitSpotVolumeValue = await MainActor.run { bybitSpotVolume }
            let kucoinOrderBookEventsValue = await MainActor.run { kucoinOrderBookEvents }
            let orderCancellationEventsValue = await MainActor.run { orderCancellationEvents }
            let sentimentScoresValue = await MainActor.run { sentimentScores }
            let activeSpotTradesValue = await MainActor.run { activeSpotTrades }

            print("DEBUG: fetchMarketData for \(pair): kucoinCurrentPrice[\(pair)]=\(kucoinCurrentPriceValue[pair] ?? 0.0), bybitCurrentPrice[\(pair)]=\(bybitCurrentPriceValue[pair] ?? 0.0), kucoinIsConnected=\(kucoinIsConnected), bybitIsConnected=\(bybitIsConnected)")

            return (
                kucoinSpotPrice: kucoinCurrentPriceValue[pair] ?? 0.0,
                bybitSpotPrice: bybitCurrentPriceValue[pair] ?? 0.0,
                kucoinSpotPrices: kucoinPricesValue[pair] ?? [],
                bybitSpotPrices: bybitPricesValue[pair] ?? [],
                kucoinVolumes: kucoinSpotVolumeValue[pair] ?? [],
                bybitVolumes: bybitSpotVolumeValue[pair] ?? [],
                kucoinEvents: kucoinOrderBookEventsValue[pair] ?? [],
                bybitEvents: orderCancellationEventsValue[pair] ?? [],
                sentiment: sentimentScoresValue[pair] ?? 0.0,
                activeTrades: activeSpotTradesValue[pair] ?? 0
            )
        }

        // Helper function to check trade conditions
        func checkTradeConditions(
            pair: String,
            kucoinSpotPrice: Double,
            bybitSpotPrice: Double,
            kucoinSpotPrices: [Double],
            bybitSpotPrices: [Double],
            kucoinVolumes: [Double],
            bybitVolumes: [Double],
            kucoinEvents: [(timestamp: Date, level: Int, volume: Double)],
            bybitEvents: [(timestamp: Date, level: Int, volume: Double)],
            activeTrades: Int
        ) async -> Bool {
            let volatilityPauseActiveValue = await MainActor.run { volatilityPauseActive }
            let isTradingPausedValue = await MainActor.run { isTradingPaused }
            guard !volatilityPauseActiveValue else {
                print("DEBUG: HFT Scalping paused due to volatility for \(pair)")
                return false
            }
            guard !(isTradingPausedValue[pair] ?? false) else {
                print("DEBUG: HFT Scalping paused for \(pair) due to manual pause")
                return false
            }
            guard !(await MainActor.run { kucoinInSpotTrade[pair] ?? false }) else {
                print("DEBUG: HFT Scalping skipped for \(pair) due to active KuCoin trade")
                return false
            }
            guard kucoinSpotPrice > 0, bybitSpotPrice > 0 else {
                print("DEBUG: Invalid prices for HFT Scalping - KuCoin: \(kucoinSpotPrice), Bybit: \(bybitSpotPrice)")
                await MainActor.run {
                    logAlert(event: "Invalid prices for HFT Scalping - KuCoin: \(kucoinSpotPrice), Bybit: \(bybitSpotPrice)")
                }
                return false
            }

            let spotTradeAmountValue = await MainActor.run { spotTradeAmount }
            let minLiquidityThresholdValue = await MainActor.run { minLiquidityThreshold }
            let _ = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "spot", tradeAmount: spotTradeAmountValue, price: kucoinSpotPrice) ?? 0.0
            let _ = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "futures", tradeAmount: spotTradeAmountValue, price: kucoinSpotPrice) ?? 0.0
            let _ = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "spot", tradeAmount: spotTradeAmountValue, price: bybitSpotPrice) ?? 0.0
            let _ = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "futures", tradeAmount: spotTradeAmountValue, price: bybitSpotPrice) ?? 0.0
            print("DEBUG: Min liquidity threshold for \(pair): \(minLiquidityThresholdValue)")

            let calculateImbalances: (String) async -> (Double, Double) = { pair in
                let kucoinBookRaw = await MainActor.run { localKucoinOrderBooks[pair] } ?? BevaixOrderBook(bids: [], asks: [])
                let bybitBookRaw = await MainActor.run { localBybitOrderBooks[pair] } ?? BevaixOrderBook(bids: [], asks: [])
                let kucoinBook = kucoinBookRaw
                let bybitBook = bybitBookRaw
                
                let kucoinTotalBidVolume: Double = kucoinBook.bids.reduce(0.0) { $0 + $1.quantity }
                let kucoinTotalAskVolume: Double = kucoinBook.asks.reduce(0.0) { $0 + $1.quantity }
                let kucoinImbalance: Double = kucoinTotalBidVolume > 0 ? kucoinTotalAskVolume / kucoinTotalBidVolume : 1.0
                
                let bybitTotalBidVolume: Double = bybitBook.bids.reduce(0.0) { $0 + $1.quantity }
                let bybitTotalAskVolume: Double = bybitBook.asks.reduce(0.0) { $0 + $1.quantity }
                let bybitImbalance: Double = bybitTotalBidVolume > 0 ? bybitTotalAskVolume / bybitTotalBidVolume : 1.0
                
                return (kucoinImbalance, bybitImbalance)
            }
            let (kucoinImbalance, bybitImbalance) = await calculateImbalances(pair)
            let orderBookImbalanceThresholdValue = getDouble("ORDER_BOOK_IMBALANCE_THRESHOLD", defaultValue: 2.0)
            guard kucoinImbalance < orderBookImbalanceThresholdValue, bybitImbalance < orderBookImbalanceThresholdValue else {
                print("DEBUG: Order book imbalance too high for \(pair): KuCoin=\(kucoinImbalance), Bybit=\(bybitImbalance), Threshold=\(orderBookImbalanceThresholdValue)")
                await MainActor.run {
                    logAlert(event: "Order book imbalance too high for \(pair): KuCoin=\(kucoinImbalance), Bybit=\(bybitImbalance)")
                }
                return false
            }

            let maxActiveSpotTradesValue = await MainActor.run { maxActiveSpotTrades }
            guard activeTrades < maxActiveSpotTradesValue else {
                print("DEBUG: Max active spot trades reached for \(pair): \(activeTrades)")
                return false
            }

            let spoofingThreshold = await MainActor.run { spoofingVolumeThreshold * 2.0 }
            let spoofingDetected = kucoinEvents.filter { Date().timeIntervalSince($0.timestamp) < 60 }.count > 2 && kucoinEvents.contains(where: { $0.volume > spoofingThreshold }) ||
                                   bybitEvents.filter { Date().timeIntervalSince($0.timestamp) < 60 }.count > 2 && bybitEvents.contains(where: { $0.volume > spoofingThreshold })
            guard !spoofingDetected else {
                print("DEBUG: Order book spoofing detected for \(pair), Threshold=\(spoofingThreshold)")
                await MainActor.run {
                    logAlert(event: "Order book spoofing detected for \(pair)")
                }
                return false
            }

            let volumeSpikeThreshold = getDouble("VOLUME_SPIKE_THRESHOLD", defaultValue: 1.5)
            let volumeSpike = (kucoinVolumes.last ?? 0.0) / (kucoinVolumes.isEmpty ? 1.0 : kucoinVolumes.reduce(0.0, +) / Double(kucoinVolumes.count)) > volumeSpikeThreshold ||
                              (bybitVolumes.last ?? 0.0) / (bybitVolumes.isEmpty ? 1.0 : bybitVolumes.reduce(0.0, +) / Double(kucoinVolumes.count)) > volumeSpikeThreshold
            guard !volumeSpike else {
                print("DEBUG: Volume spike detected for \(pair)")
                await MainActor.run {
                    logAlert(event: "Volume spike detected for \(pair)")
                }
                return false
            }

            return true
        }

        // Helper function to calculate indicators
        func calculateIndicators(
            kucoinSpotPrices: [Double],
            bybitSpotPrices: [Double]
        ) async -> (
            kucoinSpotEmaShort: Double, kucoinSpotEmaLong: Double,
            bybitSpotEmaShort: Double, bybitSpotEmaLong: Double,
            kucoinSpotRsi: Double, bybitSpotRsi: Double,
            kucoinMacd: (macd: Double, signal: Double, histogram: Double),
            bybitMacd: (macd: Double, signal: Double, histogram: Double)
        ) {
            let spotEmaShortPeriodValue = await MainActor.run { spotEmaShortPeriod }
            let spotEmaLongPeriodValue = await MainActor.run { spotEmaLongPeriod }
            let spotRsiPeriodValue = await MainActor.run { spotRsiPeriod }
            let macdShortPeriodValue = await MainActor.run { macdShortPeriod }
            let macdLongPeriodValue = await MainActor.run { macdLongPeriod }
            let macdSignalPeriodValue = await MainActor.run { macdSignalPeriod }

            return (
                kucoinSpotEmaShort: calculateEMA(prices: kucoinSpotPrices, period: spotEmaShortPeriodValue) ?? 0.0,
                kucoinSpotEmaLong: calculateEMA(prices: kucoinSpotPrices, period: spotEmaLongPeriodValue) ?? 0.0,
                bybitSpotEmaShort: calculateEMA(prices: bybitSpotPrices, period: spotEmaShortPeriodValue) ?? 0.0,
                bybitSpotEmaLong: calculateEMA(prices: bybitSpotPrices, period: spotEmaLongPeriodValue) ?? 0.0,
                kucoinSpotRsi: calculateRSI(prices: kucoinSpotPrices, period: spotRsiPeriodValue) ?? 50.0,
                bybitSpotRsi: calculateRSI(prices: bybitSpotPrices, period: spotRsiPeriodValue) ?? 50.0,
                kucoinMacd: calculateMACD(prices: kucoinSpotPrices, shortPeriod: macdShortPeriodValue, longPeriod: macdLongPeriodValue, signalPeriod: macdSignalPeriodValue) ?? (macd: 0.0, signal: 0.0, histogram: 0.0),
                bybitMacd: calculateMACD(prices: bybitSpotPrices, shortPeriod: macdShortPeriodValue, longPeriod: macdLongPeriodValue, signalPeriod: macdSignalPeriodValue) ?? (macd: 0.0, signal: 0.0, histogram: 0.0)
            )
        }

        // Helper function to execute trade
        func executeTrade(
            exchange: String,
            pair: String,
            spotPrice: Double,
            tradeAmount: Double,
            buySignal: Bool,
            sellSignal: Bool,
            sentiment: Double,
            isBalanceSufficient: Bool,
            isWithinLossLimit: Bool,
            maxActiveSpotTradesValue: Int
        ) async {
            let scalpEntryThresholdValue = await MainActor.run { scalpEntryThreshold }
            let scalpProfitTargetValue = await MainActor.run { scalpProfitTarget }
            let scalpStopLossValue = await MainActor.run { scalpStopLoss }

            if buySignal && isBalanceSufficient && sentiment > 0.0 && isWithinLossLimit {
                let predictedSpread = await fetchSpreadPrediction(pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: spotPrice) ?? 0.0
                await MainActor.run {
                    print("DEBUG: Predicted spread for \(exchange.capitalized) \(pair): \(predictedSpread)")
                    logHistoricalTradeToCSV(pair: pair, strategy: "HFT-Scalping", profit: 0.0, fees: 0.0)
                }
                let success = await executeScalpingTrade(
                    pair: pair,
                    exchange: exchange,
                    entryPrice: spotPrice * (1 + scalpEntryThresholdValue),
                    targetPrice: spotPrice * (1 + scalpProfitTargetValue),
                    stopPrice: spotPrice * (1 - scalpStopLossValue),
                    tradeAmount: tradeAmount,
                    maxActiveTrades: maxActiveSpotTradesValue
                )
                if success {
                    await MainActor.run {
                        activeSpotTrades[pair] = (activeSpotTrades[pair] ?? 0) + 1
                        if exchange == "kucoin" {
                            kucoinInSpotTrade[pair] = true
                            kucoinSpotEntryPrice[pair] = spotPrice
                        } else {
                            bybitInSpotTrade[pair] = true
                            bybitSpotEntryPrice[pair] = spotPrice
                        }
                    }
                    print("DEBUG: Executed HFT scalping buy on \(exchange.capitalized) for \(pair) at \(spotPrice)")
                    await MainActor.run {
                        logAlert(event: "Executed HFT scalping buy on \(exchange.capitalized) for \(pair) at \(spotPrice)")
                    }
                }
            } else if sellSignal && isBalanceSufficient && sentiment < 0.0 {
                let predictedSpread = await fetchSpreadPrediction(pair: pair, exchange: exchange, spotPrice: spotPrice, futuresPrice: spotPrice) ?? 0.0
                await MainActor.run {
                    print("DEBUG: Predicted spread for \(exchange.capitalized) \(pair): \(predictedSpread)")
                    logHistoricalTradeToCSV(pair: pair, strategy: "HFT-Scalping", profit: 0.0, fees: 0.0)
                }
                let success = await executeScalpingTrade(
                    pair: pair,
                    exchange: exchange,
                    entryPrice: spotPrice * (1 - scalpEntryThresholdValue),
                    targetPrice: spotPrice * (1 - scalpProfitTargetValue),
                    stopPrice: spotPrice * (1 + scalpStopLossValue),
                    tradeAmount: tradeAmount,
                    maxActiveTrades: maxActiveSpotTradesValue
                )
                if success {
                    await MainActor.run {
                        activeSpotTrades[pair] = (activeSpotTrades[pair] ?? 0) + 1
                        if exchange == "kucoin" {
                            kucoinInSpotTrade[pair] = true
                            kucoinSpotEntryPrice[pair] = spotPrice
                        } else {
                            bybitInSpotTrade[pair] = true
                            bybitSpotEntryPrice[pair] = spotPrice
                        }
                    }
                    print("DEBUG: Executed HFT scalping sell on \(exchange.capitalized) for \(pair) at \(spotPrice)")
                    await MainActor.run {
                        logAlert(event: "Executed HFT scalping sell on \(exchange.capitalized) for \(pair) at \(spotPrice)")
                    }
                }
            }
        }

        Task {
            while true {
                await withTaskGroup(of: Void.self) { group in
                    let tradingPairsValue = await MainActor.run { localTradingPairs }
                    for pair in tradingPairsValue {
                        group.addTask {
                            let marketData = await fetchMarketData(pair: pair)
                            guard await checkTradeConditions(
                                pair: pair,
                                kucoinSpotPrice: marketData.kucoinSpotPrice,
                                bybitSpotPrice: marketData.bybitSpotPrice,
                                kucoinSpotPrices: marketData.kucoinSpotPrices,
                                bybitSpotPrices: marketData.bybitSpotPrices,
                                kucoinVolumes: marketData.kucoinVolumes,
                                bybitVolumes: marketData.bybitVolumes,
                                kucoinEvents: marketData.kucoinEvents,
                                bybitEvents: marketData.bybitEvents,
                                activeTrades: marketData.activeTrades
                            ) else {
                                return
                            }

                            let indicators = await calculateIndicators(
                                kucoinSpotPrices: marketData.kucoinSpotPrices,
                                bybitSpotPrices: marketData.bybitSpotPrices
                            )

                            if marketData.kucoinSpotPrice > 0 && marketData.bybitSpotPrice > 0 {
                                let spread = abs(marketData.kucoinSpotPrice - marketData.bybitSpotPrice) / min(marketData.kucoinSpotPrice, marketData.bybitSpotPrice)
                                let predictedSpread = await fetchSpreadPrediction(pair: pair, exchange: "kucoin", spotPrice: marketData.kucoinSpotPrice, futuresPrice: marketData.bybitSpotPrice) ?? 0.0
                                await MainActor.run {
                                    saveHistoricalSpreadsToCSV(pair: pair, spread: spread, predictedSpreadChange: predictedSpread)
                                }
                            } else {
                                print("DEBUG: Skipping spread logging for \(pair) due to invalid prices: KuCoin=\(marketData.kucoinSpotPrice), Bybit=\(marketData.bybitSpotPrice)")
                                await MainActor.run {
                                    logAlert(event: "Skipping spread logging for \(pair) due to invalid prices: KuCoin=\(marketData.kucoinSpotPrice), Bybit=\(marketData.bybitSpotPrice)")
                                }
                            }

                            let spotRsiLowerThresholdValue = await MainActor.run { spotRsiLowerThreshold }
                            let spotRsiUpperThresholdValue = await MainActor.run { spotRsiUpperThreshold }
                            let macdConfirmationThresholdValue = await MainActor.run { macdConfirmationThreshold }

                            let kucoinBuySignal = indicators.kucoinSpotEmaShort > indicators.kucoinSpotEmaLong &&
                                                  indicators.kucoinSpotRsi < spotRsiLowerThresholdValue &&
                                                  indicators.kucoinMacd.histogram > macdConfirmationThresholdValue
                            let kucoinSellSignal = indicators.kucoinSpotEmaShort < indicators.kucoinSpotEmaLong &&
                                                   indicators.kucoinSpotRsi > spotRsiUpperThresholdValue &&
                                                   indicators.kucoinMacd.histogram < -macdConfirmationThresholdValue
                            let bybitBuySignal = indicators.bybitSpotEmaShort > indicators.bybitSpotEmaLong &&
                                                 indicators.bybitSpotRsi < spotRsiLowerThresholdValue &&
                                                 indicators.bybitMacd.histogram > macdConfirmationThresholdValue
                            let bybitSellSignal = indicators.bybitSpotEmaShort < indicators.bybitSpotEmaLong &&
                                                  indicators.bybitSpotRsi > spotRsiUpperThresholdValue &&
                                                  indicators.bybitMacd.histogram < -macdConfirmationThresholdValue

                            let kucoinBalanceLocal = await MainActor.run { kucoinBalance }
                            let bybitBalanceLocal = await MainActor.run { bybitBalance }

                            let kucoinVolatility: Double
                            if marketData.kucoinSpotPrices.count >= 2 {
                                let returns = zip(marketData.kucoinSpotPrices.dropFirst(), marketData.kucoinSpotPrices).map { log($0 / $1) }
                                let mean = returns.reduce(0.0, +) / Double(returns.count)
                                let variance = returns.reduce(0.0) { $0 + pow($1 - mean, 2) } / Double(returns.count)
                                kucoinVolatility = sqrt(variance)
                            } else {
                                kucoinVolatility = 0.01
                            }
                            let kucoinTradeAmount = await dynamicTradeAmount(balance: kucoinBalanceLocal, riskPercent: tradeAmountPercentage, volatility: kucoinVolatility)

                            let bybitVolatility: Double
                            if marketData.bybitSpotPrices.count >= 2 {
                                let returns = zip(marketData.bybitSpotPrices.dropFirst(), marketData.bybitSpotPrices).map { log($0 / $1) }
                                let mean = returns.reduce(0.0, +) / Double(returns.count)
                                let variance = returns.reduce(0.0) { $0 + pow($1 - mean, 2) } / Double(returns.count)
                                bybitVolatility = sqrt(variance)
                            } else {
                                bybitVolatility = 0.01
                            }
                            let bybitTradeAmount = await dynamicTradeAmount(balance: bybitBalanceLocal, riskPercent: tradeAmountPercentage, volatility: bybitVolatility)

                            let isBalanceSufficientKucoin = kucoinBalanceLocal >= kucoinTradeAmount * marketData.kucoinSpotPrice
                            let isWithinLossLimitKucoin = await checkDailyLossLimit(exchange: "kucoin", pair: pair, potentialLoss: kucoinTradeAmount * marketData.kucoinSpotPrice * spotStopLossPercentage)
                            await executeTrade(
                                exchange: "kucoin",
                                pair: pair,
                                spotPrice: marketData.kucoinSpotPrice,
                                tradeAmount: kucoinTradeAmount,
                                buySignal: kucoinBuySignal,
                                sellSignal: kucoinSellSignal,
                                sentiment: marketData.sentiment,
                                isBalanceSufficient: isBalanceSufficientKucoin,
                                isWithinLossLimit: isWithinLossLimitKucoin,
                                maxActiveSpotTradesValue: await MainActor.run { maxActiveSpotTrades }
                            )

                            let isBalanceSufficientBybit = bybitBalanceLocal >= bybitTradeAmount * marketData.bybitSpotPrice
                            let isWithinLossLimitBybit = await checkDailyLossLimit(exchange: "bybit", pair: pair, potentialLoss: bybitTradeAmount * marketData.bybitSpotPrice * spotStopLossPercentage)
                            await executeTrade(
                                exchange: "bybit",
                                pair: pair,
                                spotPrice: marketData.bybitSpotPrice,
                                tradeAmount: bybitTradeAmount,
                                buySignal: bybitBuySignal,
                                sellSignal: bybitSellSignal,
                                sentiment: marketData.sentiment,
                                isBalanceSufficient: isBalanceSufficientBybit,
                                isWithinLossLimit: isWithinLossLimitBybit,
                                maxActiveSpotTradesValue: await MainActor.run { maxActiveSpotTrades }
                            )
                        }
                    }
                }
                try? await Task.sleep(nanoseconds: UInt64(getDouble("HFT_CHECK_INTERVAL_SECONDS", defaultValue: 0.5) * 1_000_000_000))
            }
        }
    }
}


//--------------------------------------------------------------------------------------------------------------Block 19 - Machine Learning Prediction Engine


import Foundation // Added for String.Encoding and other Foundation types


extension ExchangeWebSocket {
    @MainActor static var kucoinRunningProfitLoss: Double = 0.0
    @MainActor static var bybitRunningProfitLoss: Double = 0.0
    static var hftLastTradeTime: [String: (exchange: String, timestamp: Date)] = [:]

    static func evaluateHFTStrategy(pair: String, kucoinSpotRsi: Double, bybitSpotRsi: Double) async {
        let kucoinSpotPrice = await MainActor.run(body: { kucoinCurrentPrice[pair] }) ?? 0.0
        let bybitSpotPrice = await MainActor.run(body: { bybitCurrentPrice[pair] }) ?? 0.0
        let kucoinSpotPrices = await MainActor.run(body: { kucoinPrices[pair] }) ?? []
        let bybitSpotPrices = await MainActor.run(body: { bybitPrices[pair] }) ?? []
        let kucoinBalanceValue = kucoinBalance
        let kucoinRunningProfitLossValue = kucoinRunningProfitLoss
        let bybitBalanceValue = bybitBalance
        let bybitRunningProfitLossValue = bybitRunningProfitLoss
        let kucoinLastTrade = await MainActor.run(body: { hftLastTradeTime["kucoin_\(pair)"] })
        let bybitLastTrade = await MainActor.run(body: { hftLastTradeTime["bybit_\(pair)"] })
        let scalpEntryThreshold: Double = getDouble("SCALP_ENTRY_THRESHOLD", defaultValue: 0.0006)
        let scalpExitThreshold: Double = getDouble("SCALP_PROFIT_TARGET", defaultValue: 0.0012)
        let rsiOverboughtThreshold: Double = getDouble("SPOT_RSI_UPPER_THRESHOLD", defaultValue: 70.0)
        let rsiOversoldThreshold: Double = getDouble("SPOT_RSI_LOWER_THRESHOLD", defaultValue: 30.0)

        func executeHFTTrade(exchange: String, price: Double, prices: [Double], balance: Double, runningProfitLoss: Double, rsi: Double) async -> (newBalance: Double, newRunningProfitLoss: Double) {
            var balanceLocal = balance
            var runningProfitLossLocal = runningProfitLoss
            let priceChange = prices.count >= 2 ? (price - prices[prices.count - 2]) / prices[prices.count - 2] : 0.0
            let kellySize = await calculateKellyCriterion(pair: pair)
            let baseTradeAmount = min(balanceLocal * getDouble("HFT_MAX_BALANCE_PERCENTAGE", defaultValue: 0.3), getDouble("HFT_TRADE_AMOUNT", defaultValue: 100.0))
            let targetNetProfit = getDouble("TARGET_NET_PROFIT", defaultValue: 0.20)
            let makerFee = exchange == "kucoin" ? kucoinMakerFee : bybitMakerFee
            let takerFee = exchange == "kucoin" ? kucoinTakerFee : bybitTakerFee
            let orderType = environment["HFT_ORDER_TYPE"]?.lowercased() ?? "market"
            let feeRate = orderType == "limit" ? makerFee : takerFee
            let minPriceMove = scalpExitThreshold + (feeRate * 2)
            let tradeAmount = targetNetProfit / minPriceMove * price * kellySize
            let trailingStopPercentage = getDouble("HFT_TRAILING_STOP_PERCENTAGE", defaultValue: 0.03)

            guard tradeAmount <= baseTradeAmount else {
                print("DEBUG: Trade amount exceeds base trade amount for \(exchange)-\(pair): TradeAmount=\(tradeAmount), BaseTradeAmount=\(baseTradeAmount)")
                await MainActor.run(body: {
                    logAlert(event: "Trade amount exceeds base trade amount for \(exchange)-\(pair): TradeAmount=\(tradeAmount), BaseTradeAmount=\(baseTradeAmount)")
                })
                return (balanceLocal, runningProfitLossLocal)
            }

            guard balanceLocal >= tradeAmount * price else {
                print("DEBUG: Insufficient balance for \(exchange)-\(pair): Available \(balanceLocal), Required \(tradeAmount * price)")
                await MainActor.run(body: {
                    logAlert(event: "Insufficient balance for \(exchange)-\(pair): Available \(balanceLocal), Required \(tradeAmount * price)")
                })
                return (balanceLocal, runningProfitLossLocal)
            }

            guard let book = await MainActor.run(body: { exchange == "kucoin" ? kucoinOrderBooks[pair] : bybitOrderBooks[pair] }),
                  let entryPrice = book.bids.first?.price,
                  abs(price - entryPrice) / entryPrice < getDouble("MAX_SLIPPAGE", defaultValue: 0.005) else {
                print("DEBUG: HFT Trade skipped for \(exchange)-\(pair): Slippage too high or invalid order book")
                return (balanceLocal, runningProfitLossLocal)
            }

            if priceChange >= scalpEntryThreshold && tradeAmount > 0 && balanceLocal >= tradeAmount && rsi < rsiOverboughtThreshold && rsi >= rsiOversoldThreshold {
                let entryPrice = price
                var exitPrice: Double = 0.0
                let startTime = Date()

                while Date().timeIntervalSince(startTime) <= getDouble("HFT_MAX_TRADE_DURATION_SECONDS", defaultValue: 20.0) {
                    let currentPrice = await MainActor.run(body: { exchange == "kucoin" ? kucoinCurrentPrice[pair] : bybitCurrentPrice[pair] }) ?? entryPrice
                    if currentPrice > 0 {
                        let peakPrice = max(entryPrice, currentPrice)
                        let priceDiff = (currentPrice - entryPrice) / entryPrice
                        let dropFromPeak = (peakPrice - currentPrice) / peakPrice
                        if priceDiff >= scalpExitThreshold || priceDiff <= -getDouble("SCALP_STOP_LOSS", defaultValue: 0.0015) || dropFromPeak >= trailingStopPercentage {
                            exitPrice = currentPrice
                            break
                        }
                    }
                    try? await Task.sleep(nanoseconds: 50_000_000) // 50ms
                }

                if exitPrice == 0.0 {
                    exitPrice = await MainActor.run(body: { exchange == "kucoin" ? kucoinCurrentPrice[pair] : bybitCurrentPrice[pair] }) ?? entryPrice
                }

                let quantity = tradeAmount / entryPrice
                let grossProfit = (exitPrice - entryPrice) * quantity
                let fees = tradeAmount * feeRate * 2
                let feeBuffer = fees * 1.2
                let netProfit = grossProfit - fees

                if netProfit <= feeBuffer {
                    print("INFO: HFT Trade skipped for \(exchange)-\(pair): Net profit (\(netProfit)) does not exceed fee buffer (\(feeBuffer))")
                    return (balanceLocal, runningProfitLossLocal)
                }

                balanceLocal += netProfit
                runningProfitLossLocal += netProfit

                let isWin = netProfit > 0
                if var metrics = await MainActor.run(body: { tradeMetrics[pair] }) {
                    metrics.wins += isWin ? 1 : 0
                    metrics.losses += isWin ? 0 : 1
                    metrics.totalProfit += netProfit
                    metrics.totalFees += fees
                    await MainActor.run(body: { tradeMetrics[pair] = metrics })
                }
                if var perfMetrics = await MainActor.run(body: { performanceMetrics[pair] }) {
                    perfMetrics.trades += 1
                    perfMetrics.wins += isWin ? 1 : 0
                    perfMetrics.profit += netProfit
                    perfMetrics.fees += fees
                    await MainActor.run(body: { performanceMetrics[pair] = perfMetrics })
                }

                print("INFO: \(exchange.capitalized) HFT Trade for \(pair): Type: Scalp, Amount: \(tradeAmount) USDT, Entry: \(entryPrice), Exit: \(exitPrice), Gross Profit: \(grossProfit), Fees: \(fees), Net Profit: \(netProfit), Running P/L: \(runningProfitLossLocal), Balance: \(balanceLocal)")
                
                await MainActor.run(body: { hftLastTradeTime["\(exchange)_\(pair)"] = (exchange, Date()) })
                ExchangeWebSocket.sendTradeToFlaskServer(
                    strategy: "HFT-Scalp",
                    pair: pair,
                    exchange: exchange,
                    spotPrice: entryPrice,
                    futuresPrice: exitPrice,
                    tradeAmount: tradeAmount,
                    profit: netProfit
                )

                let timestamp = ISO8601DateFormatter().string(from: Date())
                let logEntry = "\(timestamp),HFT-Scalp,\(pair),\(exchange),\(entryPrice),\(exitPrice),\(tradeAmount),\(netProfit),\(fees)\n"
                let tradesCSVURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trade_log.csv")
                do {
                    let fileManager = FileManager.default
                    let directoryURL = tradesCSVURL.deletingLastPathComponent()
                    if !fileManager.fileExists(atPath: directoryURL.path) {
                        try fileManager.createDirectory(at: directoryURL, withIntermediateDirectories: true)
                    }
                    if !fileManager.fileExists(atPath: tradesCSVURL.path) {
                        let header = "timestamp,strategy,pair,exchange,entry_price,exit_price,trade_amount,net_profit,fees\n"
                        try header.write(to: tradesCSVURL, atomically: true, encoding: .utf8)
                    }
                    if let fileHandle = try? FileHandle(forWritingTo: tradesCSVURL) {
                        defer { fileHandle.closeFile() }
                        if let data = logEntry.data(using: .utf8) {
                            fileHandle.seekToEndOfFile()
                            fileHandle.write(data)
                        }
                    } else {
                        let existingContent = (try? String(contentsOf: tradesCSVURL, encoding: .utf8)) ?? ""
                        let newContent = existingContent + logEntry
                        try newContent.write(to: tradesCSVURL, atomically: true, encoding: .utf8)
                    }
                } catch {
                    print("DEBUG: Failed to log trade to CSV: \(error.localizedDescription)")
                    await MainActor.run(body: {
                        logAlert(event: "Failed to log trade to CSV: \(error.localizedDescription)")
                    })
                }
            }
            return (balanceLocal, runningProfitLossLocal)
        }

        if let lastKucoinTrade = kucoinLastTrade, lastKucoinTrade.exchange == "kucoin" {
            let timeSinceLastTrade = Date().timeIntervalSince(lastKucoinTrade.timestamp)
            if timeSinceLastTrade < hftCooldownSeconds {
                print("INFO: KuCoin HFT on cooldown for \(pair): \(Int(hftCooldownSeconds - timeSinceLastTrade)) seconds remaining")
            } else {
                if kucoinSpotPrice > 0 && kucoinSpotPrices.count >= spotEmaShortPeriod {
                    let (newKucoinBalance, newKucoinRunningProfitLoss) = await executeHFTTrade(
                        exchange: "kucoin",
                        price: kucoinSpotPrice,
                        prices: kucoinSpotPrices,
                        balance: kucoinBalanceValue,
                        runningProfitLoss: kucoinRunningProfitLossValue,
                        rsi: kucoinSpotRsi
                    )
                    kucoinBalance = newKucoinBalance
                    kucoinRunningProfitLoss = newKucoinRunningProfitLoss
                }
            }
        } else {
            if kucoinSpotPrice > 0 && kucoinSpotPrices.count >= spotEmaShortPeriod {
                let (newKucoinBalance, newKucoinRunningProfitLoss) = await executeHFTTrade(
                    exchange: "kucoin",
                    price: kucoinSpotPrice,
                    prices: kucoinSpotPrices,
                    balance: kucoinBalanceValue,
                    runningProfitLoss: kucoinRunningProfitLossValue,
                    rsi: kucoinSpotRsi
                )
                kucoinBalance = newKucoinBalance
                kucoinRunningProfitLoss = newKucoinRunningProfitLoss
            }
        }

        if let lastBybitTrade = bybitLastTrade, lastBybitTrade.exchange == "bybit" {
            let timeSinceLastTrade = Date().timeIntervalSince(lastBybitTrade.timestamp)
            if timeSinceLastTrade < hftCooldownSeconds {
                print("INFO: Bybit HFT on cooldown for \(pair): \(Int(hftCooldownSeconds - timeSinceLastTrade)) seconds remaining")
            } else {
                if bybitSpotPrice > 0 && bybitSpotPrices.count >= spotEmaShortPeriod {
                    let (newBybitBalance, newBybitRunningProfitLoss) = await executeHFTTrade(
                        exchange: "bybit",
                        price: bybitSpotPrice,
                        prices: bybitSpotPrices,
                        balance: bybitBalanceValue,
                        runningProfitLoss: bybitRunningProfitLossValue,
                        rsi: bybitSpotRsi
                    )
                    bybitBalance = newBybitBalance
                    bybitRunningProfitLoss = newBybitRunningProfitLoss
                }
            }
        } else {
            if bybitSpotPrice > 0 && bybitSpotPrices.count >= spotEmaShortPeriod {
                let (newBybitBalance, newBybitRunningProfitLoss) = await executeHFTTrade(
                    exchange: "bybit",
                    price: bybitSpotPrice,
                    prices: bybitSpotPrices,
                    balance: bybitBalanceValue,
                    runningProfitLoss: bybitRunningProfitLossValue,
                    rsi: bybitSpotRsi
                )
                bybitBalance = newBybitBalance
                bybitRunningProfitLoss = newBybitRunningProfitLoss
            }
        }
    }

    static func evaluateFundingRateMomentum(pair: String, kucoinFundingRate: Double, bybitFundingRate: Double) async {
        let fundingMomentumThreshold = getDouble("FUNDING_MOMENTUM_THRESHOLD", defaultValue: 0.00008)
        let tradeAmount = getDouble("FUTURES_TRADE_AMOUNT", defaultValue: 150.0)
        let kucoinFuturesPrice = await MainActor.run(body: { kucoinCurrentFuturesPrice[pair] }) ?? 0.0
        let bybitFuturesPrice = await MainActor.run(body: { bybitCurrentFuturesPrice[pair] }) ?? 0.0

        if kucoinFundingRate > fundingMomentumThreshold && kucoinFuturesPrice > 0 {
            let tradeAmount = min(tradeAmount, kucoinBalance)
            if tradeAmount > 0 && kucoinBalance >= tradeAmount {
                print("INFO: KuCoin Funding Rate Momentum Trade for \(pair): Long, Amount: \(tradeAmount), Funding Rate: \(kucoinFundingRate)")
                kucoinBalance -= tradeAmount * kucoinFuturesPrice * futuresStopLossPercentage
            }
        }

        if bybitFundingRate > fundingMomentumThreshold && bybitFuturesPrice > 0 {
            let tradeAmount = min(tradeAmount, bybitBalance)
            if tradeAmount > 0 && bybitBalance >= tradeAmount {
                print("INFO: Bybit Funding Rate Momentum Trade for \(pair): Long, Amount: \(tradeAmount), Target Profit: \(spoofingProfitTarget)")
                bybitBalance += tradeAmount * spoofingProfitTarget
            }
        }
    }

    static func spoofLiquidity(pair: String, kucoinOrderBook: [[String: Any]], bybitOrderBook: [[String: Any]]) async {
        let spoofingVolumeThreshold = getDouble("SPOOFING_VOLUME_THRESHOLD", defaultValue: 1.5)
        let spoofingProfitTarget = getDouble("SPOOFING_PROFIT_TARGET", defaultValue: 0.008)

        let kucoinVolume = kucoinOrderBook.reduce(0.0) { $0 + ($1["volume"] as? Double ?? 0.0) }
        let bybitVolume = bybitOrderBook.reduce(0.0) { $0 + ($1["volume"] as? Double ?? 0.0) }

        if kucoinVolume > spoofingVolumeThreshold {
            let tradeAmount = min(kucoinBalance * 0.1, getDouble("SLIPPAGE_TRADE_AMOUNT", defaultValue: 100.0))
            if tradeAmount > 0 && kucoinBalance >= tradeAmount {
                print("INFO: KuCoin Spoofing Liquidity Trade for \(pair): Amount: \(tradeAmount), Target Profit: \(spoofingProfitTarget)")
                kucoinBalance += tradeAmount * spoofingProfitTarget
            }
        }

        if bybitVolume > spoofingVolumeThreshold {
            let tradeAmount = min(bybitBalance * 0.1, getDouble("SLIPPAGE_TRADE_AMOUNT", defaultValue: 100.0))
            if tradeAmount > 0 && bybitBalance >= tradeAmount {
                print("INFO: Bybit Spoofing Liquidity Trade for \(pair): Amount: \(tradeAmount), Target Profit: \(spoofingProfitTarget)")
                bybitBalance += tradeAmount * spoofingProfitTarget
            }
        }
    }

    static func optimizeTradeLatency(pair: String) async {
        let latencySpikeThreshold = getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 80.0)
        let latency = await measureTradeExecutionLatency()
        if latency > latencySpikeThreshold {
            print("INFO: Latency spike detected for \(pair): \(latency)ms. Optimizing trade execution...")
            await MainActor.run {
                logAlert(event: "High latency detected for trade execution for \(pair): \(latency)ms")
            }
            try? await Task.sleep(nanoseconds: 100_000_000) // 100ms
        }
    }

    static func measureTradeExecutionLatency() async -> Double {
        let start = Date()
        try? await Task.sleep(nanoseconds: 10_000_000) // 10ms
        return Date().timeIntervalSince(start) * 1000
    }

    static func sendTradeToFlaskServer(strategy: String, pair: String, exchange: String, spotPrice: Double, futuresPrice: Double, tradeAmount: Double, profit: Double) {
        let flaskUrl = URL(string: environment["FLASK_SERVER_URL"] ?? "http://localhost:5001/log_trade")!
        var request = URLRequest(url: flaskUrl)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.timeoutInterval = 10.0
        
        let tradeData: [String: Any] = [
            "strategy": strategy,
            "pair": pair,
            "exchange": exchange,
            "spot_price": spotPrice,
            "futures_price": futuresPrice,
            "trade_amount": tradeAmount,
            "profit": profit,
            "timestamp": ISO8601DateFormatter().string(from: Date())
        ]
        
        do {
            request.httpBody = try JSONSerialization.data(withJSONObject: tradeData)
        } catch {
            print("DEBUG: Failed to serialize trade data for Flask server: \(error.localizedDescription)")
            Task { @MainActor in
                logAlert(event: "Failed to serialize trade data for Flask server: \(error.localizedDescription)")
            }
            return
        }
        
        let startTime = Date()
        URLSession.shared.dataTask(with: request) { data, response, error in
            let latency = Date().timeIntervalSince(startTime) * 1000
            Task { @MainActor in
                lastLatency["flask-trade-log"] = latency
                if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 80.0) {
                    logAlert(event: "High latency detected for Flask trade log: \(latency)ms")
                }
                if let error = error {
                    logAlert(event: "Failed to send trade to Flask server: \(error.localizedDescription)")
                }
            }
        }.resume()
    }
}



//-------------------------------------------------------------------------------------------------------------------------Block 20 - API Data Retrieval and Authentication

//--------------- Block 20 - API Data Retrieval and Authentication
// VARIABLES TO ADD: Fixed redeclaration issues and Sendable conformance problems

import CryptoKit
import Foundation

extension Data {
    func hmac(key: String) -> String {
        let keyData = key.data(using: .utf8)!
        let signature = HMAC<SHA256>.authenticationCode(for: self, using: SymmetricKey(data: keyData))
        return Data(signature).base64EncodedString()
    }
}

// Extension for Block 20 API Interactions and Authentication
extension ExchangeWebSocket {
    static func fetchBalance(exchange: String) async {
        let _ = getInt("BALANCE_FETCH_TIMEOUT", defaultValue: 20)
        let maxRetries = getInt("API_MAX_RETRIES", defaultValue: 5)
        var retries = 0

        while retries < maxRetries {
            let startTime = Date()
            do {
                if exchange == "kucoin" {
                    let balance = try await fetchKuCoinBalance()
                    await MainActor.run {
                        kucoinLiveBalance = balance
                        kucoinBalance = balance ?? kucoinFallbackBalance
                        print("DEBUG: Fetched KuCoin balance: \(kucoinBalance) USDT")
                    }
                    break
                } else if exchange == "bybit" {
                    let balance = try await fetchBybitBalance()
                    await MainActor.run {
                        bybitLiveBalance = balance
                        bybitBalance = balance ?? bybitFallbackBalance
                        print("DEBUG: Fetched Bybit balance: \(bybitBalance) USDT")
                    }
                    break
                }
            } catch {
                retries += 1
                let latency = Date().timeIntervalSince(startTime) * 1000
                await MainActor.run {
                    logAlert(event: "Failed to fetch \(exchange) balance: \(error.localizedDescription), retry \(retries)/\(maxRetries), latency: \(latency)ms")
                }
                if retries == maxRetries {
                    await MainActor.run {
                        logAlert(event: "Max retries reached for \(exchange) balance fetch")
                        if exchange == "kucoin" {
                            kucoinBalance = kucoinFallbackBalance
                        } else {
                            bybitBalance = bybitFallbackBalance
                        }
                    }
                }
                try? await Task.sleep(nanoseconds: UInt64(1_000_000_000)) // 1-second delay
            }
        }
    }

    static func fetchKuCoinBalance() async throws -> Double? {
        // DEBUG: Log function start
        await MainActor.run {
            logAlert(event: " DEBUG: fetchKuCoinBalance() function started")
            logAlert(event: " DEBUG: KuCoin API Key exists: \(environment["KUCOIN_API_KEY"] != nil)")
            logAlert(event: " DEBUG: KuCoin API Secret exists: \(environment["KUCOIN_API_SECRET"] != nil)")
            logAlert(event: " DEBUG: KuCoin Passphrase exists: \(environment["KUCOIN_API_PASSPHRASE"] != nil)")
        }
        
        guard let apiKey = environment["KUCOIN_API_KEY"],
              let apiSecret = environment["KUCOIN_API_SECRET"],
              let apiPassphrase = environment["KUCOIN_API_PASSPHRASE"] else {
            await MainActor.run {
                logAlert(event: " ERROR: Missing KuCoin API credentials")
            }
            throw NSError(domain: "KuCoinAPI", code: -1, userInfo: [NSLocalizedDescriptionKey: "Missing API credentials"])
        }
        
        let url = URL(string: "https://api.kucoin.com/api/v1/accounts?currency=USDT&type=trade")!
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = Double(getInt("BALANCE_FETCH_TIMEOUT", defaultValue: 20))

        let timestamp = String(Int(Date().timeIntervalSince1970 * 1000))
        let endpoint = "/api/v1/accounts?currency=USDT&type=trade"
        let method = "GET"
        let body = "" // Empty body for GET request
        let strToSign = timestamp + method + endpoint + body
        
        await MainActor.run {
            logAlert(event: " DEBUG: KuCoin signing string: \(strToSign)")
        }
        
        let signature = strToSign.data(using: .utf8)!.hmac(key: apiSecret)
        
        // For API v2.0+: Encrypt passphrase with HMAC-SHA256 using API secret, then base64 encode
        let encryptedPassphrase = apiPassphrase.data(using: .utf8)!.hmac(key: apiSecret)

        // Set headers for API v2.0+
        request.addValue(apiKey, forHTTPHeaderField: "KC-API-KEY")
        request.addValue(signature, forHTTPHeaderField: "KC-API-SIGN")
        request.addValue(timestamp, forHTTPHeaderField: "KC-API-TIMESTAMP")
        request.addValue(encryptedPassphrase, forHTTPHeaderField: "KC-API-PASSPHRASE")
        request.addValue("2", forHTTPHeaderField: "KC-API-KEY-VERSION") // Critical: API version 2
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")

        await MainActor.run {
            logAlert(event: " DEBUG: KuCoin request headers set, making API call...")
        }

        let (data, response) = try await URLSession.shared.data(for: request)
        guard let httpResponse = response as? HTTPURLResponse else {
            await MainActor.run {
                logAlert(event: " ERROR: Non-HTTP response for KuCoin balance fetch")
            }
            throw NSError(domain: "KuCoinAPI", code: -1, userInfo: [NSLocalizedDescriptionKey: "Non-HTTP response"])
        }
        
        let responseBody = String(data: data, encoding: .utf8) ?? "Invalid data"
        await MainActor.run {
            logAlert(event: " DEBUG: KuCoin response status: \(httpResponse.statusCode)")
            logAlert(event: " DEBUG: KuCoin response: \(responseBody)")
        }
        
        if httpResponse.statusCode != 200 {
            await MainActor.run {
                logAlert(event: " ERROR: Invalid KuCoin response status \(httpResponse.statusCode): \(responseBody)")
            }
            throw NSError(domain: "KuCoinAPI", code: httpResponse.statusCode, userInfo: [NSLocalizedDescriptionKey: "HTTP \(httpResponse.statusCode)"])
        }

        let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
        guard let code = json?["code"] as? String else {
            await MainActor.run {
                logAlert(event: " ERROR: KuCoin response missing code field")
            }
            return nil
        }
        guard code == "200000" else {
            let errorMsg = json?["msg"] as? String ?? "Unknown error"
            await MainActor.run {
                logAlert(event: " ERROR: KuCoin API error code \(code): \(errorMsg)")
            }
            return nil
        }
        guard let dataJson = json?["data"] as? [[String: Any]] else {
            await MainActor.run {
                logAlert(event: " ERROR: KuCoin response missing data array")
            }
            return nil
        }
        
        await MainActor.run {
            logAlert(event: " DEBUG: KuCoin found \(dataJson.count) accounts")
        }
        
        let balance = dataJson.reduce(0.0) { sum, account in
            if (account["type"] as? String) == "trade" && (account["currency"] as? String) == "USDT",
               let availableStr = account["available"] as? String,
               let available = Double(availableStr) {
                return sum + available
            }
            return sum
        }
        
        if balance == 0.0 {
            await MainActor.run {
                logAlert(event: " WARNING: KuCoin USDT trade account has zero balance")
            }
        }

        await MainActor.run {
            logAlert(event: " SUCCESS: KuCoin balance parsed: \(balance) USDT")
        }

        return balance
    }

    static func fetchBybitBalance() async throws -> Double? {
        // DEBUG: Log function start
        await MainActor.run {
            logAlert(event: " DEBUG: fetchBybitBalance() function started")
            logAlert(event: " DEBUG: Bybit API Key exists: \(environment["BYBIT_API_KEY"] != nil)")
            logAlert(event: " DEBUG: Bybit API Secret exists: \(environment["BYBIT_API_SECRET"] != nil)")
        }
        
        guard let apiKey = environment["BYBIT_API_KEY"],
              let apiSecret = environment["BYBIT_API_SECRET"] else {
            await MainActor.run {
                logAlert(event: " ERROR: Missing Bybit API credentials")
            }
            throw NSError(domain: "BybitAPI", code: -1, userInfo: [NSLocalizedDescriptionKey: "Missing API credentials"])
        }
        
        let url = URL(string: "https://api.bybit.com/v5/account/wallet-balance?accountType=UNIFIED&coin=USDT")!
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = Double(getInt("BALANCE_FETCH_TIMEOUT", defaultValue: 20))

        let timestamp = String(Int(Date().timeIntervalSince1970 * 1000))
        let recvWindow = environment["BYBIT_RECV_WINDOW"] ?? "5000"
        let queryString = "accountType=UNIFIED&coin=USDT"
        let paramStr = timestamp + apiKey + recvWindow + queryString
        
        await MainActor.run {
            logAlert(event: " DEBUG: Bybit signing string: \(paramStr)")
        }
        
        let signature = paramStr.data(using: .utf8)!.hmac(key: apiSecret)

        request.addValue(apiKey, forHTTPHeaderField: "X-BAPI-API-KEY")
        request.addValue(timestamp, forHTTPHeaderField: "X-BAPI-TIMESTAMP")
        request.addValue(recvWindow, forHTTPHeaderField: "X-BAPI-RECV-WINDOW")
        request.addValue(signature, forHTTPHeaderField: "X-BAPI-SIGN")
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")

        await MainActor.run {
            logAlert(event: " DEBUG: Bybit request headers set, making API call...")
        }

        let (data, response) = try await URLSession.shared.data(for: request)
        guard let httpResponse = response as? HTTPURLResponse else {
            await MainActor.run {
                logAlert(event: " ERROR: Non-HTTP response for Bybit balance fetch")
            }
            throw NSError(domain: "BybitAPI", code: -1, userInfo: [NSLocalizedDescriptionKey: "Non-HTTP response"])
        }
        
        let responseBody = String(data: data, encoding: .utf8) ?? "Invalid data"
        await MainActor.run {
            logAlert(event: " DEBUG: Bybit response status: \(httpResponse.statusCode)")
            logAlert(event: " DEBUG: Bybit response: \(responseBody)")
        }
        
        if httpResponse.statusCode != 200 {
            await MainActor.run {
                logAlert(event: " ERROR: Invalid Bybit response status \(httpResponse.statusCode): \(responseBody)")
            }
            throw NSError(domain: "BybitAPI", code: httpResponse.statusCode, userInfo: [NSLocalizedDescriptionKey: "HTTP \(httpResponse.statusCode)"])
        }

        let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
        guard let retCode = json?["retCode"] as? Int else {
            await MainActor.run {
                logAlert(event: " ERROR: Bybit response missing retCode")
            }
            return nil
        }
        guard retCode == 0 else {
            let retMsg = json?["retMsg"] as? String ?? "Unknown error"
            await MainActor.run {
                logAlert(event: " ERROR: Bybit API error code \(retCode): \(retMsg)")
            }
            return nil
        }
        guard let result = json?["result"] as? [String: Any],
              let list = result["list"] as? [[String: Any]] else {
            await MainActor.run {
                logAlert(event: " ERROR: Bybit response missing result.list")
            }
            return nil
        }
        
        await MainActor.run {
            logAlert(event: " DEBUG: Bybit found \(list.count) accounts")
        }
        
        var balance = 0.0
        for account in list {
            if let coinList = account["coin"] as? [[String: Any]] {
                if let usdt = coinList.first(where: { ($0["coin"] as? String) == "USDT" }),
                   let walletBalanceStr = usdt["walletBalance"] as? String,
                   let walletBalance = Double(walletBalanceStr) {
                    balance += walletBalance
                }
            }
        }
        
        if balance == 0.0 {
            await MainActor.run {
                logAlert(event: " WARNING: Bybit USDT account has zero balance")
            }
        }

        await MainActor.run {
            logAlert(event: " SUCCESS: Bybit balance parsed: \(balance) USDT")
        }

        return balance
    }

    static func fetchKuCoinOrderBook(pair: String, isFutures: Bool) async -> BevaixOrderBook? {
        // DEBUG: Log function start
        await MainActor.run {
            logAlert(event: " DEBUG: fetchKuCoinOrderBook() started for \(pair) (futures: \(isFutures))")
        }
        
        let symbol = isFutures ? pair.replacingOccurrences(of: "-", with: "") + "M" : pair
        let baseURL = isFutures ? "https://api-futures.kucoin.com" : "https://api.kucoin.com"
        let path = isFutures ? "/api/v1/level2/snapshot" : "/api/v3/market/orderbook/level2"
        var endpoint = path + "?symbol=\(symbol)"
        if !isFutures {
            endpoint += "&limit=100"
        }
        let urlString = baseURL + endpoint
        
        await MainActor.run {
            logAlert(event: " DEBUG: KuCoin orderbook URL: \(urlString)")
        }
        
        guard let url = URL(string: urlString) else {
            await MainActor.run {
                logAlert(event: " ERROR: Invalid KuCoin orderbook URL: \(urlString)")
            }
            return nil
        }
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = Double(getInt("BALANCE_FETCH_TIMEOUT", defaultValue: 20))

        // Only add authentication headers for futures
        if isFutures {
            guard let apiKey = environment["KUCOIN_API_KEY"],
                  let apiSecret = environment["KUCOIN_API_SECRET"],
                  let apiPassphrase = environment["KUCOIN_API_PASSPHRASE"] else {
                await MainActor.run {
                    logAlert(event: " ERROR: Missing KuCoin API credentials for futures")
                }
                return nil
            }
            
            let timestamp = String(Int(Date().timeIntervalSince1970 * 1000))
            let method = "GET"
            let body = ""
            let strToSign = timestamp + method + endpoint + body
            let signature = strToSign.data(using: .utf8)!.hmac(key: apiSecret)
            let encryptedPassphrase = apiPassphrase.data(using: .utf8)!.hmac(key: apiSecret)

            request.addValue(apiKey, forHTTPHeaderField: "KC-API-KEY")
            request.addValue(signature, forHTTPHeaderField: "KC-API-SIGN")
            request.addValue(timestamp, forHTTPHeaderField: "KC-API-TIMESTAMP")
            request.addValue(encryptedPassphrase, forHTTPHeaderField: "KC-API-PASSPHRASE")
            request.addValue("2", forHTTPHeaderField: "KC-API-KEY-VERSION")
            request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        }

        do {
            let (data, response) = try await URLSession.shared.data(for: request)
            guard let httpResponse = response as? HTTPURLResponse else {
                await MainActor.run {
                    logAlert(event: " ERROR: Non-HTTP response for KuCoin orderbook \(pair)")
                }
                return nil
            }
            let responseBody = String(data: data, encoding: .utf8) ?? "Invalid data"
            
            await MainActor.run {
                logAlert(event: " DEBUG: KuCoin orderbook response status: \(httpResponse.statusCode)")
                logAlert(event: " DEBUG: KuCoin orderbook response: \(responseBody)")
            }
            
            if httpResponse.statusCode != 200 {
                await MainActor.run {
                    logAlert(event: " ERROR: Invalid KuCoin orderbook status \(httpResponse.statusCode) for \(pair): \(responseBody)")
                }
                return nil
            }
            let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
            guard let code = json?["code"] as? String else {
                await MainActor.run {
                    logAlert(event: " ERROR: KuCoin orderbook response missing code for \(pair)")
                }
                return nil
            }
            guard code == "200000" else {
                let errorMsg = json?["msg"] as? String ?? "Unknown error"
                await MainActor.run {
                    logAlert(event: " ERROR: KuCoin orderbook API error for \(pair) - code: \(code), msg: \(errorMsg)")
                }
                return nil
            }
            guard let dataJson = json?["data"] as? [String: Any],
                  let bids = dataJson["bids"] as? [[String]],
                  let asks = dataJson["asks"] as? [[String]] else {
                await MainActor.run {
                    logAlert(event: " ERROR: KuCoin orderbook missing bids/asks for \(pair): \(responseBody)")
                }
                return nil
            }
            
            await MainActor.run {
                logAlert(event: " DEBUG: KuCoin orderbook raw bids: \(bids.count), asks: \(asks.count)")
            }
            
            let parsedBids = bids.compactMap { arr -> (Double, Double)? in
                guard arr.count >= 2, let price = Double(arr[0]), let qty = Double(arr[1]) else { return nil }
                return (price, qty)
            }
            let parsedAsks = asks.compactMap { arr -> (Double, Double)? in
                guard arr.count >= 2, let price = Double(arr[0]), let qty = Double(arr[1]) else { return nil }
                return (price, qty)
            }
            
            await MainActor.run {
                logAlert(event: " DEBUG: KuCoin orderbook parsed bids: \(parsedBids.count), asks: \(parsedAsks.count)")
            }
            
            if parsedBids.isEmpty || parsedAsks.isEmpty {
                await MainActor.run {
                    logAlert(event: " ERROR: KuCoin orderbook empty after parsing for \(pair)")
                }
                return nil
            }
            
            await MainActor.run {
                logAlert(event: " SUCCESS: KuCoin orderbook parsed for \(pair)")
            }
            
            return BevaixOrderBook(bids: parsedBids, asks: parsedAsks)
        } catch {
            await MainActor.run {
                logAlert(event: " ERROR: Failed to fetch KuCoin orderbook for \(pair): \(error.localizedDescription)")
            }
            return nil
        }
    }

    // FIX: Remove duplicate function declarations to resolve redeclaration errors
    // The original implementations of these functions should be defined elsewhere
    // Removed: checkCrossExchangeArbitrage, evaluateFundingRateMomentum, sendTradeToFlaskServer
    
    // Enhanced sentiment data fetching with retry logic for 404 errors
    static func updateSentimentData() async {
        for pair in tradingPairs {
            var retries = 0
            let maxRetries = 3
            
            while retries < maxRetries {
                let success = await withCheckedContinuation { continuation in
                    fetchSentimentScore(pair: pair) { score in
                        continuation.resume(returning: score != nil)
                    }
                }
                
                if success {
                    break
                } else {
                    retries += 1
                    if retries < maxRetries {
                        await MainActor.run {
                            logAlert(event: "Retrying sentiment fetch for \(pair), attempt \(retries + 1)/\(maxRetries)")
                        }
                        try? await Task.sleep(nanoseconds: UInt64(pow(2.0, Double(retries)) * 1_000_000_000))
                    } else {
                        await MainActor.run {
                            logAlert(event: "Failed to fetch sentiment for \(pair) after \(maxRetries) attempts, using default")
                            sentimentScores[pair] = 0.0
                        }
                    }
                }
            }
        }
    }

    // Enhanced funding rate momentum evaluation
    static func evaluateFundingRateMomentum(pair: String, kucoinFundingRate: Double, bybitFundingRate: Double) async {
        let fundingRateDiff = abs(kucoinFundingRate - bybitFundingRate)
        let threshold = getDouble("FUNDING_MOMENTUM_THRESHOLD", defaultValue: 0.00008)
        
        if fundingRateDiff > threshold {
            await MainActor.run {
                logAlert(event: "Funding rate momentum detected for \(pair): KuCoin=\(kucoinFundingRate), Bybit=\(bybitFundingRate), Diff=\(fundingRateDiff)")
            }
            
            // Add funding rate to history for momentum analysis
            await MainActor.run {
                kucoinFundingRateHistory[pair, default: []].append(kucoinFundingRate)
                bybitFundingRateHistory[pair, default: []].append(bybitFundingRate)
                
                // Keep only last 24 values (assuming hourly updates)
                if kucoinFundingRateHistory[pair]!.count > 24 {
                    kucoinFundingRateHistory[pair]?.removeFirst()
                }
                if bybitFundingRateHistory[pair]!.count > 24 {
                    bybitFundingRateHistory[pair]?.removeFirst()
                }
            }
        }
    }

    // Enhanced cross-exchange arbitrage checking
    static func checkCrossExchangeArbitrage(pair: String, strategy: String, amount: Double, completion: @escaping (Bool) -> Void) async {
        let kucoinPrice = await MainActor.run { kucoinCurrentPrice[pair] ?? 0.0 }
        let bybitPrice = await MainActor.run { bybitCurrentPrice[pair] ?? 0.0 }
        
        guard kucoinPrice > 0 && bybitPrice > 0 else {
            completion(false)
            return
        }
        
        let spread = abs(kucoinPrice - bybitPrice) / max(kucoinPrice, bybitPrice)
        let minSpread = getDouble("CROSS_EXCHANGE_MIN_SPREAD_THRESHOLD", defaultValue: 0.002)
        
        if spread >= minSpread {
            await MainActor.run {
                logAlert(event: "Cross-exchange arbitrage opportunity detected for \(pair): \(String(format: "%.4f", spread * 100))% spread")
            }
            
            // Check liquidity for both exchanges
            let kucoinLiquidity = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "spot", tradeAmount: amount, price: kucoinPrice)
            let bybitLiquidity = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "spot", tradeAmount: amount, price: bybitPrice)
            
            let minLiquidity = await MainActor.run { minLiquidityThreshold }
            if let kucoinLiq = kucoinLiquidity, let bybitLiq = bybitLiquidity,
               kucoinLiq >= minLiquidity && bybitLiq >= minLiquidity {
                completion(true)
            } else {
                await MainActor.run {
                    logAlert(event: "Insufficient liquidity for cross-exchange arbitrage: \(pair)")
                }
                completion(false)
            }
        } else {
            completion(false)
        }
    }

    // Enhanced API authentication with retry logic
    static func authenticateAPI() async throws {
        var kucoinAuthSuccess = false
        var bybitAuthSuccess = false
        
        // Test KuCoin authentication
        do {
            let _ = try await fetchKuCoinBalance()
            kucoinAuthSuccess = true
        } catch {
            await MainActor.run {
                logAlert(event: "KuCoin authentication failed: \(error.localizedDescription)")
            }
        }
        
        // Test Bybit authentication
        do {
            let _ = try await fetchBybitBalance()
            bybitAuthSuccess = true
        } catch {
            await MainActor.run {
                logAlert(event: "Bybit authentication failed: \(error.localizedDescription)")
            }
        }
        
        if !kucoinAuthSuccess && !bybitAuthSuccess {
            throw NSError(domain: "AuthenticationError", code: -1, userInfo: [NSLocalizedDescriptionKey: "Failed to authenticate with both exchanges"])
        }
        
        await MainActor.run {
            logAlert(event: "API Authentication completed - KuCoin: \(kucoinAuthSuccess), Bybit: \(bybitAuthSuccess)")
        }
    }
}
