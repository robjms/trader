//-------------------------------------------------------------------------------------------------------------------- Block 9A - Enhanced WebSocket Processing with Spot Price Support




// VARIABLES TO ADD: None - all existing variables preserved and enhanced
@MainActor
class ExchangeWebSocketDelegate: NSObject, WebSocketDelegate {
nonisolated func didReceive(event: WebSocketEvent, client: WebSocketClient) {
Task { @MainActor in
switch event {
case .connected(let headers):
ExchangeWebSocket.handleWebSocketConnected(client: client, headers: headers)
case .disconnected(let reason, let code):
ExchangeWebSocket.handleWebSocketDisconnected(client: client, reason: reason, code: code)
case .text(let string):
ExchangeWebSocket.handleWebSocketTextMessage(client: client, text: string)
case .binary(let data):
ExchangeWebSocket.handleWebSocketBinaryMessage(client: client, data: data)
case .error(let error):
ExchangeWebSocket.handleWebSocketError(client: client, error: error)
default:
break
}
}
}
}
@MainActor
class KuCoinSpotWebSocketDelegateEnhanced: WebSocketDelegate {
private var hasReceivedWelcome = false
nonisolated func didReceive(event: Starscream.WebSocketEvent, client: any Starscream.WebSocketClient) {
    Task { @MainActor in
        switch event {
        case .connected(let headers):
            print("üîó [KuCoin Spot] WebSocket connected: \(headers)")
            ExchangeWebSocket.logAlert(event: "üîó KuCoin Spot WebSocket connected, waiting for welcome...")
            self.hasReceivedWelcome = false
            
        case .disconnected(let reason, let code):
            ExchangeWebSocket.kucoinIsConnected = false
            self.hasReceivedWelcome = false
            print("‚ùå [KuCoin Spot] WebSocket disconnected: \(reason) (\(code))")
            ExchangeWebSocket.logAlert(event: "‚ùå KuCoin Spot WebSocket disconnected: \(reason)")
            
            // Auto-reconnect after delay with weak self
            DispatchQueue.main.asyncAfter(deadline: .now() + 30) { [weak self] in
                guard self != nil else { return }
                ExchangeWebSocket.connectToKuCoinSpotWebSocket()
            }
            
        case .text(let text):
            print("üîç Raw KuCoin Spot message: \(text)") // Debug: Log raw message to trace data receipt
            if let data = text.data(using: .utf8),
               let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                
                // STEP 1: Handle welcome message FIRST (CRITICAL)
                if let type = json["type"] as? String, type == "welcome" {
                    self.hasReceivedWelcome = true
                    ExchangeWebSocket.kucoinIsConnected = true
                    print("‚úÖ [KuCoin Spot] Welcome message received! Now subscribing...")
                    ExchangeWebSocket.logAlert(event: "‚úÖ KuCoin Spot welcome received, subscribing to pairs...")
                    
                    // STEP 2: Subscribe to all pairs AFTER welcome
                    for pair in ExchangeWebSocket.tradingPairs {
                        // CRITICAL FIX: Convert BTC-USDT to BTCUSDT for KuCoin API
                        let symbol = pair.replacingOccurrences(of: "-", with: "")
                        let subscriptionMessage = [
                            "id": UUID().uuidString,
                            "type": "subscribe",
                            "topic": "/market/ticker:\(symbol)",  // FIXED: Use BTCUSDT format for KuCoin API
                            "privateChannel": false,
                            "response": true
                        ] as [String : Any]
                        
                        if let data = try? JSONSerialization.data(withJSONObject: subscriptionMessage),
                           let jsonString = String(data: data, encoding: .utf8) {
                            client.write(string: jsonString)
                            print("üì° [KuCoin Spot] Subscribed to: \(symbol) (pair: \(pair))")
                        }
                    }
                    return
                }
                
                // STEP 3: Don't process other messages until welcome received
                guard self.hasReceivedWelcome else {
                    print("‚ö†Ô∏è [KuCoin Spot] Ignoring message - no welcome received yet: \(json["type"] as? String ?? "unknown")")
                    return
                }
                
                // Handle subscription confirmations
                if json["type"] as? String == "ack" {
                    print("‚úÖ KuCoin Spot WebSocket subscription confirmed")
                    ExchangeWebSocket.logAlert(event: "‚úÖ KuCoin Spot subscription confirmed")
                    return
                }
                
                // FIXED: Extract price correctly and update immediately to fix $0.000000 issue
                if let subject = json["subject"] as? String,
                   subject == "trade.ticker",
                   let topic = json["topic"] as? String,
                   let data = json["data"] as? [String: Any] {
                    
                    print("üîç [KuCoin Spot] Processing ticker message:")
                    print("   Topic: \(topic)")
                    print("   Data keys: \(Array(data.keys))")
                    
                    // Extract symbol from topic (/market/ticker:BTCUSDT)
                    let symbol = topic.replacingOccurrences(of: "/market/ticker:", with: "")
                    
                    // Convert BTCUSDT back to BTC-USDT for internal storage
                    let pair: String
                    if symbol.hasSuffix("USDT") && symbol.count > 4 {
                        let baseAsset = symbol.replacingOccurrences(of: "USDT", with: "")
                        pair = "\(baseAsset)-USDT"
                    } else {
                        pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
                    }
                    
                    print("   Symbol: \(symbol) -> Pair: \(pair)")
                    
                    // CRITICAL FIX: Extract price using multiple keys (enhanced)
                    // ENHANCED FIX: Extract price using ALL possible KuCoin keys
                    let priceKeys = ["last", "price", "bestAsk", "bestBid", "sell", "buy", "close", "mark", "index"]
                    var extractedPrice: Double?
                    var usedKey = ""

                    // Try string values first
                    for key in priceKeys {
                        if let priceStr = data[key] as? String, !priceStr.isEmpty {
                            if let price = Double(priceStr), price > 0 {
                                extractedPrice = price
                                usedKey = key
                                print("‚úÖ PRICE FOUND: key='\(key)', value='\(priceStr)', parsed=\(price)")
                                break
                            }
                        }
                    }

                    // If no string value worked, try numeric values
                    if extractedPrice == nil {
                        for key in priceKeys {
                            if let priceNum = data[key] as? Double, priceNum > 0 {
                                extractedPrice = priceNum
                                usedKey = key
                                print("‚úÖ PRICE FOUND (numeric): key='\(key)', value=\(priceNum)")
                                break
                            }
                        }
                    }

                    // Debug: Print all available data if no price found
                    if extractedPrice == nil {
                        print("‚ùå NO PRICE FOUND - Available data:")
                        for (k, v) in data {
                            print("   \(k): \(v) (type: \(type(of: v)))")
                        }
                    }
                    
                    if let price = extractedPrice {
                        print("‚úÖ [KuCoin Spot] Found price for \(pair): $\(price) (key: \(usedKey))")
                        
                        // FIXED: Immediate update to fix $0.000000 dashboard issue
                        ExchangeWebSocket.kucoinCurrentPrice[pair] = price
                        ExchangeWebSocket.kucoinPrices[pair, default: []].append(price)
                        
                        // Maintain price history limit
                        if ExchangeWebSocket.kucoinPrices[pair]!.count > ExchangeWebSocket.priceHistoryRetention {
                            ExchangeWebSocket.kucoinPrices[pair]?.removeFirst()
                        }
                        
                        print("‚úÖ [KuCoin Spot] Updated price for \(pair): $\(price)")
                        ExchangeWebSocket.logAlert(event: "‚úÖ [KuCoin Spot] Updated price for \(pair): $\(price)")
                        
                        // Update last data timestamp
                        ExchangeWebSocket.lastDataUpdate[pair] = Date()
                        
                        // Trigger arbitrage check and dashboard update
                        ExchangeWebSocket.triggerCrossExchangeArbitrageCheck(pair: pair)
                        ExchangeWebSocket.updateDashboardData()
                        
                    } else {
                        print("‚ùå [KuCoin Spot] NO VALID PRICE found for \(pair)")
                        print("   Available data: \(data)")
                        ExchangeWebSocket.logAlert(event: "‚ùå KuCoin Spot: NO PRICE for \(pair)")
                    }
                }
            }
            
        case .binary(_):
            break
            
        case .ping(_):
            client.write(pong: Data())
            
        case .pong(_):
            break
            
        case .viabilityChanged(_):
            break
            
        case .reconnectSuggested(_):
            ExchangeWebSocket.logAlert(event: "KuCoin Spot WebSocket reconnection suggested")
            DispatchQueue.main.asyncAfter(deadline: .now() + 10) { [weak self] in
                guard self != nil else { return }
                ExchangeWebSocket.connectToKuCoinSpotWebSocket()
            }
            
        case .cancelled:
            ExchangeWebSocket.kucoinIsConnected = false
            self.hasReceivedWelcome = false
            print("‚ùå [KuCoin Spot] WebSocket cancelled")
            
        case .error(let error):
            ExchangeWebSocket.kucoinIsConnected = false
            self.hasReceivedWelcome = false
            print("‚ùå [KuCoin Spot] WebSocket error: \(error?.localizedDescription ?? "unknown")")
            ExchangeWebSocket.logAlert(event: "KuCoin Spot WebSocket error: \(error?.localizedDescription ?? "unknown")")
            
            // Reconnect on error with weak self
            DispatchQueue.main.asyncAfter(deadline: .now() + 30) { [weak self] in
                guard self != nil else { return }
                ExchangeWebSocket.connectToKuCoinSpotWebSocket()
            }
            
        case .peerClosed:
            ExchangeWebSocket.kucoinIsConnected = false
            self.hasReceivedWelcome = false
            print("‚ùå [KuCoin Spot] WebSocket peer closed")
            ExchangeWebSocket.logAlert(event: "KuCoin Spot WebSocket peer closed")
        }
    }
}
}
extension ExchangeWebSocket {
// Add strong reference to prevent delegate deallocation
static var kucoinSpotEnhancedDelegate: KuCoinSpotWebSocketDelegateEnhanced?
// Track welcome state for KuCoin Spot
static var kucoinSpotHasReceivedWelcome = false

// CRITICAL FIX: New function to get BOTH token AND endpoint for KuCoin Spot
static func getKuCoinWebSocketTokenAndEndpoint(completion: @escaping @Sendable (String?, String?) -> Void) {
    let url = URL(string: "https://api.kucoin.com/api/v1/bullet-public")!
    var request = URLRequest(url: url)
    request.httpMethod = "POST"
    request.addValue("application/json", forHTTPHeaderField: "Content-Type")
    request.timeoutInterval = getDouble("API_TIMEOUT_SECONDS", defaultValue: 10.0)
    
    let startTime = Date()
    URLSession.shared.dataTask(with: request) { data, response, error in
        let latency = Date().timeIntervalSince(startTime) * 1000
        Task { @MainActor in
            lastLatency["kucoin-token"] = latency
            if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 300.0) {
                logAlert(event: "High latency detected for KuCoin token fetch: \(latency)ms")
            }
        }
        
        if let error = error {
            print("‚ùå Failed to fetch KuCoin WebSocket token: \(error.localizedDescription)")
            Task { @MainActor in
                logAlert(event: "Failed to fetch KuCoin WebSocket token: \(error.localizedDescription)")
            }
            completion(nil, nil)
            return
        }
        
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200,
              let data = data else {
            print("‚ùå Invalid response for KuCoin WebSocket token")
            Task { @MainActor in
                logAlert(event: "Invalid response for KuCoin WebSocket token")
            }
            completion(nil, nil)
            return
        }
        
        do {
            guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let responseData = json["data"] as? [String: Any],
                  let token = responseData["token"] as? String,
                  let instanceServers = responseData["instanceServers"] as? [[String: Any]],
                  let firstServer = instanceServers.first,
                  let endpoint = firstServer["endpoint"] as? String else {
                print("‚ùå Failed to parse KuCoin WebSocket token response")
                Task { @MainActor in
                    logAlert(event: "Failed to parse KuCoin WebSocket token response")
                }
                completion(nil, nil)
                return
            }
            
            print("‚úÖ Successfully fetched KuCoin Spot token and endpoint: \(endpoint)")
            Task { @MainActor in
                logAlert(event: "‚úÖ Successfully fetched KuCoin Spot WebSocket token and endpoint")
            }
            completion(token, endpoint)
            
        } catch {
            print("‚ùå JSON parsing error for KuCoin token: \(error.localizedDescription)")
            Task { @MainActor in
                logAlert(event: "JSON parsing error for KuCoin token: \(error.localizedDescription)")
            }
            completion(nil, nil)
        }
    }.resume()
}

// CRITICAL FIX: New function to get BOTH token AND endpoint for KuCoin Futures
static func getKuCoinFuturesWebSocketTokenAndEndpoint(completion: @escaping @Sendable (String?, String?) -> Void) {
    let url = URL(string: "https://api-futures.kucoin.com/api/v1/bullet-public")!
    var request = URLRequest(url: url)
    request.httpMethod = "POST"
    request.addValue("application/json", forHTTPHeaderField: "Content-Type")
    request.timeoutInterval = getDouble("API_TIMEOUT_SECONDS", defaultValue: 10.0)
    
    let startTime = Date()
    URLSession.shared.dataTask(with: request) { data, response, error in
        let latency = Date().timeIntervalSince(startTime) * 1000
        Task { @MainActor in
            lastLatency["kucoin-futures-token"] = latency
            if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 300.0) {
                logAlert(event: "High latency detected for KuCoin Futures token fetch: \(latency)ms")
            }
        }
        
        if let error = error {
            print("‚ùå Failed to fetch KuCoin Futures WebSocket token: \(error.localizedDescription)")
            Task { @MainActor in
                logAlert(event: "Failed to fetch KuCoin Futures WebSocket token: \(error.localizedDescription)")
            }
            completion(nil, nil)
            return
        }
        
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200,
              let data = data else {
            print("‚ùå Invalid response for KuCoin Futures WebSocket token")
            Task { @MainActor in
                logAlert(event: "Invalid response for KuCoin Futures WebSocket token")
            }
            completion(nil, nil)
            return
        }
        
        do {
            guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let responseData = json["data"] as? [String: Any],
                  let token = responseData["token"] as? String,
                  let instanceServers = responseData["instanceServers"] as? [[String: Any]],
                  let firstServer = instanceServers.first,
                  let endpoint = firstServer["endpoint"] as? String else {
                print("‚ùå Failed to parse KuCoin Futures WebSocket token response")
                Task { @MainActor in
                    logAlert(event: "Failed to parse KuCoin Futures WebSocket token response")
                }
                completion(nil, nil)
                return
            }
            
            print("‚úÖ Successfully fetched KuCoin Futures token and endpoint: \(endpoint)")
            Task { @MainActor in
                logAlert(event: "‚úÖ Successfully fetched KuCoin Futures WebSocket token and endpoint")
            }
            completion(token, endpoint)
            
        } catch {
            print("‚ùå JSON parsing error for KuCoin Futures token: \(error.localizedDescription)")
            Task { @MainActor in
                logAlert(event: "JSON parsing error for KuCoin Futures token: \(error.localizedDescription)")
            }
            completion(nil, nil)
        }
    }.resume()
}

// Handle KuCoin Spot WebSocket events
@MainActor
static func handleKuCoinSpotWebSocketEvent(event: Starscream.WebSocketEvent, client: any Starscream.WebSocketClient) {
    switch event {
    case .connected(let headers):
        print("üîó [KuCoin Spot] WebSocket connected: \(headers)")
        logAlert(event: "üîó KuCoin Spot WebSocket connected, waiting for welcome...")
        kucoinSpotHasReceivedWelcome = false
        
    case .disconnected(let reason, let code):
        kucoinIsConnected = false
        kucoinSpotHasReceivedWelcome = false
        print("‚ùå [KuCoin Spot] WebSocket disconnected: \(reason) (\(code))")
        logAlert(event: "‚ùå KuCoin Spot WebSocket disconnected: \(reason)")
        
        // Auto-reconnect after delay
        DispatchQueue.main.asyncAfter(deadline: .now() + 30) {
            connectToKuCoinSpotWebSocket()
        }
        
    case .text(let text):
        if let data = text.data(using: .utf8),
           let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
            
            // STEP 1: Handle welcome message FIRST (CRITICAL)
            if let type = json["type"] as? String, type == "welcome" {
                kucoinSpotHasReceivedWelcome = true
                kucoinIsConnected = true
                print("‚úÖ [KuCoin Spot] Welcome message received! Now subscribing...")
                logAlert(event: "‚úÖ KuCoin Spot welcome received, subscribing to pairs...")
                
                // STEP 2: Subscribe to all pairs AFTER welcome
                for pair in tradingPairs {
                    // CRITICAL FIX: Convert BTC-USDT to BTCUSDT for KuCoin API
                    let symbol = pair.replacingOccurrences(of: "-", with: "")
                    let subscriptionMessage = [
                        "id": UUID().uuidString,
                        "type": "subscribe",
                        "topic": "/market/ticker:\(symbol)",  // FIXED: Use BTCUSDT format for KuCoin API
                        "privateChannel": false,
                        "response": true
                    ] as [String : Any]
                    
                    if let data = try? JSONSerialization.data(withJSONObject: subscriptionMessage),
                       let jsonString = String(data: data, encoding: .utf8) {
                        client.write(string: jsonString)
                        print("üì° [KuCoin Spot] Subscribed to: \(symbol) (pair: \(pair))")
                    }
                }
                return
            }
            
            // STEP 3: Don't process other messages until welcome received
            guard kucoinSpotHasReceivedWelcome else {
                print("‚ö†Ô∏è [KuCoin Spot] Ignoring message - no welcome received yet: \(json["type"] as? String ?? "unknown")")
                return
            }
            
            // Handle subscription confirmations
            if json["type"] as? String == "ack" {
                print("‚úÖ KuCoin Spot WebSocket subscription confirmed")
                logAlert(event: "‚úÖ KuCoin Spot subscription confirmed")
                return
            }
            
            // FIXED: Extract price correctly and update immediately to fix $0.000000 issue
            if let subject = json["subject"] as? String,
               subject == "trade.ticker",
               let topic = json["topic"] as? String,
               let data = json["data"] as? [String: Any] {
                
                print("üîç [KuCoin Spot] Processing ticker message:")
                print("   Topic: \(topic)")
                print("   Data keys: \(Array(data.keys))")
                
                // Extract symbol from topic (/market/ticker:BTCUSDT)
                let symbol = topic.replacingOccurrences(of: "/market/ticker:", with: "")
                
                // Convert BTCUSDT back to BTC-USDT for internal storage
                let pair: String
                if symbol.hasSuffix("USDT") && symbol.count > 4 {
                    let baseAsset = symbol.replacingOccurrences(of: "USDT", with: "")
                    pair = "\(baseAsset)-USDT"
                } else {
                    pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
                }
                
                print("   Symbol: \(symbol) -> Pair: \(pair)")
                
                // CRITICAL FIX: Extract price using multiple keys (enhanced)
                let priceKeys = ["price", "last", "bestAsk", "bestBid", "close", "c"]
                var extractedPrice: Double?
                var usedKey = ""
                
                for key in priceKeys {
                    if let priceStr = data[key] as? String,
                       let price = Double(priceStr), price > 0 {
                        extractedPrice = price
                        usedKey = key
                        break
                    }
                }
                
                if let price = extractedPrice {
                    print("‚úÖ [KuCoin Spot] Found price for \(pair): $\(price) (key: \(usedKey))")
                    print("‚úÖ [KuCoin Spot] Updated kucoinCurrentPrice[\(pair)] = $\(price)") // Debug: Confirm price update
                    kucoinCurrentPrice[pair] = price
                    kucoinPrices[pair, default: []].append(price)
                    
                    // Maintain price history limit
                    if kucoinPrices[pair]!.count > priceHistoryRetention {
                        kucoinPrices[pair]?.removeFirst()
                    }
                    
                    print("‚úÖ [KuCoin Spot] Updated price for \(pair): $\(price)")
                    logAlert(event: "‚úÖ [KuCoin Spot] Updated price for \(pair): $\(price)")
                    
                    // Update last data timestamp
                    lastDataUpdate[pair] = Date()
                    
                    // Trigger arbitrage check and dashboard update
                    triggerCrossExchangeArbitrageCheck(pair: pair)
                    updateDashboardData()
                    
                } else {
                    print("‚ùå [KuCoin Spot] NO VALID PRICE found for \(pair)")
                    print("   Available data: \(data)")
                    logAlert(event: "‚ùå KuCoin Spot: NO PRICE for \(pair)")
                }
            }
        }
        
    case .binary(_):
        break
        
    case .ping(_):
        client.write(pong: Data())
        
    case .pong(_):
        break
        
    case .viabilityChanged(_):
        break
        
    case .reconnectSuggested(_):
        logAlert(event: "KuCoin Spot WebSocket reconnection suggested")
        DispatchQueue.main.asyncAfter(deadline: .now() + 10) {
            connectToKuCoinSpotWebSocket()
        }
        
    case .cancelled:
        kucoinIsConnected = false
        kucoinSpotHasReceivedWelcome = false
        print("‚ùå [KuCoin Spot] WebSocket cancelled")
        
    case .error(let error):
        kucoinIsConnected = false
        kucoinSpotHasReceivedWelcome = false
        print("‚ùå [KuCoin Spot] WebSocket error: \(error?.localizedDescription ?? "unknown")")
        logAlert(event: "KuCoin Spot WebSocket error: \(error?.localizedDescription ?? "unknown")")
        
        // Reconnect on error
        DispatchQueue.main.asyncAfter(deadline: .now() + 30) {
            connectToKuCoinSpotWebSocket()
        }
        
    case .peerClosed:
        kucoinIsConnected = false
        kucoinSpotHasReceivedWelcome = false
        print("‚ùå [KuCoin Spot] WebSocket peer closed")
        logAlert(event: "KuCoin Spot WebSocket peer closed")
    }
}
    
