//--------------- Block 1 - Core Data Structures and Utilities
// VARIABLES TO ADD: None - All variables included in this block

@preconcurrency import Starscream
import Foundation
import SwiftDotenv
import CryptoKit

// FIXED: Add AgentType enum at the top to resolve "Cannot find type 'AgentType'" errors
enum AgentType: String, CaseIterable {
    case momentum, meanReversion, marketMaking, hft
}

// FIXED: Add single definitions of types to resolve ambiguous type lookup errors
struct HyperdimensionalVector {
    let dims: [Double]
    let mag: Double
    let ts: Date
}

struct TemporalPrediction {
    let horizon: TimeInterval
    let predPrice: Double
    let conf: Double
    let prob: Double
}

// BevaixOrderBook struct definition to avoid conflicts
struct BevaixOrderBook {
    var bids: [(price: Double, quantity: Double)]
    var asks: [(price: Double, quantity: Double)]
    
    var isEmpty: Bool {
        return bids.isEmpty && asks.isEmpty
    }
}

// AI ENHANCEMENTS - Missing Types
class NeuralAgent {
    let id = UUID()
    var strength: Float = 0.5
    
    func evaluate(market: [Float]) -> Float {
        return market.reduce(0, +) / Float(max(market.count, 1)) * strength
    }
}

actor TemporalOracle {
    func predictFuture(pair: String) async -> [Double] {
        return [Double.random(in: 0.5...1.5)]
    }
}
struct QuantumState {
    let superposition: [Double]
    let entanglement: [String: Double]
    let collapseProb: Double
    let timestamp: Date
}

// Enhanced Structures for Advanced Trading
struct AdvancedSignal {
    let type: String
    let strength: Double
    let confidence: Double
    let timestamp: Date
    let pair: String
    let exchange: String
}

struct MLPrediction {
    let prediction: Double
    var confidence: Double
    let features: [String: Double]
    var timestamp: Date  // ‚Üê CHANGE: from 'let' to 'var'
    let model: String
}
struct PerformanceMetrics {
    var totalTrades: Int
    var winningTrades: Int
    var totalProfit: Double
    var totalFees: Double
    var averageLatency: Double
    var maxDrawdown: Double
    var sharpeRatio: Double
    var lastTradeTime: Date
}

struct RiskMetrics {
    var var95: Double // Value at Risk 95%
    var var99: Double // Value at Risk 99%
    var expectedShortfall: Double
    var maxDrawdown: Double
    var volatility: Double
    var correlation: Double
    var beta: Double
}

struct MarketCondition {
    let volatility: Double
    let trend: String
    let volume: Double
    let momentum: Double
    let timestamp: Date
}

struct TradingOpportunity {
    let pair: String
    let strategy: String
    let expectedProfit: Double
    let riskLevel: Double
    var confidence: Double
    let timeHorizon: TimeInterval
}

// Global Helper Methods for Type Conversion
func getDouble(_ key: String, defaultValue: Double) -> Double {
    guard let value = ProcessInfo.processInfo.environment[key], !value.isEmpty else {
        print("Environment variable \(key) not found or empty")
        return defaultValue
    }
    let cleanedValue = value.components(separatedBy: "#")[0].trimmingCharacters(in: .whitespaces)
    if let doubleValue = Double(cleanedValue) {
        return doubleValue
    } else {
        print("Could not parse \(key) as Double: \(cleanedValue)")
        return defaultValue
    }
}

func getInt(_ key: String, defaultValue: Int) -> Int {
    guard let value = ProcessInfo.processInfo.environment[key], !value.isEmpty else {
        print("Environment variable \(key) not found or empty")
        return defaultValue
    }
    let cleanedValue = value.components(separatedBy: "#")[0].trimmingCharacters(in: .whitespaces)
    if let intValue = Int(cleanedValue) {
        return intValue
    } else {
        print("Could not parse \(key) as Int: \(cleanedValue)")
        return defaultValue
    }
}

func getBool(_ key: String, defaultValue: Bool) async -> Bool {
    guard let stringValue = ProcessInfo.processInfo.environment[key] else {
        print("Warning: Could not parse \(key) as Bool, using default: \(defaultValue)")
        await MainActor.run {
            logAlert(event: "Could not parse \(key) as Bool, using default: \(defaultValue)")
        }
        return defaultValue
    }
    let cleanedValue = stringValue.components(separatedBy: "#")[0].trimmingCharacters(in: .whitespaces).lowercased()
    if cleanedValue == "true" || cleanedValue == "1" || cleanedValue == "yes" {
        return true
    } else if cleanedValue == "false" || cleanedValue == "0" || cleanedValue == "no" {
        return false
    } else {
        print("Warning: Could not parse \(key) as Bool: \(cleanedValue), using default: \(defaultValue)")
        await MainActor.run {
            logAlert(event: "Could not parse \(key) as Bool: \(cleanedValue), using default: \(defaultValue)")
        }
        return defaultValue
    }
}

func getString(_ key: String, defaultValue: String) -> String {
    guard let value = ProcessInfo.processInfo.environment[key], !value.isEmpty else {
        print("Environment variable \(key) not found or empty")
        return defaultValue
    }
    return value.components(separatedBy: "#")[0].trimmingCharacters(in: .whitespaces)
}

// Global Environment Variable Storage



var hasValidKuCoinCredentials: Bool = true
var environment: [String: String] = {
    do {
        let fileManager = FileManager.default
        
       
        let projectRoot = "/Users/robertsteinegger/Desktop/BevaixBot"
        let projectEnvPath = URL(fileURLWithPath: projectRoot).appendingPathComponent(".env").path
        let currentDirectory = fileManager.currentDirectoryPath
        let currentEnvPath = URL(fileURLWithPath: currentDirectory).appendingPathComponent(".env").path
        
        var envPath = projectEnvPath
        var useProjectPath = true
        
        print("üîç Primary: Loading .env from \(projectEnvPath)")
        if fileManager.fileExists(atPath: projectEnvPath) {
            print("‚úÖ Found .env file at \(projectEnvPath)")
            envPath = projectEnvPath
        } else {
            print("‚ö†Ô∏è No .env file found at \(projectEnvPath)")
            print("üîç Fallback: Loading .env from \(currentEnvPath)")
            if fileManager.fileExists(atPath: currentEnvPath) {
                print("‚úÖ Found .env file at \(currentEnvPath)")
                envPath = currentEnvPath
                useProjectPath = false
            } else {
                print("‚ùå No .env file found at \(currentEnvPath)")
                Task { @MainActor in
                    logAlert(event: "No .env file found at \(projectEnvPath) or \(currentEnvPath)")
                }
            }
        }
        
        // FIXED: Set working directory to where .env file is located for SwiftDotenv
        if useProjectPath {
            fileManager.changeCurrentDirectoryPath(projectRoot)
        }
        
        // Try SwiftDotenv first (preserving original functionality)
        var envDict: [String: String] = [:]
        var swiftDotenvSuccess = false
        
        do {
            try Dotenv.configure()
            swiftDotenvSuccess = true
            print("‚úÖ SwiftDotenv configured successfully")
            print("SwiftDotenv version: \(Dotenv.version?.stringValue ?? "unknown")")
        } catch {
            print("‚ö†Ô∏è SwiftDotenv failed: \(error), falling back to manual parsing")
        }
        
        // COMPLETE original keys list - preserved exactly as in original code
        let keys = [
            "ACTIVE_PAIRS", "BYBIT_API_KEY", "BYBIT_API_SECRET", "KUCOIN_API_KEY",
            "KUCOIN_API_SECRET", "KUCOIN_API_PASSPHRASE", "BYBIT_RATE_WINDOW",
            "KUCOIN_LEVERAGE", "BYBIT_LEVERAGE", "LIQUIDITY_FEE_MULTIPLIER",
            "LIQUIDITY_PRICE_IMPACT_THRESHOLD", "ORDER_BOOK_PRICE_RANGE",
            "ORDER_BOOK_IMBALANCE_THRESHOLD", "MIN_LIQUIDITY_THRESHOLD",
            "MAX_ORDER_BOOK_IMBALANCE", "VOLATILITY_SPIKE_THRESHOLD",
            "VOLATILITY_SPIKE_WINDOW_MINUTES", "VOLATILITY_SPIKE_COOLDOWN_SECONDS",
            "VOLUME_ANOMALY_MULTIPLIER", "VOLUME_ANOMALY_WINDOW_HOURS",
            "VOLUME_ANOMALY_COOLDOWN_SECONDS", "FUTURES_TRADE_AMOUNT",
            "FUTURES_MIN_PROFIT_PERCENTAGE", "FUTURES_STOP_LOSS_PERCENTAGE",
            "FUTURES_TRAILING_STOP_PERCENTAGE", "FUTURES_SPIKE_RATE_STOP_PERCENTAGE",
            "MAX_ACTIVE_FUTURES_TRADES", "DAILY_LOSS_LIMIT_PERCENTAGE", "ATR_MULTIPLIER",
            "ARBITRAGE_MIN_BALANCE", "ARBITRAGE_TRADE_AMOUNT",
            "ARBITRAGE_MIN_SPREAD_THRESHOLD", "ARBITRAGE_HIGH_SPREAD_THRESHOLD",
            "CROSS_EXCHANGE_MIN_BALANCE", "CROSS_EXCHANGE_TRADE_AMOUNT",
            "CROSS_EXCHANGE_MIN_SPREAD_THRESHOLD",
            "CROSS_EXCHANGE_MIN_FUNDING_RATE_THRESHOLD",
            "CROSS_EXCHANGE_COOLDOWN_SECONDS", "VOLATILITY_PAUSE_SECONDS",
            "SPOT_TRADE_AMOUNT", "SPOT_FEE_RATE", "SPOT_MINUTE_PROFIT_PERCENTAGE",
            "SPOT_STOP_LOSS_PERCENTAGE", "SPOT_TRAILING_STOP_PERCENTAGE",
            "SPOT_EMA_SHORT_PERIOD", "SPOT_EMA_MEDIUM_PERIOD", "SPOT_EMA_LONG_PERIOD",
            "SPOT_RSI_PERIOD", "SPOT_RSI_UPPER_THRESHOLD", "SPOT_RSI_LOWER_THRESHOLD",
            "MAX_ACTIVE_SPOT_TRADES", "FUTURES_EMA_SHORT_PERIOD",
            "FUTURES_EMA_MEDIUM_PERIOD", "FUTURES_EMA_LONG_PERIOD",
            "BYBIT_FUTURES_FEE_RATE", "KUCOIN_FUTURES_FEE_RATE",
            "BYBIT_FALLBACK_BALANCE", "KUCOIN_FALLBACK_BALANCE",
            "PRICE_HISTORY_RETENTION", "WEBSOCKET_TIMEOUT_SECONDS",
            "BALANCE_FETCH_TIMEOUT", "MAX_FUNDING_RATE", "SCALP_ENTRY_THRESHOLD",
            "SCALP_PROFIT_TARGET", "SCALP_STOP_LOSS", "MACD_SHORT_PERIOD",
            "MACD_LONG_PERIOD", "MACD_SIGNAL_PERIOD", "MACD_CONFIRMATION_THRESHOLD",
            "MAX_SLIPPAGE", "LIQUIDITY_CHECK_INTERVAL", "MIN_ORDERBOOK_REFRESH_RATE",
            "SIMULATION_TRADE_LOGGING", "HFT_SPREAD_THRESHOLD", "HFT_TRADE_AMOUNT",
            "SPOOFING_VOLUME_THRESHOLD", "SPOOFING_PROFIT_TARGET",
            "SLIPPAGE_TRADE_AMOUNT", "FUNDING_MOMENTUM_THRESHOLD",
            "LATENCY_SPIKE_THRESHOLD", "HFT_COOLDOWN_SECONDS",
            "PRICE_REVERSAL_THRESHOLD", "PRICE_REVERSAL_WINDOW_MINUTES",
            "SLIPPAGE_DEPTH_THRESHOLD", "SLIPPAGE_PERCENTAGE",
            "ATR_FALLBACK_PERCENTAGE", "VOLUME_TRACKING_VALUE",
            "FUNDING_RATE_COST_MULTIPLIER", "TRADE_HOLD_DURATION_MINUTES",
            "MIN_PRICE_DATA_POINTS", "VOLUME_ANOMALY_THRESHOLD",
            "SPREAD_RETENTION_HOURS", "ORDER_BOOK_IMBALANCE_FALLBACK",
            "LIQUIDITY_CHECK_FALLBACK", "MARKET_MAKING_SPREAD", "HFT_ORDER_TYPE"
        ]
        
        if swiftDotenvSuccess {
            // Original SwiftDotenv loading method - preserved exactly
            for key in keys {
                if let value = Dotenv[key] {
                    envDict[key] = value.stringValue
                }
            }
            print("‚úÖ Successfully loaded .env file using SwiftDotenv")
        } else {
            // FALLBACK: Manual parsing if SwiftDotenv fails
            print("üîÑ Using manual .env parsing as fallback")
            let contents = try String(contentsOfFile: envPath, encoding: .utf8)
            let lines = contents.components(separatedBy: .newlines)
            
            for line in lines {
                let trimmed = line.trimmingCharacters(in: .whitespacesAndNewlines)
                
                // Skip empty lines and comments
                if trimmed.isEmpty || trimmed.hasPrefix("#") { continue }
                
                // Parse key=value pairs
                let parts = trimmed.components(separatedBy: "=")
                if parts.count >= 2 {
                    let key = parts[0].trimmingCharacters(in: .whitespaces)
                    let value = parts.dropFirst().joined(separator: "=").trimmingCharacters(in: .whitespaces)
                    
                    // Remove quotes if present
                    let cleanValue = value.trimmingCharacters(in: CharacterSet(charactersIn: "\"'"))
                    
                    // Only add if it's in our keys list (preserving original selective loading)
                    if keys.contains(key) {
                        envDict[key] = cleanValue
                    }
                }
            }
            print("‚úÖ Successfully loaded .env file using manual parsing")
        }
        
        // ORIGINAL KuCoin credential validation logic - preserved exactly
        let requiredKuCoinKeys = ["KUCOIN_API_KEY", "KUCOIN_API_SECRET", "KUCOIN_API_PASSPHRASE"]
        var missingKeys = [String]()
        for key in requiredKuCoinKeys {
            if envDict[key] == nil || envDict[key]!.isEmpty {
                missingKeys.append(key)
            }
        }
        if !missingKeys.isEmpty {
            let missingMessage = "Missing or empty KuCoin API credentials: \(missingKeys.joined(separator: ", ")). Disabling KuCoin functionality."
            print("WARNING: \(missingMessage)")
            Task { @MainActor in
                logAlert(event: missingMessage)
            }
            hasValidKuCoinCredentials = false // Disable KuCoin operations
        }
        
        // ORIGINAL debug logging - preserved exactly
        print("DEBUG: Loaded environment variables: \(envDict)")
        print("DEBUG: ACTIVE_PAIRS from env: \(envDict["ACTIVE_PAIRS"] ?? "not found")")
        print("DEBUG: BYBIT_API_KEY from env: \(envDict["BYBIT_API_KEY"] ?? "not found")")
        print("DEBUG: KUCOIN_API_KEY from env: \(envDict["KUCOIN_API_KEY"] ?? "not found")")
        
        // ENHANCED: Set ProcessInfo environment for global access (needed for getDouble, getString, etc.)
        for (key, value) in envDict {
            setenv(key, value, 1)
        }
        
        print("‚úÖ Loaded \(envDict.count) environment variables")
        return envDict
        
    } catch {
        // ORIGINAL error handling - preserved exactly
        print("Failed to load .env file: \(error)")
        Task { @MainActor in
            logAlert(event: "Failed to load .env file: \(error)")
        }
        return [:] // Return empty dictionary to allow bot to continue
    }
}()


// Global Alert Logging Function
func logAlert(event: String, completion: @escaping @Sendable () -> Void = {}) {
    let alertsCSVURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/alerts.csv")
    Task {
        await MainActor.run {
            let timestamp = ISO8601DateFormatter().string(from: Date())
            let logEntry = "\(timestamp),\(event)\n"
            do {
                let fileManager = FileManager.default
                if !fileManager.fileExists(atPath: alertsCSVURL.path) {
                    try "timestamp,event\n".write(to: alertsCSVURL, atomically: true, encoding: .utf8)
                    try fileManager.setAttributes([.posixPermissions: 0o644], ofItemAtPath: alertsCSVURL.path)
                }
                if let fileHandle = try? FileHandle(forWritingTo: alertsCSVURL) {
                    defer { fileHandle.closeFile() }
                    if let data = logEntry.data(using: .utf8) {
                        fileHandle.seekToEndOfFile()
                        fileHandle.write(data)
                    }
                } else {
                    let fileHandle = try FileHandle(forWritingTo: alertsCSVURL)
                    defer { fileHandle.closeFile() }
                    if let data = logEntry.data(using: .utf8) {
                        fileHandle.seekToEndOfFile()
                        fileHandle.write(data)
                    }
                }
                print("DEBUG: Logged alert to alerts.csv: \(logEntry.trimmingCharacters(in: .whitespacesAndNewlines))")
            } catch {
                print("DEBUG: Failed to log alert to alerts.csv: \(error.localizedDescription)")
            }
            completion()
        }
    }
}


// ADD THESE 4 COMPLETE CLASSES BEFORE @MainActor class ExchangeWebSocket {



class KuCoinSpotWebSocketDelegate: WebSocketDelegate {
    func didReceive(event: Starscream.WebSocketEvent, client: any Starscream.WebSocketClient) {
        Task { @MainActor in
            switch event {
            case .connected(let headers):
                ExchangeWebSocket.kucoinIsConnected = true
                print("‚úÖ [KuCoin Spot] WebSocket connected: \(headers)")
                ExchangeWebSocket.logAlert(event: "‚úÖ KuCoin Spot WebSocket connected")
                
                // Subscribe to all pairs
                for pair in ExchangeWebSocket.tradingPairs {
                    let symbol = pair.replacingOccurrences(of: "-", with: "")
                    let subscriptionMessage = [
                        "id": UUID().uuidString,
                        "type": "subscribe",
                        "topic": "/market/ticker:\(symbol)",
                        "privateChannel": false,
                        "response": true
                    ] as [String : Any]
                    
                    if let data = try? JSONSerialization.data(withJSONObject: subscriptionMessage),
                       let jsonString = String(data: data, encoding: .utf8) {
                        client.write(string: jsonString)
                        print("Subscribed to KuCoin spot topic: /market/ticker:\(symbol) for pair: \(pair)")
                    }
                }
                
            case .disconnected(let reason, let code):
                ExchangeWebSocket.kucoinIsConnected = false
                print("‚ùå [KuCoin Spot] WebSocket disconnected: \(reason) (\(code))")
                ExchangeWebSocket.logAlert(event: "‚ùå KuCoin Spot WebSocket disconnected: \(reason)")
                
            case .text(let text):
                if let data = text.data(using: .utf8),
                   let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                    
                    // Handle subscription confirmations
                    if json["type"] as? String == "ack" {
                        print("KuCoin Spot WebSocket subscription confirmed")
                        return
                    }
                    
                    // Handle price data
                    if let subject = json["subject"] as? String,
                       subject == "trade.ticker",
                       let topic = json["topic"] as? String,
                       let data = json["data"] as? [String: Any] {
                        
                        let symbol = topic.replacingOccurrences(of: "/market/ticker:", with: "")
                        let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
                        
                        if let priceStr = data["price"] as? String,
                           let price = Double(priceStr), price > 0 {
                            
                            ExchangeWebSocket.kucoinCurrentPrice[pair] = price
                            ExchangeWebSocket.kucoinPrices[pair, default: []].append(price)
                            
                            // Maintain price history limit
                            if ExchangeWebSocket.kucoinPrices[pair]!.count > ExchangeWebSocket.priceHistoryRetention {
                                ExchangeWebSocket.kucoinPrices[pair]?.removeFirst()
                            }
                            
                            print("‚úÖ [KuCoin Spot] Updated price for \(pair): $\(price)")
                            
                            // Update last data timestamp
                            ExchangeWebSocket.lastDataUpdate[pair] = Date()
                        }
                    }
                }
                
            case .binary(_):
                break
                
            case .ping(_):
                client.write(pong: Data())
                
            case .pong(_):
                break
                
            case .viabilityChanged(_):
                break
                
            case .reconnectSuggested(_):
                Task { @MainActor in
                    ExchangeWebSocket.logAlert(event: "KuCoin Spot WebSocket reconnection suggested")
                }
                
            case .cancelled:
                ExchangeWebSocket.kucoinIsConnected = false
                print("‚ùå [KuCoin Spot] WebSocket cancelled")
                
            case .error(let error):
                ExchangeWebSocket.kucoinIsConnected = false
                print("‚ùå [KuCoin Spot] WebSocket error: \(error?.localizedDescription ?? "unknown")")
                ExchangeWebSocket.logAlert(event: "KuCoin Spot WebSocket error: \(error?.localizedDescription ?? "unknown")")
                
            case .peerClosed:
                ExchangeWebSocket.kucoinIsConnected = false
                print("‚ùå [KuCoin Spot] WebSocket peer closed")
                ExchangeWebSocket.logAlert(event: "KuCoin Spot WebSocket peer closed")
            }
        }
    }
}

class KuCoinFuturesWebSocketDelegate: WebSocketDelegate {
    func didReceive(event: Starscream.WebSocketEvent, client: any Starscream.WebSocketClient) {
        Task { @MainActor in
            switch event {
            case .connected(let headers):
                ExchangeWebSocket.kucoinFuturesIsConnected = true
                print("‚úÖ [KuCoin Futures] WebSocket connected: \(headers)")
                ExchangeWebSocket.logAlert(event: "‚úÖ KuCoin Futures WebSocket connected")
                
                // Subscribe to all pairs
                for pair in ExchangeWebSocket.tradingPairs {
                    let futuresSymbol = ExchangeWebSocket.kucoinFuturesSymbols[pair] ?? "\(pair.replacingOccurrences(of: "-USDT", with: ""))USDTM"
                    let subscriptionMessage = [
                        "id": UUID().uuidString,
                        "type": "subscribe",
                        "topic": "/contractMarket/ticker:\(futuresSymbol)",
                        "privateChannel": false,
                        "response": true
                    ] as [String : Any]
                    
                    if let data = try? JSONSerialization.data(withJSONObject: subscriptionMessage),
                       let jsonString = String(data: data, encoding: .utf8) {
                        client.write(string: jsonString)
                        print("Subscribed to KuCoin futures topic: /contractMarket/ticker:\(futuresSymbol) for pair: \(pair)")
                    }
                }
                
            case .disconnected(let reason, let code):
                ExchangeWebSocket.kucoinFuturesIsConnected = false
                print("‚ùå [KuCoin Futures] WebSocket disconnected: \(reason) (\(code))")
                ExchangeWebSocket.logAlert(event: "‚ùå KuCoin Futures WebSocket disconnected: \(reason)")
                
            case .text(let text):
                if let data = text.data(using: .utf8),
                   let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                    
                    // Handle subscription confirmations
                    if json["type"] as? String == "ack" {
                        print("KuCoin Futures WebSocket subscription confirmed")
                        return
                    }
                    
                    // Handle price data
                    if let subject = json["subject"] as? String,
                       subject == "ticker",
                       let topic = json["topic"] as? String,
                       let data = json["data"] as? [String: Any] {
                        
                        let futuresSymbol = topic.replacingOccurrences(of: "/contractMarket/ticker:", with: "")
                        
                        // Find the pair that matches this futures symbol
                        var pair: String?
                        for (tradingPair, symbol) in ExchangeWebSocket.kucoinFuturesSymbols {
                            if symbol == futuresSymbol {
                                pair = tradingPair
                                break
                            }
                        }
                        
                        if let pair = pair,
                           let priceStr = data["price"] as? String,
                           let price = Double(priceStr), price > 0 {
                            
                            ExchangeWebSocket.kucoinCurrentFuturesPrice[pair] = price
                            ExchangeWebSocket.kucoinFuturesPrices[pair, default: []].append(price)
                            
                            // Maintain price history limit
                            if ExchangeWebSocket.kucoinFuturesPrices[pair]!.count > ExchangeWebSocket.priceHistoryRetention {
                                ExchangeWebSocket.kucoinFuturesPrices[pair]?.removeFirst()
                            }
                            
                            print("‚úÖ [KuCoin Futures] Updated price for \(pair): $\(price)")
                            
                            // Update last data timestamp
                            ExchangeWebSocket.lastDataUpdate[pair] = Date()
                        }
                    }
                }
                
            case .binary(_):
                break
                
            case .ping(_):
                client.write(pong: Data())
                
            case .pong(_):
                break
                
            case .viabilityChanged(_):
                break
                
            case .reconnectSuggested(_):
                Task { @MainActor in
                    ExchangeWebSocket.logAlert(event: "KuCoin Futures WebSocket reconnection suggested")
                }
                
            case .cancelled:
                ExchangeWebSocket.kucoinFuturesIsConnected = false
                print("‚ùå [KuCoin Futures] WebSocket cancelled")
                
            case .error(let error):
                ExchangeWebSocket.kucoinFuturesIsConnected = false
                print("‚ùå [KuCoin Futures] WebSocket error: \(error?.localizedDescription ?? "unknown")")
                ExchangeWebSocket.logAlert(event: "KuCoin Futures WebSocket error: \(error?.localizedDescription ?? "unknown")")
                
            case .peerClosed:
                ExchangeWebSocket.kucoinFuturesIsConnected = false
                print("‚ùå [KuCoin Futures] WebSocket peer closed")
                ExchangeWebSocket.logAlert(event: "KuCoin Futures WebSocket peer closed")
            }
        }
    }
}

class BybitSpotWebSocketDelegate: WebSocketDelegate {
    func didReceive(event: Starscream.WebSocketEvent, client: any Starscream.WebSocketClient) {
        Task { @MainActor in
            switch event {
            case .connected(let headers):
                ExchangeWebSocket.bybitIsConnected = true
                print("‚úÖ [Bybit Spot] WebSocket connected: \(headers)")
                ExchangeWebSocket.logAlert(event: "‚úÖ Bybit Spot WebSocket connected")
                
                // Subscribe to all pairs
                var topics: [String] = []
                for pair in ExchangeWebSocket.tradingPairs {
                    let symbol = pair.replacingOccurrences(of: "-", with: "")
                    topics.append("tickers.\(symbol)")
                    topics.append("orderbook.50.\(symbol)")
                    topics.append("publicTrade.\(symbol)")
                    print("Subscribed to Bybit spot topics: tickers.\(symbol), orderbook.50.\(symbol), publicTrade.\(symbol) for pair: \(pair)")
                }
                
                let subscriptionMessage = [
                    "op": "subscribe",
                    "args": topics
                ] as [String : Any]
                
                if let data = try? JSONSerialization.data(withJSONObject: subscriptionMessage),
                   let jsonString = String(data: data, encoding: .utf8) {
                    client.write(string: jsonString)
                }
                
            case .disconnected(let reason, let code):
                ExchangeWebSocket.bybitIsConnected = false
                print("‚ùå [Bybit Spot] WebSocket disconnected: \(reason) (\(code))")
                ExchangeWebSocket.logAlert(event: "‚ùå Bybit Spot WebSocket disconnected: \(reason)")
                
            case .text(let text):
                if let data = text.data(using: .utf8),
                   let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                    
                    // Handle subscription confirmations
                    if json["op"] as? String == "subscribe" {
                        print("Bybit Spot subscription confirmed")
                        return
                    }
                    
                    // Handle price data
                    if let topic = json["topic"] as? String,
                       let data = json["data"] as? [String: Any] {
                        
                        if topic.hasPrefix("tickers.") {
                            let symbol = topic.replacingOccurrences(of: "tickers.", with: "")
                            let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
                            
                            if let priceStr = data["lastPrice"] as? String,
                               let price = Double(priceStr), price > 0 {
                                
                                ExchangeWebSocket.bybitCurrentPrice[pair] = price
                                ExchangeWebSocket.bybitPrices[pair, default: []].append(price)
                                
                                // Maintain price history limit
                                if ExchangeWebSocket.bybitPrices[pair]!.count > ExchangeWebSocket.priceHistoryRetention {
                                    ExchangeWebSocket.bybitPrices[pair]?.removeFirst()
                                }
                                
                                print("‚úÖ [Bybit Spot] Updated price for \(pair): $\(price)")
                                
                                // Update last data timestamp
                                ExchangeWebSocket.lastDataUpdate[pair] = Date()
                            }
                        }
                    }
                }
                
            case .binary(_):
                break
                
            case .ping(_):
                client.write(pong: Data())
                
            case .pong(_):
                break
                
            case .viabilityChanged(_):
                break
                
            case .reconnectSuggested(_):
                Task { @MainActor in
                    ExchangeWebSocket.logAlert(event: "Bybit Spot WebSocket reconnection suggested")
                }
                
            case .cancelled:
                ExchangeWebSocket.bybitIsConnected = false
                print("‚ùå [Bybit Spot] WebSocket cancelled")
                
            case .error(let error):
                ExchangeWebSocket.bybitIsConnected = false
                print("‚ùå [Bybit Spot] WebSocket error: \(error?.localizedDescription ?? "unknown")")
                ExchangeWebSocket.logAlert(event: "Bybit Spot WebSocket error: \(error?.localizedDescription ?? "unknown")")
                
            case .peerClosed:
                ExchangeWebSocket.bybitIsConnected = false
                print("‚ùå [Bybit Spot] WebSocket peer closed")
                ExchangeWebSocket.logAlert(event: "Bybit Spot WebSocket peer closed")
            }
        }
    }
}

class BybitFuturesWebSocketDelegate: WebSocketDelegate {
    func didReceive(event: Starscream.WebSocketEvent, client: any Starscream.WebSocketClient) {
        Task { @MainActor in
            switch event {
            case .connected(let headers):
                ExchangeWebSocket.bybitFuturesIsConnected = true
                print("‚úÖ [Bybit Futures] WebSocket connected: \(headers)")
                ExchangeWebSocket.logAlert(event: "‚úÖ Bybit Futures WebSocket connected")
                
                // Subscribe to all pairs
                var topics: [String] = []
                for pair in ExchangeWebSocket.tradingPairs {
                    let symbol = pair.replacingOccurrences(of: "-", with: "")
                    topics.append("tickers.\(symbol)")
                    topics.append("orderbook.50.\(symbol)")
                    topics.append("publicTrade.\(symbol)")
                    print("Subscribed to Bybit futures topics: tickers.\(symbol), orderbook.50.\(symbol), publicTrade.\(symbol) for pair: \(pair)")
                }
                
                let subscriptionMessage = [
                    "op": "subscribe",
                    "args": topics
                ] as [String : Any]
                
                if let data = try? JSONSerialization.data(withJSONObject: subscriptionMessage),
                   let jsonString = String(data: data, encoding: .utf8) {
                    client.write(string: jsonString)
                }
                
            case .disconnected(let reason, let code):
                ExchangeWebSocket.bybitFuturesIsConnected = false
                print("‚ùå [Bybit Futures] WebSocket disconnected: \(reason) (\(code))")
                ExchangeWebSocket.logAlert(event: "‚ùå Bybit Futures WebSocket disconnected: \(reason)")
                
            case .text(let text):
                if let data = text.data(using: .utf8),
                   let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                    
                    // Handle subscription confirmations
                    if json["op"] as? String == "subscribe" {
                        print("Bybit Futures subscription confirmed")
                        return
                    }
                    
                    // Handle price data
                    if let topic = json["topic"] as? String,
                       let data = json["data"] as? [String: Any] {
                        
                        if topic.hasPrefix("tickers.") {
                            let symbol = topic.replacingOccurrences(of: "tickers.", with: "")
                            let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
                            
                            if let priceStr = data["lastPrice"] as? String,
                               let price = Double(priceStr), price > 0 {
                                
                                ExchangeWebSocket.bybitCurrentFuturesPrice[pair] = price
                                ExchangeWebSocket.bybitFuturesPrices[pair, default: []].append(price)
                                
                                // Maintain price history limit
                                if ExchangeWebSocket.bybitFuturesPrices[pair]!.count > ExchangeWebSocket.priceHistoryRetention {
                                    ExchangeWebSocket.bybitFuturesPrices[pair]?.removeFirst()
                                }
                                
                                print("‚úÖ [Bybit Futures] Updated price for \(pair): $\(price)")
                                
                                // Update last data timestamp
                                ExchangeWebSocket.lastDataUpdate[pair] = Date()
                            }
                        }
                    }
                }
                
            case .binary(_):
                break
                
            case .ping(_):
                client.write(pong: Data())
                
            case .pong(_):
                break
                
            case .viabilityChanged(_):
                break
                
            case .reconnectSuggested(_):
                Task { @MainActor in
                    ExchangeWebSocket.logAlert(event: "Bybit Futures WebSocket reconnection suggested")
                }
                
            case .cancelled:
                ExchangeWebSocket.bybitFuturesIsConnected = false
                print("‚ùå [Bybit Futures] WebSocket cancelled")
                
            case .error(let error):
                ExchangeWebSocket.bybitFuturesIsConnected = false
                print("‚ùå [Bybit Futures] WebSocket error: \(error?.localizedDescription ?? "unknown")")
                ExchangeWebSocket.logAlert(event: "Bybit Futures WebSocket error: \(error?.localizedDescription ?? "unknown")")
                
            case .peerClosed:
                ExchangeWebSocket.bybitFuturesIsConnected = false
                print("‚ùå [Bybit Futures] WebSocket peer closed")
                ExchangeWebSocket.logAlert(event: "Bybit Futures WebSocket peer closed")
            }
        }
    }
}


//----------------------------------------------------------------------------------------

@MainActor
class ExchangeWebSocket {
    // Starscream WebSockets
    static var kucoinSocket: WebSocket?
    static var kucoinFuturesSocket: WebSocket?
    static var bybitSocket: WebSocket?
    static var bybitSpotSocket: WebSocket?
    static var bybitWebSocket: WebSocket?
    
    static var tradeMetrics: [String: (wins: Int, losses: Int, totalProfit: Double, totalFees: Double)] = [:]
    
    // Connection States
    static var kucoinIsConnected: Bool = false
    static var kucoinFuturesIsConnected: Bool = false
    static var bybitIsConnected: Bool = false
    static var bybitFuturesIsConnected: Bool = false
    
    // WebSocket Tokens
    static var kucoinToken: String?
    static var kucoinFuturesToken: String?
    
    // WebSocket Reconnection Tracking
    static var kucoinReconnectAttempts: Int = 0
    static var kucoinFuturesReconnectAttempts: Int = 0
    static var bybitReconnectAttempts: Int = 0
    static var bybitSpotReconnectAttempts: Int = 0
    static var maxReconnectAttempts: Int = 10
    static var lastHeartbeat: [String: Date] = [:]
    static var messageQueue: [[String: Any]] = []
    static var isProcessingQueue: Bool = false
    static var enhancedMessageQueue: [[String: Any]] = []
    
    static var websocketReconnectAttempts: [String: Int] = [:]
    
    
    
    // WebSocket Activity Monitoring
   
    static var lastWebsocketActivity: [String: Date] = [:]
    static var lastEvolution: Date = .distantPast
    
    // Emergency Controls
    static var emergencyStopActive: Bool = false
    static var consecutiveLosses: [String: Int] = [:]
    static var tradingActive: Bool = true
    static var executionLatencies: [String: [Double]] = [:]
    static var realtimeMetrics: [String: Double] = [:]
    static var strategyAllocations: [String: Double] = [:]
    static var strategyReturns: [String: [Double]] = [:]
    
    // Price Storage
    static var kucoinPrices: [String: [Double]] = [:]
    static var kucoinFuturesPrices: [String: [Double]] = [:]
    static var bybitPrices: [String: [Double]] = [:]
    static var bybitFuturesPrices: [String: [Double]] = [:]
    
    // Current Prices
    static var kucoinCurrentPrice: [String: Double] = [:]
    static var kucoinCurrentFuturesPrice: [String: Double] = [:]
    static var bybitCurrentPrice: [String: Double] = [:]
    static var bybitCurrentFuturesPrice: [String: Double] = [:]
    
    
    
    // Volume Storage
    static var kucoinSpotVolume: [String: [Double]] = [:]
    static var kucoinFuturesVolume: [String: [Double]] = [:]
    static var bybitSpotVolume: [String: [Double]] = [:]
    static var bybitFuturesVolume: [String: [Double]] = [:]
    
    // Order Book Storage
    static var kucoinFuturesOrderBook: [String: [(price: Double, volume: Double, side: String)]] = [:]
    static var bybitFuturesOrderBook: [String: [(price: Double, volume: Double, side: String)]] = [:]
    static var kucoinOrderBooks: [String: BevaixOrderBook] = [:]
    static var bybitOrderBooks: [String: BevaixOrderBook] = [:]
    
    // ATR Storage
    static var kucoinFuturesATR: [String: Double] = [:]
    static var bybitFuturesATR: [String: Double] = [:]
    
    // Trading States
    static var kucoinInSpotTrade: [String: Bool] = [:]
    static var bybitInSpotTrade: [String: Bool] = [:]
    static var kucoinSpotEntryPrice: [String: Double] = [:]
    static var bybitSpotEntryPrice: [String: Double] = [:]
    static var kucoinFuturesEntryPrice: [String: Double] = [:]
    static var bybitFuturesEntryPrice: [String: Double] = [:]
    static var kucoinSpotTrailingStop: [String: Double] = [:]
    static var bybitSpotTrailingStop: [String: Double] = [:]
    static var activeSpotTrades: [String: Int] = [:]
    
    // Arbitrage States
    static var arbitrageExecuted: [String: (Bool, Date)] = [:]
    static var crossExchangeArbitrageExecuted: [String: (Bool, Date)] = [:]
    
    // Funding Rates
    static var bybitFundingRates: [String: Double] = [:]
    static var kucoinFundingRates: [String: Double] = [:]
    static var bybitFundingRateHistory: [String: [Double]] = [:]
    static var kucoinFundingRateHistory: [String: [Double]] = [:]
    
    // Balances
    static var kucoinBalance: Double = 0.0
    static var bybitBalance: Double = 0.0
    static var kucoinBalances: [String: Double] = [:]
    static var bybitBalances: [String: Double] = [:]
    static var kucoinLiveBalance: Double?
    static var bybitLiveBalance: Double?
    
    // Daily Loss Tracking
    static var dailyLoss: [String: Double] = ["bybit": 0.0, "kucoin": 0.0]
    static var lastDailyReset: Date = Date()
    static var portfolioDrawdown: Double = 0.0
    
    // Historical Spreads Storage
    static var historicalSpreads: [String: [Double]] = [:]
    
    // Sentiment Scores
    static var sentimentScores: [String: Double] = [:]
    
    // Multi-Timeframe EMA Storage
    static var kucoinSpotEMA1Min: [String: (short: Double, medium: Double, long: Double)] = [:]
    static var kucoinSpotEMA5Min: [String: (short: Double, medium: Double, long: Double)] = [:]
    static var kucoinSpotEMA15Min: [String: (short: Double, medium: Double, long: Double)] = [:]
    static var bybitSpotEMA1Min: [String: (short: Double, medium: Double, long: Double)] = [:]
    static var bybitSpotEMA5Min: [String: (short: Double, medium: Double, long: Double)] = [:]
    static var bybitSpotEMA15Min: [String: (short: Double, medium: Double, long: Double)] = [:]
    
    // Latency Monitoring
    static var lastLatency: [String: Double] = [:]
    static fileprivate var lastKucoinFetchTime: [String: Date] = [:]
    static fileprivate var lastBybitFetchTime: [String: Date] = [:]
    
    // Order Book Spoofing Detection
    static var orderCancellationEvents: [String: [(timestamp: Date, level: Int, volume: Double)]] = [:]
    static var kucoinOrderBookEvents: [String: [(timestamp: Date, level: Int, volume: Double)]] = [:]
    
    // VaR and Kelly Sizing
    static var varEstimates: [String: Double] = [:]
    static var kellySizes: [String: Double] = [:]
    
    // Performance Dashboard
    static var performanceMetrics: [String: (profit: Double, fees: Double, trades: Int, wins: Int)] = [:]
    
    // Enhanced Trading Variables for Advanced Features
    static var strategyPerformance: [String: PerformanceMetrics] = [:]
    static var mlPredictions: [String: MLPrediction] = [:]
    static var riskMetrics: [String: RiskMetrics] = [:]
    static var advancedSignals: [String: [AdvancedSignal]] = [:]
    static var marketConditions: [String: MarketCondition] = [:]
    static var tradingOpportunities: [TradingOpportunity] = []
    
    // Technical Indicators
    static var emaShort: [String: [Double]] = [:]
    static var emaMedium: [String: [Double]] = [:]
    static var emaLong: [String: [Double]] = [:]
    static var rsiValues: [String: [Double]] = [:]
    static var macdValues: [String: [(macd: Double, signal: Double, histogram: Double)]] = [:]
    static var bollingerBands: [String: [(upper: Double, middle: Double, lower: Double)]] = [:]
    static var atrValues: [String: [Double]] = [:]
    static var vwapValues: [String: [Double]] = [:]
    static var stochasticValues: [String: [(k: Double, d: Double)]] = [:]
    static var williamsR: [String: [Double]] = [:]
    static var cciValues: [String: [Double]] = [:]
    static var mfiValues: [String: [Double]] = [:]
    static var obvValues: [String: [Double]] = [:]
    static var adxValues: [String: [Double]] = [:]
    static var parValues: [String: [Double]] = [:]
    static var ichiValues: [String: [(tenkan: Double, kijun: Double, chikou: Double)]] = [:]
    static var pivotPoints: [String: [(pivot: Double, r1: Double, r2: Double, s1: Double, s2: Double)]] = [:]
    static var fibonacciLevels: [String: [Double]] = [:]
    
    // Sentiment and ML
    static var newsImpact: [String: Double] = [:]
    static var socialSentiment: [String: Double] = [:]
    static var whaleActivity: [String: Double] = [:]
    static var institutionalFlow: [String: Double] = [:]
    
    // Risk Management
    static var correlationMatrix: [String: [String: Double]] = [:]
    static var volatilityScores: [String: Double] = [:]
    static var liquidityScores: [String: Double] = [:]
    static var exposureByPair: [String: Double] = [:]
    static var exposureByStrategy: [String: Double] = [:]
    static var dailyLossByPair: [String: Double] = [:]
    static var dailyLossByExchange: [String: Double] = [:]
    static var maxDrawdownByStrategy: [String: Double] = [:]
    
    // Strategy-Specific Variables
    static var arbitrageOpportunities: [String: Double] = [:]
    static var momentumSignals: [String: Double] = [:]
    static var meanReversionSignals: [String: Double] = [:]
    static var marketMakingSignals: [String: Double] = [:]
    static var hftSignals: [String: Double] = [:]
    
    // Execution Tracking
    static var lastTradeTime: [String: Date] = [:]
    static var cooldownPeriods: [String: TimeInterval] = [:]
    static var executionLatency: [String: [Double]] = [:]
    static var slippageTracking: [String: [Double]] = [:]
    static var fillRates: [String: Double] = [:]
    
    // Position Management
    static var activePositions: [String: Double] = [:]
    static var entryPrices: [String: Double] = [:]
    static var stopLossPrices: [String: Double] = [:]
    static var takeProfitPrices: [String: Double] = [:]
    static var trailingStopPrices: [String: Double] = [:]
    static var positionSizes: [String: Double] = [:]
    static var leverageUsed: [String: Double] = [:]
    
    // Performance Optimization
    static var cpuUsage: Double = 0.0
    static var memoryUsage: Double = 0.0
    static var networkLatency: [String: Double] = [:]
    static var apiCallCounts: [String: Int] = [:]
    static var errorCounts: [String: Int] = [:]
    static var reconnectionCounts: [String: Int] = [:]
    
    // Real-time Monitoring
    static var lastDataUpdate: [String: Date] = [:]
    static var healthStatus: [String: String] = [:]
    static var alertThresholds: [String: Double] = [:]
    static var performanceAlerts: [String] = []
    
    // Missing Variables for Trading Logic
    static var futuresArbitrageExecuted: [String: (profit: Double, timestamp: Date)] = [:]
    static var hftArbitrageExecuted: [String: (profit: Double, timestamp: Date)] = [:]
    static var activeFuturesTrades: [String: Int] = [:]
    static var runningProfitLoss: [String: Double] = [:]
    static var kucoinFuturesBalance: Double = 0.0
    static var bybitFuturesBalance: Double = 0.0
    static var kucoinFuturesPositions: [String: Double] = [:]
    static var bybitFuturesPositions: [String: Double] = [:]
    static var kucoinSymbols: [String: String] = [:]
    static var bybitSymbols: [String: String] = [:]
    static var bybitFuturesSymbols: [String: String] = [:]
    
    // AI Enhancement Variables
    static var quantumProcessor: EvolutionEngine = EvolutionEngine()
    static var neuralSwarm: [NeuralAgent] = []
    static var patternEngine: EvolutionEngine = EvolutionEngine()
    static var temporalOracle: TemporalOracle = TemporalOracle()
    static var evolutionEngine: EvolutionEngine = EvolutionEngine()
    
    
    // Helper for dynamic spread threshold
    static func adjustSpreadThreshold(pair: String, baseThreshold: Double) -> Double {
        let atr = kucoinFuturesATR[pair] ?? 0.01
        let volatility = atr / (kucoinCurrentPrice[pair] ?? 1.0)
        return baseThreshold * (1 + volatility)
    }
    
    // Parameters (will be loaded from .env)
    static var tradingPairs: [String] = []
    static var kucoinFuturesSymbols: [String: String] = [:]
    static var liquidityDepthMultiplier: Double = 0.0
    static var liquidityPriceImpactThreshold: Double = 0.0
    static var orderBookPriceRange: Double = 0.0
    static var orderBookImbalanceThreshold: Double = 0.0
    static var futuresTradeAmount: Double = 0.0
    static var futuresMinProfitPercentage: Double = 0.0
    static var futuresStopLossPercentage: Double = 0.0
    static var futuresTrailingStopPercentage: Double = 0.0
    static var futuresSpikeTrailingStopPercentage: Double = 0.0
    static var maxActiveFuturesTrades: Int = 0
    static var dailyLossLimitPercentage: Double = 0.0
    static var atrMultiplier: Double = 0.0
    static var arbitrageMinBalance: Double = 0.0
    static var arbitrageTradeAmount: Double = 0.0
    static var arbitrageMinSpreadThreshold: Double = 0.001
    static var arbitrageHighSpreadThreshold: Double = 0.005
    static var crossExchangeMinBalance: Double = 0.0
    static var crossExchangeTradeAmount: Double = 0.0
    static var crossExchangeMinSpreadThreshold: Double = 0.002
    static var crossExchangeMinFundingRateThreshold: Double = 0.0
    static var crossExchangeCooldownSeconds: Double = 0.0
    static var volatilityPauseSeconds: Double = 0.0
    static var volatilitySpikeThreshold: Double = 0.0
    static var volatilitySpikeWindowMinutes: Int = 0
    static var volatilitySpikeCooldownSeconds: Int = 0
    static var volumeAnomalyMultiplier: Double = 0.0
    static var volumeAnomalyWindowHours: Int = 0
    static var volumeAnomalyCooldownSeconds: Int = 0
    static var minLiquidityThreshold: Double = 0.0
    static var maxOrderBookImbalance: Double = 0.0
    static var websocketTimeoutSeconds: Int = 0
    static var balanceFetchTimeout: Int = 0
    static var arbitrageThreshold: Double = 0.001
    static var maxFundingRate: Double = 0.0
    static var crossExchangeArbitrageThreshold: Double = 0.002
    static var hftSpreadThreshold: Double = 0.003
    static var hftTradeAmount: Double = 200.0
    static var macdShortPeriod: Int = 0
    static var macdLongPeriod: Int = 0
    static var macdSignalPeriod: Int = 0
    static var macdConfirmationThreshold: Double = 0.0
    static var maxSlippage: Double = 0.0
    static var liquidityCheckInterval: Int = 0
    static var minOrderbookRefreshRate: Int = 0
    static var spotTradeAmount: Double = 0.0
    static var spotFeeRate: Double = 0.0
    static var spotMinProfitPercentage: Double = 0.0
    static var spotStopLossPercentage: Double = 0.0
    static var spotTrailingStopPercentage: Double = 0.0
    static var spotEmaShortPeriod: Int = 0
    static var spotEmaMediumPeriod: Int = 0
    static var spotEmaLongPeriod: Int = 0
    static var spotRsiPeriod: Int = 0
    static var spotRsiUpperThreshold: Double = 0.0
    static var spotRsiLowerThreshold: Double = 0.0
    static var maxActiveSpotTrades: Int = 0
    static var futuresEmaShortPeriod: Int = 0
    static var futuresEmaMediumPeriod: Int = 0
    static var futuresEmaLongPeriod: Int = 0
    static var bybitFuturesFeeRate: Double = 0.0
    static var kucoinFuturesFeeRate: Double = 0.0
    static var bybitFallbackBalance: Double = 0.0
    static var kucoinFallbackBalance: Double = 0.0
    static var bybitRecvWindow: String = ""
    static var kucoinLeverage: String = ""
    static var bybitLeverage: String = ""
    static var priceHistoryRetention: Int = 0
   
    
    // HFT parameters
    static var scalpEntryThreshold: Double = 0.0
    static var scalpProfitTarget: Double = 0.0
    static var scalpStopLoss: Double = 0.0
    static var spoofingVolumeThreshold: Double = 0.0
    static var spoofingProfitTarget: Double = 0.0
    static var slippageTradeAmount: Double = 0.0
    static var fundingMomentumThreshold: Double = 0.0
    static var latencySpikeThreshold: Double = 0.0
    static var hftCooldownSeconds: Double = 0.0

    // Added variables for trading strategy and arbitrage
    static var shortSMAPeriod: Int = 10
    static var longSMAPeriod: Int = 20
    static var bybitPositions: [String: Double] = [:]
    static var kucoinPositions: [String: Double] = [:]
    static var tradeAmountPercentage: Double = 0.1
    static var stopLossPercentage: Double = 0.02
    static var bybitEntryPrices: [String: Double] = [:]
    static var kucoinEntryPrices: [String: Double] = [:]
    static var takeProfitPercentage: Double = 0.05
    static var fundingRateAdjustmentFactor: Double = 0.01

    // New variables for enhanced features
    static var kucoinMakerFee: Double = 0.0002
    static var kucoinTakerFee: Double = 0.0005
    static var bybitMakerFee: Double = 0.0001
    static var bybitTakerFee: Double = 0.0004
    static var lastFeeUpdate: Date = .distantPast
    static var kellyWinProbability: Double = 0.6
    static var kellyRewardToRisk: Double = 2.0
    static var volatilityPauseActive: Bool = false
    static var lastVolatilityPause: Date = .distantPast
    static var lastSummaryTime: Date = .distantPast
    
    
    static var kucoinDelegate: KuCoinSpotWebSocketDelegate?

    static var bybitDelegate: BybitFuturesWebSocketDelegate?
    // Add these inside the ExchangeWebSocket class in Block 1:
    
    
    
    // New variables for performance optimization
    static var lastPriceUpdate: [String: (price: Double, timestamp: Date)] = [:]
    static var isTradingPaused: [String: Bool] = [:]

    // FIXED FUNCTIONS - All missing functions that were causing scope errors
    static func updateDynamicConfiguration() {
        let volatilityLevel = calculateMarketVolatility()
        if volatilityLevel > 0.05 {
            tradingActive = false
            logAlert(event: "High volatility detected, pausing trading")
        } else {
            tradingActive = true
        }
    }
    
    static func updateRiskMetrics() {
        for pair in tradingPairs {
            let prices = kucoinPrices[pair] ?? []
            if prices.count > 100 {
                let returns = zip(prices.dropFirst(), prices.dropLast()).map { (current, previous) in
                    (current - previous) / previous
                }
                
                let variance = calculateVariance(returns)
                let volatility = sqrt(variance)
                
                volatilityScores[pair] = volatility
                
                let maxDD = RiskCalculator.calculateMaxDrawdown(prices: prices)
                maxDrawdownByStrategy[pair] = maxDD
            }
        }
    }
    
    static func assessPortfolioRisk() {
        let totalExposure = exposureByPair.values.reduce(0, +)
        let maxExposure = max(kucoinBalance, bybitBalance) * 0.8
        
        if totalExposure > maxExposure {
            emergencyStopActive = true
            logAlert(event: "Portfolio exposure limit exceeded: \(totalExposure) > \(maxExposure)")
        }
    }
    
    static func monitorDataQuality() {
        let now = Date()
        for pair in tradingPairs {
            if let lastUpdate = lastDataUpdate[pair] {
                let timeSince = now.timeIntervalSince(lastUpdate)
                if timeSince > 60 {
                    logAlert(event: "Stale data detected for \(pair): \(timeSince)s since last update")
                }
            }
        }
    }
    
    static func calculateMarketVolatility() -> Double {
        var volatilities: [Double] = []
        
        for pair in tradingPairs {
            if let volatility = volatilityScores[pair] {
                volatilities.append(volatility)
            }
        }
        
        guard !volatilities.isEmpty else { return 0.0 }
        return volatilities.reduce(0, +) / Double(volatilities.count)
    }
    
    static func calculateVariance(_ values: [Double]) -> Double {
        guard !values.isEmpty else { return 0.0 }
        let mean = values.reduce(0, +) / Double(values.count)
        let squaredDiffs = values.map { pow($0 - mean, 2) }
        return squaredDiffs.reduce(0, +) / Double(squaredDiffs.count)
    }
    
    static func calculateMomentumSignal(pair: String) -> Double {
        let prices = kucoinPrices[pair] ?? []
        guard prices.count >= 20 else { return 0.0 }
        
        let recentPrices = Array(prices.suffix(20))
        let priceChange = (recentPrices.last! - recentPrices.first!) / recentPrices.first!
        return priceChange
    }
    
    static func calculateMeanReversionSignal(pair: String) -> Double {
        let prices = kucoinPrices[pair] ?? []
        guard prices.count >= 50 else { return 0.0 }
        
        let recentPrices = Array(prices.suffix(50))
        let sma = recentPrices.reduce(0, +) / Double(recentPrices.count)
        let currentPrice = recentPrices.last!
        return (sma - currentPrice) / currentPrice
    }
    
    static func calculateMarketMakingSignal(pair: String) -> Double {
        let orderBook = kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
        guard !orderBook.bids.isEmpty, !orderBook.asks.isEmpty else { return 0.0 }
        
        let bestBid = orderBook.bids.first!.price
        let bestAsk = orderBook.asks.first!.price
        let spread = (bestAsk - bestBid) / bestBid
        return spread > 0.001 ? 1.0 : 0.0
    }

    // Helper for order book imbalance calculation
    static func calculateOrderBookImbalance(book: BevaixOrderBook) -> Double {
        let bidVolume = book.bids.reduce(0.0) { $0 + $1.quantity }
        let askVolume = book.asks.reduce(0.0) { $0 + $1.quantity }
        return bidVolume > 0 && askVolume > 0 ? max(bidVolume, askVolume) / min(bidVolume, askVolume) : 0.0
    }
    
    static func calculateOrderBookImbalanceFutures(book: [(price: Double, volume: Double, side: String)]) -> Double {
        let bidVolume = book.filter { $0.side == "buy" }.reduce(0.0) { $0 + $1.volume }
        let askVolume = book.filter { $0.side == "sell" }.reduce(0.0) { $0 + $1.volume }
        return bidVolume > 0 && askVolume > 0 ? max(bidVolume, askVolume) / min(bidVolume, askVolume) : 0.0
    }

    // WebSocket order book update with validation
    static func updateOrderBook(pair: String, exchange: String, message: [String: Any]) {
        let startTime = Date()
        Task { @MainActor in
            let latency = Date().timeIntervalSince(startTime) * 1000
            if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 80.0) {
                logAlert(event: "High latency detected for order book fetch for \(exchange)-\(pair): \(latency)ms")
            }

            guard let data = message["data"] as? [String: Any],
                  let bids = data["bids"] as? [[String]], let asks = data["asks"] as? [[String]] else {
                logAlert(event: "Invalid order book response for \(exchange)-\(pair)-spot")
                return
            }

            var parsedBids: [(price: Double, quantity: Double)] = []
            var parsedAsks: [(price: Double, quantity: Double)] = []
            var parseError = false

            for bid in bids {
                if bid.count >= 2, let price = Double(bid[0]), let quantity = Double(bid[1]), price > 0, quantity > 0 {
                    parsedBids.append((price: price, quantity: quantity))
                } else {
                    parseError = true
                    break
                }
            }
            for ask in asks {
                if ask.count >= 2, let price = Double(ask[0]), let quantity = Double(ask[1]), price > 0, quantity > 0 {
                    parsedAsks.append((price: price, quantity: quantity))
                } else {
                    parseError = true
                    break
                }
            }

            if parseError || parsedBids.isEmpty || parsedAsks.isEmpty {
                logAlert(event: "Invalid order book response for \(exchange)-\(pair)-spot: Parse error or empty data")
                return
            }

            let orderBook = BevaixOrderBook(bids: parsedBids, asks: parsedAsks)
            if exchange == "kucoin" {
                kucoinOrderBooks[pair] = orderBook
            } else {
                bybitOrderBooks[pair] = orderBook
            }

            // Check for imbalance
            let imbalance = calculateOrderBookImbalance(book: orderBook)
            if imbalance > getDouble("MAX_ORDER_BOOK_IMBALANCE", defaultValue: 20.0) {
                logAlert(event: "Order book imbalance for \(exchange)-\(pair)-spot: Imbalance \(imbalance)")
            }
        }
    }

    // Price update with zero-price validation
    static func updatePrice(pair: String, exchange: String, price: Double) {
        Task { @MainActor in
            if price <= 0 {
                logAlert(event: "Zero price detected for \(exchange)-\(pair)")
                return
            }
            if exchange == "kucoin" {
                kucoinCurrentPrice[pair] = price
                kucoinPrices[pair, default: []].append(price)
                if kucoinPrices[pair]!.count > getInt("PRICE_HISTORY_RETENTION", defaultValue: 1440) {
                    kucoinPrices[pair]?.removeFirst()
                }
            } else {
                bybitCurrentPrice[pair] = price
                bybitPrices[pair, default: []].append(price)
                if bybitPrices[pair]!.count > getInt("PRICE_HISTORY_RETENTION", defaultValue: 1440) {
                    bybitPrices[pair]?.removeFirst()
                }
            }
            lastPriceUpdate[pair] = (price: price, timestamp: Date())
        }
    }

    // WebSocket message handling with retry logic
    static func handleWebSocketMessage(socket: WebSocket, message: [String: Any], exchange: String) async {
        let startTime = Date()
        guard let topic = message["topic"] as? String else {
            await MainActor.run {
                logAlert(event: "Invalid WebSocket message format for \(exchange): Missing topic")
            }
            return
        }

        let maxRetries = getInt("MAX_RECONNECT_ATTEMPTS", defaultValue: 10)
        if topic.contains("level2") || topic.contains("orderbook") {
            if let pair = extractPairFromTopic(topic) {
                var retries = 0
                while retries < maxRetries {
                    updateOrderBook(pair: pair, exchange: exchange, message: message)
                    // Check if update was successful by verifying order book data
                    let orderBook = exchange == "kucoin" ? kucoinOrderBooks[pair] : bybitOrderBooks[pair]
                    if orderBook != nil && !orderBook!.bids.isEmpty && !orderBook!.asks.isEmpty {
                        break
                    }
                    retries += 1
                    await MainActor.run {
                        logAlert(event: "Failed to update order book for \(exchange)-\(pair), retry \(retries)/\(maxRetries)")
                    }
                    if retries == maxRetries {
                        await MainActor.run {
                            logAlert(event: "Max retries reached for order book fetch: \(exchange)-\(pair)-spot")
                        }
                    }
                    try? await Task.sleep(nanoseconds: UInt64(1_000_000_000)) // 1-second delay
                }
            }
        } else if topic.contains("ticker") {
            if let pair = extractPairFromTopic(topic), let data = message["data"] as? [String: Any], let price = data["bestAskPrice"] as? String, let priceDouble = Double(price), priceDouble > 0 {
                updatePrice(pair: pair, exchange: exchange, price: priceDouble)
            } else {
                await MainActor.run {
                    logAlert(event: "Invalid ticker response for \(exchange): \(message)")
                }
            }
        }

        let latency = Date().timeIntervalSince(startTime) * 1000
        if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 80.0) {
            await MainActor.run {
                logAlert(event: "High latency detected for WebSocket message processing for \(exchange): \(latency)ms")
            }
        }
    }

    static func extractPairFromTopic(_ topic: String) -> String? {
        let components = topic.split(separator: ":")
        if components.count > 1 {
            let pair = String(components[1]).replacingOccurrences(of: "USDTM", with: "-USDT")
            return tradingPairs.contains(pair) ? pair : nil
        }
        return nil
    }
    // Add this function right after logDashboardMetrics function
    @MainActor
    static func writeDashboardJSON() {
        let dashboardURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/dashboard.json")
        
        let dashboardData: [String: Any] = [
            "timestamp": ISO8601DateFormatter().string(from: Date()),
            "kucoinBalance": kucoinBalance,
            "bybitBalance": bybitBalance,
            "kucoinFuturesBalance": kucoinFuturesBalance,
            "bybitFuturesBalance": bybitFuturesBalance,
            "totalTrades": performanceMetrics.values.reduce(0) { $0 + $1.trades },
            "totalProfit": performanceMetrics.values.reduce(0.0) { $0 + $1.profit },
            "totalFees": performanceMetrics.values.reduce(0.0) { $0 + $1.fees },
            "tradingPairs": tradingPairs,
            "prices": [
                "kucoin": kucoinCurrentPrice,
                "bybit": bybitCurrentPrice,
                "kucoinFutures": kucoinCurrentFuturesPrice,
                "bybitFutures": bybitCurrentFuturesPrice
            ]
        ]
        
        do {
            let jsonData = try JSONSerialization.data(withJSONObject: dashboardData, options: .prettyPrinted)
            try jsonData.write(to: dashboardURL)
            print("DEBUG: Updated dashboard.json with balances - KuCoin: \(kucoinBalance), Bybit: \(bybitBalance)")
        } catch {
            print("DEBUG: Failed to write dashboard.json: \(error.localizedDescription)")
            logAlert(event: "Failed to write dashboard.json: \(error.localizedDescription)")
        }
    }

    static func initializeParameters(completion: @escaping () -> Void) {
        let rawPairs = environment["ACTIVE_PAIRS"] ?? "BTC-USDT,ETH-USDT,SOL-USDT,LINK-USDT,FLOKI-USDT,TON-USDT,NEAR-USDT,ARB-USDT,WIF-USDT,PEPE-USDT,BONK-USDT,SHIB-USDT,XRP-USDT,ADA-USDT,DOGE-USDT,AVAX-USDT,DOT-USDT,MATIC-USDT,SUI-USDT,APT-USDT,INJ-USDT,OP-USDT"
        print("DEBUG: Raw ACTIVE_PAIRS from .env: \(rawPairs)")
        tradingPairs = rawPairs.split(separator: ",").map { String($0).trimmingCharacters(in: .whitespaces) }
        print("DEBUG: Loaded tradingPairs: \(tradingPairs)")
        print("DEBUG: Number of pairs loaded: \(tradingPairs.count)")

        // FIXED: Use proper fallback balance values from .env file
        let kucoinInitialBalance = getDouble("KUCOIN_FALLBACK_BALANCE", defaultValue: 522.235326)
        let bybitInitialBalance = getDouble("BYBIT_FALLBACK_BALANCE", defaultValue: 716.65266351)
        kucoinBalance = kucoinInitialBalance
        bybitBalance = bybitInitialBalance
        kucoinFuturesBalance = kucoinInitialBalance  // FIXED: Initialize futures balance
        bybitFuturesBalance = bybitInitialBalance    // FIXED: Initialize futures balance
        
        tradingPairs.forEach { pair in
            let kucoinAllocation = kucoinInitialBalance / Double(tradingPairs.count)
            let bybitAllocation = bybitInitialBalance / Double(tradingPairs.count)
            kucoinBalances[pair] = kucoinAllocation
            bybitBalances[pair] = bybitAllocation
        }

        fetchKuCoinFuturesSymbols {
            Task { @MainActor in
                if kucoinFuturesSymbols.isEmpty {
                    for pair in tradingPairs {
                        let components = pair.components(separatedBy: "-")
                        if components.count == 2 {
                            let base = components[0]
                            let quote = components[1]
                            let adjustedBase = base == "BTC" ? "XBT" : base
                            kucoinFuturesSymbols[pair] = "\(adjustedBase)\(quote)M"
                        } else {
                            print("DEBUG: Invalid trading pair format: \(pair)")
                            Task { @MainActor in
                                logAlert(event: "Invalid trading pair format: \(pair)")
                            }
                        }
                    }
                }
                print("DEBUG: Initialized kucoinFuturesSymbols: \(kucoinFuturesSymbols)")
                
                // Initialize storage dictionaries for all pairs
                tradingPairs.forEach { pair in
                    kucoinPrices[pair] = kucoinPrices[pair] ?? []
                    kucoinFuturesPrices[pair] = kucoinFuturesPrices[pair] ?? []
                    bybitPrices[pair] = bybitPrices[pair] ?? []
                    bybitFuturesPrices[pair] = bybitFuturesPrices[pair] ?? []
                    kucoinCurrentPrice[pair] = kucoinCurrentPrice[pair] ?? 0.0
                    kucoinCurrentFuturesPrice[pair] = kucoinCurrentFuturesPrice[pair] ?? 0.0
                    bybitCurrentPrice[pair] = bybitCurrentPrice[pair] ?? 0.0
                    bybitCurrentFuturesPrice[pair] = bybitCurrentFuturesPrice[pair] ?? 0.0
                    bybitPositions[pair] = bybitPositions[pair] ?? 0.0
                    kucoinPositions[pair] = kucoinPositions[pair] ?? 0.0
                    kucoinSpotVolume[pair] = kucoinSpotVolume[pair] ?? []
                    kucoinFuturesVolume[pair] = kucoinFuturesVolume[pair] ?? []
                    bybitSpotVolume[pair] = bybitSpotVolume[pair] ?? []
                    bybitFuturesVolume[pair] = bybitFuturesVolume[pair] ?? []
                    kucoinFuturesOrderBook[pair] = kucoinFuturesOrderBook[pair] ?? []
                    bybitFuturesOrderBook[pair] = bybitFuturesOrderBook[pair] ?? []
                    kucoinOrderBooks[pair] = kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
                    bybitOrderBooks[pair] = bybitOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
                    bybitFundingRateHistory[pair] = bybitFundingRateHistory[pair] ?? []
                    kucoinFundingRateHistory[pair] = kucoinFundingRateHistory[pair] ?? []
                    sentimentScores[pair] = sentimentScores[pair] ?? 0.0
                    kucoinSpotEMA1Min[pair] = kucoinSpotEMA1Min[pair] ?? (short: 0.0, medium: 0.0, long: 0.0)
                    kucoinSpotEMA5Min[pair] = kucoinSpotEMA5Min[pair] ?? (short: 0.0, medium: 0.0, long: 0.0)
                    kucoinSpotEMA15Min[pair] = kucoinSpotEMA15Min[pair] ?? (short: 0.0, medium: 0.0, long: 0.0)
                    bybitSpotEMA1Min[pair] = bybitSpotEMA1Min[pair] ?? (short: 0.0, medium: 0.0, long: 0.0)
                    bybitSpotEMA5Min[pair] = bybitSpotEMA5Min[pair] ?? (short: 0.0, medium: 0.0, long: 0.0)
                    bybitSpotEMA15Min[pair] = bybitSpotEMA15Min[pair] ?? (short: 0.0, medium: 0.0, long: 0.0)
                    lastLatency[pair] = lastLatency[pair] ?? 0.0
                    orderCancellationEvents[pair] = orderCancellationEvents[pair] ?? []
                    varEstimates[pair] = varEstimates[pair] ?? 0.0
                    kellySizes[pair] = kellySizes[pair] ?? 0.0
                    performanceMetrics[pair] = performanceMetrics[pair] ?? (profit: 0.0, fees: 0.0, trades: 0, wins: 0)
                    tradeMetrics[pair] = tradeMetrics[pair] ?? (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)
                    kucoinOrderBookEvents[pair] = kucoinOrderBookEvents[pair] ?? []
                    print("DEBUG: Initialized storage for pair: \(pair)")
                }

                // Load other parameters
                liquidityDepthMultiplier = getDouble("LIQUIDITY_DEPTH_MULTIPLIER", defaultValue: 7.0)
                liquidityPriceImpactThreshold = getDouble("LIQUIDITY_PRICE_IMPACT_THRESHOLD", defaultValue: 0.005)
                orderBookPriceRange = getDouble("ORDER_BOOK_PRICE_RANGE", defaultValue: 0.005)
                orderBookImbalanceThreshold = getDouble("ORDER_BOOK_IMBALANCE_THRESHOLD", defaultValue: 1.5)
                minLiquidityThreshold = getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 500.0)
                maxOrderBookImbalance = getDouble("MAX_ORDER_BOOK_IMBALANCE", defaultValue: 20.0)
                volatilitySpikeThreshold = getDouble("VOLATILITY_SPIKE_THRESHOLD", defaultValue: 0.05)
                volatilitySpikeWindowMinutes = getInt("VOLATILITY_SPIKE_WINDOW_MINUTES", defaultValue: 5)
                volatilitySpikeCooldownSeconds = getInt("VOLATILITY_SPIKE_COOLDOWN_SECONDS", defaultValue: 900)
                volumeAnomalyMultiplier = getDouble("VOLUME_ANOMALY_MULTIPLIER", defaultValue: 5.0)
                volumeAnomalyWindowHours = getInt("VOLUME_ANOMALY_WINDOW_HOURS", defaultValue: 1)
                volumeAnomalyCooldownSeconds = getInt("VOLUME_ANOMALY_COOLDOWN_SECONDS", defaultValue: 1800)
                futuresTradeAmount = getDouble("FUTURES_TRADE_AMOUNT", defaultValue: 600.0)  // FIXED: Use .env value
                futuresMinProfitPercentage = getDouble("FUTURES_MIN_PROFIT_PERCENTAGE", defaultValue: 0.0010)  // FIXED: Use .env value
                futuresStopLossPercentage = getDouble("FUTURES_STOP_LOSS_PERCENTAGE", defaultValue: 0.0020)
                futuresTrailingStopPercentage = getDouble("FUTURES_TRAILING_STOP_PERCENTAGE", defaultValue: 0.0020)
                futuresSpikeTrailingStopPercentage = getDouble("FUTURES_SPIKE_TRAILING_STOP_PERCENTAGE", defaultValue: 0.004)
                maxActiveFuturesTrades = getInt("MAX_ACTIVE_FUTURES_TRADES", defaultValue: 30)  // FIXED: Use .env value
                dailyLossLimitPercentage = getDouble("DAILY_LOSS_LIMIT_PERCENTAGE", defaultValue: 0.08)
                atrMultiplier = getDouble("ATR_MULTIPLIER", defaultValue: 0.8)
                arbitrageMinBalance = getDouble("ARBITRAGE_MIN_BALANCE", defaultValue: 20.0)
                arbitrageTradeAmount = getDouble("ARBITRAGE_TRADE_AMOUNT", defaultValue: 500.0)
                arbitrageMinSpreadThreshold = getDouble("ARBITRAGE_MIN_SPREAD_THRESHOLD", defaultValue: 0.0030)
                arbitrageHighSpreadThreshold = getDouble("ARBITRAGE_HIGH_SPREAD_THRESHOLD", defaultValue: 0.0035)
                crossExchangeMinBalance = getDouble("CROSS_EXCHANGE_MIN_BALANCE", defaultValue: 300.0)
                crossExchangeTradeAmount = getDouble("CROSS_EXCHANGE_TRADE_AMOUNT", defaultValue: 300.0)
                crossExchangeMinSpreadThreshold = getDouble("CROSS_EXCHANGE_MIN_SPREAD_THRESHOLD", defaultValue: 0.0020)
                crossExchangeMinFundingRateThreshold = getDouble("CROSS_EXCHANGE_MIN_FUNDING_RATE_THRESHOLD", defaultValue: 0.0000005)
                crossExchangeCooldownSeconds = getDouble("CROSS_EXCHANGE_COOLDOWN_SECONDS", defaultValue: 0.2)
                volatilityPauseSeconds = getDouble("VOLATILITY_PAUSE_SECONDS", defaultValue: 300)
                spotTradeAmount = getDouble("SPOT_TRADE_AMOUNT", defaultValue: 50.0)  // FIXED: Use .env value
                spotFeeRate = getDouble("SPOT_FEE_RATE", defaultValue: 0.001)
                spotMinProfitPercentage = getDouble("SPOT_MINUTE_PROFIT_PERCENTAGE", defaultValue: 0.0030)
                spotStopLossPercentage = getDouble("SPOT_STOP_LOSS_PERCENTAGE", defaultValue: 0.0020)
                spotTrailingStopPercentage = getDouble("SPOT_TRAILING_STOP_PERCENTAGE", defaultValue: 0.0010)
                spotEmaShortPeriod = getInt("SPOT_EMA_SHORT_PERIOD", defaultValue: 5)
                spotEmaMediumPeriod = getInt("SPOT_EMA_MEDIUM_PERIOD", defaultValue: 10)
                spotEmaLongPeriod = getInt("SPOT_EMA_LONG_PERIOD", defaultValue: 20)
                spotRsiPeriod = getInt("SPOT_RSI_PERIOD", defaultValue: 14)
                spotRsiUpperThreshold = getDouble("SPOT_RSI_UPPER_THRESHOLD", defaultValue: 70.0)
                spotRsiLowerThreshold = getDouble("SPOT_RSI_LOWER_THRESHOLD", defaultValue: 30.0)
                maxActiveSpotTrades = getInt("MAX_ACTIVE_SPOT_TRADES", defaultValue: 20)
                futuresEmaShortPeriod = getInt("FUTURES_EMA_SHORT_PERIOD", defaultValue: 5)
                futuresEmaMediumPeriod = getInt("FUTURES_EMA_MEDIUM_PERIOD", defaultValue: 10)
                futuresEmaLongPeriod = getInt("FUTURES_EMA_LONG_PERIOD", defaultValue: 20)
                bybitFuturesFeeRate = getDouble("BYBIT_FUTURES_FEE_RATE", defaultValue: 0.0002)
                kucoinFuturesFeeRate = getDouble("KUCOIN_FUTURES_FEE_RATE", defaultValue: 0.0002)
                bybitFallbackBalance = getDouble("BYBIT_FALLBACK_BALANCE", defaultValue: 716.65266351)
                kucoinFallbackBalance = getDouble("KUCOIN_FALLBACK_BALANCE", defaultValue: 522.235326)
                bybitRecvWindow = environment["BYBIT_RECV_WINDOW"] ?? "5000"
                kucoinLeverage = environment["KUCOIN_LEVERAGE"] ?? "6"
                bybitLeverage = environment["BYBIT_LEVERAGE"] ?? "6"
                priceHistoryRetention = getInt("PRICE_HISTORY_RETENTION", defaultValue: 2880)
                websocketTimeoutSeconds = getInt("WEBSOCKET_TIMEOUT_SECONDS", defaultValue: 8)
                balanceFetchTimeout = getInt("BALANCE_FETCH_TIMEOUT", defaultValue: 12)
                maxFundingRate = getDouble("MAX_FUNDING_RATE", defaultValue: 0.0005)
                macdShortPeriod = getInt("MACD_SHORT_PERIOD", defaultValue: 8)
                macdLongPeriod = getInt("MACD_LONG_PERIOD", defaultValue: 20)
                macdSignalPeriod = getInt("MACD_SIGNAL_PERIOD", defaultValue: 6)
                macdConfirmationThreshold = getDouble("MACD_CONFIRMATION_THRESHOLD", defaultValue: 0.0001)
                maxSlippage = getDouble("MAX_SLIPPAGE", defaultValue: 0.005)
                liquidityCheckInterval = getInt("LIQUIDITY_CHECK_INTERVAL", defaultValue: 30)
                minOrderbookRefreshRate = getInt("MIN_ORDERBOOK_REFRESH_RATE", defaultValue: 1)
                scalpEntryThreshold = getDouble("SCALP_ENTRY_THRESHOLD", defaultValue: 0.0006)
                scalpProfitTarget = getDouble("SCALP_PROFIT_TARGET", defaultValue: 0.0040)
                scalpStopLoss = getDouble("SCALP_STOP_LOSS", defaultValue: 0.0015)
                spoofingVolumeThreshold = getDouble("SPOOFING_VOLUME_THRESHOLD", defaultValue: 1.5)
                spoofingProfitTarget = getDouble("SPOOFING_PROFIT_TARGET", defaultValue: 0.008)
                slippageTradeAmount = getDouble("SLIPPAGE_TRADE_AMOUNT", defaultValue: 100.0)
                fundingMomentumThreshold = getDouble("FUNDING_MOMENTUM_THRESHOLD", defaultValue: 0.00008)
                latencySpikeThreshold = getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 500.0)
                hftCooldownSeconds = getDouble("HFT_COOLDOWN_SECONDS", defaultValue: 1.5)
                
                print("DEBUG: Initialized balances - KuCoin: \(kucoinBalance), KuCoin Futures: \(kucoinFuturesBalance)")
                print("DEBUG: Initialized balances - Bybit: \(bybitBalance), Bybit Futures: \(bybitFuturesBalance)")
                print("DEBUG: Initialized futures trade amount: \(futuresTradeAmount)")
                print("DEBUG: Initialized spot trade amount: \(spotTradeAmount)")

                // Fetch initial sentiment scores
                for pair in tradingPairs {
                    fetchSentimentScore(pair: pair) { score in
                        Task { @MainActor in
                            sentimentScores[pair] = score ?? 0.0
                            print("DEBUG: Initialized sentiment score for \(pair): \(sentimentScores[pair] ?? 0.0)")
                        }
                    }
                }

                // Schedule periodic dashboard updates
                Task {
                    while true {
                        do {
                            try await Task.sleep(nanoseconds: 10_000_000_000) // Every 10 seconds
                            logDashboardMetrics()
                        } catch {
                            print("DEBUG: Dashboard update sleep interrupted: \(error.localizedDescription)")
                            Task { @MainActor in
                                logAlert(event: "Dashboard update sleep interrupted: \(error.localizedDescription)")
                            }
                        }
                    }
                }

                completion()
            }
        }
    }
    
    // FIXED fetchSentimentScore with proper async access
    static func fetchSentimentScore(pair: String, completion: @escaping @Sendable (Double?) -> Void) {
        Task { @MainActor in
            let envValue = await MainActor.run { environment }
            let url = URL(string: envValue["SENTIMENT_SERVER_URL"] ?? "http://127.0.0.1:5001/sentiment")!
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.addValue("application/json", forHTTPHeaderField: "Content-Type")
            request.timeoutInterval = Double(getInt("BALANCE_FETCH_TIMEOUT", defaultValue: 20))

            let payload: [String: Any] = ["pair": pair]
            do {
                let jsonData = try JSONSerialization.data(withJSONObject: payload, options: [])
                request.httpBody = jsonData
            } catch {
                print("DEBUG: Failed to serialize sentiment payload for \(pair): \(error.localizedDescription)")
                logAlert(event: "Failed to serialize sentiment payload for \(pair): \(error.localizedDescription)")
                completion(nil)
                return
            }

            let startTime = Date()
            let task = URLSession.shared.dataTask(with: request) { data, response, error in
                let latency = Date().timeIntervalSince(startTime) * 1000
                Task { @MainActor in
                    lastLatency["sentiment-\(pair)"] = latency
                    if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 80.0) {
                        logAlert(event: "üü¢ High latency detected for sentiment score fetch for \(pair): \(latency)ms")
                    }
                }

                if let error = error {
                    print("DEBUG: Failed to fetch sentiment for \(pair): \(error.localizedDescription)")
                    Task { @MainActor in
                        logAlert(event: "üü¢ Failed to fetch sentiment for \(pair): \(error.localizedDescription)")
                    }
                    completion(nil)
                    return
                }

                guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200,
                      let data = data,
                      let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                      let sentimentScore = json["sentiment_score"] as? Double else {
                    let responseBody = data != nil ? String(data: data!, encoding: .utf8) ?? "Invalid data" : "No data"
                    print("DEBUG: Invalid sentiment response for \(pair): \(responseBody)")
                    Task { @MainActor in
                        logAlert(event: "üü¢ Invalid sentiment response for \(pair): \(responseBody)")
                    }
                    completion(nil)
                    return
                }

                // Validate sentiment score range (-1 to 1)
                if sentimentScore < -1.0 || sentimentScore > 1.0 {
                    print("DEBUG: Invalid sentiment score \(sentimentScore) for \(pair), expected range -1.0 to 1.0")
                    Task { @MainActor in
                        logAlert(event: "üü¢ Invalid sentiment score \(sentimentScore) for \(pair), expected range -1.0 to 1.0")
                    }
                    completion(nil)
                    return
                }

                Task { @MainActor in
                    sentimentScores[pair] = sentimentScore
                    print("DEBUG: Fetched sentiment score for \(pair): \(sentimentScore)")
                    logAlert(event: "üü¢ SUCCESS: Fetched sentiment score for \(pair): \(sentimentScore)")
                }
                completion(sentimentScore)
            }
            task.resume()
        }
    }

    static func fetchKuCoinFuturesSymbols(completion: @escaping () -> Void) {
        if kucoinFuturesSymbols.isEmpty {
            for pair in tradingPairs {
                let components = pair.components(separatedBy: "-")
                if components.count == 2 {
                    let base = components[0]
                    let quote = components[1]
                    let adjustedBase = base == "BTC" ? "XBT" : base
                    kucoinFuturesSymbols[pair] = "\(adjustedBase)\(quote)M"
                } else {
                    print("DEBUG: Invalid trading pair format: \(pair)")
                    logAlert(event: "Invalid trading pair format: \(pair)")
                }
            }
        }
        print("DEBUG: Initialized kucoinFuturesSymbols: \(kucoinFuturesSymbols)")
        completion()
    }
}
