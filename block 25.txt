// --------------------------------------------------------- Block 25 - Self-Evolution & Learning System

// Genetic evolution (mutate/crossover for strats)
struct EvolvableStrategy: Sendable {
    let id = UUID()
    var genome: [Double]
    var fitness: Double = 0
    var trades: Int = 0
    var winRate: Double = 0
    var generation: Int = 0
    var age: Int = 0
    var specialization: String = "general"
    
    init(genome: [Double]? = nil) {
        self.genome = genome ?? (0..<100).map { _ in Double.random(in: 0...1) }
    }
    
    mutating func mutate(rate: Double = 0.02, strength: Double = 0.1) {
        for i in genome.indices {
            if Double.random(in: 0...1) < rate {
                genome[i] += Double.random(in: -strength...strength)
                genome[i] = max(-1.0, min(1.0, genome[i]))  // Clamp to valid range
            }
        }
        generation += 1
        age += 1
    }
    
    func crossover(with other: EvolvableStrategy) -> EvolvableStrategy {
        var newGenome = [Double]()
        let crossoverPoint = Int.random(in: 1..<genome.count-1)
        
        // Two-point crossover
        for i in 0..<genome.count {
            if i < crossoverPoint {
                newGenome.append(genome[i])
            } else {
                newGenome.append(other.genome[i])
            }
        }
        
        var offspring = EvolvableStrategy(genome: newGenome)
        offspring.generation = max(generation, other.generation) + 1
        offspring.specialization = fitness > other.fitness ? specialization : other.specialization
        return offspring
    }
    
    func calculateFitnessScore(profitability: Double, consistency: Double, risk: Double) -> Double {
        // Multi-objective fitness function
        let profitScore = profitability * 0.4
        let consistencyScore = consistency * 0.3
        let riskAdjustedScore = (1.0 - risk) * 0.3
        return profitScore + consistencyScore + riskAdjustedScore
    }
    
    mutating func updatePerformance(profit: Double, win: Bool) {
        trades += 1
        winRate = (winRate * Double(trades - 1) + (win ? 1.0 : 0.0)) / Double(trades)
        
        // Update fitness based on recent performance
        let recentProfit = profit / 100.0  // Normalize
        let consistency = winRate
        let riskMetric = abs(profit) / 100.0  // Simple risk measure
        
        fitness = calculateFitnessScore(
            profitability: recentProfit,
            consistency: consistency,
            risk: min(1.0, riskMetric)
        )
    }
}

actor EvolutionEngine {
    var generation = 0
    var pool: [EvolvableStrategy] = (0..<64).map { _ in EvolvableStrategy() }  // Larger population
    var eliteSize: Int = 8
    var tournamentSize: Int = 4
    var mutationRate: Double = 0.02
    var crossoverRate: Double = 0.8
    var speciesNiches: [String: [EvolvableStrategy]] = [:]
    
    func evolveStrategies() async {
        generation += 1
        
        // Evaluate fitness (simulate performance)
        await evaluateFitness()
        
        // Sort by fitness
        pool.sort { $0.fitness > $1.fitness }
        
        // Preserve elite strategies
        let elite = Array(pool.prefix(eliteSize))
        var newPool = elite
        
        // Generate offspring
        while newPool.count < pool.count {
            let parent1 = tournamentSelection()
            let parent2 = tournamentSelection()
            
            var offspring: EvolvableStrategy
            if Double.random(in: 0...1) < crossoverRate {
                offspring = parent1.crossover(with: parent2)
            } else {
                offspring = parent1  // Clone parent
            }
            
            // Mutate offspring
            offspring.mutate(rate: mutationRate, strength: 0.1)
            newPool.append(offspring)
        }
        
        pool = newPool
        await specializeStrategies()
        await pruneWeakStrategies()
    }
    
    private func evaluateFitness() async {
        // Simulate strategy performance evaluation
        for i in pool.indices {
            let basePerformance = Double.random(in: -0.5...2.0)  // -50% to 200% return
            let consistency = Double.random(in: 0.3...0.9)      // 30% to 90% win rate
            let risk = Double.random(in: 0.1...0.8)             // Risk metric
            
            pool[i].fitness = pool[i].calculateFitnessScore(
                profitability: basePerformance,
                consistency: consistency,
                risk: risk
            )
            
            // Age penalty for very old strategies
            if pool[i].age > 100 {
                pool[i].fitness *= 0.9  // 10% fitness penalty
            }
        }
    }
    
    private func tournamentSelection() -> EvolvableStrategy {
        let tournament = Array(pool.shuffled().prefix(tournamentSize))
        return tournament.max(by: { $0.fitness < $1.fitness }) ?? pool.first!
    }
    
    private func specializeStrategies() async {
        // Group strategies by performance characteristics
        speciesNiches.removeAll()
        
        for strategy in pool {
            var niche = "general"
            
            if strategy.winRate > 0.7 {
                niche = "high_consistency"
            } else if strategy.fitness > 1.5 {
                niche = "high_profit"
            } else if strategy.age > 50 {
                niche = "experienced"
            }
            
            speciesNiches[niche, default: []].append(strategy)
        }
    }
    
    private func pruneWeakStrategies() async {
        // Remove strategies that are consistently poor performers
        pool = pool.filter { strategy in
            if strategy.age > 20 && strategy.fitness < 0.2 {
                return false  // Remove weak old strategies
            }
            return true
        }
        
        // Ensure minimum population size
        while pool.count < 32 {
            pool.append(EvolvableStrategy())
        }
    }
    
    func getBestStrategy() -> EvolvableStrategy? {
        return pool.max(by: { $0.fitness < $1.fitness })
    }
    
    func getStrategiesByNiche(_ niche: String) -> [EvolvableStrategy] {
        return speciesNiches[niche] ?? []
    }
    
    func getPopulationStats() -> (avgFitness: Double, maxFitness: Double, diversity: Double) {
        let avgFitness = pool.map { $0.fitness }.reduce(0, +) / Double(pool.count)
        let maxFitness = pool.map { $0.fitness }.max() ?? 0.0
        
        // Calculate genetic diversity
        var diversitySum = 0.0
        for i in 0..<pool.count {
            for j in (i+1)..<pool.count {
                let distance = calculateGeneticDistance(pool[i], pool[j])
                diversitySum += distance
            }
        }
        let diversity = diversitySum / Double((pool.count * (pool.count - 1)) / 2)
        
        return (avgFitness, maxFitness, diversity)
    }
    
    private func calculateGeneticDistance(_ s1: EvolvableStrategy, _ s2: EvolvableStrategy) -> Double {
        let differences = zip(s1.genome, s2.genome).map { abs($0 - $1) }
        return differences.reduce(0, +) / Double(differences.count)
    }
    
    func adaptMutationRate() async {
        let (_, _, diversity) = getPopulationStats()
        
        // Increase mutation rate if population is converging
        if diversity < 0.1 {
            mutationRate = min(0.1, mutationRate * 1.5)
        } else if diversity > 0.5 {
            mutationRate = max(0.01, mutationRate * 0.8)
        }
    }
    
    func resetPopulation(keepElite: Bool = true) async {
        let elite = keepElite ? Array(pool.sorted { $0.fitness > $1.fitness }.prefix(eliteSize)) : []
        pool = elite + (0..<(64 - elite.count)).map { _ in EvolvableStrategy() }
        generation = 0
    }
}

// FIXED: Add missing variables to ExchangeWebSocket
extension ExchangeWebSocket {
    static var evolutionEngine: EvolutionEngine? = EvolutionEngine()
    
    // Strategy performance tracking
    static var strategyPerformanceHistory: [UUID: [Double]] = [:]
    static var activeStrategies: [UUID: EvolvableStrategy] = [:]
    
    static func updateStrategyPerformance(strategyId: UUID, profit: Double, win: Bool) async {
        strategyPerformanceHistory[strategyId, default: []].append(profit)
        if strategyPerformanceHistory[strategyId]!.count > 100 {
            strategyPerformanceHistory[strategyId]!.removeFirst()
        }
        
        if var strategy = activeStrategies[strategyId] {
            strategy.updatePerformance(profit: profit, win: win)
            activeStrategies[strategyId] = strategy
        }
    }
    
    static func getStrategyRecommendation(pair: String) async -> EvolvableStrategy? {
        return await evolutionEngine?.getBestStrategy()
    }
}

