//-------------------------------------------------------------------------------------------------------------------------Block 11 - WebSocket Data Handling

extension ExchangeWebSocket {
    private static var kucoinSpotDelegate: KuCoinSpotWebSocketDelegate?
    private static var kucoinFuturesDelegate: KuCoinFuturesWebSocketDelegate?

    @MainActor
    static func connectKucoinMaster() {
        guard hasValidKuCoinCredentials else {
            print("Skipping KuCoin WebSocket connection due to missing credentials")
            Task { @MainActor in
                logAlert(event: "Skipping KuCoin WebSocket connection due to missing credentials")
            }
            return
        }
        print("Attempting to connect to KuCoin WebSocket...")
        fetchKuCoinWsToken { token in
            guard let token = token else {
                print("Failed to fetch KuCoin WebSocket token, retrying in 5 seconds...")
                DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                    connectKucoinMaster()
                }
                return
            }
            Task { @MainActor in
                kucoinToken = token
                let wsURLString = "wss://ws-api.kucoin.com/endpoint?token=\(token)&acceptUserMessage=true"
                guard let wsURL = URL(string: wsURLString) else {
                    print("Invalid KuCoin WebSocket URL: \(wsURLString), retrying in 5 seconds...")
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectKucoinMaster()
                    }
                    return
                }
                var request = URLRequest(url: wsURL)
                request.timeoutInterval = 10
                kucoinSocket = WebSocket(request: request)
                kucoinSpotDelegate = KuCoinSpotWebSocketDelegate()
                kucoinSocket?.delegate = kucoinSpotDelegate
                kucoinSocket?.connect()
                
                weak var ws = kucoinSocket
                ws?.onEvent = { event in
                    Task { @MainActor in
                        switch event {
                        case .connected(_):
                            print("‚úÖ KuCoin Spot WebSocket connected via onEvent")
                            logAlert(event: "‚úÖ KuCoin Spot WebSocket connected via onEvent")
                            kucoinIsConnected = true
                            kucoinReconnectAttempts = 0
                            
                            for (index, pair) in tradingPairs.enumerated() {
                                // Fixed symbol formatting for KuCoin spot
                                let formattedPair = pair.replacingOccurrences(of: "-", with: "")
                                let spotTopic = "/market/ticker:\(formattedPair)"
                                let spotSubscribeMessage: [String: Any] = [
                                    "id": Int(Date().timeIntervalSince1970 * 1000) + index,
                                    "type": "subscribe",
                                    "topic": spotTopic,
                                    "privateChannel": false,
                                    "response": true
                                ]
                                if let spotData = try? JSONSerialization.data(withJSONObject: spotSubscribeMessage),
                                   let spotMessage = String(data: spotData, encoding: .utf8) {
                                    ws?.write(string: spotMessage)
                                    print("‚úÖ Subscribed to KuCoin spot topic: \(spotTopic) for pair: \(pair)")
                                    logAlert(event: "‚úÖ Subscribed to KuCoin spot topic: \(spotTopic) for pair: \(pair)")
                                } else {
                                    print("‚ùå Failed to subscribe to KuCoin spot topic: \(spotTopic) for pair: \(pair)")
                                    logAlert(event: "‚ùå Failed to subscribe to KuCoin spot topic: \(spotTopic) for pair: \(pair)")
                                }
                                
                                try? await Task.sleep(nanoseconds: 100_000_000) // 0.1 seconds
                            }
                            Timer.scheduledTimer(withTimeInterval: 15.0, repeats: true) { _ in
                                Task { @MainActor in
                                    let pingMessage = "{\"id\": \"ping_\(Int(Date().timeIntervalSince1970))\", \"type\": \"ping\"}"
                                    ws?.write(string: pingMessage)
                                    print("üíì Sent ping to KuCoin Spot WebSocket")
                                }
                            }
                        case .disconnected(_, _):
                            print("‚ùå KuCoin Spot WebSocket disconnected via onEvent")
                            logAlert(event: "‚ùå KuCoin Spot WebSocket disconnected via onEvent")
                            kucoinIsConnected = false
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectKucoinMaster()
                            }
                        case .error(_):
                            print("‚ùå KuCoin Spot WebSocket error via onEvent")
                            logAlert(event: "‚ùå KuCoin Spot WebSocket error via onEvent")
                            kucoinIsConnected = false
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectKucoinMaster()
                            }
                        case .text(let string):
                            if let data = string.data(using: .utf8),
                               let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                               let type = json["type"] as? String, type == "welcome" {
                                print("‚úÖ KuCoin Spot WebSocket subscription confirmed")
                                logAlert(event: "‚úÖ KuCoin Spot WebSocket welcome message received")
                            }
                            // Route message to Block 9 handler
                            Task {
                                await handleKuCoinSpotMessage(string)
                            }
                        case .peerClosed:
                            print("‚ùå KuCoin Spot WebSocket peer closed connection")
                            logAlert(event: "‚ùå KuCoin Spot WebSocket peer closed connection")
                            kucoinIsConnected = false
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectKucoinMaster()
                            }
                        default:
                            break
                        }
                    }
                }
            }
        }
    }

    @MainActor
    static func connectKucoinFutures() {
        guard hasValidKuCoinCredentials else {
            print("Skipping KuCoin Futures WebSocket connection due to missing credentials")
            Task { @MainActor in
                logAlert(event: "Skipping KuCoin Futures WebSocket connection due to missing credentials")
            }
            return
        }
        print("Attempting to connect to KuCoin Futures WebSocket...")
        fetchKucoinFuturesWsToken { token in
            guard let token = token else {
                print("Failed to fetch KuCoin Futures WebSocket token, retrying in 5 seconds...")
                DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                    connectKucoinFutures()
                }
                return
            }
            Task { @MainActor in
                kucoinFuturesToken = token
                let connectId = UUID().uuidString
                let wsURLString = "wss://ws-api-futures.kucoin.com/?token=\(token)&connectId=\(connectId)"
                guard let wsURL = URL(string: wsURLString) else {
                    print("Invalid KuCoin Futures WebSocket URL: \(wsURLString), retrying in 5 seconds...")
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectKucoinFutures()
                    }
                    return
                }
                var request = URLRequest(url: wsURL)
                request.timeoutInterval = 10
                kucoinFuturesSocket = WebSocket(request: request)
                kucoinFuturesDelegate = KuCoinFuturesWebSocketDelegate()
                kucoinFuturesSocket?.delegate = kucoinFuturesDelegate
                kucoinFuturesSocket?.connect()
                
                weak var ws = kucoinFuturesSocket
                ws?.onEvent = { event in
                    Task { @MainActor in
                        switch event {
                        case .connected(_):
                            print("‚úÖ KuCoin Futures WebSocket connected via onEvent")
                            logAlert(event: "‚úÖ KuCoin Futures WebSocket connected via onEvent")
                            kucoinFuturesIsConnected = true
                            // Only use variables that exist
                            
                            for (index, pair) in tradingPairs.enumerated() {
                                guard let futuresSymbol = kucoinFuturesSymbols[pair] else {
                                    print("No futures symbol found for pair: \(pair), skipping subscription")
                                    continue
                                }
                                let priceTopic = "/contractMarket/tickerV2:\(futuresSymbol)"
                                let priceSubscription: [String: Any] = [
                                    "id": Int(Date().timeIntervalSince1970 * 1000) + index,
                                    "type": "subscribe",
                                    "topic": priceTopic,
                                    "privateChannel": false,
                                    "response": true
                                ]
                                if let priceData = try? JSONSerialization.data(withJSONObject: priceSubscription),
                                   let priceMessage = String(data: priceData, encoding: .utf8) {
                                    ws?.write(string: priceMessage)
                                    print("‚úÖ Subscribed to KuCoin Futures price topic: \(priceTopic) for pair: \(pair)")
                                    logAlert(event: "‚úÖ Subscribed to KuCoin Futures price topic: \(priceTopic) for pair: \(pair)")
                                } else {
                                    print("‚ùå Failed to subscribe to KuCoin Futures price topic: \(priceTopic) for pair: \(pair)")
                                    logAlert(event: "‚ùå Failed to subscribe to KuCoin Futures price topic: \(priceTopic) for pair: \(pair)")
                                }
                                let orderBookTopic = "/contractMarket/level2:\(futuresSymbol)"
                                let orderBookSubscription: [String: Any] = [
                                    "id": Int(Date().timeIntervalSince1970 * 1000) + index + 2000,
                                    "type": "subscribe",
                                    "topic": orderBookTopic,
                                    "privateChannel": false,
                                    "response": true
                                ]
                                if let orderBookData = try? JSONSerialization.data(withJSONObject: orderBookSubscription),
                                   let orderBookMessage = String(data: orderBookData, encoding: .utf8) {
                                    ws?.write(string: orderBookMessage)
                                    print("‚úÖ Subscribed to KuCoin Futures order book topic: \(orderBookTopic) for pair: \(pair)")
                                    logAlert(event: "‚úÖ Subscribed to KuCoin Futures order book topic: \(orderBookTopic) for pair: \(pair)")
                                } else {
                                    print("‚ùå Failed to subscribe to KuCoin Futures order book topic: \(orderBookTopic) for pair: \(pair)")
                                    logAlert(event: "‚ùå Failed to subscribe to KuCoin Futures order book topic: \(orderBookTopic) for pair: \(pair)")
                                }
                                let fundingTopic = "/contract/instrument:\(futuresSymbol)"
                                let fundingSubscription: [String: Any] = [
                                    "id": Int(Date().timeIntervalSince1970 * 1000) + index + 1000,
                                    "type": "subscribe",
                                    "topic": fundingTopic,
                                    "privateChannel": false,
                                    "response": true
                                ]
                                if let fundingData = try? JSONSerialization.data(withJSONObject: fundingSubscription),
                                   let fundingMessage = String(data: fundingData, encoding: .utf8) {
                                    ws?.write(string: fundingMessage)
                                    print("‚úÖ Subscribed to KuCoin Futures funding rate topic: \(fundingTopic) for pair: \(pair)")
                                    logAlert(event: "‚úÖ Subscribed to KuCoin Futures funding rate topic: \(fundingTopic) for pair: \(pair)")
                                } else {
                                    print("‚ùå Failed to subscribe to KuCoin Futures funding rate topic: \(fundingTopic) for pair: \(pair)")
                                    logAlert(event: "‚ùå Failed to subscribe to KuCoin Futures funding rate topic: \(fundingTopic) for pair: \(pair)")
                                }
                                
                                try? await Task.sleep(nanoseconds: 100_000_000) // 0.1 seconds
                            }
                            Timer.scheduledTimer(withTimeInterval: 15.0, repeats: true) { _ in
                                Task { @MainActor in
                                    let pingMessage = "{\"id\": \"ping_\(Int(Date().timeIntervalSince1970))\", \"type\": \"ping\"}"
                                    ws?.write(string: pingMessage)
                                    print("üíì Sent ping to KuCoin Futures WebSocket")
                                }
                            }
                        case .disconnected(_, _):
                            print("‚ùå KuCoin Futures WebSocket disconnected via onEvent")
                            logAlert(event: "‚ùå KuCoin Futures WebSocket disconnected via onEvent")
                            kucoinFuturesIsConnected = false
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectKucoinFutures()
                            }
                        case .error(_):
                            print("‚ùå KuCoin Futures WebSocket error via onEvent")
                            logAlert(event: "‚ùå KuCoin Futures WebSocket error via onEvent")
                            kucoinFuturesIsConnected = false
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectKucoinFutures()
                            }
                        case .text(let string):
                            if let data = string.data(using: .utf8),
                               let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                               let type = json["type"] as? String, type == "welcome" {
                                print("‚úÖ KuCoin Futures WebSocket subscription confirmed")
                                logAlert(event: "‚úÖ KuCoin Futures WebSocket welcome message received")
                            }
                            // Route message to Block 9 handler
                            Task {
                                await handleKuCoinFuturesMessage(string)
                            }
                        case .peerClosed:
                            print("‚ùå KuCoin Futures WebSocket peer closed connection")
                            logAlert(event: "‚ùå KuCoin Futures WebSocket peer closed connection")
                            kucoinFuturesIsConnected = false
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectKucoinFutures()
                            }
                        default:
                            break
                        }
                    }
                }
            }
        }
    }

    @MainActor
    static func connectBybit() {
        print("Attempting to connect to Bybit WebSocket...")
        bybitSocket = WebSocket(request: URLRequest(url: URL(string: "wss://stream.bybit.com/v5/public/spot")!))
        bybitSpotDelegate = BybitSpotWebSocketDelegate()
        bybitSocket?.delegate = bybitSpotDelegate
        bybitSocket?.connect()
        
        weak var spotWs = bybitSocket
        spotWs?.onEvent = { event in
            Task { @MainActor in
                switch event {
                case .connected(_):
                    print("‚úÖ Bybit Spot WebSocket connected via onEvent")
                    logAlert(event: "‚úÖ Bybit Spot WebSocket connected via onEvent")
                    bybitIsConnected = true
                    // Only use variables that exist
                    
                    for pair in tradingPairs {
                        // Fixed symbol formatting for Bybit
                        let symbol = pair.replacingOccurrences(of: "-", with: "")
                        let subscribeMessage: [String: Any] = [
                            "req_id": "bybit_spot_\(Int(Date().timeIntervalSince1970 * 1000))",
                            "op": "subscribe",
                            "args": [
                                "tickers.\(symbol)",
                                "orderbook.50.\(symbol)",
                                "publicTrade.\(symbol)"
                            ]
                        ]
                        if let data = try? JSONSerialization.data(withJSONObject: subscribeMessage),
                           let message = String(data: data, encoding: .utf8) {
                            spotWs?.write(string: message)
                            print("‚úÖ Subscribed to Bybit spot topics: tickers.\(symbol), orderbook.50.\(symbol), publicTrade.\(symbol) for pair: \(pair)")
                            logAlert(event: "‚úÖ Subscribed to Bybit spot topics for pair: \(pair)")
                        } else {
                            print("‚ùå Failed to subscribe to Bybit spot topics for pair: \(pair)")
                            logAlert(event: "‚ùå Failed to subscribe to Bybit spot topics for pair: \(pair)")
                        }
                    }
                    Timer.scheduledTimer(withTimeInterval: 20.0, repeats: true) { _ in
                        Task { @MainActor in
                            let pingMessage = "{\"op\": \"ping\", \"req_id\": \"bybit_spot_\(Int(Date().timeIntervalSince1970 * 1000))\"}"
                            spotWs?.write(string: pingMessage)
                            print("üíì Sent ping to Bybit Spot WebSocket")
                        }
                    }
                case .disconnected(_, _):
                    print("‚ùå Bybit Spot WebSocket disconnected via onEvent")
                    logAlert(event: "‚ùå Bybit Spot WebSocket disconnected via onEvent")
                    bybitIsConnected = false
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectBybit()
                    }
                case .error(_):
                    print("‚ùå Bybit Spot WebSocket error via onEvent")
                    logAlert(event: "‚ùå Bybit Spot WebSocket error via onEvent")
                    bybitIsConnected = false
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectBybit()
                    }
                case .text(let string):
                    if let data = string.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                       let success = json["success"] as? Bool, success,
                       let retMsg = json["ret_msg"] as? String, retMsg == "subscribe" {
                        print("‚úÖ Bybit Spot subscription confirmed")
                        logAlert(event: "‚úÖ Bybit Spot subscription confirmed")
                    }
                    // Route message to Block 9 handler
                    Task {
                        await handleBybitSpotMessage(string)
                    }
                case .peerClosed:
                    print("‚ùå Bybit Spot WebSocket peer closed connection")
                    logAlert(event: "‚ùå Bybit Spot WebSocket peer closed connection")
                    bybitIsConnected = false
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectBybit()
                    }
                default:
                    break
                }
            }
        }
        
        bybitSpotSocket = WebSocket(request: URLRequest(url: URL(string: "wss://stream.bybit.com/v5/public/linear")!))
        bybitFuturesDelegate = BybitFuturesWebSocketDelegate()
        bybitSpotSocket?.delegate = bybitFuturesDelegate
        bybitSpotSocket?.connect()
        
        weak var futuresWs = bybitSpotSocket
        futuresWs?.onEvent = { event in
            Task { @MainActor in
                switch event {
                case .connected(_):
                    print("‚úÖ Bybit Futures WebSocket connected via onEvent")
                    logAlert(event: "‚úÖ Bybit Futures WebSocket connected via onEvent")
                    bybitFuturesIsConnected = true
                    // Only use variables that exist
                    
                    for pair in tradingPairs {
                        // Fixed symbol formatting for Bybit futures
                        let symbol = pair.replacingOccurrences(of: "-", with: "")
                        let subscribeMessage: [String: Any] = [
                            "req_id": "bybit_futures_\(Int(Date().timeIntervalSince1970 * 1000))",
                            "op": "subscribe",
                            "args": [
                                "tickers.\(symbol)",
                                "orderbook.50.\(symbol)",
                                "publicTrade.\(symbol)"
                            ]
                        ]
                        if let data = try? JSONSerialization.data(withJSONObject: subscribeMessage),
                           let message = String(data: data, encoding: .utf8) {
                            futuresWs?.write(string: message)
                            print("‚úÖ Subscribed to Bybit futures topics: tickers.\(symbol), orderbook.50.\(symbol), publicTrade.\(symbol) for pair: \(pair)")
                            logAlert(event: "‚úÖ Subscribed to Bybit futures topics for pair: \(pair)")
                        } else {
                            print("‚ùå Failed to subscribe to Bybit futures topics for pair: \(pair)")
                            logAlert(event: "‚ùå Failed to subscribe to Bybit futures topics for pair: \(pair)")
                        }
                    }
                    Timer.scheduledTimer(withTimeInterval: 20.0, repeats: true) { _ in
                        Task { @MainActor in
                            let pingMessage = "{\"op\": \"ping\", \"req_id\": \"bybit_futures_\(Int(Date().timeIntervalSince1970 * 1000))\"}"
                            futuresWs?.write(string: pingMessage)
                            print("üíì Sent ping to Bybit Futures WebSocket")
                        }
                    }
                case .disconnected(_, _):
                    print("‚ùå Bybit Futures WebSocket disconnected via onEvent")
                    logAlert(event: "‚ùå Bybit Futures WebSocket disconnected via onEvent")
                    bybitFuturesIsConnected = false
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectBybit()
                    }
                case .error(_):
                    print("‚ùå Bybit Futures WebSocket error via onEvent")
                    logAlert(event: "‚ùå Bybit Futures WebSocket error via onEvent")
                    bybitFuturesIsConnected = false
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectBybit()
                    }
                case .text(let string):
                    if let data = string.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                       let success = json["success"] as? Bool, success,
                       let retMsg = json["ret_msg"] as? String, retMsg == "subscribe" {
                        print("‚úÖ Bybit Futures subscription confirmed")
                        logAlert(event: "‚úÖ Bybit Futures subscription confirmed")
                    }
                    // Route message to Block 9 handler
                    Task {
                        await handleBybitFuturesMessage(string)
                    }
                case .peerClosed:
                    print("‚ùå Bybit Futures WebSocket peer closed connection")
                    logAlert(event: "‚ùå Bybit Futures WebSocket peer closed connection")
                    bybitFuturesIsConnected = false
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectBybit()
                    }
                default:
                    break
                }
            }
        }
    }
}
