//-------------------------------------------------------------------------------------------------------------------------Block 11 - WebSocket Data Handling


extension ExchangeWebSocket {
    private static var kucoinSpotDelegate: KuCoinSpotWebSocketDelegate?
    private static var kucoinFuturesDelegate: KuCoinFuturesWebSocketDelegate?
  

    @MainActor
    static func connectKucoinMaster() {
        guard hasValidKuCoinCredentials else {
            print("Skipping KuCoin WebSocket connection due to missing credentials")
            Task { @MainActor in
                logAlert(event: "Skipping KuCoin WebSocket connection due to missing credentials")
            }
            return
        }
        print("Attempting to connect to KuCoin WebSocket...")
        fetchKuCoinWsToken { token in
            guard let token = token else {
                print("Failed to fetch KuCoin WebSocket token, retrying in 5 seconds...")
                DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                    connectKucoin()
                }
                return
            }
            Task { @MainActor in
                kucoinToken = token
                let wsURLString = "wss://ws-api.kucoin.com/endpoint?token=\(token)&acceptUserMessage=true"
                guard let wsURL = URL(string: wsURLString) else {
                    print("Invalid KuCoin WebSocket URL: \(wsURLString), retrying in 5 seconds...")
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectKucoin()
                    }
                    return
                }
                var request = URLRequest(url: wsURL)
                request.timeoutInterval = 10
                kucoinSocket = WebSocket(request: request)
                kucoinSpotDelegate = KuCoinSpotWebSocketDelegate()
                kucoinSocket?.delegate = kucoinSpotDelegate
                kucoinSocket?.connect()
                
                weak var ws = kucoinSocket
                ws?.onEvent = { event in
                    Task { @MainActor in
                        switch event {
                        case .connected(_):
                            for (index, pair) in tradingPairs.enumerated() {
                                // Fixed symbol formatting for KuCoin spot
                                let formattedPair = pair.replacingOccurrences(of: "-", with: "")
                                let spotTopic = "/market/ticker:\(formattedPair)"
                                let spotSubscribeMessage: [String: Any] = [
                                    "id": Int(Date().timeIntervalSince1970 * 1000) + index,
                                    "type": "subscribe",
                                    "topic": spotTopic,
                                    "privateChannel": false,
                                    "response": true
                                ]
                                if let spotData = try? JSONSerialization.data(withJSONObject: spotSubscribeMessage),
                                   let spotMessage = String(data: spotData, encoding: .utf8) {
                                    ws?.write(string: spotMessage)
                                    print("Subscribed to KuCoin spot topic: \(spotTopic) for pair: \(pair)")
                                } else {
                                    print("Failed to subscribe to KuCoin spot topic: \(spotTopic) for pair: \(pair)")
                                }
                            }
                            Timer.scheduledTimer(withTimeInterval: 15.0, repeats: true) { _ in
                                Task { @MainActor in
                                    let pingMessage = "{\"id\": \"ping_\(Int(Date().timeIntervalSince1970))\", \"type\": \"ping\"}"
                                    ws?.write(string: pingMessage)
                                    print("Sent ping to KuCoin Spot WebSocket")
                                }
                            }
                        case .disconnected(_, _):
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectKucoin()
                            }
                        case .error(_):
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectKucoin()
                            }
                        case .text(let string):
                            if let data = string.data(using: .utf8),
                               let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                               let type = json["type"] as? String, type == "welcome" {
                                print("KuCoin Spot WebSocket subscription confirmed")
                            }
                        case .peerClosed:
                            print("KuCoin Spot WebSocket peer closed connection")
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectKucoin()
                            }
                        default:
                            break
                        }
                    }
                }
            }
        }
    }

    @MainActor
    static func connectKucoinFutures() {
        guard hasValidKuCoinCredentials else {
            print("Skipping KuCoin Futures WebSocket connection due to missing credentials")
            Task { @MainActor in
                logAlert(event: "Skipping KuCoin Futures WebSocket connection due to missing credentials")
            }
            return
        }
        print("Attempting to connect to KuCoin Futures WebSocket...")
        fetchKucoinFuturesWsToken { token in
            guard let token = token else {
                print("Failed to fetch KuCoin Futures WebSocket token, retrying in 5 seconds...")
                DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                    connectKucoinFutures()
                }
                return
            }
            Task { @MainActor in
                kucoinFuturesToken = token
                let connectId = UUID().uuidString
                let wsURLString = "wss://ws-api-futures.kucoin.com/?token=\(token)&connectId=\(connectId)"
                guard let wsURL = URL(string: wsURLString) else {
                    print("Invalid KuCoin Futures WebSocket URL: \(wsURLString), retrying in 5 seconds...")
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectKucoinFutures()
                    }
                    return
                }
                var request = URLRequest(url: wsURL)
                request.timeoutInterval = 10
                kucoinFuturesSocket = WebSocket(request: request)
                kucoinFuturesDelegate = KuCoinFuturesWebSocketDelegate()
                kucoinFuturesSocket?.delegate = kucoinFuturesDelegate
                kucoinFuturesSocket?.connect()
                
                weak var ws = kucoinFuturesSocket
                ws?.onEvent = { event in
                    Task { @MainActor in
                        switch event {
                        case .connected(_):
                            for (index, pair) in tradingPairs.enumerated() {
                                guard let futuresSymbol = kucoinFuturesSymbols[pair] else {
                                    print("No futures symbol found for pair: \(pair), skipping subscription")
                                    continue
                                }
                                let priceTopic = "/contractMarket/tickerV2:\(futuresSymbol)"
                                let priceSubscription: [String: Any] = [
                                    "id": Int(Date().timeIntervalSince1970 * 1000) + index,
                                    "type": "subscribe",
                                    "topic": priceTopic,
                                    "privateChannel": false,
                                    "response": true
                                ]
                                if let priceData = try? JSONSerialization.data(withJSONObject: priceSubscription),
                                   let priceMessage = String(data: priceData, encoding: .utf8) {
                                    ws?.write(string: priceMessage)
                                    print("Subscribed to KuCoin Futures price topic: \(priceTopic) for pair: \(pair)")
                                } else {
                                    print("Failed to subscribe to KuCoin Futures price topic: \(priceTopic) for pair: \(pair)")
                                }
                                let orderBookTopic = "/contractMarket/level2:\(futuresSymbol)"
                                let orderBookSubscription: [String: Any] = [
                                    "id": Int(Date().timeIntervalSince1970 * 1000) + index + 2000,
                                    "type": "subscribe",
                                    "topic": orderBookTopic,
                                    "privateChannel": false,
                                    "response": true
                                ]
                                if let orderBookData = try? JSONSerialization.data(withJSONObject: orderBookSubscription),
                                   let orderBookMessage = String(data: orderBookData, encoding: .utf8) {
                                    ws?.write(string: orderBookMessage)
                                    print("Subscribed to KuCoin Futures order book topic: \(orderBookTopic) for pair: \(pair)")
                                } else {
                                    print("Failed to subscribe to KuCoin Futures order book topic: \(orderBookTopic) for pair: \(pair)")
                                }
                                let fundingTopic = "/contract/instrument:\(futuresSymbol)"
                                let fundingSubscription: [String: Any] = [
                                    "id": Int(Date().timeIntervalSince1970 * 1000) + index + 1000,
                                    "type": "subscribe",
                                    "topic": fundingTopic,
                                    "privateChannel": false,
                                    "response": true
                                ]
                                if let fundingData = try? JSONSerialization.data(withJSONObject: fundingSubscription),
                                   let fundingMessage = String(data: fundingData, encoding: .utf8) {
                                    ws?.write(string: fundingMessage)
                                    print("Subscribed to KuCoin Futures funding rate topic: \(fundingTopic) for pair: \(pair)")
                                } else {
                                    print("Failed to subscribe to KuCoin Futures funding rate topic: \(fundingTopic) for pair: \(pair)")
                                }
                            }
                            Timer.scheduledTimer(withTimeInterval: 15.0, repeats: true) { _ in
                                Task { @MainActor in
                                    let pingMessage = "{\"id\": \"ping_\(Int(Date().timeIntervalSince1970))\", \"type\": \"ping\"}"
                                    ws?.write(string: pingMessage)
                                    print("Sent ping to KuCoin Futures WebSocket")
                                }
                            }
                        case .disconnected(_, _):
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectKucoinFutures()
                            }
                        case .error(_):
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectKucoinFutures()
                            }
                        case .text(let string):
                            if let data = string.data(using: .utf8),
                               let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                               let type = json["type"] as? String, type == "welcome" {
                                print("KuCoin Futures WebSocket subscription confirmed")
                            }
                        case .peerClosed:
                            print("KuCoin Futures WebSocket peer closed connection")
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectKucoinFutures()
                            }
                        default:
                            break
                        }
                    }
                }
            }
        }
    }

            @MainActor
            static func connectBybit() {
                print("Attempting to connect to Bybit WebSocket...")
                bybitSocket = WebSocket(request: URLRequest(url: URL(string: "wss://stream.bybit.com/v5/public/spot")!))
                bybitSpotDelegate = BybitSpotWebSocketDelegate()
                bybitSocket?.delegate = bybitSpotDelegate
                bybitSocket?.connect()
                
                weak var spotWs = bybitSocket
                spotWs?.onEvent = { event in
                    Task { @MainActor in
                        switch event {
                        case .connected(_):
                            for pair in tradingPairs {
                                // Fixed symbol formatting for Bybit
                                let symbol = pair.replacingOccurrences(of: "-", with: "")
                                let subscribeMessage: [String: Any] = [
                                    "req_id": "bybit_spot_\(Int(Date().timeIntervalSince1970 * 1000))",
                                    "op": "subscribe",
                                    "args": [
                                        "tickers.\(symbol)",
                                        "orderbook.50.\(symbol)",
                                        "publicTrade.\(symbol)"
                                    ]
                                ]
                                if let data = try? JSONSerialization.data(withJSONObject: subscribeMessage),
                                   let message = String(data: data, encoding: .utf8) {
                                    spotWs?.write(string: message)
                                    print("Subscribed to Bybit spot topics: tickers.\(symbol), orderbook.50.\(symbol), publicTrade.\(symbol) for pair: \(pair)")
                                } else {
                                    print("Failed to subscribe to Bybit spot topics for pair: \(pair)")
                                }
                            }
                            Timer.scheduledTimer(withTimeInterval: 20.0, repeats: true) { _ in
                                Task { @MainActor in
                                    let pingMessage = "{\"op\": \"ping\", \"req_id\": \"bybit_spot_\(Int(Date().timeIntervalSince1970 * 1000))\"}"
                                    spotWs?.write(string: pingMessage)
                                    print("Sent ping to Bybit Spot WebSocket")
                                }
                            }
                        case .disconnected(_, _):
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectBybit()
                            }
                        case .error(_):
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectBybit()
                            }
                        case .text(let string):
                            if let data = string.data(using: .utf8),
                               let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                               let success = json["success"] as? Bool, success,
                               let retMsg = json["ret_msg"] as? String, retMsg == "subscribe" {
                                print("Bybit Spot subscription confirmed")
                            }
                        case .peerClosed:
                            print("Bybit Spot WebSocket peer closed connection")
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectBybit()
                            }
                        default:
                            break
                        }
                    }
                }
                
                bybitSpotSocket = WebSocket(request: URLRequest(url: URL(string: "wss://stream.bybit.com/v5/public/linear")!))
                bybitFuturesDelegate = BybitFuturesWebSocketDelegate()
                bybitSpotSocket?.delegate = bybitFuturesDelegate
                bybitSpotSocket?.connect()
                
                weak var futuresWs = bybitSpotSocket
                futuresWs?.onEvent = { event in
                    Task { @MainActor in
                        switch event {
                        case .connected(_):
                            for pair in tradingPairs {
                                // Fixed symbol formatting for Bybit futures
                                let symbol = pair.replacingOccurrences(of: "-", with: "")
                                let subscribeMessage: [String: Any] = [
                                    "req_id": "bybit_futures_\(Int(Date().timeIntervalSince1970 * 1000))",
                                    "op": "subscribe",
                                    "args": [
                                        "tickers.\(symbol)",
                                        "orderbook.50.\(symbol)",
                                        "publicTrade.\(symbol)"
                                    ]
                                ]
                                if let data = try? JSONSerialization.data(withJSONObject: subscribeMessage),
                                   let message = String(data: data, encoding: .utf8) {
                                    futuresWs?.write(string: message)
                                    print("Subscribed to Bybit futures topics: tickers.\(symbol), orderbook.50.\(symbol), publicTrade.\(symbol) for pair: \(pair)")
                                } else {
                                    print("Failed to subscribe to Bybit futures topics for pair: \(pair)")
                                }
                            }
                            Timer.scheduledTimer(withTimeInterval: 20.0, repeats: true) { _ in
                                Task { @MainActor in
                                    let pingMessage = "{\"op\": \"ping\", \"req_id\": \"bybit_futures_\(Int(Date().timeIntervalSince1970 * 1000))\"}"
                                    futuresWs?.write(string: pingMessage)
                                    print("Sent ping to Bybit Futures WebSocket")
                                }
                            }
                        case .disconnected(_, _):
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectBybit()
                            }
                        case .error(_):
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectBybit()
                            }
                        case .text(let string):
                            if let data = string.data(using: .utf8),
                               let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                               let success = json["success"] as? Bool, success,
                               let retMsg = json["ret_msg"] as? String, retMsg == "subscribe" {
                                print("Bybit Futures subscription confirmed")
                            }
                        case .peerClosed:
                            print("Bybit Futures WebSocket peer closed connection")
                            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                                connectBybit()
                            }
                        default:
                            break
                        }
                    }
                }
            }
        }
