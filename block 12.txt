
//--------------------------------------------------------------------------------------------------------------------------Block 12 - Trading Loop Monitoring and Support

import Foundation // Added for String.Encoding and other Foundation types

extension ExchangeWebSocket {
    static var totalProfit: Double = 0.0
    static var totalFees: Double = 0.0
    static var kellyCreditRatio: Double = getDouble("KELLY_CREDIT_RATIO", defaultValue: 2.0)
    static var totalBalance: Double = 0.0



    static func fetchOrderBookDepth(for exchange: String, pair: String, marketType: String, retryCount: Int = 0) async throws -> Double? {
        let maxRetries = getInt("API_MAX_RETRIES", defaultValue: 3)
        guard retryCount < maxRetries else {
            let book = exchange == "bybit" ? bybitOrderBooks[pair] : kucoinOrderBooks[pair]
            let cachedDepth = book.map { book in
                let bidDepth = book.bids.prefix(10).reduce(0.0) { $0 + $1.price * $1.quantity }
                let askDepth = book.asks.prefix(10).reduce(0.0) { $0 + $1.price * $1.quantity }
                return bidDepth + askDepth
            } ?? getDouble("MIN_LIQUIDITY_THRESHOLD", defaultValue: 500.0)
            print("DEBUG: Max retries reached, using cached depth for \(exchange)-\(pair)-\(marketType): \(cachedDepth)")
            await MainActor.run {
                logAlert(event: "Max retries reached for order book fetch: \(exchange)-\(pair)-\(marketType)")
            }
            return cachedDepth
        }

        let symbol = pair.replacingOccurrences(of: "-USDT", with: "USDT")
        var url: URL?
        if exchange == "bybit" {
            let category = marketType == "spot" ? "spot" : "linear"
            url = URL(string: "https://api.bybit.com/v5/market/orderbook?category=\(category)&symbol=\(symbol)&limit=50")
        } else {
            let endpoint = marketType == "spot" ? "/api/v1/market/orderbook/level2_50?symbol=\(symbol)" : "/api/v1/contractMarket/level2?symbol=\(symbol)M"
            url = URL(string: "https://api\(marketType == "spot" ? "" : "-futures").kucoin.com\(endpoint)")
        }

        guard let requestUrl = url else {
            print("Invalid order book URL for \(exchange)-\(pair)-\(marketType)")
            await MainActor.run {
                logAlert(event: "Invalid order book URL for \(exchange)-\(pair)-\(marketType)")
            }
            try await Task.sleep(nanoseconds: 2_000_000_000)
            return try await fetchOrderBookDepth(for: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1)
        }

        var request = URLRequest(url: requestUrl)
        request.httpMethod = "GET"
        request.timeoutInterval = getDouble("API_TIMEOUT_SECONDS", defaultValue: 10.0)

        let startTime = Date()
        let (data, response) = try await URLSession.shared.data(for: request)
        let latency = Date().timeIntervalSince(startTime) * 1000
        await MainActor.run {
            lastLatency[pair] = latency
            if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 300.0) {
                print("High latency detected for order book fetch: \(latency)ms")
                logAlert(event: "High latency detected for order book fetch: \(latency)ms")
            }
        }

        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
            print("Invalid order book response for \(exchange)-\(pair)-\(marketType)")
            await MainActor.run {
                logAlert(event: "Invalid order book response for \(exchange)-\(pair)-\(marketType)")
            }
            try await Task.sleep(nanoseconds: 2_000_000_000)
            return try await fetchOrderBookDepth(for: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1)
        }

        let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
        if exchange == "bybit" {
            guard let result = json?["result"] as? [String: Any],
                  let bids = result["b"] as? [[String]],
                  let asks = result["a"] as? [[String]],
                  !bids.isEmpty, !asks.isEmpty else {
                print("Failed to parse Bybit order book data for \(pair)-\(marketType)")
                await MainActor.run {
                    logAlert(event: "Failed to parse Bybit order book data for \(pair)-\(marketType)")
                }
                try await Task.sleep(nanoseconds: 2_000_000_000)
                return try await fetchOrderBookDepth(for: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1)
            }

            var bidDepth: Double = 0.0
            var askDepth: Double = 0.0

            for bid in bids.prefix(10) {
                if let priceStr = bid.first, let qtyStr = bid.last,
                   let price = Double(priceStr), let qty = Double(qtyStr) {
                    bidDepth += price * qty
                }
            }

            for ask in asks.prefix(10) {
                if let priceStr = ask.first, let qtyStr = ask.last,
                   let price = Double(priceStr), let qty = Double(qtyStr) {
                    askDepth += price * qty
                }
            }

            let totalDepth = bidDepth + askDepth
            print("DEBUG: Bybit order book depth for \(pair)-\(marketType): \(totalDepth)")
            return totalDepth
        } else {
            guard let dataDict = json?["data"] as? [String: Any],
                  let bids = dataDict["bids"] as? [[String]],
                  let asks = dataDict["asks"] as? [[String]],
                  !bids.isEmpty, !asks.isEmpty else {
                print("Failed to parse KuCoin order book data for \(pair)-\(marketType)")
                await MainActor.run {
                    logAlert(event: "Failed to parse KuCoin order book data for \(pair)-\(marketType)")
                }
                try await Task.sleep(nanoseconds: 2_000_000_000)
                return try await fetchOrderBookDepth(for: exchange, pair: pair, marketType: marketType, retryCount: retryCount + 1)
            }

            var bidDepth: Double = 0.0
            var askDepth: Double = 0.0

            for bid in bids.prefix(10) {
                if let priceStr = bid.first, let qtyStr = bid.last,
                   let price = Double(priceStr), let qty = Double(qtyStr) {
                    bidDepth += price * qty
                }
            }

            for ask in asks.prefix(10) {
                if let priceStr = ask.first, let qtyStr = ask.last,
                   let price = Double(priceStr), let qty = Double(qtyStr) {
                    askDepth += price * qty
                }
            }

            let totalDepth = bidDepth + askDepth
            print("DEBUG: KuCoin order book depth for \(pair)-\(marketType): \(totalDepth)")
            return totalDepth
        }
    }

    private static func fetchAndLogBalances(isInitial: Bool = false, completion: @escaping @Sendable () -> Void) {
        fetchKucoinBalance { _ in
            Task { @MainActor in
                fetchBybitBalance { _ in
                    Task { @MainActor in
                        if isInitial {
                            print("ðŸ’µ Initial Balances: KuCoin: \(ExchangeWebSocket.kucoinBalance) | Bybit: \(ExchangeWebSocket.bybitBalance)")
                        }
                        completion()
                    }
                }
            }
        }
    }

    static func dynamicTradeAmount(balance: Double, riskPercent: Double, volatility: Double, pair: String = tradingPairs.first ?? "BTC-USDT") async -> Double {
        let kellyFraction = await calculateKellyCriterion(pair: pair)
        let baseAmount = min(balance * riskPercent, balance * 0.6)
        let volatilityAdjusted = baseAmount * (1.0 / (1.0 + volatility * 0.3))
        let kellyAmount = balance * max(0.0, min(kellyFraction, 0.6))
        return min(volatilityAdjusted, kellyAmount)
    }

    static func rebalanceExchanges() {
        let balanceDifferenceThreshold = 0.08
        let totalBalance = kucoinBalance + bybitBalance
        
        guard totalBalance > 0 else { return }
        
        let kucoinBalanceRatio = kucoinBalance / totalBalance
        let bybitBalanceRatio = bybitBalance / totalBalance
        
        if abs(kucoinBalanceRatio - bybitBalanceRatio) > balanceDifferenceThreshold {
            let targetBalance = totalBalance / 2
            let transferAmount = abs(kucoinBalance - targetBalance)
            
            if kucoinBalance > bybitBalance {
                ExchangeWebSocket.kucoinBalance -= transferAmount
                ExchangeWebSocket.bybitBalance += transferAmount
            } else {
                ExchangeWebSocket.bybitBalance -= transferAmount
                ExchangeWebSocket.kucoinBalance += transferAmount
            }
        }
    }

    static func fetchExchangeFees(exchange: String, completion: @escaping @Sendable (Double?, Double?) -> Void) {
        if exchange == "kucoin" {
            completion(0.0001, 0.0004)
        } else if exchange == "bybit" {
            completion(0.0001, 0.0004)
        } else {
            completion(nil, nil)
        }
    }

    static func printPeriodicSummary() {
        print("ðŸ“Š Performance Summary:")
        print("ðŸ“Š Total Profit: \(totalProfit), Total Fees: \(totalFees)")
        for (pair, metrics) in tradeMetrics {
            print("\(pair): Wins: \(metrics.wins), Losses: \(metrics.losses), Profit: \(metrics.totalProfit), Fees: \(metrics.totalFees)")
        }
    }



    static func connectWebSocket(exchange: String, pair: String, marketType: String) {
        print("ðŸ“¡ Connecting WebSocket for \(exchange), pair: \(pair), marketType: \(marketType)")
    }

    static func checkCircuitBreaker(pair: String) {
        let prices = ExchangeWebSocket.kucoinPrices[pair] ?? []
        guard prices.count >= 60 else { return }
        let recentPrices = prices.suffix(60)
        let volatility = (recentPrices.max()! - recentPrices.min()!) / Double(recentPrices.count)
        if volatility > ExchangeWebSocket.volatilitySpikeThreshold {
            isTradingPaused[pair] = true
            lastVolatilityPause = Date()
            print("âš–ï¸ Circuit breaker triggered for \(pair): Volatility: \(String(format: "%.4f", volatility))")
            Task { @MainActor in
                logAlert(event: "Circuit breaker triggered for \(pair): Volatility: \(String(format: "%.4f", volatility))")
            }
        }
    }

    static func marketMaker(pair: String, exchange: String) {
        let spread = getDouble("MARKET_MAKING_SPREAD", defaultValue: 0.001)
        let price = exchange == "kucoin" ? kucoinCurrentPrice[pair] ?? 0.0 : bybitCurrentPrice[pair] ?? 0.0
        print("ðŸ“ˆ Market-making for \(pair) on \(exchange): Bid: \(String(format: "%.4f", price * (1 - spread))), Ask: \(String(format: "%.4f", price * (1 + spread)))")
    }

    static func executeScalpingTrade(pair: String, exchange: String, entryPrice: Double, targetPrice: Double, stopPrice: Double, tradeAmount: Double, maxActiveTrades: Int) async -> Bool {
        let trailingProfitPercent = getDouble("TRAILING_PROFIT_PERCENT", defaultValue: 0.03)
        let feeRate = exchange == "kucoin" ? kucoinTakerFee : bybitTakerFee
        let quantity = tradeAmount / entryPrice
        var highestPrice = entryPrice
        var trailingTargetPrice = entryPrice * (1 + trailingProfitPercent)
        var exitPrice: Double = 0.0
        let startTime = Date()
        let dashboardJSONURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/dashboard.json")

        // Copy balance to avoid inout capture
        var localKucoinBalance = kucoinBalance
        var localBybitBalance = bybitBalance

        while Date().timeIntervalSince(startTime) < 60 {
            if let currentPrice = await MainActor.run(body: { exchange == "bybit" ? bybitCurrentPrice[pair] : kucoinCurrentPrice[pair] }) {
                if currentPrice > highestPrice {
                    highestPrice = currentPrice
                    trailingTargetPrice = highestPrice * (1 - trailingProfitPercent)
                }
                if currentPrice >= targetPrice || currentPrice <= stopPrice || currentPrice <= trailingTargetPrice {
                    exitPrice = currentPrice
                    break
                }
            }
            try? await Task.sleep(nanoseconds: 1_00_000_000) // 100ms
        }

        if exitPrice == 0.0 {
            exitPrice = await MainActor.run { exchange == "bybit" ? bybitCurrentPrice[pair] : kucoinCurrentPrice[pair] } ?? entryPrice
        }

        let profit = quantity * (exitPrice - entryPrice)
        let fees = tradeAmount * feeRate * 2
        if exchange == "kucoin" {
            localKucoinBalance += profit - fees
        } else {
            localBybitBalance += profit - fees
        }
        print("ðŸ“Š Scalping trade for \(pair) on \(exchange): Profit: \(profit), Fees: \(fees)")
        await MainActor.run {
            // Update global balances after Task
            if exchange == "kucoin" {
                kucoinBalance = localKucoinBalance
            } else {
                bybitBalance = localBybitBalance
            }
            updateTradeMetrics(
                pair: pair,
                profit: profit,
                fees: fees,
                isWin: profit > 0,
                dashboardJSONURL: dashboardJSONURL,
                totalProfit: &ExchangeWebSocket.totalProfit,
                totalFees: &ExchangeWebSocket.totalFees
            )
            logTradeToCSV(
                pair: pair,
                strategy: "HFT Scalping",
                profit: profit,
                fees: fees,
                tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trade_log.csv")
            )
            sendTradeToFlaskServer(strategy: "HFT Scalping", pair: pair, exchange: exchange, spotPrice: 0.0, futuresPrice: 0.0, tradeAmount: 0.0, profit: profit)
        }
        return profit > 0
    }

    static func executeFuturesTrade(pair: String, exchange: String, entryPrice: Double, targetPrice: Double, stopPrice: Double, tradeAmount: Double) {
        let feeRate = exchange == "bybit" ? bybitTakerFee : kucoinTakerFee
        let quantity = tradeAmount / entryPrice
        let leverage = exchange == "bybit" ? getDouble("BYBIT_LEVERAGE", defaultValue: 3.0) : getDouble("KUCOIN_LEVERAGE", defaultValue: 3.0)
        let effectiveTradeAmount = tradeAmount * leverage
        var exitPrice: Double = 0.0
        let startTime = Date()
        let dashboardJSONURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/dashboard.json")
        
        // Copy balance to avoid inout capture
        var localKucoinBalance = kucoinBalance
        var localBybitBalance = bybitBalance

        while Date().timeIntervalSince(startTime) < 60 {
            if let price = (exchange == "bybit" ? bybitCurrentFuturesPrice[pair] : kucoinCurrentFuturesPrice[pair]) {
                if price >= targetPrice || price <= stopPrice {
                    exitPrice = price
                    break
                }
            }
            Thread.sleep(forTimeInterval: 0.1)
        }
        
        if exitPrice == 0.0 {
            exitPrice = (exchange == "bybit" ? bybitCurrentFuturesPrice[pair] : kucoinCurrentFuturesPrice[pair]) ?? entryPrice
        }
        
        let grossProfit = (exitPrice - entryPrice) * quantity * leverage
        let fees = effectiveTradeAmount * feeRate * 2
        let profit = grossProfit - fees
        
        if exchange == "bybit" {
            localBybitBalance += profit
        } else {
            localKucoinBalance += profit
        }
        print("ðŸ“Š Futures trade for \(pair) on \(exchange): Profit: \(profit), Fees: \(fees)")
        Task { @MainActor in
            // Update global balances after Task
            if exchange == "bybit" {
                bybitBalance = localBybitBalance
            } else {
                kucoinBalance = localKucoinBalance
            }
            updateTradeMetrics(
                pair: pair,
                profit: profit,
                fees: fees,
                isWin: profit > 0,
                dashboardJSONURL: dashboardJSONURL,
                totalProfit: &ExchangeWebSocket.totalProfit,
                totalFees: &ExchangeWebSocket.totalFees
            )
            logTradeToCSV(
                pair: pair,
                strategy: "Funding Rate Momentum",
                profit: profit,
                fees: fees,
                tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trade_log.csv")
            )
            sendTradeToFlaskServer(strategy: "Funding Rate Momentum", pair: pair, exchange: exchange, spotPrice: 0.0, futuresPrice: 0.0, tradeAmount: 0.0, profit: profit)
        }
    }

    static func updateDashboardJSON(dashboardJSONURL: URL, totalProfit: Double, totalFees: Double) {
        Task { @MainActor in
            let timestamp = ISO8601DateFormatter().string(from: Date())
            do {
                let fileManager = FileManager.default
                let directoryURL = dashboardJSONURL.deletingLastPathComponent()
                if !fileManager.fileExists(atPath: directoryURL.path) {
                    try fileManager.createDirectory(at: directoryURL, withIntermediateDirectories: true, attributes: nil)
                }
                var perPairMetrics: [[String: Any]] = []
                for pair in tradingPairs {
                    let metrics = tradeMetrics[pair] ?? (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)
                    let trades = metrics.wins + metrics.losses
                    let winRate = trades > 0 ? Double(metrics.wins) / Double(trades) * 100.0 : 0.0
                    let sentiment = sentimentScores[pair] ?? 0.0
                    let pairData: [String: Any] = [
                        "pair": pair,
                        "trades": trades,
                        "wins": metrics.wins,
                        "losses": metrics.losses,
                        "winRate": winRate,
                        "profit": metrics.totalProfit,
                        "fees": metrics.totalFees,
                        "sentiment": sentiment
                    ]
                    perPairMetrics.append(pairData)
                }
                
                let dashboardData: [String: Any] = [
                    "timestamp": timestamp,
                    "totalProfit": totalProfit,
                    "totalFees": totalFees,
                    "totalTrades": tradeMetrics.values.reduce(0) { $0 + $1.wins + $1.losses },
                    "kucoinBalance": kucoinBalance,
                    "bybitBalance": bybitBalance,
                    "perPairMetrics": perPairMetrics,
                    "livePrices": tradingPairs.map { pair in
                        [
                            "pair": pair,
                            "kucoinSpot": kucoinCurrentPrice[pair] ?? 0.0,
                            "kucoinFutures": kucoinCurrentFuturesPrice[pair] ?? 0.0,
                            "bybitSpot": bybitCurrentPrice[pair] ?? 0.0,
                            "bybitFutures": bybitCurrentFuturesPrice[pair] ?? 0.0
                        ]
                    }
                ]
                
                let jsonData = try JSONSerialization.data(withJSONObject: dashboardData, options: [.prettyPrinted])
                try jsonData.write(to: dashboardJSONURL, options: .atomic)
                print("ðŸ“ˆ Updated dashboard JSON at \(dashboardJSONURL.path)")
            } catch {
                print("âš ï¸ Failed to update dashboard JSON: \(error.localizedDescription)")
                logAlert(event: "Failed to update dashboard JSON: \(error.localizedDescription)")
            }
        }
    }

    static func calculateKellyCriterion(pair: String) async -> Double {
        // Use empirical win probability from tradeMetrics, fallback to default
        let metrics = tradeMetrics[pair] ?? (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)
        let totalTrades = metrics.wins + metrics.losses
        let winProbability = totalTrades > 0 ? Double(metrics.wins) / Double(totalTrades) : kellyWinProbability
        
        // Adjust reward-to-risk based on ATR for volatility
        let atr = kucoinFuturesATR[pair] ?? 0.01
        let currentPrice = kucoinCurrentPrice[pair] ?? 1.0
        let volatilityAdjustment = atr / currentPrice
        let rewardToRisk = kellyRewardToRisk * (1 + volatilityAdjustment * 0.5) // Scale by volatility
        
        // Calculate Kelly fraction
        let kelly = (winProbability * (rewardToRisk + 1) - 1) / rewardToRisk
        
        // Apply bounds and validation
        guard rewardToRisk > 0 else {
            Task { @MainActor in
                logAlert(event: "ðŸŸ¡ Invalid reward-to-risk ratio for \(pair): \(rewardToRisk)")
            }
            return 0.01 // Minimum safe fraction
        }
        
        // Clamp between 0.01 and 0.5 for safety
        let clampedKelly = max(min(kelly, 0.5), 0.01)
        
        // Store in kellySizes for pair-specific sizing
        await MainActor.run {
            kellySizes[pair] = clampedKelly
            logAlert(event: "ðŸŸ¡ Calculated Kelly fraction for \(pair): \(clampedKelly), p=\(winProbability), r=\(rewardToRisk)")
        }
        
        return clampedKelly
    }

    static func calculateOrderBookVWAP(pair: String, exchange: String, priceRange: Double, currentPrice: Double) -> Double? {
        let orderBook = exchange == "kucoin" ? kucoinOrderBooks[pair] : bybitOrderBooks[pair]
        guard let book = orderBook, !book.bids.isEmpty, !book.asks.isEmpty else {
            print("DEBUG: Order book unavailable for \(pair) on \(exchange)")
            Task { @MainActor in
                logAlert(event: "Order book unavailable for \(pair) on \(exchange)")
            }
            return nil
        }

        let minPrice = currentPrice * (1 - priceRange)
        let maxPrice = currentPrice * (1 + priceRange)

        var totalVolume: Double = 0.0
        var totalPriceVolume: Double = 0.0

        for bid in book.bids {
            if bid.price >= minPrice && bid.price <= maxPrice {
                totalPriceVolume += bid.price * bid.quantity
                totalVolume += bid.quantity
            }
        }

        for ask in book.asks {
            if ask.price >= minPrice && ask.price <= maxPrice {
                totalPriceVolume += ask.price * ask.quantity
                totalVolume += ask.quantity
            }
        }

        guard totalVolume > 0 else {
            print("DEBUG: Zero total volume in VWAP calculation for \(pair) on \(exchange)")
            Task { @MainActor in
                logAlert(event: "Zero total volume in VWAP calculation for \(pair) on \(exchange)")
            }
            return nil
        }

        let vwap = totalPriceVolume / totalVolume
        print("DEBUG: Calculated VWAP for \(pair) on \(exchange): \(vwap)")
        return vwap
    }

    static func checkDailyLossLimit(exchange: String, pair: String, potentialLoss: Double) async -> Bool {
        let dailyLossLimit = getDouble("DAILY_LOSS_LIMIT", defaultValue: 100.0)
        let currentLoss = await MainActor.run { dailyLoss[exchange] ?? 0.0 }
        let newTotalLoss = currentLoss + potentialLoss
        let exceedsLimit = newTotalLoss > dailyLossLimit
        
        if exceedsLimit {
            print("DEBUG: Daily loss limit exceeded for \(exchange)-\(pair): Current \(currentLoss), Potential \(potentialLoss), Limit \(dailyLossLimit)")
            await MainActor.run {
                logAlert(event: "Daily loss limit exceeded for \(exchange)-\(pair): Current \(currentLoss), Potential \(potentialLoss)")
            }
        }
        return !exceedsLimit
    }
}
