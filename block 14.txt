//------------------------------------------------------------------------------------------------------Block 14 - Core Trading Loop Execution


import Foundation

extension ExchangeWebSocket {
    
    // MISSING FUNCTION ADDED: evaluateFundingRateMomentum
    static func evaluateFundingRateMomentum(pair: String, kucoinFundingRate: Double, bybitFundingRate: Double) async {
        // Calculate funding rate differential
        let fundingRateDifference = abs(kucoinFundingRate - bybitFundingRate)
        
        // Check if funding rate momentum exceeds threshold
        guard fundingRateDifference > fundingMomentumThreshold else {
            print("DEBUG: Funding rate momentum below threshold for \(pair): \(fundingRateDifference) < \(fundingMomentumThreshold)")
            return
        }
        
        // Get current prices for both exchanges
        let kucoinPrice = await MainActor.run { kucoinCurrentPrice[pair] ?? 0.0 }
        let bybitPrice = await MainActor.run { bybitCurrentPrice[pair] ?? 0.0 }
        
        guard kucoinPrice > 0, bybitPrice > 0 else {
            await MainActor.run {
                logAlert(event: "Invalid prices for funding rate momentum evaluation - \(pair): KuCoin=\(kucoinPrice), Bybit=\(bybitPrice)")
            }
            return
        }
        
        // Check liquidity on both exchanges
        let tradeAmount = await MainActor.run { futuresTradeAmount }
        let kucoinLiquidity = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "futures", tradeAmount: tradeAmount, price: kucoinPrice)
        let bybitLiquidity = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "futures", tradeAmount: tradeAmount, price: bybitPrice)
        
        let minLiquidityThresholdValue = await MainActor.run { minLiquidityThreshold }
        guard let kucoinLiquidity = kucoinLiquidity, let bybitLiquidity = bybitLiquidity,
              kucoinLiquidity >= minLiquidityThresholdValue, bybitLiquidity >= minLiquidityThresholdValue else {
            await MainActor.run {
                logAlert(event: "Insufficient liquidity for funding rate momentum trade - \(pair): KuCoin=\(kucoinLiquidity ?? 0.0), Bybit=\(bybitLiquidity ?? 0.0)")
            }
            return
        }
        
        // Determine which exchange has higher funding rate (pay funding) and which has lower (receive funding)
        let (payExchange, receiveExchange, payRate, receiveRate) = kucoinFundingRate > bybitFundingRate ?
            ("kucoin", "bybit", kucoinFundingRate, bybitFundingRate) :
            ("bybit", "kucoin", bybitFundingRate, kucoinFundingRate)
        
        // Calculate expected profit from funding rate arbitrage
        let expectedFundingProfit = (payRate - receiveRate) * tradeAmount
        let minProfitThreshold = await MainActor.run { futuresMinProfitPercentage * tradeAmount }
        
        guard expectedFundingProfit > minProfitThreshold else {
            print("DEBUG: Funding rate profit below minimum threshold for \(pair): \(expectedFundingProfit) < \(minProfitThreshold)")
            return
        }
        
        // Check daily loss limits
        let stopLossPercentage = await MainActor.run { futuresStopLossPercentage }
        let potentialLoss = tradeAmount * stopLossPercentage
        let dailyLossCheck = await checkDailyLossLimit(exchange: payExchange, pair: pair, potentialLoss: potentialLoss)
        guard dailyLossCheck else {
            await MainActor.run {
                logAlert(event: "Daily loss limit would be exceeded for funding rate momentum trade - \(pair)")
            }
            return
        }
        
        // Execute the funding rate arbitrage strategy
        await MainActor.run {
            let strategy = "funding_rate_momentum"
            
            // Log the opportunity
            logAlert(event: "Funding rate momentum opportunity detected for \(pair): \(payExchange)=\(payRate), \(receiveExchange)=\(receiveRate), Expected profit: $\(expectedFundingProfit)")
            
            // Check simulation mode
            Task {
                let isSimulation = await getBool("SIMULATION_TRADE_LOGGING", defaultValue: true)
                
                if isSimulation {
                    // Simulation mode - log trades without executing
                    let timestamp = ISO8601DateFormatter().string(from: Date())
                    
                    // Log to CSV with proper trade entry format using accessible variables
                    let _ = "\(timestamp),\(pair),\(strategy),\(payExchange),sell,\(payExchange == "kucoin" ? kucoinPrice : bybitPrice),\(tradeAmount),\(expectedFundingProfit),simulation\n"
                    let _ = "\(timestamp),\(pair),\(strategy),\(receiveExchange),buy,\(receiveExchange == "kucoin" ? kucoinPrice : bybitPrice),\(tradeAmount),\(expectedFundingProfit),simulation\n"
                    
                    // Write to trades CSV file
                    logTradeToCSV(pair: pair, strategy: strategy, profit: expectedFundingProfit, fees: (tradeAmount * 0.0002 * 2), tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trades.csv"))
                    
                    // Send to Flask server for ML training
                    sendTradeToFlaskServer(strategy: strategy, pair: pair, exchange: "cross-exchange", spotPrice: (kucoinPrice + bybitPrice) / 2, futuresPrice: 0.0, tradeAmount: tradeAmount, profit: expectedFundingProfit)
                    
                    print("SIMULATION: Funding rate momentum trade for \(pair) at \(timestamp)")
                    print("SIMULATION: Strategy: \(strategy)")
                    print("SIMULATION: Expected funding profit: $\(expectedFundingProfit)")
                    
                    logAlert(event: "SIMULATION: \(strategy) trade executed for \(pair) at \(timestamp) - Expected profit: $\(expectedFundingProfit)")
                } else {
                    // Live trading would be implemented here
                    logAlert(event: "LIVE: \(strategy) opportunity detected for \(pair)")
                }
            }
        }
    }
    
    // MISSING FUNCTION ADDED: Core HFT opportunity detection
    static func detectAndExecuteHFTOpportunity(pair: String) async {
        // Get current prices from both exchanges
        let kucoinSpotPrice = kucoinCurrentPrice[pair] ?? 0.0
        let bybitSpotPrice = bybitCurrentPrice[pair] ?? 0.0
        let kucoinFuturesPrice = kucoinCurrentFuturesPrice[pair] ?? 0.0
        let bybitFuturesPrice = bybitCurrentFuturesPrice[pair] ?? 0.0
        
        // Skip if no price data
        guard kucoinSpotPrice > 0, bybitSpotPrice > 0, kucoinFuturesPrice > 0, bybitFuturesPrice > 0 else {
            print("DEBUG: Missing price data for \(pair)")
            return
        }
        
        // STRATEGY 1: Cross-Exchange Spot Arbitrage
        await checkCrossExchangeSpotArbitrage(pair: pair, kucoinPrice: kucoinSpotPrice, bybitPrice: bybitSpotPrice)
        
        // STRATEGY 2: Futures-Spot Arbitrage on each exchange
        await checkFuturesSpotArbitrage(pair: pair, exchange: "kucoin", spotPrice: kucoinSpotPrice, futuresPrice: kucoinFuturesPrice)
        await checkFuturesSpotArbitrage(pair: pair, exchange: "bybit", spotPrice: bybitSpotPrice, futuresPrice: bybitFuturesPrice)
        
        // STRATEGY 3: Cross-Exchange Futures Arbitrage
        await checkCrossExchangeFuturesArbitrage(pair: pair, kucoinPrice: kucoinFuturesPrice, bybitPrice: bybitFuturesPrice)
    }
    
    // MISSING FUNCTION ADDED: Cross-exchange spot arbitrage
    static func checkCrossExchangeSpotArbitrage(pair: String, kucoinPrice: Double, bybitPrice: Double) async {
        let spread = abs(kucoinPrice - bybitPrice) / min(kucoinPrice, bybitPrice)
        let minSpread = getDouble("CROSS_EXCHANGE_MIN_SPREAD_THRESHOLD", defaultValue: 0.002)
        
        guard spread >= minSpread else { return }
        
        let buyExchange = kucoinPrice < bybitPrice ? "kucoin" : "bybit"
        let sellExchange = kucoinPrice < bybitPrice ? "bybit" : "kucoin"
        let buyPrice = min(kucoinPrice, bybitPrice)
        let sellPrice = max(kucoinPrice, bybitPrice)
        
        let tradeAmount = getDouble("SPOT_TRADE_AMOUNT", defaultValue: 50.0)
        
        // Check if trade is profitable after fees
        let expectedProfit = (sellPrice - buyPrice) * (tradeAmount / buyPrice)
        let totalFees = tradeAmount * (kucoinTakerFee + bybitTakerFee)
        let netProfit = expectedProfit - totalFees
        
        guard netProfit > getDouble("FUTURES_MIN_PROFIT_PERCENTAGE", defaultValue: 0.001) * tradeAmount else {
            print("DEBUG: Cross-exchange spread \(pair) not profitable: spread=\(spread*100)%, net=\(netProfit)")
            return
        }
        
        // Check liquidity
        let buyLiquidity = await checkLiquidityAsyncUnique(exchange: buyExchange, pair: pair, marketType: "spot", tradeAmount: tradeAmount, price: buyPrice)
        let sellLiquidity = await checkLiquidityAsyncUnique(exchange: sellExchange, pair: pair, marketType: "spot", tradeAmount: tradeAmount, price: sellPrice)
        
        guard buyLiquidity != nil, sellLiquidity != nil else {
            print("DEBUG: Insufficient liquidity for cross-exchange arbitrage \(pair)")
            return
        }
        
        // Execute the arbitrage
        print("ðŸš€ EXECUTING Cross-Exchange Arbitrage: \(pair) - Buy \(buyExchange) @\(buyPrice), Sell \(sellExchange) @\(sellPrice), Spread: \(String(format: "%.3f", spread*100))%, Profit: $\(String(format: "%.2f", netProfit))")
        
        let buySuccess = await executeTrade(exchange: buyExchange, pair: pair, side: "buy", price: buyPrice, amount: tradeAmount / buyPrice, strategy: "Cross-Exchange Arbitrage")
        let sellSuccess = await executeTrade(exchange: sellExchange, pair: pair, side: "sell", price: sellPrice, amount: tradeAmount / sellPrice, strategy: "Cross-Exchange Arbitrage")
        
        if buySuccess && sellSuccess {
            await MainActor.run {
                logAlert(event: "âœ… SUCCESS: Cross-exchange arbitrage executed for \(pair) - Profit: $\(String(format: "%.2f", netProfit))")
            }
        }
    }
    
    // MISSING FUNCTION ADDED: Futures-spot arbitrage on single exchange
    static func checkFuturesSpotArbitrage(pair: String, exchange: String, spotPrice: Double, futuresPrice: Double) async {
        let spread = abs(futuresPrice - spotPrice) / spotPrice
        let minSpread = getDouble("ARBITRAGE_MIN_SPREAD_THRESHOLD", defaultValue: 0.003)
        
        guard spread >= minSpread else { return }
        
        let tradeAmount = getDouble("FUTURES_TRADE_AMOUNT", defaultValue: 600.0)
        
        // Calculate potential profit
        let expectedProfit = abs(futuresPrice - spotPrice) * (tradeAmount / spotPrice)
        let feeRate = exchange == "kucoin" ? kucoinTakerFee : bybitTakerFee
        let totalFees = tradeAmount * feeRate * 2 // Both spot and futures trades
        let netProfit = expectedProfit - totalFees
        
        guard netProfit > getDouble("FUTURES_MIN_PROFIT_PERCENTAGE", defaultValue: 0.001) * tradeAmount else {
            print("DEBUG: Futures-spot spread \(pair) on \(exchange) not profitable: spread=\(spread*100)%, net=\(netProfit)")
            return
        }
        
        // Check liquidity for both spot and futures
        let spotLiquidity = await checkLiquidityAsyncUnique(exchange: exchange, pair: pair, marketType: "spot", tradeAmount: tradeAmount, price: spotPrice)
        let futuresLiquidity = await checkLiquidityAsyncUnique(exchange: exchange, pair: pair, marketType: "futures", tradeAmount: tradeAmount, price: futuresPrice)
        
        guard spotLiquidity != nil, futuresLiquidity != nil else {
            print("DEBUG: Insufficient liquidity for futures-spot arbitrage \(pair) on \(exchange)")
            return
        }
        
        // Execute the arbitrage (buy low, sell high)
        let (buyMarket, sellMarket, buyPrice, sellPrice) = futuresPrice > spotPrice ?
            ("spot", "futures", spotPrice, futuresPrice) :
            ("futures", "spot", futuresPrice, spotPrice)
        
        print("ðŸš€ EXECUTING Futures-Spot Arbitrage: \(pair) on \(exchange) - Buy \(buyMarket) @\(buyPrice), Sell \(sellMarket) @\(sellPrice), Spread: \(String(format: "%.3f", spread*100))%, Profit: $\(String(format: "%.2f", netProfit))")
        
        let buySuccess = await executeTrade(exchange: exchange, pair: pair, side: "buy", price: buyPrice, amount: tradeAmount / buyPrice, strategy: "Futures-Spot Arbitrage")
        let sellSuccess = await executeTrade(exchange: exchange, pair: pair, side: "sell", price: sellPrice, amount: tradeAmount / sellPrice, strategy: "Futures-Spot Arbitrage")
        
        if buySuccess && sellSuccess {
            await MainActor.run {
                logAlert(event: "âœ… SUCCESS: Futures-spot arbitrage executed for \(pair) on \(exchange) - Profit: $\(String(format: "%.2f", netProfit))")
            }
        }
    }
    
    // MISSING FUNCTION ADDED: Cross-exchange futures arbitrage
    static func checkCrossExchangeFuturesArbitrage(pair: String, kucoinPrice: Double, bybitPrice: Double) async {
        let spread = abs(kucoinPrice - bybitPrice) / min(kucoinPrice, bybitPrice)
        let minSpread = getDouble("CROSS_EXCHANGE_MIN_SPREAD_THRESHOLD", defaultValue: 0.002)
        
        guard spread >= minSpread else { return }
        
        let buyExchange = kucoinPrice < bybitPrice ? "kucoin" : "bybit"
        let sellExchange = kucoinPrice < bybitPrice ? "bybit" : "kucoin"
        let buyPrice = min(kucoinPrice, bybitPrice)
        let sellPrice = max(kucoinPrice, bybitPrice)
        
        let tradeAmount = getDouble("FUTURES_TRADE_AMOUNT", defaultValue: 600.0)
        
        // Check if trade is profitable after fees
        let expectedProfit = (sellPrice - buyPrice) * (tradeAmount / buyPrice)
        let totalFees = tradeAmount * (kucoinFuturesFeeRate + bybitFuturesFeeRate)
        let netProfit = expectedProfit - totalFees
        
        guard netProfit > getDouble("FUTURES_MIN_PROFIT_PERCENTAGE", defaultValue: 0.001) * tradeAmount else {
            print("DEBUG: Cross-exchange futures spread \(pair) not profitable: spread=\(spread*100)%, net=\(netProfit)")
            return
        }
        
        // Check liquidity
        let buyLiquidity = await checkLiquidityAsyncUnique(exchange: buyExchange, pair: pair, marketType: "futures", tradeAmount: tradeAmount, price: buyPrice)
        let sellLiquidity = await checkLiquidityAsyncUnique(exchange: sellExchange, pair: pair, marketType: "futures", tradeAmount: tradeAmount, price: sellPrice)
        
        guard buyLiquidity != nil, sellLiquidity != nil else {
            print("DEBUG: Insufficient liquidity for cross-exchange futures arbitrage \(pair)")
            return
        }
        
        // Execute the arbitrage
        print("ðŸš€ EXECUTING Cross-Exchange Futures Arbitrage: \(pair) - Buy \(buyExchange) @\(buyPrice), Sell \(sellExchange) @\(sellPrice), Spread: \(String(format: "%.3f", spread*100))%, Profit: $\(String(format: "%.2f", netProfit))")
        
        let buySuccess = await executeTrade(exchange: buyExchange, pair: pair, side: "buy", price: buyPrice, amount: tradeAmount / buyPrice, strategy: "Cross-Exchange Futures Arbitrage")
        let sellSuccess = await executeTrade(exchange: sellExchange, pair: pair, side: "sell", price: sellPrice, amount: tradeAmount / sellPrice, strategy: "Cross-Exchange Futures Arbitrage")
        
        if buySuccess && sellSuccess {
            await MainActor.run {
                logAlert(event: "âœ… SUCCESS: Cross-exchange futures arbitrage executed for \(pair) - Profit: $\(String(format: "%.2f", netProfit))")
            }
        }
    }
    
    static func startTradingLoop() {
        Task { @MainActor in
            ExchangeWebSocket.connectKucoin()
            ExchangeWebSocket.connectBybit()
            await ExchangeWebSocket.startOrderBookPolling()
            
            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                ExchangeWebSocket.monitorHFTScalpingOpportunities()
                ExchangeWebSocket.startMainTradingLoop() // ENHANCED: Start comprehensive trading loop
                print("âœ… TRADING ACTIVE")
            }
        }
    }

    // ENHANCED: Complete executeTrade method with all original functionality preserved
    static func executeTrade(exchange: String, pair: String, side: String, price: Double, amount: Double, strategy: String) async -> Bool {
        guard await checkDailyLossLimit(exchange: exchange, pair: pair, potentialLoss: amount * price * getDouble("STOP_LOSS_PERCENTAGE", defaultValue: 0.02)) else {
            print("DEBUG: Trade skipped for \(exchange)-\(pair): Daily loss limit exceeded")
            return false
        }

        guard let _ = await checkLiquidityAsyncUnique(exchange: exchange, pair: pair, marketType: "spot", tradeAmount: amount, price: price) else {
            print("DEBUG: Trade skipped for \(exchange)-\(pair): Insufficient liquidity")
            return false
        }

        let volatility = await calculateVolatility(pair: pair, exchange: exchange)
        let tradeAmount = await dynamicTradeAmount(balance: exchange == "kucoin" ? kucoinBalance : bybitBalance, riskPercent: getDouble("RISK_PERCENTAGE", defaultValue: 0.01), volatility: volatility, pair: pair)

        guard tradeAmount > 0 else {
            print("DEBUG: Trade skipped for \(exchange)-\(pair): Invalid trade amount (\(tradeAmount))")
            return false
        }

        let adjustedAmount = min(amount, tradeAmount)
        ExchangeWebSocket.executeHFTTrade(exchange: exchange, pair: pair, side: side, price: price, amount: adjustedAmount)

        let profit = side == "buy" ? -adjustedAmount * price : adjustedAmount * price
        let fees = adjustedAmount * price * (exchange == "kucoin" ? kucoinTakerFee : bybitTakerFee)
        let netProfit = profit - fees

        await MainActor.run {
            updateTradeMetrics(
                pair: pair,
                profit: netProfit,
                fees: fees,
                isWin: netProfit > 0,
                dashboardJSONURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/dashboard.json"),
                totalProfit: &ExchangeWebSocket.totalProfit,
                totalFees: &ExchangeWebSocket.totalFees
            )
            logTradeToCSV(
                pair: pair,
                strategy: strategy,
                profit: netProfit,
                fees: fees,
                tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trades.csv")
            )
            sendTradeToFlaskServer(strategy: strategy, pair: pair, exchange: exchange, spotPrice: price, futuresPrice: 0.0, tradeAmount: adjustedAmount, profit: netProfit)
        }

        return netProfit > 0
    }

    static func calculateVolatility(pair: String, exchange: String) async -> Double {
        let prices = exchange == "kucoin" ? kucoinPrices[pair] : bybitPrices[pair]
        guard let priceArray = prices, priceArray.count >= 60 else {
            return getDouble("DEFAULT_VOLATILITY", defaultValue: 0.01)
        }
        let recentPrices = priceArray.suffix(60)
        let mean = recentPrices.reduce(0.0, +) / Double(recentPrices.count)
        let variance = recentPrices.reduce(0.0) { $0 + pow($1 - mean, 2) } / Double(recentPrices.count)
        return sqrt(variance) / mean
    }

    static func startOrderBookPolling() async {
        while true {
            for pair in tradingPairs {
                for exchange in ["kucoin", "bybit"] {
                    for marketType in ["spot", "futures"] {
                        do {
                            let _ = try await fetchOrderBookDepth(for: exchange, pair: pair, marketType: marketType)
                            await MainActor.run {
                                let orderBook = exchange == "kucoin" ? kucoinOrderBooks[pair] : bybitOrderBooks[pair]
                                if orderBook != nil {
                                    logAlert(event: "Updated order book for \(exchange)-\(pair)-\(marketType)")
                                }
                            }
                        } catch {
                            await MainActor.run {
                                logAlert(event: "Failed to poll order book for \(exchange)-\(pair)-\(marketType): \(error)")
                            }
                        }
                    }
                }
            }
            try? await Task.sleep(nanoseconds: 10_000_000_000) // 10 seconds
        }
    }
    
    static func scanTradingOpportunities() async {
        while tradingActive {
            do {
                await withTaskGroup(of: Void.self) { group in
                    for pair in tradingPairs {
                        group.addTask {
                            await evaluateArbitrageOpportunities(pair: pair)
                            await evaluateHFTOpportunities(pair: pair)
                            await evaluateMarketMakingOpportunities(pair: pair)
                            await evaluateFundingRateOpportunities(pair: pair)
                        }
                    }
                }
                
                assessPortfolioRisk()
                updateRiskMetrics()
                monitorDataQuality()
                
                try await Task.sleep(nanoseconds: 250_000_000) // 250ms scan interval
            } catch {
                await MainActor.run {
                    logAlert(event: "Error in scanTradingOpportunities: \(error)")
                }
                try? await Task.sleep(nanoseconds: 1_000_000_000) // 1 second on error
            }
        }
    }
    
    static func evaluateArbitrageOpportunities(pair: String) async {
        let kucoinPrice = await MainActor.run { kucoinCurrentPrice[pair] ?? 0.0 }
        let bybitPrice = await MainActor.run { bybitCurrentPrice[pair] ?? 0.0 }
        let kucoinFuturesPrice = await MainActor.run { kucoinCurrentFuturesPrice[pair] ?? 0.0 }
        let bybitFuturesPrice = await MainActor.run { bybitCurrentFuturesPrice[pair] ?? 0.0 }
        
        if kucoinPrice > 0 && bybitPrice > 0 {
            let spread = abs(kucoinPrice - bybitPrice) / min(kucoinPrice, bybitPrice)
            if spread > crossExchangeMinSpreadThreshold {
                await checkCrossExchangeArbitrage(pair: pair, strategy: "cross-arbitrage", amount: crossExchangeTradeAmount) { success in
                    if success {
                        Task { @MainActor in
                            logAlert(event: "âœ… Cross-exchange arbitrage executed for \(pair)")
                        }
                    }
                }
            }
        }
        
        if kucoinPrice > 0 && kucoinFuturesPrice > 0 {
            let spread = abs(kucoinPrice - kucoinFuturesPrice) / min(kucoinPrice, kucoinFuturesPrice)
            if spread > arbitrageMinSpreadThreshold {
                executeSpotFuturesArbitrage(
                    pair: pair,
                    kucoinSpotPrice: kucoinPrice,
                    kucoinFuturesPrice: kucoinFuturesPrice,
                    bybitSpotPrice: bybitPrice,
                    bybitFuturesPrice: bybitFuturesPrice,
                    amount: arbitrageTradeAmount
                ) { success in
                    if success {
                        Task { @MainActor in
                            logAlert(event: "âœ… KuCoin spot-futures arbitrage executed for \(pair)")
                        }
                    }
                }
            }
        }
        
        if bybitPrice > 0 && bybitFuturesPrice > 0 {
            let spread = abs(bybitPrice - bybitFuturesPrice) / min(bybitPrice, bybitFuturesPrice)
            if spread > arbitrageMinSpreadThreshold {
                executeSpotFuturesArbitrage(
                    pair: pair,
                    kucoinSpotPrice: kucoinPrice,
                    kucoinFuturesPrice: kucoinFuturesPrice,
                    bybitSpotPrice: bybitPrice,
                    bybitFuturesPrice: bybitFuturesPrice,
                    amount: arbitrageTradeAmount
                ) { success in
                    if success {
                        Task { @MainActor in
                            logAlert(event: "âœ… Bybit spot-futures arbitrage executed for \(pair)")
                        }
                    }
                }
            }
        }
    }
    
    static func evaluateHFTOpportunities(pair: String) async {
        let kucoinPrice = await MainActor.run { kucoinCurrentPrice[pair] ?? 0.0 }
        let bybitPrice = await MainActor.run { bybitCurrentPrice[pair] ?? 0.0 }
        let kucoinPrices = await MainActor.run { self.kucoinPrices[pair] ?? [] }
        let bybitPrices = await MainActor.run { self.bybitPrices[pair] ?? [] }
        
        guard kucoinPrice > 0 && bybitPrice > 0 else { return }
        
        let kucoinRSI = calculateRSI(prices: kucoinPrices, period: spotRsiPeriod) ?? 50.0
        let bybitRSI = calculateRSI(prices: bybitPrices, period: spotRsiPeriod) ?? 50.0
        
        await evaluateHFTStrategy(pair: pair, kucoinSpotRsi: kucoinRSI, bybitSpotRsi: bybitRSI)
        await evaluateLatencyArbitrage(pair: pair, kucoinPrice: kucoinPrice, bybitPrice: bybitPrice)
        await evaluateOrderBookImbalance(pair: pair)
        await evaluateVolumeSpikes(pair: pair)
    }
    
    static func evaluateMarketMakingOpportunities(pair: String) async {
        let kucoinBook = await MainActor.run { kucoinOrderBooks[pair] }
        let bybitBook = await MainActor.run { bybitOrderBooks[pair] }
        
        if let book = kucoinBook, !book.bids.isEmpty && !book.asks.isEmpty {
            let spread = (book.asks.first!.price - book.bids.first!.price) / book.bids.first!.price
            let marketMakingSpread = getDouble("MARKET_MAKING_SPREAD", defaultValue: 0.002)
            
            if spread > marketMakingSpread {
                await executeMarketMaking(exchange: "kucoin", pair: pair, orderBook: book)
            }
        }
        
        if let book = bybitBook, !book.bids.isEmpty && !book.asks.isEmpty {
            let spread = (book.asks.first!.price - book.bids.first!.price) / book.bids.first!.price
            let marketMakingSpread = getDouble("MARKET_MAKING_SPREAD", defaultValue: 0.002)
            
            if spread > marketMakingSpread {
                await executeMarketMaking(exchange: "bybit", pair: pair, orderBook: book)
            }
        }
    }
    
    static func evaluateFundingRateOpportunities(pair: String) async {
        let kucoinFundingRate = await MainActor.run { kucoinFundingRates[pair] ?? 0.0 }
        let bybitFundingRate = await MainActor.run { bybitFundingRates[pair] ?? 0.0 }
        
        await evaluateFundingRateMomentum(pair: pair, kucoinFundingRate: kucoinFundingRate, bybitFundingRate: bybitFundingRate)
    }
    
    static func evaluateLatencyArbitrage(pair: String, kucoinPrice: Double, bybitPrice: Double) async {
        let latencyDiff = abs((lastLatency["kucoin-\(pair)"] ?? 0.0) - (lastLatency["bybit-\(pair)"] ?? 0.0))
        
        if latencyDiff > 50.0 {
            let spread = abs(kucoinPrice - bybitPrice) / min(kucoinPrice, bybitPrice)
            if spread > hftSpreadThreshold {
                await MainActor.run {
                    logAlert(event: "ðŸš€ Latency arbitrage opportunity detected for \(pair): Spread \(spread), Latency diff \(latencyDiff)ms")
                }
                
                let success = await executeTrade(
                    exchange: latencyDiff > 0 ? "kucoin" : "bybit",
                    pair: pair,
                    side: kucoinPrice > bybitPrice ? "sell" : "buy",
                    price: kucoinPrice > bybitPrice ? kucoinPrice : bybitPrice,
                    amount: hftTradeAmount,
                    strategy: "Latency-Arbitrage"
                )
                
                if success {
                    await MainActor.run {
                        logAlert(event: "âœ… Latency arbitrage executed for \(pair)")
                    }
                }
            }
        }
    }
    
    static func evaluateOrderBookImbalance(pair: String) async {
        let kucoinBook = await MainActor.run { kucoinOrderBooks[pair] }
        let bybitBook = await MainActor.run { bybitOrderBooks[pair] }
        
        if let kBook = kucoinBook {
            let imbalance = calculateOrderBookImbalance(book: kBook)
            if imbalance > getDouble("ORDER_BOOK_IMBALANCE_THRESHOLD", defaultValue: 3.0) {
                let signal = imbalance > 1.0 ? "buy" : "sell"
                let success = await executeTrade(
                    exchange: "kucoin",
                    pair: pair,
                    side: signal,
                    price: kucoinCurrentPrice[pair] ?? 0.0,
                    amount: spotTradeAmount,
                    strategy: "OrderBook-Imbalance"
                )
                
                if success {
                    await MainActor.run {
                        logAlert(event: "âœ… Order book imbalance trade executed for \(pair) on KuCoin")
                    }
                }
            }
        }
        
        if let bBook = bybitBook {
            let imbalance = calculateOrderBookImbalance(book: bBook)
            if imbalance > getDouble("ORDER_BOOK_IMBALANCE_THRESHOLD", defaultValue: 3.0) {
                let signal = imbalance > 1.0 ? "buy" : "sell"
                let success = await executeTrade(
                    exchange: "bybit",
                    pair: pair,
                    side: signal,
                    price: bybitCurrentPrice[pair] ?? 0.0,
                    amount: spotTradeAmount,
                    strategy: "OrderBook-Imbalance"
                )
                
                if success {
                    await MainActor.run {
                        logAlert(event: "âœ… Order book imbalance trade executed for \(pair) on Bybit")
                    }
                }
            }
        }
    }
    
    static func evaluateVolumeSpikes(pair: String) async {
        let kucoinVolumes = await MainActor.run { kucoinSpotVolume[pair] ?? [] }
        let bybitVolumes = await MainActor.run { bybitSpotVolume[pair] ?? [] }
        
        if kucoinVolumes.count >= 10 {
            let avgVolume = kucoinVolumes.suffix(10).reduce(0, +) / 10.0
            let currentVolume = kucoinVolumes.last ?? 0.0
            
            if currentVolume > avgVolume * volumeAnomalyMultiplier {
                await MainActor.run {
                    logAlert(event: "ðŸ“ˆ Volume spike detected on KuCoin \(pair): \(currentVolume) vs avg \(avgVolume)")
                }
                
                let success = await executeTrade(
                    exchange: "kucoin",
                    pair: pair,
                    side: "buy",
                    price: kucoinCurrentPrice[pair] ?? 0.0,
                    amount: spotTradeAmount * 0.5,
                    strategy: "Volume-Momentum"
                )
                
                if success {
                    await MainActor.run {
                        logAlert(event: "âœ… Volume momentum trade executed for \(pair) on KuCoin")
                    }
                }
            }
        }
        
        if bybitVolumes.count >= 10 {
            let avgVolume = bybitVolumes.suffix(10).reduce(0, +) / 10.0
            let currentVolume = bybitVolumes.last ?? 0.0
            
            if currentVolume > avgVolume * volumeAnomalyMultiplier {
                await MainActor.run {
                    logAlert(event: "ðŸ“ˆ Volume spike detected on Bybit \(pair): \(currentVolume) vs avg \(avgVolume)")
                }
                
                let success = await executeTrade(
                    exchange: "bybit",
                    pair: pair,
                    side: "buy",
                    price: bybitCurrentPrice[pair] ?? 0.0,
                    amount: spotTradeAmount * 0.5,
                    strategy: "Volume-Momentum"
                )
                
                if success {
                    await MainActor.run {
                        logAlert(event: "âœ… Volume momentum trade executed for \(pair) on Bybit")
                    }
                }
            }
        }
    }
    
    static func executeMarketMaking(exchange: String, pair: String, orderBook: BevaixOrderBook) async {
        guard !orderBook.bids.isEmpty && !orderBook.asks.isEmpty else { return }
        
        let bestBid = orderBook.bids.first!.price
        let bestAsk = orderBook.asks.first!.price
        let midPrice = (bestBid + bestAsk) / 2.0
        let marketMakingSpread = getDouble("MARKET_MAKING_SPREAD", defaultValue: 0.002)
        
        let bidPrice = midPrice * (1 - marketMakingSpread / 2)
        let askPrice = midPrice * (1 + marketMakingSpread / 2)
        
        let success = await executeTrade(
            exchange: exchange,
            pair: pair,
            side: "both",
            price: midPrice,
            amount: spotTradeAmount * 0.3,
            strategy: "Market-Making"
        )
        
        if success {
            await MainActor.run {
                logAlert(event: "âœ… Market making executed for \(pair) on \(exchange): Bid \(bidPrice), Ask \(askPrice)")
            }
        }
    }
    
    static func startMainTradingLoop() {
        Task {
            while tradingActive {
                do {
                    let totalBalance = kucoinBalance + bybitBalance
                    let balanceRatio = totalBalance > 0 ? kucoinBalance / totalBalance : 0.5
                    let pairCount = Double(tradingPairs.count)
                    let tradingIntensity = pairCount > 0 ? pairCount / 22.0 : 0.0
                    let baseRiskFactor = dailyLossLimitPercentage * tradingIntensity
                    let adjustedRisk = balanceRatio * baseRiskFactor
                    let volatilityMultiplier = calculateMarketVolatility()
                    let finalRiskScore = adjustedRisk * (1.0 + volatilityMultiplier)
                    
                    if finalRiskScore > 0.1 {
                        await MainActor.run {
                            logAlert(event: "âš ï¸ High risk factor detected: \(finalRiskScore)")
                        }
                    }
                    
                    await scanTradingOpportunities()
                    await monitorActivePositions()
                    await orchestrateAITrading()
                    await adjustDynamicParameters()
                    await updatePerformanceMetrics()
                    
                    try await Task.sleep(nanoseconds: 100_000_000) // 100ms main loop
                } catch {
                    await MainActor.run {
                        logAlert(event: "Error in main trading loop: \(error)")
                    }
                    try? await Task.sleep(nanoseconds: 1_000_000_000) // 1 second on error
                }
            }
        }
    }
    
    static func monitorActivePositions() async {
        for pair in tradingPairs {
            if await MainActor.run(body: { kucoinInSpotTrade[pair] ?? false }) {
                let entryPrice = await MainActor.run { kucoinSpotEntryPrice[pair] ?? 0.0 }
                let currentPrice = await MainActor.run { kucoinCurrentPrice[pair] ?? 0.0 }
                let trailingStop = await MainActor.run { kucoinSpotTrailingStop[pair] ?? 0.0 }
                
                if currentPrice > 0 && entryPrice > 0 {
                    let profitPercent = (currentPrice - entryPrice) / entryPrice
                    let newTrailingStop = currentPrice * (1 - spotTrailingStopPercentage)
                    
                    let shouldExit = profitPercent >= spotMinProfitPercentage ||
                                   currentPrice <= trailingStop ||
                                   profitPercent <= -spotStopLossPercentage
                    
                    if shouldExit {
                        await MainActor.run {
                            kucoinInSpotTrade[pair] = false
                            kucoinSpotEntryPrice[pair] = 0.0
                            kucoinSpotTrailingStop[pair] = 0.0
                            activeSpotTrades[pair] = max(0, (activeSpotTrades[pair] ?? 0) - 1)
                            
                            let profit = (currentPrice - entryPrice) * (kucoinPositions[pair] ?? 0.0)
                            kucoinBalance += profit
                            kucoinPositions[pair] = 0.0
                            
                            logAlert(event: "ðŸ”„ Closed KuCoin position for \(pair): Profit \(String(format: "%.4f", profitPercent * 100))%")
                        }
                    } else if newTrailingStop > trailingStop {
                        await MainActor.run {
                            kucoinSpotTrailingStop[pair] = newTrailingStop
                        }
                    }
                }
            }
            
            if await MainActor.run(body: { bybitInSpotTrade[pair] ?? false }) {
                let entryPrice = await MainActor.run { bybitSpotEntryPrice[pair] ?? 0.0 }
                let currentPrice = await MainActor.run { bybitCurrentPrice[pair] ?? 0.0 }
                let trailingStop = await MainActor.run { bybitSpotTrailingStop[pair] ?? 0.0 }
                
                if currentPrice > 0 && entryPrice > 0 {
                    let profitPercent = (currentPrice - entryPrice) / entryPrice
                    let newTrailingStop = currentPrice * (1 - spotTrailingStopPercentage)
                    
                    let shouldExit = profitPercent >= spotMinProfitPercentage ||
                                   currentPrice <= trailingStop ||
                                   profitPercent <= -spotStopLossPercentage
                    
                    if shouldExit {
                        await MainActor.run {
                            bybitInSpotTrade[pair] = false
                            bybitSpotEntryPrice[pair] = 0.0
                            bybitSpotTrailingStop[pair] = 0.0
                            activeSpotTrades[pair] = max(0, (activeSpotTrades[pair] ?? 0) - 1)
                            
                            let profit = (currentPrice - entryPrice) * (bybitPositions[pair] ?? 0.0)
                            bybitBalance += profit
                            bybitPositions[pair] = 0.0
                            
                            logAlert(event: "ðŸ”„ Closed Bybit position for \(pair): Profit \(String(format: "%.4f", profitPercent * 100))%")
                        }
                    } else if newTrailingStop > trailingStop {
                        await MainActor.run {
                            bybitSpotTrailingStop[pair] = newTrailingStop
                        }
                    }
                }
            }
        }
    }
    
    static func orchestrateAITrading() async {
        let aiConfidence = await calculateAIConfidence()
        
        if aiConfidence > 0.8 {
            for pair in tradingPairs.prefix(5) {
                let signals = await generateAISignals(pair: pair)
                await executeAITrades(pair: pair, signals: signals, confidence: aiConfidence)
            }
        }
    }
    
    static func calculateAIConfidence() async -> Double {
        var confidenceFactors: [Double] = []
        
        let volatility = calculateMarketVolatility()
        confidenceFactors.append(1.0 - min(volatility * 10, 1.0))
        
        let dataQuality = await assessDataQuality()
        confidenceFactors.append(dataQuality)
        
        let recentPerformance = await assessRecentPerformance()
        confidenceFactors.append(recentPerformance)
        
        return confidenceFactors.reduce(0, +) / Double(confidenceFactors.count)
    }
    
    static func generateAISignals(pair: String) async -> [String: Double] {
        var signals: [String: Double] = [:]
        
        signals["momentum"] = calculateMomentumSignal(pair: pair)
        signals["meanReversion"] = calculateMeanReversionSignal(pair: pair)
        signals["marketMaking"] = calculateMarketMakingSignal(pair: pair)
        signals["sentiment"] = await MainActor.run { sentimentScores[pair] ?? 0.0 }
        
        return signals
    }
    
    static func executeAITrades(pair: String, signals: [String: Double], confidence: Double) async {
        let momentumSignal = signals["momentum"] ?? 0.0
        let sentimentSignal = signals["sentiment"] ?? 0.0
        
        let combinedSignal = (momentumSignal + sentimentSignal) / 2.0
        let signalStrength = abs(combinedSignal) * confidence
        
        if signalStrength > 0.6 {
            let exchange = compareExchangeLiquidity(pair: pair)
            let side = combinedSignal > 0 ? "buy" : "sell"
            let price = await MainActor.run {
                exchange == "kucoin" ? kucoinCurrentPrice[pair] ?? 0.0 : bybitCurrentPrice[pair] ?? 0.0
            }
            
            if price > 0 {
                let success = await executeTrade(
                    exchange: exchange,
                    pair: pair,
                    side: side,
                    price: price,
                    amount: spotTradeAmount * signalStrength,
                    strategy: "AI-Enhanced"
                )
                
                if success {
                    await MainActor.run {
                        logAlert(event: "ðŸ¤– AI-enhanced trade executed for \(pair): Signal \(signalStrength)")
                    }
                }
            }
        }
    }
    
    static func adjustDynamicParameters() async {
        let marketCondition = await analyzeCurrentMarketCondition()
        
        switch marketCondition {
        case "high_volatility":
            await MainActor.run {
                spotTrailingStopPercentage = min(spotTrailingStopPercentage * 1.5, 0.05)
                logAlert(event: "ðŸ“Š Adjusted trailing stop for high volatility: \(spotTrailingStopPercentage)")
            }
        case "low_volatility":
            await MainActor.run {
                spotTrailingStopPercentage = max(spotTrailingStopPercentage * 0.8, 0.001)
                logAlert(event: "ðŸ“Š Adjusted trailing stop for low volatility: \(spotTrailingStopPercentage)")
            }
        case "trending":
            await MainActor.run {
                scalpProfitTarget = scalpProfitTarget * 1.2
                logAlert(event: "ðŸ“Š Increased profit target for trending market: \(scalpProfitTarget)")
            }
        default:
            break
        }
    }
    
    static func analyzeCurrentMarketCondition() async -> String {
        let volatility = calculateMarketVolatility()
        var trendingPairs = 0
        
        for pair in tradingPairs {
            let momentum = calculateMomentumSignal(pair: pair)
            if abs(momentum) > 0.02 {
                trendingPairs += 1
            }
        }
        
        let trendingRatio = Double(trendingPairs) / Double(tradingPairs.count)
        
        if volatility > 0.05 {
            return "high_volatility"
        } else if volatility < 0.01 {
            return "low_volatility"
        } else if trendingRatio > 0.6 {
            return "trending"
        } else {
            return "normal"
        }
    }
    
    static func updatePerformanceMetrics() async {
        let currentTime = Date()
        
        await MainActor.run {
            let totalTrades = tradeMetrics.values.reduce(0) { $0 + $1.wins + $1.losses }
            let totalWins = tradeMetrics.values.reduce(0) { $0 + $1.wins }
            let winRate = totalTrades > 0 ? Double(totalWins) / Double(totalTrades) : 0.0
            let totalProfitValue = tradeMetrics.values.reduce(0.0) { $0 + $1.totalProfit }
            let totalFeesValue = tradeMetrics.values.reduce(0.0) { $0 + $1.totalFees }
            let netProfit = totalProfitValue - totalFeesValue
            
            realtimeMetrics["total_trades"] = Double(totalTrades)
            realtimeMetrics["win_rate"] = winRate
            realtimeMetrics["total_profit"] = totalProfitValue
            realtimeMetrics["total_fees"] = totalFeesValue
            realtimeMetrics["net_profit"] = netProfit
            realtimeMetrics["kucoin_balance"] = kucoinBalance
            realtimeMetrics["bybit_balance"] = bybitBalance
            
            if currentTime.timeIntervalSince(lastSummaryTime) > 300 {
                lastSummaryTime = currentTime
                
                let averageLatency = lastLatency.values.reduce(0, +) / Double(max(lastLatency.count, 1))
                let tradesPerMinute = totalTrades > 0 ? Double(totalTrades) / max(currentTime.timeIntervalSince(Date().addingTimeInterval(-3600)), 1) * 60 : 0
                
                let performanceSummary = """
                ðŸ“Š 5-Minute Performance Summary:
                Total Trades: \(totalTrades) | Win Rate: \(String(format: "%.1f", winRate * 100))%
                Net Profit: \(String(format: "%.2f", netProfit)) USDT | ROI: \(String(format: "%.2f", netProfit / max(totalBalance, 1) * 100))%
                Trades/Min: \(String(format: "%.1f", tradesPerMinute)) | Avg Latency: \(String(format: "%.1f", averageLatency))ms
                KuCoin: \(String(format: "%.2f", kucoinBalance)) | Bybit: \(String(format: "%.2f", bybitBalance))
                """
                
                print(performanceSummary)
                logAlert(event: performanceSummary)
            }
        }
    }
    
    static func assessDataQuality() async -> Double {
        var qualityScore = 1.0
        let now = Date()
        
        for pair in tradingPairs {
            let lastUpdate = await MainActor.run { lastDataUpdate[pair] }
            if let update = lastUpdate {
                let staleness = now.timeIntervalSince(update)
                if staleness > 60 {
                    qualityScore *= 0.9
                }
            } else {
                qualityScore *= 0.8
            }
        }
        
        return max(qualityScore, 0.1)
    }
    
    static func assessRecentPerformance() async -> Double {
        let recentTrades = await MainActor.run {
            tradeMetrics.values.reduce(0) { $0 + $1.wins + $1.losses }
        }
        
        guard recentTrades > 0 else { return 0.5 }
        
        let winRate = await MainActor.run {
            let wins = tradeMetrics.values.reduce(0) { $0 + $1.wins }
            return Double(wins) / Double(recentTrades)
        }
        
        return winRate
    }
}

// Main entry point
DispatchQueue.main.async {
    ExchangeWebSocket.initializeParameters {
        ExchangeWebSocket.startTradingLoop()
        ExchangeWebSocket.logDashboardMetrics()
    }
}

RunLoop.main.run()
