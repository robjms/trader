//---------------------------------------------------------------------------------------------------------------------Block 14 - Core Trading Loop Execution - FIXED

extension ExchangeWebSocket {
    
    // FIXED: Enhanced trading loop with proper execution
    static func startTradingLoop() async {
        print("ðŸš€ Starting Enhanced Trading Loop...")
        logAlert(event: "ðŸš€ Starting Enhanced Trading Loop...")
        
        var loopCount = 0
        
        while tradingActive && !emergencyStopActive {
            let startTime = Date()
            
            do {
                // Increment loop counter
                loopCount += 1
                
                if loopCount % 10 == 0 {
                    print("ðŸ”„ Trading Loop #\(loopCount) - Active Pairs: \(tradingPairs.count)")
                }
                
                // 1. Check connection health
                await checkConnectionHealth()
                
                // 2. Update balances periodically (every 30 loops)
                if loopCount % 30 == 0 {
                    await updateBalances()
                }
                
                // 3. Process trading opportunities for each pair
                await withTaskGroup(of: Void.self) { group in
                    for pair in tradingPairs {
                        group.addTask {
                            await processPairTradingLogic(pair: pair)
                        }
                    }
                }
                
                // 4. Risk management checks
                await performRiskManagementChecks()
                
                // 5. Update performance metrics
                updatePerformanceMetrics()
                
                // 6. Update dashboard every few loops
                if loopCount % 5 == 0 {
                    updateDashboardJSON()
                }
                
                // Calculate loop execution time
                let executionTime = Date().timeIntervalSince(startTime)
                
                if executionTime > 1.0 {
                    print("âš ï¸ Slow trading loop execution: \(String(format: "%.2f", executionTime))s")
                    logAlert(event: "âš ï¸ Slow trading loop execution: \(String(format: "%.2f", executionTime))s")
                }
                
                // Sleep for configured interval (targeting 4+ trades per minute)
                let sleepTime = max(0.1, 0.5 - executionTime) // Minimum 100ms, target 500ms loop
                try await Task.sleep(nanoseconds: UInt64(sleepTime * 1_000_000_000))
                
            } catch {
                print("âŒ Trading loop error: \(error)")
                logAlert(event: "âŒ Trading loop error: \(error)")
                
                // Brief pause before retrying
                try? await Task.sleep(nanoseconds: 2_000_000_000) // 2 seconds
            }
        }
        
        print("â¹ï¸ Trading loop stopped")
        logAlert(event: "â¹ï¸ Trading loop stopped")
    }
    
    // FIXED: Process trading logic for individual pairs
    static func processPairTradingLogic(pair: String) async {
        let kucoinPrice = kucoinCurrentPrice[pair] ?? 0.0
        let bybitPrice = bybitCurrentPrice[pair] ?? 0.0
        
        // Skip if no price data
        guard kucoinPrice > 0 || bybitPrice > 0 else {
            return
        }
        
        // 1. Cross-exchange arbitrage opportunities
        if kucoinPrice > 0 && bybitPrice > 0 {
            await evaluateCrossExchangeArbitrage(pair: pair, kucoinPrice: kucoinPrice, bybitPrice: bybitPrice)
        }
        
        // 2. HFT scalping opportunities
        if bybitPrice > 0 {
            await evaluateHFTScalping(pair: pair, exchange: "bybit", price: bybitPrice)
        }
        
        if kucoinPrice > 0 {
            await evaluateHFTScalping(pair: pair, exchange: "kucoin", price: kucoinPrice)
        }
        
        // 3. Market making opportunities
        await evaluateMarketMaking(pair: pair)
    }
    
    // FIXED: Cross-exchange arbitrage evaluation with ML
    static func evaluateCrossExchangeArbitrage(pair: String, kucoinPrice: Double, bybitPrice: Double) async {
        let priceDiff = abs(kucoinPrice - bybitPrice)
        let avgPrice = (kucoinPrice + bybitPrice) / 2
        let spreadPercent = priceDiff / avgPrice
        
        // Check minimum spread threshold
        guard spreadPercent >= crossExchangeMinSpreadThreshold else {
            return
        }
        
        // Check cooldown period
        if let (_, lastTime) = crossExchangeArbitrageExecuted[pair] {
            let timeSinceLastTrade = Date().timeIntervalSince(lastTime)
            guard timeSinceLastTrade >= crossExchangeCooldownSeconds else {
                return
            }
        }
        
        // ML enhancement - get sentiment and confidence
        let sentimentScore = sentimentScores[pair] ?? 0.0
        let mlConfidence = evaluateCrossExchangeOpportunityWithML(
            pair: pair,
            kucoinPrice: kucoinPrice,
            bybitPrice: bybitPrice,
            spreadPercent: spreadPercent,
            sentimentScore: sentimentScore
        )
        
        // Execute trade if confidence is high enough
        if mlConfidence > 0.6 {
            let tradeAmount = min(crossExchangeTradeAmount, kucoinBalance * 0.1, bybitBalance * 0.1)
            
            if tradeAmount >= 10.0 { // Minimum trade size
                await executeCrossExchangeArbitrage(
                    pair: pair,
                    kucoinPrice: kucoinPrice,
                    bybitPrice: bybitPrice,
                    tradeAmount: tradeAmount,
                    mlConfidence: mlConfidence
                )
            }
        }
    }
    
    // FIXED: Execute cross-exchange arbitrage trade
    static func executeCrossExchangeArbitrage(pair: String, kucoinPrice: Double, bybitPrice: Double, tradeAmount: Double, mlConfidence: Double) async {
        let buyExchange = kucoinPrice < bybitPrice ? "kucoin" : "bybit"
        let sellExchange = buyExchange == "kucoin" ? "bybit" : "kucoin"
        let buyPrice = buyExchange == "kucoin" ? kucoinPrice : bybitPrice
        let sellPrice = sellExchange == "kucoin" ? kucoinPrice : bybitPrice
        
        let grossProfit = (sellPrice - buyPrice) * (tradeAmount / buyPrice)
        let estimatedFees = tradeAmount * (spotFeeRate * 2) // Buy + sell fees
        let netProfit = grossProfit - estimatedFees
        
        // Ensure minimum profit threshold
        guard netProfit >= 0.20 else { // Minimum $0.20 profit
            return
        }
        
        // Log simulated trade (since SIMULATION_TRADE_LOGGING is true)
        let isSimulation = await getBool("SIMULATION_TRADE_LOGGING", defaultValue: true)
        
        if isSimulation {
            await logSimulatedTrade(
                pair: pair,
                strategy: "cross_exchange_arbitrage",
                buyExchange: buyExchange,
                sellExchange: sellExchange,
                tradeAmount: tradeAmount,
                buyPrice: buyPrice,
                sellPrice: sellPrice,
                grossProfit: grossProfit,
                fees: estimatedFees,
                netProfit: netProfit,
                mlConfidence: mlConfidence
            )
        }
        
        // Update arbitrage tracking
        crossExchangeArbitrageExecuted[pair] = (true, Date())
        
        print("ðŸ’° Cross-Exchange Arbitrage: \(pair) - Buy \(buyExchange) $\(String(format: "%.4f", buyPrice)), Sell \(sellExchange) $\(String(format: "%.4f", sellPrice)), Profit: $\(String(format: "%.2f", netProfit))")
    }
    
    // FIXED: HFT scalping evaluation
    static func evaluateHFTScalping(pair: String, exchange: String, price: Double) async {
        let priceHistory = exchange == "bybit" ? bybitPrices[pair] ?? [] : kucoinPrices[pair] ?? []
        
        // Need sufficient price history for technical analysis
        guard priceHistory.count >= 20 else { return }
        
        // Calculate RSI
        guard let rsi = calculateRSI(prices: priceHistory, period: 14) else { return }
        
        // Scalping signals
        let isOversold = rsi < 30
        let isOverbought = rsi > 70
        
        // Price momentum
        let recentPrices = Array(priceHistory.suffix(5))
        let priceChange = (recentPrices.last! - recentPrices.first!) / recentPrices.first!
        let momentumThreshold = 0.002 // 0.2% momentum
        
        let shouldBuy = isOversold && priceChange > -momentumThreshold
        let shouldSell = isOverbought && priceChange < momentumThreshold
        
        if shouldBuy || shouldSell {
            let tradeAmount = min(spotTradeAmount, (exchange == "bybit" ? bybitBalance : kucoinBalance) * 0.05)
            
            if tradeAmount >= 10.0 {
                await executeHFTScalping(
                    pair: pair,
                    exchange: exchange,
                    action: shouldBuy ? "buy" : "sell",
                    price: price,
                    tradeAmount: tradeAmount,
                    rsi: rsi
                )
            }
        }
    }
    
    // FIXED: Execute HFT scalping trade
    static func executeHFTScalping(pair: String, exchange: String, action: String, price: Double, tradeAmount: Double, rsi: Double) async {
        let targetProfitPercent = 0.003 // 0.3% target profit
        let targetPrice = action == "buy" ? price * (1 + targetProfitPercent) : price * (1 - targetProfitPercent)
        
        let estimatedFees = tradeAmount * spotFeeRate
        let grossProfit = tradeAmount * targetProfitPercent
        let netProfit = grossProfit - estimatedFees
        
        guard netProfit >= 0.10 else { return } // Minimum $0.10 profit
        
        // Log simulated trade
        let isSimulation = await getBool("SIMULATION_TRADE_LOGGING", defaultValue: true)
        
        if isSimulation {
            await logSimulatedTrade(
                pair: pair,
                strategy: "hft_scalping",
                buyExchange: exchange,
                sellExchange: exchange,
                tradeAmount: tradeAmount,
                buyPrice: action == "buy" ? price : targetPrice,
                sellPrice: action == "buy" ? targetPrice : price,
                grossProfit: grossProfit,
                fees: estimatedFees,
                netProfit: netProfit,
                mlConfidence: rsi / 100.0
            )
        }
        
        print("âš¡ HFT Scalping: \(pair) on \(exchange) - \(action.uppercased()) at $\(String(format: "%.4f", price)), Target: $\(String(format: "%.4f", targetPrice)), Profit: $\(String(format: "%.2f", netProfit))")
    }
    
    // FIXED: Market making evaluation
    static func evaluateMarketMaking(pair: String) async {
        let kucoinBook = kucoinOrderBooks[pair]
        let bybitBook = bybitOrderBooks[pair]
        
        // Check if we have order book data
        guard let kBook = kucoinBook, !kBook.bids.isEmpty && !kBook.asks.isEmpty,
              let bBook = bybitBook, !bBook.bids.isEmpty && !bBook.asks.isEmpty else {
            return
        }
        
        // Calculate spreads
        let kucoinSpread = (kBook.asks.first?.price ?? 0) - (kBook.bids.first?.price ?? 0)
        let bybitSpread = (bBook.asks.first?.price ?? 0) - (bBook.bids.first?.price ?? 0)
        
        let avgPrice = ((kBook.bids.first?.price ?? 0) + (kBook.asks.first?.price ?? 0) + (bBook.bids.first?.price ?? 0) + (bBook.asks.first?.price ?? 0)) / 4
        
        let kucoinSpreadPercent = kucoinSpread / avgPrice
        let bybitSpreadPercent = bybitSpread / avgPrice
        
        // Market make on exchange with wider spread (more profitable)
        let targetExchange = kucoinSpreadPercent > bybitSpreadPercent ? "kucoin" : "bybit"
        let targetSpreadPercent = max(kucoinSpreadPercent, bybitSpreadPercent)
        
        // Only market make if spread is wide enough
        if targetSpreadPercent >= 0.001 { // 0.1% minimum spread
            let tradeAmount = min(50.0, (targetExchange == "bybit" ? bybitBalance : kucoinBalance) * 0.03)
            
            if tradeAmount >= 5.0 {
                await executeMarketMaking(
                    pair: pair,
                    exchange: targetExchange,
                    spread: targetSpreadPercent,
                    tradeAmount: tradeAmount,
                    midPrice: avgPrice
                )
            }
        }
    }
    
    // FIXED: Execute market making
    static func executeMarketMaking(pair: String, exchange: String, spread: Double, tradeAmount: Double, midPrice: Double) async {
        let estimatedProfit = tradeAmount * spread * 0.5 // Capture half the spread
        let estimatedFees = tradeAmount * spotFeeRate * 2 // Both sides
        let netProfit = estimatedProfit - estimatedFees
        
        guard netProfit >= 0.05 else { return } // Minimum $0.05 profit
        
        // Log simulated market making
        let isSimulation = await getBool("SIMULATION_TRADE_LOGGING", defaultValue: true)
        
        if isSimulation {
            await logSimulatedTrade(
                pair: pair,
                strategy: "market_making",
                buyExchange: exchange,
                sellExchange: exchange,
                tradeAmount: tradeAmount,
                buyPrice: midPrice * (1 - spread/2),
                sellPrice: midPrice * (1 + spread/2),
                grossProfit: estimatedProfit,
                fees: estimatedFees,
                netProfit: netProfit,
                mlConfidence: spread * 100
            )
        }
        
        print("ðŸŽ¯ Market Making: \(pair) on \(exchange) - Spread: \(String(format: "%.3f", spread*100))%, Profit: $\(String(format: "%.2f", netProfit))")
    }
    
    // FIXED: Log simulated trades to CSV
    @MainActor
    static func logSimulatedTrade(
        pair: String,
        strategy: String,
        buyExchange: String,
        sellExchange: String,
        tradeAmount: Double,
        buyPrice: Double,
        sellPrice: Double,
        grossProfit: Double,
        fees: Double,
        netProfit: Double,
        mlConfidence: Double
    ) async {
        let timestamp = ISO8601DateFormatter().string(from: Date())
        let tradeLogURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trade_log.csv")
        
        // Create CSV header if file doesn't exist
        if !FileManager.default.fileExists(atPath: tradeLogURL.path) {
            let header = "timestamp,pair,strategy,buy_exchange,sell_exchange,trade_amount,buy_price,sell_price,gross_profit,fees,net_profit,ml_confidence\n"
            try? header.write(to: tradeLogURL, atomically: true, encoding: .utf8)
        }
        
        // Prepare trade entry
        let tradeEntry = "\(timestamp),\(pair),\(strategy),\(buyExchange),\(sellExchange),\(String(format: "%.2f", tradeAmount)),\(String(format: "%.4f", buyPrice)),\(String(format: "%.4f", sellPrice)),\(String(format: "%.2f", grossProfit)),\(String(format: "%.2f", fees)),\(String(format: "%.2f", netProfit)),\(String(format: "%.3f", mlConfidence))\n"
        
        // Append to file
        do {
            let fileHandle = try FileHandle(forWritingTo: tradeLogURL)
            fileHandle.seekToEndOfFile()
            if let data = tradeEntry.data(using: .utf8) {
                fileHandle.write(data)
            }
            fileHandle.closeFile()
            
            // Update performance metrics
            var metrics = performanceMetrics[pair] ?? (profit: 0.0, fees: 0.0, trades: 0, wins: 0)
            metrics.profit += netProfit
            metrics.fees += fees
            metrics.trades += 1
            if netProfit > 0 { metrics.wins += 1 }
            performanceMetrics[pair] = metrics
            
            print("ðŸ“Š Trade logged: \(strategy) - \(pair) - Profit: $\(String(format: "%.2f", netProfit))")
            
        } catch {
            print("âŒ Failed to log trade: \(error)")
            logAlert(event: "âŒ Failed to log trade: \(error)")
        }
    }
    
    // FIXED: ML opportunity evaluation
    static func evaluateCrossExchangeOpportunityWithML(
        pair: String,
        kucoinPrice: Double,
        bybitPrice: Double,
        spreadPercent: Double,
        sentimentScore: Double
    ) -> Double {
        // Simple ML confidence scoring based on multiple factors
        var confidence: Double = 0.0
        
        // 1. Spread magnitude (higher spread = higher confidence)
        let spreadScore = min(spreadPercent / 0.01, 1.0) // Normalize to 0.01 (1%) max
        confidence += spreadScore * 0.4
        
        // 2. Sentiment alignment
        let sentimentScore = abs(sentimentScore) // Strength of sentiment regardless of direction
        confidence += sentimentScore * 0.2
        
        // 3. Price history volatility
        let kucoinPrices = kucoinPrices[pair] ?? []
        if kucoinPrices.count >= 10 {
            let recentPrices = Array(kucoinPrices.suffix(10))
            let volatility = calculateVolatility(prices: recentPrices)
            let volatilityScore = min(volatility / 0.02, 1.0) // Normalize to 2% max
            confidence += volatilityScore * 0.2
        }
        
        // 4. Time of day factor (prime trading hours)
        let primeTimeScore = isPrimeTradingTime() ? 0.2 : 0.1
        confidence += primeTimeScore
        
        return min(confidence, 1.0) // Cap at 1.0
    }
    
    // Helper function to calculate price volatility
    static func calculateVolatility(prices: [Double]) -> Double {
        guard prices.count > 1 else { return 0.0 }
        
        let returns = zip(prices.dropFirst(), prices.dropLast()).map { (current, previous) in
            (current - previous) / previous
        }
        
        let mean = returns.reduce(0, +) / Double(returns.count)
        let variance = returns.map { pow($0 - mean, 2) }.reduce(0, +) / Double(returns.count)
        return sqrt(variance)
    }
    
    // FIXED: Connection health monitoring
    static func checkConnectionHealth() async {
        if !kucoinIsConnected && hasValidKuCoinCredentials {
            print("âš ï¸ KuCoin connection lost - attempting reconnect")
            connectKucoin()
        }
        
        if !bybitIsConnected {
            print("âš ï¸ Bybit connection lost - attempting reconnect")
            connectBybit()
        }
    }
    
    // FIXED: Update balances periodically
    static func updateBalances() async {
        await withTaskGroup(of: Void.self) { group in
            group.addTask {
                fetchKucoinBalance { balance in
                    // Balance updated in callback
                }
            }
            
            group.addTask {
                fetchBybitBalance { balance in
                    // Balance updated in callback
                }
            }
        }
    }
    
    // FIXED: Risk management checks
    static func performRiskManagementChecks() async {
        // Check daily loss limits
        let totalLoss = dailyLoss.values.reduce(0, +)
        let totalBalance = kucoinBalance + bybitBalance
        let lossPercentage = totalBalance > 0 ? totalLoss / totalBalance : 0
        
        if lossPercentage >= dailyLossLimitPercentage {
            emergencyStopActive = true
            print("ðŸ›‘ EMERGENCY STOP: Daily loss limit exceeded (\(String(format: "%.1f", lossPercentage*100))%)")
            logAlert(event: "ðŸ›‘ EMERGENCY STOP: Daily loss limit exceeded (\(String(format: "%.1f", lossPercentage*100))%)")
        }
        
        // Reset daily loss at midnight
        let calendar = Calendar.current
        if !calendar.isDate(lastDailyReset, inSameDayAs: Date()) {
            dailyLoss = ["bybit": 0.0, "kucoin": 0.0]
            lastDailyReset = Date()
            print("ðŸ”„ Daily loss counters reset")
        }
    }
    
    // FIXED: Update performance metrics
    @MainActor
    static func updatePerformanceMetrics() {
        let totalTrades = performanceMetrics.values.reduce(0) { $0 + $1.trades }
        let totalProfit = performanceMetrics.values.reduce(0.0) { $0 + $1.profit }
        let totalWins = performanceMetrics.values.reduce(0) { $0 + $1.wins }
        
        // Log summary every 100 trades
        if totalTrades > 0 && totalTrades % 100 == 0 {
            let winRate = Double(totalWins) / Double(totalTrades) * 100
            print("ðŸ“ˆ Performance Summary: \(totalTrades) trades, $\(String(format: "%.2f", totalProfit)) profit, \(String(format: "%.1f", winRate))% win rate")
            logAlert(event: "ðŸ“ˆ Performance: \(totalTrades) trades, $\(String(format: "%.2f", totalProfit)) profit, \(String(format: "%.1f", winRate))% win rate")
        }
    }
}

// Main entry point
DispatchQueue.main.async {
    ExchangeWebSocket.initializeParameters {
        ExchangeWebSocket.startTradingLoop()
        ExchangeWebSocket.scanTradingOpportunities()
        ExchangeWebSocket.monitorFundingRateArbitrage()
        ExchangeWebSocket.monitorCrossExchangeArbitrage()
        ExchangeWebSocket.logDashboardMetrics()
        
        // Fetch initial balances
        ExchangeWebSocket.fetchKucoinBalance { _ in
            print("Initial KuCoin balance fetched")
        }
        ExchangeWebSocket.fetchBybitBalance { _ in
            print("Initial Bybit balance fetched")
        }
        
        print("ðŸš€ BevaixBot fully initialized and trading!")
    }
}

RunLoop.main.run()
