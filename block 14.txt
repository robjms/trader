
//------------------------------------------------------------------------------------------------------Block 14 - Core Trading Loop Execution



import Foundation

extension ExchangeWebSocket {
    static func startTradingLoop() {
        Task { @MainActor in
            ExchangeWebSocket.connectKucoin()
            ExchangeWebSocket.connectBybit()
            await ExchangeWebSocket.startOrderBookPolling()
            
            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                ExchangeWebSocket.monitorHFTScalpingOpportunities()
                print("✅ TRADING ACTIVE")
            }
        }
    }

    static func executeTrade(exchange: String, pair: String, side: String, price: Double, amount: Double, strategy: String) async -> Bool {
        guard await checkDailyLossLimit(exchange: exchange, pair: pair, potentialLoss: amount * price * getDouble("STOP_LOSS_PERCENTAGE", defaultValue: 0.02)) else {
            print("DEBUG: Trade skipped for \(exchange)-\(pair): Daily loss limit exceeded")
            return false
        }

        guard let _ = await checkLiquidityAsyncUnique(exchange: exchange, pair: pair, marketType: "spot", tradeAmount: amount, price: price) else {
            print("DEBUG: Trade skipped for \(exchange)-\(pair): Insufficient liquidity")
            return false
        }

        let volatility = await calculateVolatility(pair: pair, exchange: exchange)
        let tradeAmount = await dynamicTradeAmount(balance: exchange == "kucoin" ? kucoinBalance : bybitBalance, riskPercent: getDouble("RISK_PERCENTAGE", defaultValue: 0.01), volatility: volatility, pair: pair)

        guard tradeAmount > 0 else {
            print("DEBUG: Trade skipped for \(exchange)-\(pair): Invalid trade amount (\(tradeAmount))")
            return false
        }

        let adjustedAmount = min(amount, tradeAmount)
        ExchangeWebSocket.executeHFTTrade(exchange: exchange, pair: pair, side: side, price: price, amount: adjustedAmount)

        let profit = side == "buy" ? -adjustedAmount * price : adjustedAmount * price
        let fees = adjustedAmount * price * (exchange == "kucoin" ? kucoinTakerFee : bybitTakerFee)
        let netProfit = profit - fees

        await MainActor.run {
            updateTradeMetrics(
                pair: pair,
                profit: netProfit,
                fees: fees,
                isWin: netProfit > 0,
                dashboardJSONURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/dashboard.json"),
                totalProfit: &ExchangeWebSocket.totalProfit,
                totalFees: &ExchangeWebSocket.totalFees
            )
            logTradeToCSV(
                pair: pair,
                strategy: strategy,
                profit: netProfit,
                fees: fees,
                tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trades.csv")
            )
            sendTradeToFlaskServer(strategy: strategy, pair: pair, exchange: exchange, spotPrice: price, futuresPrice: 0.0, tradeAmount: adjustedAmount, profit: netProfit)
        }

        return netProfit > 0
    }

    static func calculateVolatility(pair: String, exchange: String) async -> Double {
        let prices = exchange == "kucoin" ? kucoinPrices[pair] : bybitPrices[pair]
        guard let priceArray = prices, priceArray.count >= 60 else {
            return getDouble("DEFAULT_VOLATILITY", defaultValue: 0.01)
        }
        let recentPrices = priceArray.suffix(60)
        let mean = recentPrices.reduce(0.0, +) / Double(recentPrices.count)
        let variance = recentPrices.reduce(0.0) { $0 + pow($1 - mean, 2) } / Double(recentPrices.count)
        return sqrt(variance) / mean
    }

    static func startOrderBookPolling() async {
        while true {
            for pair in tradingPairs {
                for exchange in ["kucoin", "bybit"] {
                    for marketType in ["spot", "futures"] {
                        do {
                            let _ = try await fetchOrderBookDepth(for: exchange, pair: pair, marketType: marketType)
                            await MainActor.run {
                                let orderBook = exchange == "kucoin" ? kucoinOrderBooks[pair] : bybitOrderBooks[pair]
                                if orderBook != nil {
                                    logAlert(event: "Updated order book for \(exchange)-\(pair)-\(marketType)")
                                }
                            }
                        } catch {
                            await MainActor.run {
                                logAlert(event: "Failed to poll order book for \(exchange)-\(pair)-\(marketType): \(error)")
                            }
                        }
                    }
                }
            }
            try? await Task.sleep(nanoseconds: 10_000_000_000) // 10 seconds
        }
    }

    // FIX: Remove duplicate detectVolatilitySpike function to resolve redeclaration error
    // The original detectVolatilitySpike function should be defined elsewhere in the codebase
    // This comment replaces the duplicate function that was causing the redeclaration error
    
    static func monitorCrossExchangeArbitrageOpportunities() {
        Task { @MainActor in
            while tradingActive && !emergencyStopActive {
                for pair in tradingPairs {
                    guard !isTradingPaused[pair, default: false] else { continue }
                    
                    let kucoinSpotPrice = kucoinCurrentPrice[pair] ?? 0.0
                    let bybitSpotPrice = bybitCurrentPrice[pair] ?? 0.0
                    
                    guard kucoinSpotPrice > 0 && bybitSpotPrice > 0 else { continue }
                    
                    let spread = abs(kucoinSpotPrice - bybitSpotPrice) / max(kucoinSpotPrice, bybitSpotPrice)
                    let minSpread = getDouble("CROSS_EXCHANGE_MIN_SPREAD_THRESHOLD", defaultValue: 0.002)
                    
                    if spread >= minSpread {
                        let kucoinBook = kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
                        let bybitBook = bybitOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
                        
                        // FIX: Use isEmpty property instead of non-existent member
                        if !kucoinBook.isEmpty && !bybitBook.isEmpty {
                            let tradeAmount = min(crossExchangeTradeAmount, min(kucoinBalance, bybitBalance) * 0.1)
                            
                            if tradeAmount > 10.0 {
                                print("Cross-exchange arbitrage opportunity detected for \(pair): \(String(format: "%.4f", spread * 100))% spread")
                                
                                Task {
                                    await executeEnhancedCrossExchangeArbitrage(
                                        pair: pair,
                                        kucoinSpotPrice: kucoinSpotPrice,
                                        bybitSpotPrice: bybitSpotPrice,
                                        strategy: "Cross-Exchange Arbitrage",
                                        kucoinSpotPrices: kucoinPrices[pair] ?? [],
                                        bybitSpotPrices: bybitPrices[pair] ?? [],
                                        amount: tradeAmount
                                    ) { success in
                                        if success {
                                            Task { @MainActor in
                                                crossExchangeArbitrageExecuted[pair] = (true, Date())
                                                logAlert(event: "Cross-exchange arbitrage executed for \(pair)")
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                try? await Task.sleep(nanoseconds: UInt64(getDouble("ARBITRAGE_CHECK_INTERVAL_SECONDS", defaultValue: 0.5) * 1_000_000_000))
            }
        }
    }

    static func monitorHFTScalpingOpportunities() {
        Task { @MainActor in
            while tradingActive && !emergencyStopActive {
                for pair in tradingPairs {
                    guard !isTradingPaused[pair, default: false] else { continue }
                    
                    let exchanges = ["kucoin", "bybit"]
                    for exchange in exchanges {
                        let currentPrice = exchange == "kucoin" ?
                            kucoinCurrentPrice[pair] ?? 0.0 :
                            bybitCurrentPrice[pair] ?? 0.0
                        
                        guard currentPrice > 0 else { continue }
                        
                        let orderBook = exchange == "kucoin" ?
                            kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: []) :
                            bybitOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
                        
                        // FIX: Use isEmpty property instead of non-existent member
                        guard !orderBook.isEmpty else { continue }
                        
                        let spread = orderBook.asks.first?.price ?? 0.0 - (orderBook.bids.first?.price ?? 0.0)
                        let spreadPercent = spread / currentPrice
                        
                        if spreadPercent >= getDouble("HFT_SPREAD_THRESHOLD", defaultValue: 0.003) {
                            let balance = exchange == "kucoin" ? kucoinBalance : bybitBalance
                            let tradeAmount = min(balance * 0.02, getDouble("HFT_TRADE_AMOUNT", defaultValue: 200.0))
                            
                            if tradeAmount > 5.0 {
                                print("HFT scalping opportunity detected for \(pair) on \(exchange): \(String(format: "%.4f", spreadPercent * 100))% spread")
                                
                                Task {
                                    let success = await executeScalpingTrade(
                                        pair: pair,
                                        exchange: exchange,
                                        entryPrice: orderBook.bids.first?.price ?? currentPrice,
                                        targetPrice: orderBook.asks.first?.price ?? currentPrice,
                                        stopPrice: currentPrice * (1 - getDouble("SCALP_STOP_LOSS", defaultValue: 0.0015)),
                                        tradeAmount: tradeAmount,
                                        maxActiveTrades: getInt("MAX_ACTIVE_SPOT_TRADES", defaultValue: 2)
                                    )
                                    
                                    if success {
                                        await MainActor.run {
                                            hftArbitrageExecuted[pair] = (profit: spreadPercent * tradeAmount, timestamp: Date())
                                            logAlert(event: "HFT scalping trade executed for \(pair) on \(exchange)")
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                try? await Task.sleep(nanoseconds: UInt64(getDouble("HFT_COOLDOWN_SECONDS", defaultValue: 1.5) * 1_000_000_000))
            }
        }
    }

    static func monitorMarketMakingOpportunities() {
        Task { @MainActor in
            while tradingActive && !emergencyStopActive {
                for pair in tradingPairs {
                    guard !isTradingPaused[pair, default: false] else { continue }
                    
                    let exchanges = ["kucoin", "bybit"]
                    for exchange in exchanges {
                        let currentPrice = exchange == "kucoin" ?
                            kucoinCurrentPrice[pair] ?? 0.0 :
                            bybitCurrentPrice[pair] ?? 0.0
                        
                        guard currentPrice > 0 else { continue }
                        
                        let orderBook = exchange == "kucoin" ?
                            kucoinOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: []) :
                            bybitOrderBooks[pair] ?? BevaixOrderBook(bids: [], asks: [])
                        
                        // FIX: Use isEmpty property instead of non-existent member
                        guard !orderBook.isEmpty else { continue }
                        
                        let spread = getDouble("MARKET_MAKING_SPREAD", defaultValue: 0.001)
                        let bidPrice = currentPrice * (1 - spread)
                        let askPrice = currentPrice * (1 + spread)
                        
                        let balance = exchange == "kucoin" ? kucoinBalance : bybitBalance
                        let orderSize = min(balance * 0.01, 50.0)
                        
                        if orderSize > 1.0 {
                            print("Market making opportunity for \(pair) on \(exchange): Bid \(String(format: "%.4f", bidPrice)), Ask \(String(format: "%.4f", askPrice))")
                            // Market making logic would be implemented here
                        }
                    }
                }
                
                try? await Task.sleep(nanoseconds: 5_000_000_000) // 5 seconds
            }
        }
    }

    static func monitorMomentumOpportunities() {
        Task { @MainActor in
            while tradingActive && !emergencyStopActive {
                for pair in tradingPairs {
                    guard !isTradingPaused[pair, default: false] else { continue }
                    
                    let exchanges = ["kucoin", "bybit"]
                    for exchange in exchanges {
                        let prices = exchange == "kucoin" ?
                            kucoinPrices[pair] ?? [] :
                            bybitPrices[pair] ?? []
                        
                        guard prices.count >= 20 else { continue }
                        
                        let recentPrices = Array(prices.suffix(20))
                        let shortEMA = calculateEMA(prices: recentPrices, period: 5) ?? 0.0
                        let longEMA = calculateEMA(prices: recentPrices, period: 10) ?? 0.0
                        
                        if shortEMA > longEMA * 1.002 { // 0.2% momentum threshold
                            let currentPrice = recentPrices.last ?? 0.0
                            let balance = exchange == "kucoin" ? kucoinBalance : bybitBalance
                            let tradeAmount = min(balance * 0.03, 100.0)
                            
                            if tradeAmount > 5.0 && currentPrice > 0 {
                                print("Momentum opportunity detected for \(pair) on \(exchange): Short EMA \(String(format: "%.4f", shortEMA)) > Long EMA \(String(format: "%.4f", longEMA))")
                                // Momentum trading logic would be implemented here
                            }
                        }
                    }
                }
                
                try? await Task.sleep(nanoseconds: 10_000_000_000) // 10 seconds
            }
        }
    }

    static func monitorMeanReversionOpportunities() {
        Task { @MainActor in
            while tradingActive && !emergencyStopActive {
                for pair in tradingPairs {
                    guard !isTradingPaused[pair, default: false] else { continue }
                    
                    let exchanges = ["kucoin", "bybit"]
                    for exchange in exchanges {
                        let prices = exchange == "kucoin" ?
                            kucoinPrices[pair] ?? [] :
                            bybitPrices[pair] ?? []
                        
                        guard prices.count >= 50 else { continue }
                        
                        let recentPrices = Array(prices.suffix(50))
                        let currentPrice = recentPrices.last ?? 0.0
                        let mean = recentPrices.reduce(0.0, +) / Double(recentPrices.count)
                        let stdDev = sqrt(recentPrices.reduce(0.0) { $0 + pow($1 - mean, 2) } / Double(recentPrices.count))
                        
                        let deviationFromMean = abs(currentPrice - mean) / stdDev
                        
                        if deviationFromMean > 2.0 { // 2 standard deviations
                            let balance = exchange == "kucoin" ? kucoinBalance : bybitBalance
                            let tradeAmount = min(balance * 0.02, 75.0)
                            
                            if tradeAmount > 5.0 && currentPrice > 0 {
                                print("Mean reversion opportunity detected for \(pair) on \(exchange): Price \(String(format: "%.4f", currentPrice)), Mean \(String(format: "%.4f", mean)), Deviation \(String(format: "%.2f", deviationFromMean))σ")
                                // Mean reversion trading logic would be implemented here
                            }
                        }
                    }
                }
                
                try? await Task.sleep(nanoseconds: 15_000_000_000) // 15 seconds
            }
        }
    }
}

// Main entry point
DispatchQueue.main.async {
    ExchangeWebSocket.initializeParameters {
        ExchangeWebSocket.startTradingLoop()
        ExchangeWebSocket.logDashboardMetrics()
    }
}

RunLoop.main.run()

