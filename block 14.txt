
import Foundation

extension ExchangeWebSocket {
    static func startTradingLoop() {
        Task { @MainActor in
            ExchangeWebSocket.connectKucoin()
            ExchangeWebSocket.connectBybit()
            await ExchangeWebSocket.startOrderBookPolling()
            
            DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                ExchangeWebSocket.monitorHFTScalpingOpportunities()
                ExchangeWebSocket.startMainTradingLoop() // ENHANCED: Start comprehensive trading loop
                print("âœ… TRADING ACTIVE")
            }
        }
    }

    // ENHANCED: Complete executeTrade method with all original functionality preserved
    static func executeTrade(exchange: String, pair: String, side: String, price: Double, amount: Double, strategy: String) async -> Bool {
        guard await checkDailyLossLimit(exchange: exchange, pair: pair, potentialLoss: amount * price * getDouble("STOP_LOSS_PERCENTAGE", defaultValue: 0.02)) else {
            print("DEBUG: Trade skipped for \(exchange)-\(pair): Daily loss limit exceeded")
            return false
        }

        guard let _ = await checkLiquidityAsyncUnique(exchange: exchange, pair: pair, marketType: "spot", tradeAmount: amount, price: price) else {
            print("DEBUG: Trade skipped for \(exchange)-\(pair): Insufficient liquidity")
            return false
        }

        let volatility = await calculateVolatility(pair: pair, exchange: exchange)
        let tradeAmount = await dynamicTradeAmount(balance: exchange == "kucoin" ? kucoinBalance : bybitBalance, riskPercent: getDouble("RISK_PERCENTAGE", defaultValue: 0.01), volatility: volatility, pair: pair)

        guard tradeAmount > 0 else {
            print("DEBUG: Trade skipped for \(exchange)-\(pair): Invalid trade amount (\(tradeAmount))")
            return false
        }

        let adjustedAmount = min(amount, tradeAmount)
        ExchangeWebSocket.executeHFTTrade(exchange: exchange, pair: pair, side: side, price: price, amount: adjustedAmount)

        let profit = side == "buy" ? -adjustedAmount * price : adjustedAmount * price
        let fees = adjustedAmount * price * (exchange == "kucoin" ? kucoinTakerFee : bybitTakerFee)
        let netProfit = profit - fees

        await MainActor.run {
            updateTradeMetrics(
                pair: pair,
                profit: netProfit,
                fees: fees,
                isWin: netProfit > 0,
                dashboardJSONURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/dashboard.json"),
                totalProfit: &ExchangeWebSocket.totalProfit,
                totalFees: &ExchangeWebSocket.totalFees
            )
            logTradeToCSV(
                pair: pair,
                strategy: strategy,
                profit: netProfit,
                fees: fees,
                tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trades.csv")
            )
            sendTradeToFlaskServer(strategy: strategy, pair: pair, exchange: exchange, spotPrice: price, futuresPrice: 0.0, tradeAmount: adjustedAmount, profit: netProfit)
        }

        return netProfit > 0
    }

    static func calculateVolatility(pair: String, exchange: String) async -> Double {
        let prices = exchange == "kucoin" ? kucoinPrices[pair] : bybitPrices[pair]
        guard let priceArray = prices, priceArray.count >= 60 else {
            return getDouble("DEFAULT_VOLATILITY", defaultValue: 0.01)
        }
        let recentPrices = priceArray.suffix(60)
        let mean = recentPrices.reduce(0.0, +) / Double(recentPrices.count)
        let variance = recentPrices.reduce(0.0) { $0 + pow($1 - mean, 2) } / Double(recentPrices.count)
        return sqrt(variance) / mean
    }

    static func startOrderBookPolling() async {
        while true {
            for pair in tradingPairs {
                for exchange in ["kucoin", "bybit"] {
                    for marketType in ["spot", "futures"] {
                        do {
                            let _ = try await fetchOrderBookDepth(for: exchange, pair: pair, marketType: marketType)
                            await MainActor.run {
                                let orderBook = exchange == "kucoin" ? kucoinOrderBooks[pair] : bybitOrderBooks[pair]
                                if orderBook != nil {
                                    logAlert(event: "Updated order book for \(exchange)-\(pair)-\(marketType)")
                                }
                            }
                        } catch {
                            await MainActor.run {
                                logAlert(event: "Failed to poll order book for \(exchange)-\(pair)-\(marketType): \(error)")
                            }
                        }
                    }
                }
            }
            try? await Task.sleep(nanoseconds: 10_000_000_000) // 10 seconds
        }
    }
    
    // FIXED: Added missing scanTradingOpportunities method (Error line 7542)
    static func scanTradingOpportunities() async {
        // ENHANCED: Comprehensive opportunity scanning with all strategies
        while tradingActive {
            do {
                await withTaskGroup(of: Void.self) { group in
                    for pair in tradingPairs {
                        group.addTask {
                            // Multi-strategy opportunity evaluation
                            await evaluateArbitrageOpportunities(pair: pair)
                            await evaluateHFTOpportunities(pair: pair)
                            await evaluateMarketMakingOpportunities(pair: pair)
                            await evaluateFundingRateOpportunities(pair: pair)
                        }
                    }
                }
                
                // ENHANCED: Portfolio-level risk management
                await assessPortfolioRisk()
                await updateRiskMetrics()
                await monitorDataQuality()
                
                try await Task.sleep(nanoseconds: 250_000_000) // 250ms scan interval
            } catch {
                await MainActor.run {
                    logAlert(event: "Error in scanTradingOpportunities: \(error)")
                }
                try? await Task.sleep(nanoseconds: 1_000_000_000) // 1 second on error
            }
        }
    }
    
    // ENHANCED: Individual opportunity evaluation methods
    static func evaluateArbitrageOpportunities(pair: String) async {
        let kucoinPrice = await MainActor.run { kucoinCurrentPrice[pair] ?? 0.0 }
        let bybitPrice = await MainActor.run { bybitCurrentPrice[pair] ?? 0.0 }
        let kucoinFuturesPrice = await MainActor.run { kucoinCurrentFuturesPrice[pair] ?? 0.0 }
        let bybitFuturesPrice = await MainActor.run { bybitCurrentFuturesPrice[pair] ?? 0.0 }
        
        // Cross-exchange arbitrage
        if kucoinPrice > 0 && bybitPrice > 0 {
            let spread = abs(kucoinPrice - bybitPrice) / min(kucoinPrice, bybitPrice)
            if spread > crossExchangeMinSpreadThreshold {
                await checkCrossExchangeArbitrage(pair: pair, strategy: "cross-arbitrage", amount: crossExchangeTradeAmount) { success in
                    if success {
                        Task { @MainActor in
                            logAlert(event: "âœ… Cross-exchange arbitrage executed for \(pair)")
                        }
                    }
                }
            }
        }
        
        // Spot-futures arbitrage on KuCoin
        if kucoinPrice > 0 && kucoinFuturesPrice > 0 {
            let spread = abs(kucoinPrice - kucoinFuturesPrice) / min(kucoinPrice, kucoinFuturesPrice)
            if spread > arbitrageMinSpreadThreshold {
                executeSpotFuturesArbitrage(
                    pair: pair,
                    kucoinSpotPrice: kucoinPrice,
                    kucoinFuturesPrice: kucoinFuturesPrice,
                    bybitSpotPrice: bybitPrice,
                    bybitFuturesPrice: bybitFuturesPrice,
                    amount: arbitrageTradeAmount
                ) { success in
                    if success {
                        Task { @MainActor in
                            logAlert(event: "âœ… KuCoin spot-futures arbitrage executed for \(pair)")
                        }
                    }
                }
            }
        }
        
        // Spot-futures arbitrage on Bybit
        if bybitPrice > 0 && bybitFuturesPrice > 0 {
            let spread = abs(bybitPrice - bybitFuturesPrice) / min(bybitPrice, bybitFuturesPrice)
            if spread > arbitrageMinSpreadThreshold {
                executeSpotFuturesArbitrage(
                    pair: pair,
                    kucoinSpotPrice: kucoinPrice,
                    kucoinFuturesPrice: kucoinFuturesPrice,
                    bybitSpotPrice: bybitPrice,
                    bybitFuturesPrice: bybitFuturesPrice,
                    amount: arbitrageTradeAmount
                ) { success in
                    if success {
                        Task { @MainActor in
                            logAlert(event: "âœ… Bybit spot-futures arbitrage executed for \(pair)")
                        }
                    }
                }
            }
        }
    }
    
    static func evaluateHFTOpportunities(pair: String) async {
        let kucoinPrice = await MainActor.run { kucoinCurrentPrice[pair] ?? 0.0 }
        let bybitPrice = await MainActor.run { bybitCurrentPrice[pair] ?? 0.0 }
        let kucoinPrices = await MainActor.run { self.kucoinPrices[pair] ?? [] }
        let bybitPrices = await MainActor.run { self.bybitPrices[pair] ?? [] }
        
        guard kucoinPrice > 0 && bybitPrice > 0 else { return }
        
        // Calculate technical indicators
        let kucoinRSI = calculateRSI(prices: kucoinPrices, period: spotRsiPeriod) ?? 50.0
        let bybitRSI = calculateRSI(prices: bybitPrices, period: spotRsiPeriod) ?? 50.0
        
        // Enhanced HFT evaluation with all indicators
        await evaluateHFTStrategy(pair: pair, kucoinSpotRsi: kucoinRSI, bybitSpotRsi: bybitRSI)
        
        // ENHANCED: Additional HFT patterns
        await evaluateLatencyArbitrage(pair: pair, kucoinPrice: kucoinPrice, bybitPrice: bybitPrice)
        await evaluateOrderBookImbalance(pair: pair)
        await evaluateVolumeSpikes(pair: pair)
    }
    
    static func evaluateMarketMakingOpportunities(pair: String) async {
        let kucoinBook = await MainActor.run { kucoinOrderBooks[pair] }
        let bybitBook = await MainActor.run { bybitOrderBooks[pair] }
        
        // KuCoin market making
        if let book = kucoinBook, !book.bids.isEmpty && !book.asks.isEmpty {
            let spread = (book.asks.first!.price - book.bids.first!.price) / book.bids.first!.price
            let marketMakingSpread = getDouble("MARKET_MAKING_SPREAD", defaultValue: 0.002)
            
            if spread > marketMakingSpread {
                await executeMarketMaking(exchange: "kucoin", pair: pair, orderBook: book)
            }
        }
        
        // Bybit market making
        if let book = bybitBook, !book.bids.isEmpty && !book.asks.isEmpty {
            let spread = (book.asks.first!.price - book.bids.first!.price) / book.bids.first!.price
            let marketMakingSpread = getDouble("MARKET_MAKING_SPREAD", defaultValue: 0.002)
            
            if spread > marketMakingSpread {
                await executeMarketMaking(exchange: "bybit", pair: pair, orderBook: book)
            }
        }
    }
    
    static func evaluateFundingRateOpportunities(pair: String) async {
        let kucoinFundingRate = await MainActor.run { kucoinFundingRates[pair] ?? 0.0 }
        let bybitFundingRate = await MainActor.run { bybitFundingRates[pair] ?? 0.0 }
        
        await evaluateFundingRateMomentum(pair: pair, kucoinFundingRate: kucoinFundingRate, bybitFundingRate: bybitFundingRate)
    }
    
    // ENHANCED: Additional HFT evaluation methods
    static func evaluateLatencyArbitrage(pair: String, kucoinPrice: Double, bybitPrice: Double) async {
        let latencyDiff = abs((lastLatency["kucoin-\(pair)"] ?? 0.0) - (lastLatency["bybit-\(pair)"] ?? 0.0))
        
        if latencyDiff > 50.0 { // 50ms latency difference
            let spread = abs(kucoinPrice - bybitPrice) / min(kucoinPrice, bybitPrice)
            if spread > hftSpreadThreshold {
                await MainActor.run {
                    logAlert(event: "ðŸš€ Latency arbitrage opportunity detected for \(pair): Spread \(spread), Latency diff \(latencyDiff)ms")
                }
                
                // Execute latency arbitrage
                let success = await executeTrade(
                    exchange: latencyDiff > 0 ? "kucoin" : "bybit",
                    pair: pair,
                    side: kucoinPrice > bybitPrice ? "sell" : "buy",
                    price: kucoinPrice > bybitPrice ? kucoinPrice : bybitPrice,
                    amount: hftTradeAmount,
                    strategy: "Latency-Arbitrage"
                )
                
                if success {
                    await MainActor.run {
                        logAlert(event: "âœ… Latency arbitrage executed for \(pair)")
                    }
                }
            }
        }
    }
    
    static func evaluateOrderBookImbalance(pair: String) async {
        let kucoinBook = await MainActor.run { kucoinOrderBooks[pair] }
        let bybitBook = await MainActor.run { bybitOrderBooks[pair] }
        
        if let kBook = kucoinBook {
            let imbalance = calculateOrderBookImbalance(book: kBook)
            if imbalance > getDouble("ORDER_BOOK_IMBALANCE_THRESHOLD", defaultValue: 3.0) {
                let signal = imbalance > 1.0 ? "buy" : "sell"
                let success = await executeTrade(
                    exchange: "kucoin",
                    pair: pair,
                    side: signal,
                    price: kucoinCurrentPrice[pair] ?? 0.0,
                    amount: spotTradeAmount,
                    strategy: "OrderBook-Imbalance"
                )
                
                if success {
                    await MainActor.run {
                        logAlert(event: "âœ… Order book imbalance trade executed for \(pair) on KuCoin")
                    }
                }
            }
        }
        
        if let bBook = bybitBook {
            let imbalance = calculateOrderBookImbalance(book: bBook)
            if imbalance > getDouble("ORDER_BOOK_IMBALANCE_THRESHOLD", defaultValue: 3.0) {
                let signal = imbalance > 1.0 ? "buy" : "sell"
                let success = await executeTrade(
                    exchange: "bybit",
                    pair: pair,
                    side: signal,
                    price: bybitCurrentPrice[pair] ?? 0.0,
                    amount: spotTradeAmount,
                    strategy: "OrderBook-Imbalance"
                )
                
                if success {
                    await MainActor.run {
                        logAlert(event: "âœ… Order book imbalance trade executed for \(pair) on Bybit")
                    }
                }
            }
        }
    }
    
    static func evaluateVolumeSpikes(pair: String) async {
        let kucoinVolumes = await MainActor.run { kucoinSpotVolume[pair] ?? [] }
        let bybitVolumes = await MainActor.run { bybitSpotVolume[pair] ?? [] }
        
        // Detect volume spikes
        if kucoinVolumes.count >= 10 {
            let avgVolume = kucoinVolumes.suffix(10).reduce(0, +) / 10.0
            let currentVolume = kucoinVolumes.last ?? 0.0
            
            if currentVolume > avgVolume * volumeAnomalyMultiplier {
                await MainActor.run {
                    logAlert(event: "ðŸ“ˆ Volume spike detected on KuCoin \(pair): \(currentVolume) vs avg \(avgVolume)")
                }
                
                // Volume momentum trade
                let success = await executeTrade(
                    exchange: "kucoin",
                    pair: pair,
                    side: "buy", // Assume volume spike indicates buying pressure
                    price: kucoinCurrentPrice[pair] ?? 0.0,
                    amount: spotTradeAmount * 0.5, // Smaller size for volume trades
                    strategy: "Volume-Momentum"
                )
                
                if success {
                    await MainActor.run {
                        logAlert(event: "âœ… Volume momentum trade executed for \(pair) on KuCoin")
                    }
                }
            }
        }
        
        if bybitVolumes.count >= 10 {
            let avgVolume = bybitVolumes.suffix(10).reduce(0, +) / 10.0
            let currentVolume = bybitVolumes.last ?? 0.0
            
            if currentVolume > avgVolume * volumeAnomalyMultiplier {
                await MainActor.run {
                    logAlert(event: "ðŸ“ˆ Volume spike detected on Bybit \(pair): \(currentVolume) vs avg \(avgVolume)")
                }
                
                // Volume momentum trade
                let success = await executeTrade(
                    exchange: "bybit",
                    pair: pair,
                    side: "buy", // Assume volume spike indicates buying pressure
                    price: bybitCurrentPrice[pair] ?? 0.0,
                    amount: spotTradeAmount * 0.5, // Smaller size for volume trades
                    strategy: "Volume-Momentum"
                )
                
                if success {
                    await MainActor.run {
                        logAlert(event: "âœ… Volume momentum trade executed for \(pair) on Bybit")
                    }
                }
            }
        }
    }
    
    static func executeMarketMaking(exchange: String, pair: String, orderBook: BevaixOrderBook) async {
        guard !orderBook.bids.isEmpty && !orderBook.asks.isEmpty else { return }
        
        let bestBid = orderBook.bids.first!.price
        let bestAsk = orderBook.asks.first!.price
        let midPrice = (bestBid + bestAsk) / 2.0
        let marketMakingSpread = getDouble("MARKET_MAKING_SPREAD", defaultValue: 0.002)
        
        // Place orders inside the spread
        let bidPrice = midPrice * (1 - marketMakingSpread / 2)
        let askPrice = midPrice * (1 + marketMakingSpread / 2)
        
        // Simulate market making orders
        let success = await executeTrade(
            exchange: exchange,
            pair: pair,
            side: "both", // Special case for market making
            price: midPrice,
            amount: spotTradeAmount * 0.3, // Smaller size for market making
            strategy: "Market-Making"
        )
        
        if success {
            await MainActor.run {
                logAlert(event: "âœ… Market making executed for \(pair) on \(exchange): Bid \(bidPrice), Ask \(askPrice)")
            }
        }
    }
    
    // ENHANCED: Main trading loop with comprehensive strategy orchestration (Fixes line 7315 complex expression)
    static func startMainTradingLoop() {
        Task {
            while tradingActive {
                do {
                    // FIXED: Break up complex expression into sub-expressions (Line 7315 fix)
                    let totalBalance = kucoinBalance + bybitBalance
                    let balanceRatio = totalBalance > 0 ? kucoinBalance / totalBalance : 0.5
                    let pairCount = Double(tradingPairs.count)
                    let tradingIntensity = pairCount > 0 ? pairCount / 22.0 : 0.0
                    let baseRiskFactor = dailyLossLimitPercentage * tradingIntensity
                    let adjustedRisk = balanceRatio * baseRiskFactor
                    let volatilityMultiplier = calculateMarketVolatility()
                    let finalRiskScore = adjustedRisk * (1.0 + volatilityMultiplier)
                    
                    if finalRiskScore > 0.1 {
                        await MainActor.run {
                            logAlert(event: "âš ï¸ High risk factor detected: \(finalRiskScore)")
                        }
                    }
                    
                    // FIXED: Added await for async function calls (Lines 7487, 7493)
                    await scanTradingOpportunities()
                    await monitorActivePositions()
                    
                    // ENHANCED: AI-driven strategy selection
                    await orchestrateAITrading()
                    
                    // ENHANCED: Dynamic parameter adjustment
                    await adjustDynamicParameters()
                    
                    // ENHANCED: Performance monitoring
                    await updatePerformanceMetrics()
                    
                    try await Task.sleep(nanoseconds: 100_000_000) // 100ms main loop
                } catch {
                    await MainActor.run {
                        logAlert(event: "Error in main trading loop: \(error)")
                    }
                    try? await Task.sleep(nanoseconds: 1_000_000_000) // 1 second on error
                }
            }
        }
    }
    
    // ENHANCED: Active position monitoring with trailing stops
    static func monitorActivePositions() async {
        for pair in tradingPairs {
            // Monitor KuCoin positions
            if await MainActor.run(body: { kucoinInSpotTrade[pair] ?? false }) {
                let entryPrice = await MainActor.run { kucoinSpotEntryPrice[pair] ?? 0.0 }
                let currentPrice = await MainActor.run { kucoinCurrentPrice[pair] ?? 0.0 }
                let trailingStop = await MainActor.run { kucoinSpotTrailingStop[pair] ?? 0.0 }
                
                if currentPrice > 0 && entryPrice > 0 {
                    let profitPercent = (currentPrice - entryPrice) / entryPrice
                    let newTrailingStop = currentPrice * (1 - spotTrailingStopPercentage)
                    
                    // Enhanced exit conditions
                    let shouldExit = profitPercent >= spotMinProfitPercentage ||
                                   currentPrice <= trailingStop ||
                                   profitPercent <= -spotStopLossPercentage
                    
                    if shouldExit {
                        await MainActor.run {
                            kucoinInSpotTrade[pair] = false
                            kucoinSpotEntryPrice[pair] = 0.0
                            kucoinSpotTrailingStop[pair] = 0.0
                            activeSpotTrades[pair] = max(0, (activeSpotTrades[pair] ?? 0) - 1)
                            
                            let profit = (currentPrice - entryPrice) * (kucoinPositions[pair] ?? 0.0)
                            kucoinBalance += profit
                            kucoinPositions[pair] = 0.0
                            
                            logAlert(event: "ðŸ”„ Closed KuCoin position for \(pair): Profit \(String(format: "%.4f", profitPercent * 100))%")
                        }
                    } else if newTrailingStop > trailingStop {
                        await MainActor.run {
                            kucoinSpotTrailingStop[pair] = newTrailingStop
                        }
                    }
                }
            }
            
            // Monitor Bybit positions (same logic)
            if await MainActor.run(body: { bybitInSpotTrade[pair] ?? false }) {
                let entryPrice = await MainActor.run { bybitSpotEntryPrice[pair] ?? 0.0 }
                let currentPrice = await MainActor.run { bybitCurrentPrice[pair] ?? 0.0 }
                let trailingStop = await MainActor.run { bybitSpotTrailingStop[pair] ?? 0.0 }
                
                if currentPrice > 0 && entryPrice > 0 {
                    let profitPercent = (currentPrice - entryPrice) / entryPrice
                    let newTrailingStop = currentPrice * (1 - spotTrailingStopPercentage)
                    
                    let shouldExit = profitPercent >= spotMinProfitPercentage ||
                                   currentPrice <= trailingStop ||
                                   profitPercent <= -spotStopLossPercentage
                    
                    if shouldExit {
                        await MainActor.run {
                            bybitInSpotTrade[pair] = false
                            bybitSpotEntryPrice[pair] = 0.0
                            bybitSpotTrailingStop[pair] = 0.0
                            activeSpotTrades[pair] = max(0, (activeSpotTrades[pair] ?? 0) - 1)
                            
                            let profit = (currentPrice - entryPrice) * (bybitPositions[pair] ?? 0.0)
                            bybitBalance += profit
                            bybitPositions[pair] = 0.0
                            
                            logAlert(event: "ðŸ”„ Closed Bybit position for \(pair): Profit \(String(format: "%.4f", profitPercent * 100))%")
                        }
                    } else if newTrailingStop > trailingStop {
                        await MainActor.run {
                            bybitSpotTrailingStop[pair] = newTrailingStop
                        }
                    }
                }
            }
        }
    }
    
    // ENHANCED: AI trading orchestration
    static func orchestrateAITrading() async {
        // Check if AI system should make trading decisions
        let aiConfidence = await calculateAIConfidence()
        
        if aiConfidence > 0.8 {
            for pair in tradingPairs.prefix(5) { // Limit AI trading to top 5 pairs
                let signals = await generateAISignals(pair: pair)
                await executeAITrades(pair: pair, signals: signals, confidence: aiConfidence)
            }
        }
    }
    
    static func calculateAIConfidence() async -> Double {
        // Combine multiple AI systems for confidence score
        var confidenceFactors: [Double] = []
        
        // Market volatility factor
        let volatility = calculateMarketVolatility()
        confidenceFactors.append(1.0 - min(volatility * 10, 1.0))
        
        // Data quality factor
        let dataQuality = await assessDataQuality()
        confidenceFactors.append(dataQuality)
        
        // Performance factor
        let recentPerformance = await assessRecentPerformance()
        confidenceFactors.append(recentPerformance)
        
        // Return weighted average
        return confidenceFactors.reduce(0, +) / Double(confidenceFactors.count)
    }
    
    static func generateAISignals(pair: String) async -> [String: Double] {
        var signals: [String: Double] = [:]
        
        // Generate signals from each AI system
        signals["momentum"] = calculateMomentumSignal(pair: pair)
        signals["meanReversion"] = calculateMeanReversionSignal(pair: pair)
        signals["marketMaking"] = calculateMarketMakingSignal(pair: pair)
        signals["sentiment"] = await MainActor.run { sentimentScores[pair] ?? 0.0 }
        
        return signals
    }
    
    static func executeAITrades(pair: String, signals: [String: Double], confidence: Double) async {
        let momentumSignal = signals["momentum"] ?? 0.0
        let sentimentSignal = signals["sentiment"] ?? 0.0
        
        // Combined signal strength
        let combinedSignal = (momentumSignal + sentimentSignal) / 2.0
        let signalStrength = abs(combinedSignal) * confidence
        
        if signalStrength > 0.6 {
            let exchange = compareExchangeLiquidity(pair: pair)
            let side = combinedSignal > 0 ? "buy" : "sell"
            let price = await MainActor.run {
                exchange == "kucoin" ? kucoinCurrentPrice[pair] ?? 0.0 : bybitCurrentPrice[pair] ?? 0.0
            }
            
            if price > 0 {
                let success = await executeTrade(
                    exchange: exchange,
                    pair: pair,
                    side: side,
                    price: price,
                    amount: spotTradeAmount * signalStrength, // Scale by signal strength
                    strategy: "AI-Enhanced"
                )
                
                if success {
                    await MainActor.run {
                        logAlert(event: "ðŸ¤– AI-enhanced trade executed for \(pair): Signal \(signalStrength)")
                    }
                }
            }
        }
    }
    
    // ENHANCED: Dynamic parameter adjustment based on market conditions
    static func adjustDynamicParameters() async {
        let marketCondition = await analyzeCurrentMarketCondition()
        
        switch marketCondition {
        case "high_volatility":
            await MainActor.run {
                spotTrailingStopPercentage = min(spotTrailingStopPercentage * 1.5, 0.05)
                logAlert(event: "ðŸ“Š Adjusted trailing stop for high volatility: \(spotTrailingStopPercentage)")
            }
        case "low_volatility":
            await MainActor.run {
                spotTrailingStopPercentage = max(spotTrailingStopPercentage * 0.8, 0.001)
                logAlert(event: "ðŸ“Š Adjusted trailing stop for low volatility: \(spotTrailingStopPercentage)")
            }
        case "trending":
            await MainActor.run {
                scalpProfitTarget = scalpProfitTarget * 1.2
                logAlert(event: "ðŸ“Š Increased profit target for trending market: \(scalpProfitTarget)")
            }
        default:
            break
        }
    }
    
    static func analyzeCurrentMarketCondition() async -> String {
        let volatility = calculateMarketVolatility()
        var trendingPairs = 0
        
        for pair in tradingPairs {
            let momentum = calculateMomentumSignal(pair: pair)
            if abs(momentum) > 0.02 {
                trendingPairs += 1
            }
        }
        
        let trendingRatio = Double(trendingPairs) / Double(tradingPairs.count)
        
        if volatility > 0.05 {
            return "high_volatility"
        } else if volatility < 0.01 {
            return "low_volatility"
        } else if trendingRatio > 0.6 {
            return "trending"
        } else {
            return "normal"
        }
    }
    
    // ENHANCED: Comprehensive performance monitoring
    static func updatePerformanceMetrics() async {
        let currentTime = Date()
        
        await MainActor.run {
            // Calculate real-time metrics
            let totalTrades = tradeMetrics.values.reduce(0) { $0 + $1.wins + $1.losses }
            let totalWins = tradeMetrics.values.reduce(0) { $0 + $1.wins }
            let winRate = totalTrades > 0 ? Double(totalWins) / Double(totalTrades) : 0.0
            let totalProfitValue = tradeMetrics.values.reduce(0.0) { $0 + $1.totalProfit }
            let totalFeesValue = tradeMetrics.values.reduce(0.0) { $0 + $1.totalFees }
            let netProfit = totalProfitValue - totalFeesValue
            
            // Update real-time metrics
            realtimeMetrics["total_trades"] = Double(totalTrades)
            realtimeMetrics["win_rate"] = winRate
            realtimeMetrics["total_profit"] = totalProfitValue
            realtimeMetrics["total_fees"] = totalFeesValue
            realtimeMetrics["net_profit"] = netProfit
            realtimeMetrics["kucoin_balance"] = kucoinBalance
            realtimeMetrics["bybit_balance"] = bybitBalance
            
            // Log detailed performance summary every 5 minutes
            if currentTime.timeIntervalSince(lastSummaryTime) > 300 {
                lastSummaryTime = currentTime
                
                let averageLatency = lastLatency.values.reduce(0, +) / Double(max(lastLatency.count, 1))
                let tradesPerMinute = totalTrades > 0 ? Double(totalTrades) / max(currentTime.timeIntervalSince(Date().addingTimeInterval(-3600)), 1) * 60 : 0
                
                let performanceSummary = """
                ðŸ“Š 5-Minute Performance Summary:
                Total Trades: \(totalTrades) | Win Rate: \(String(format: "%.1f", winRate * 100))%
                Net Profit: \(String(format: "%.2f", netProfit)) USDT | ROI: \(String(format: "%.2f", netProfit / max(totalBalance, 1) * 100))%
                Trades/Min: \(String(format: "%.1f", tradesPerMinute)) | Avg Latency: \(String(format: "%.1f", averageLatency))ms
                KuCoin: \(String(format: "%.2f", kucoinBalance)) | Bybit: \(String(format: "%.2f", bybitBalance))
                """
                
                print(performanceSummary)
                logAlert(event: performanceSummary)
            }
        }
    }
    
    // ENHANCED: Helper methods for AI confidence calculation
    static func assessDataQuality() async -> Double {
        var qualityScore = 1.0
        let now = Date()
        
        for pair in tradingPairs {
            let lastUpdate = await MainActor.run { lastDataUpdate[pair] }
            if let update = lastUpdate {
                let staleness = now.timeIntervalSince(update)
                if staleness > 60 {
                    qualityScore *= 0.9 // Reduce quality for stale data
                }
            } else {
                qualityScore *= 0.8 // Reduce quality for missing data
            }
        }
        
        return max(qualityScore, 0.1)
    }
    
    static func assessRecentPerformance() async -> Double {
        let recentTrades = await MainActor.run {
            tradeMetrics.values.reduce(0) { $0 + $1.wins + $1.losses }
        }
        
        guard recentTrades > 0 else { return 0.5 }
        
        let winRate = await MainActor.run {
            let wins = tradeMetrics.values.reduce(0) { $0 + $1.wins }
            return Double(wins) / Double(recentTrades)
        }
        
        return winRate
    }
}

// Main entry point
DispatchQueue.main.async {
    ExchangeWebSocket.initializeParameters {
        ExchangeWebSocket.startTradingLoop()
        ExchangeWebSocket.logDashboardMetrics()
    }
}

RunLoop.main.run()
