
//------------------------------------------------------------------------------------------------------------------------------Block 5 - Risk Assessment and Management


extension ExchangeWebSocket {
    static func calculateEMA(prices: [Double], period: Int) -> Double? {
        guard prices.count >= period else { return nil }
        let k = 2.0 / Double(period + 1)
        var ema = prices[0]
        for i in 1..<prices.count {
            ema = prices[i] * k + ema * (1 - k)
        }
        return ema
    }

    static func calculateMultiTimeframeEMAs(pair: String, exchange: String, prices: [Double]) {
        let minPrices1 = Array(prices.suffix(60)) // 1-minute timeframe
        let minPrices5 = Array(prices.suffix(300)) // 5-minute timeframe
        let minPrices15 = Array(prices.suffix(900)) // 15-minute timeframe

        let shortPeriod = spotEmaShortPeriod
        let mediumPeriod = spotEmaMediumPeriod
        let longPeriod = spotEmaLongPeriod

        if let emaShort1 = calculateEMA(prices: minPrices1, period: shortPeriod),
           let emaMedium1 = calculateEMA(prices: minPrices1, period: mediumPeriod),
           let emaLong1 = calculateEMA(prices: minPrices1, period: longPeriod),
           let emaShort5 = calculateEMA(prices: minPrices5, period: shortPeriod),
           let emaMedium5 = calculateEMA(prices: minPrices5, period: mediumPeriod),
           let emaLong5 = calculateEMA(prices: minPrices5, period: longPeriod),
           let emaShort15 = calculateEMA(prices: minPrices15, period: shortPeriod),
           let emaMedium15 = calculateEMA(prices: minPrices15, period: mediumPeriod),
           let emaLong15 = calculateEMA(prices: minPrices15, period: longPeriod) {
            Task { @MainActor in
                if exchange == "kucoin" {
                    kucoinSpotEMA1Min[pair] = (emaShort1, emaMedium1, emaLong1)
                    kucoinSpotEMA5Min[pair] = (emaShort5, emaMedium5, emaLong5)
                    kucoinSpotEMA15Min[pair] = (emaShort15, emaMedium15, emaLong15)
                } else {
                    bybitSpotEMA1Min[pair] = (emaShort1, emaMedium1, emaLong1)
                    bybitSpotEMA5Min[pair] = (emaShort5, emaMedium5, emaLong5)
                    bybitSpotEMA15Min[pair] = (emaShort15, emaMedium15, emaLong15)
                }
            }
        }
    }

    static func calculateMACD(prices: [Double], shortPeriod: Int, longPeriod: Int, signalPeriod: Int) -> (macd: Double, signal: Double, histogram: Double)? {
        guard prices.count >= max(longPeriod, signalPeriod) else { return nil }
        
        guard let shortEMA = calculateEMA(prices: prices, period: shortPeriod),
              let longEMA = calculateEMA(prices: prices, period: longPeriod) else {
            return nil
        }
        
        let macd = shortEMA - longEMA
        let macdSeries = prices.suffix(signalPeriod).enumerated().map { _ in
            shortEMA - longEMA // Simplified, assumes recent prices for signal
        }
        
        guard let signal = calculateEMA(prices: macdSeries, period: signalPeriod) else {
            return nil
        }
        
        let histogram = macd - signal
        return (macd: macd, signal: signal, histogram: histogram)
    }

    static func calculateRSI(prices: [Double], period: Int) -> Double? {
        guard prices.count >= period + 1 else { return nil }
        var gains: [Double] = []
        var losses: [Double] = []
        for i in 1..<prices.count {
            let diff = prices[i] - prices[i - 1]
            if diff > 0 {
                gains.append(diff)
                losses.append(0)
            } else {
                gains.append(0)
                losses.append(abs(diff))
            }
        }
        guard gains.count >= period else { return nil }
        let avgGain = gains.suffix(period).reduce(0.0, +) / Double(period)
        let avgLoss = losses.suffix(period).reduce(0.0, +) / Double(period)
        guard avgLoss != 0 else { return 100 }
        let rs = avgGain / avgLoss
        return 100 - (100 / (1 + rs))
    }

    static func calculateATR(prices: [Double]) -> Double? {
        guard prices.count > 1 else { return nil }
        var trs: [Double] = []
        for i in 1..<prices.count {
            let highLow = abs(prices[i] - prices[i - 1])
            trs.append(highLow)
        }
        guard !trs.isEmpty else { return nil }
        return trs.reduce(0, +) / Double(trs.count)
    }

    static func calculateVaR(pair: String, tradeAmount: Double, prices: [Double]) -> Double? {
        guard prices.count >= 1440 else { return nil } // 24 hours of data
        let returns = prices.enumerated().dropFirst().map { (i, price) in
            log(price / prices[i - 1])
        }
        guard !returns.isEmpty else { return nil }
        let meanReturn = returns.reduce(0, +) / Double(returns.count)
        let variance = returns.reduce(0.0) { $0 + pow($1 - meanReturn, 2) } / Double(returns.count)
        let stdDev = sqrt(variance)
        let zScore = -1.645 // 95% confidence level
        let varValue = tradeAmount * (meanReturn + zScore * stdDev)
        Task { @MainActor in
            varEstimates[pair] = varValue
        }
        return varValue
    }

    static func calculateKellySize(pair: String, balance: Double, sentimentScore: Double) -> Double {
        let winProb = kellyWinProbability
        let rewardToRisk = kellyRewardToRisk
        let sentimentAdjustment = sentimentScore < 0 ? 0.5 : 1.0
        let kellyFraction = (winProb * (rewardToRisk + 1) - 1) / rewardToRisk
        let adjustedFraction = kellyFraction * sentimentAdjustment
        let positionSize = balance * max(0.01, min(0.3, adjustedFraction))
        Task { @MainActor in
            kellySizes[pair] = positionSize
        }
        return positionSize
    }

    static func checkVolatility(exchange: String, pair: String, atr: Double) -> Bool {
        let currentPrice = exchange == "bybit" ? bybitCurrentFuturesPrice[pair] ?? 0.0 : kucoinCurrentFuturesPrice[pair] ?? 0.0
        guard currentPrice > 0 else { return false }
        let atrPercentage = atr / currentPrice
        return atrPercentage >= atrMultiplier
    }

    static func detectVolatilitySpike(exchange: String, pair: String) -> Bool {
        let prices = exchange == "bybit" ? bybitFuturesPrices[pair] ?? [] : kucoinFuturesPrices[pair] ?? []
        guard prices.count >= volatilitySpikeWindowMinutes else { return false }
        let recentPrices = prices.suffix(volatilitySpikeWindowMinutes)
        guard let minPrice = recentPrices.min(), let maxPrice = recentPrices.max() else { return false }
        let priceRange = (maxPrice - minPrice) / minPrice
        return priceRange >= volatilitySpikeThreshold
    }

    static func checkVolumeAnomaly(exchange: String, pair: String, marketType: String) -> Bool {
        let volumes: [Double]
        switch (exchange, marketType) {
        case ("kucoin", "spot"):
            volumes = kucoinSpotVolume[pair] ?? []
        case ("kucoin", "futures"):
            volumes = kucoinFuturesVolume[pair] ?? []
        case ("bybit", "spot"):
            volumes = bybitSpotVolume[pair] ?? []
        case ("bybit", "futures"):
            volumes = bybitFuturesVolume[pair] ?? []
        default:
            return false
        }
        guard volumes.count >= volumeAnomalyWindowHours * 60 else { return false }
        let recentVolumes = volumes.suffix(volumeAnomalyWindowHours * 60)
        let avgVolume = recentVolumes.reduce(0, +) / Double(recentVolumes.count)
        guard let maxVolume = recentVolumes.max() else { return false }
        return maxVolume >= avgVolume * volumeAnomalyMultiplier
    }

    static func isPrimeTradingTime() -> Bool {
        let calendar = Calendar(identifier: .gregorian)
        let now = Date()
        guard let gmtZone = TimeZone(identifier: "GMT") else { return false }
        let components = calendar.dateComponents(in: gmtZone, from: now)
        guard let currentHour = components.hour else { return false }
        let londonHours = 8...17
        let nyHours = 13...22
        return londonHours.contains(currentHour) || nyHours.contains(currentHour)
    }

    static func dynamicCooldown(volatility: Double) -> Double {
        return max(2, min(10, 10 * (1 - volatility)))
    }

    static func calculateBollingerBands(prices: [Double], period: Int, multiplier: Double = 2.0) -> (upper: Double, middle: Double, lower: Double)? {
        guard prices.count >= period else { return nil }
        let recentPrices = prices.suffix(period)
        let sma = recentPrices.reduce(0, +) / Double(period)
        let variance = recentPrices.reduce(0.0) { $0 + pow($1 - sma, 2) } / Double(period)
        let stdDev = sqrt(variance)
        let upperBand = sma + multiplier * stdDev
        let lowerBand = sma - multiplier * stdDev
        return (upper: upperBand, middle: sma, lower: lowerBand)
    }

    static func calculateFundingRateTrend(pair: String, exchange: String) -> Double? {
        let history = exchange == "bybit" ? bybitFundingRateHistory[pair] ?? [] : kucoinFundingRateHistory[pair] ?? []
        guard history.count >= 3 else { return nil }
        let recentRates = history.suffix(3)
        let trend = recentRates.enumerated().reduce(0.0) { (sum, item) in
            sum + (item.element - (recentRates[recentRates.count - 1] / Double(recentRates.count)))
        } / Double(recentRates.count)
        return trend
    }

    // CRITICAL MISSING SUPPORT FUNCTIONS - These are vital for trading operations:

    static func dynamicTradeAmount(balance: Double, riskPercent: Double, volatility: Double, pair: String = "") -> Double {
        let baseAmount = balance * riskPercent
        let volatilityAdjustment = max(0.5, min(2.0, 1.0 / (1.0 + volatility)))
        let kellySize = pair.isEmpty ? baseAmount : (kellySizes[pair] ?? baseAmount)
        return min(baseAmount * volatilityAdjustment, kellySize)
    }

    static func checkLiquidityAsyncUnique(exchange: String, pair: String, marketType: String, tradeAmount: Double, price: Double) async -> Double? {
        return await checkLiquidityAsync(exchange: exchange, pair: pair, marketType: marketType, tradeAmount: tradeAmount, price: price)
    }


    static func executeHFTTrade(exchange: String, pair: String, side: String, price: Double, amount: Double) {
        Task { @MainActor in
            let simulationEnabled = await getBool("SIMULATION_TRADE_LOGGING", defaultValue: true)
            
            if simulationEnabled {
                let profit = side == "buy" ? amount * 0.002 : amount * 0.001 // Simulated profit
                let fees = amount * (exchange == "kucoin" ? kucoinTakerFee : bybitTakerFee)
                let netProfit = profit - fees
                
                // Update running totals
                totalProfit += netProfit
                totalFees += fees
                
                // Log simulated trade
                let timestamp = ISO8601DateFormatter().string(from: Date())
                let logEntry = "\(timestamp),\(exchange),\(pair),\(side),\(price),\(amount),\(netProfit),\(fees),simulation\n"
                
                do {
                    let tradesCSVURL = URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trade_log.csv")
                    let fileManager = FileManager.default
                    
                    if !fileManager.fileExists(atPath: tradesCSVURL.path) {
                        try "timestamp,exchange,pair,side,price,amount,profit,fees,type\n".write(to: tradesCSVURL, atomically: true, encoding: .utf8)
                    }
                    
                    let fileHandle = try FileHandle(forWritingTo: tradesCSVURL)
                    defer { fileHandle.closeFile() }
                    fileHandle.seekToEndOfFile()
                    if let data = logEntry.data(using: .utf8) {
                        fileHandle.write(data)
                    }
                    
                    print("üîÑ SIMULATED TRADE: \(exchange) \(side) \(amount) \(pair) @ \(price) = \(netProfit) USDT profit")
                    logAlert(event: "üîÑ SIMULATED TRADE: \(exchange) \(side) \(amount) \(pair) @ \(price) = \(netProfit) USDT profit")
                } catch {
                    logAlert(event: "Failed to log trade: \(error)")
                }
            } else {
                // Real trade execution would go here
                print("‚ö†Ô∏è REAL TRADE DISABLED - Set SIMULATION_TRADE_LOGGING=false to enable")
                logAlert(event: "‚ö†Ô∏è REAL TRADE DISABLED - Set SIMULATION_TRADE_LOGGING=false to enable")
            }
        }
    }



 

    static func sendTradeToFlaskServer(strategy: String, pair: String, exchange: String, spotPrice: Double, futuresPrice: Double, tradeAmount: Double, profit: Double) {
        let payload: [String: Any] = [
            "strategy": strategy,
            "pair": pair,
            "exchange": exchange,
            "spot_price": spotPrice,
            "futures_price": futuresPrice,
            "trade_amount": tradeAmount,
            "profit": profit,
            "fees": 0.0, // Placeholder
            "timestamp": ISO8601DateFormatter().string(from: Date())
        ]
        
        guard let url = URL(string: "http://127.0.0.1:5001/trade") else { return }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        
        do {
            request.httpBody = try JSONSerialization.data(withJSONObject: payload)
        } catch {
            print("Failed to serialize trade payload: \(error)")
            return
        }
        
        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                print("Failed to send trade to Flask: \(error)")
                return
            }
            
            if let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 {
                print("Trade sent to Flask successfully")
            } else {
                print("Failed to send trade to Flask: Invalid response")
            }
        }
        task.resume()
    }

    static func checkLiquidityAsync(exchange: String, pair: String, marketType: String, tradeAmount: Double, price: Double) async -> Double? {
        let orderBook: BevaixOrderBook?
        
        if marketType == "spot" {
            orderBook = exchange == "kucoin" ? kucoinOrderBooks[pair] : bybitOrderBooks[pair]
        } else {
            orderBook = exchange == "kucoin" ? kucoinOrderBooks[pair] : bybitOrderBooks[pair] // Use spot for futures as placeholder
        }
        
        guard let book = orderBook, !book.isEmpty else {
            print("No order book data for \(exchange)-\(pair)-\(marketType)")
            return nil
        }
        
        var cumulativeVolume = 0.0
        var weightedPrice = 0.0
        let levels = book.asks.sorted { $0.price < $1.price } // Assume buy side for simplicity
        
        for level in levels {
            let available = level.quantity
            let take = min(tradeAmount - cumulativeVolume, available)
            weightedPrice += take * level.price
            cumulativeVolume += take
            
            if cumulativeVolume >= tradeAmount {
                break
            }
        }
        
        if cumulativeVolume < tradeAmount {
            print("Insufficient liquidity for \(exchange)-\(pair)-\(marketType): Needed \(tradeAmount), available \(cumulativeVolume)")
            return nil
        }
        
        let avgPrice = weightedPrice / cumulativeVolume
        let bestPrice = levels.first!.price
        let slippage = abs(avgPrice - bestPrice) / bestPrice
        
        return slippage
    }

    static func checkLiquidity(exchange: String, pair: String, marketType: String, tradeAmount: Double, price: Double) -> Double? {
        let orderBook: BevaixOrderBook?
        
        if marketType == "spot" {
            orderBook = exchange == "kucoin" ? kucoinOrderBooks[pair] : bybitOrderBooks[pair]
        } else {
            orderBook = exchange == "kucoin" ? kucoinOrderBooks[pair] : bybitOrderBooks[pair] // Use spot for futures as placeholder
        }
        
        guard let book = orderBook, !book.isEmpty else {
            print("No order book data for \(exchange)-\(pair)-\(marketType)")
            return nil
        }
        
        var cumulativeVolume = 0.0
        var weightedPrice = 0.0
        let levels = book.asks.sorted { $0.price < $1.price } // Assume buy side for simplicity
        
        for level in levels {
            let available = level.quantity
            let take = min(tradeAmount - cumulativeVolume, available)
            weightedPrice += take * level.price
            cumulativeVolume += take
            
            if cumulativeVolume >= tradeAmount {
                break
            }
        }
        
        if cumulativeVolume < tradeAmount {
            print("Insufficient liquidity for \(exchange)-\(pair)-\(marketType): Needed \(tradeAmount), available \(cumulativeVolume)")
            return nil
        }
        
        let avgPrice = weightedPrice / cumulativeVolume
        let bestPrice = levels.first!.price
        let slippage = abs(avgPrice - bestPrice) / bestPrice
        
        return slippage
    }

    static func optimizeOrderSizing(exchange: String, pair: String, baseAmount: Double) -> Double {
        let orderBook = exchange == "kucoin" ? kucoinOrderBooks[pair] : bybitOrderBooks[pair]
        guard let book = orderBook, !book.bids.isEmpty && !book.asks.isEmpty else { return baseAmount }
        
        // Calculate optimal size based on order book depth
        let bidDepth = book.bids.prefix(5).reduce(0.0) { $0 + $1.quantity }
        let askDepth = book.asks.prefix(5).reduce(0.0) { $0 + $1.quantity }
        let avgDepth = (bidDepth + askDepth) / 2
        
        // Limit trade size to a fraction of available depth
        let maxSize = avgDepth * 0.1 // Use 10% of top 5 levels
        return min(baseAmount, maxSize)
    }

    static func evaluateLatencyArbitrage(pair: String) async -> Bool {
        await MainActor.run {
            let kucoinLatency = lastLatency["kucoin-\(pair)"] ?? 0
            let bybitLatency = lastLatency["bybit-\(pair)"] ?? 0
            
            let latencyDifference = abs(kucoinLatency - bybitLatency)
            
            // If one exchange is significantly faster, it might provide an edge
            if latencyDifference > latencySpikeThreshold {
                let fasterExchange = kucoinLatency < bybitLatency ? "kucoin" : "bybit"
                print("‚ö° LATENCY EDGE: \(fasterExchange) is \(latencyDifference)ms faster for \(pair)")
                logAlert(event: "‚ö° LATENCY EDGE: \(fasterExchange) is \(latencyDifference)ms faster for \(pair)")
                return true
            }
            
            return false
        }
    }

    static func monitorOrderBookDepthChanges(exchange: String, pair: String) {
        Task { @MainActor in
            let currentBook = exchange == "kucoin" ? kucoinOrderBooks[pair] : bybitOrderBooks[pair]
            guard let book = currentBook, !book.bids.isEmpty && !book.asks.isEmpty else { return }
            
            let topBidSize = book.bids.first?.quantity ?? 0
            let topAskSize = book.asks.first?.quantity ?? 0
            
            // Track significant changes in top-level liquidity
            let key = "\(exchange)-\(pair)-depth"
            if let lastSizes = lastPriceUpdate[key] {
                let bidChange = abs(topBidSize - lastSizes.price) / lastSizes.price
                let askChange = abs(topAskSize - lastSizes.timestamp.timeIntervalSince1970) / lastSizes.timestamp.timeIntervalSince1970
                
                if bidChange > 0.5 || askChange > 0.5 {
                    logAlert(event: "üìä Significant depth change for \(exchange)-\(pair): Bid change \(bidChange * 100)%, Ask change \(askChange * 100)%")
                }
            }
            
            lastPriceUpdate[key] = (price: topBidSize, timestamp: Date())
        }
    }

    static func calculateVWAP(prices: [Double], volumes: [Double]) -> Double? {
        guard prices.count == volumes.count, !prices.isEmpty else { return nil }
        
        let totalVolumeValue = zip(prices, volumes).reduce(0) { $0 + ($1.0 * $1.1) }
        let totalVolume = volumes.reduce(0, +)
        
        return totalVolume > 0 ? totalVolumeValue / totalVolume : nil
    }

    static func detectMarketRegimeChange(pair: String) -> Bool {
        Task { @MainActor in
            let prices = kucoinPrices[pair] ?? []
            guard prices.count >= 100 else { return false }
            
            let recentPrices = Array(prices.suffix(50))
            let olderPrices = Array(prices.suffix(100).prefix(50))
            
            let recentVolatility = calculateVolatilityFromPrices(recentPrices)
            let olderVolatility = calculateVolatilityFromPrices(olderPrices)
            
            let volatilityChange = abs(recentVolatility - olderVolatility) / olderVolatility
            
            if volatilityChange > 0.5 { // 50% change in volatility
                let regimeType = recentVolatility > olderVolatility ? "high_volatility" : "low_volatility"
                logAlert(event: "üìà Market regime change detected for \(pair): \(regimeType) - Volatility changed by \(volatilityChange * 100)%")
                return true
            }
            return false
       // error is on the line below
        }
    
        return false
    }

    
    
    
    
    
    
    static func calculateVolatilityFromPrices(_ prices: [Double]) -> Double {
        guard prices.count > 1 else { return 0.0 }
        
        let returns = zip(prices.dropFirst(), prices.dropLast()).map { (current, previous) in
            (current - previous) / previous
        }
        
        let mean = returns.reduce(0, +) / Double(returns.count)
        let variance = returns.reduce(0.0) { $0 + pow($1 - mean, 2) } / Double(returns.count)
        
        return sqrt(variance)
    }

    // Advanced ML Enhancement Functions
    static func generateMLFeatures(pair: String) -> [String: Double] {
        var features: [String: Double] = [:]
        
        // Price-based features
        if let kucoinPrice = kucoinCurrentPrice[pair] {
            features["kucoin_price"] = kucoinPrice
        }
        if let bybitPrice = bybitCurrentPrice[pair] {
            features["bybit_price"] = bybitPrice
        }
        
        // Technical indicator features
        if let rsi = rsiValues[pair]?.last {
            features["rsi"] = rsi
        }
        if let macd = macdValues[pair]?.last {
            features["macd"] = macd.macd
            features["macd_signal"] = macd.signal
            features["macd_histogram"] = macd.histogram
        }
        
        // Volume features
        if let kucoinVolume = kucoinSpotVolume[pair]?.last {
            features["kucoin_volume"] = kucoinVolume
        }
        if let bybitVolume = bybitSpotVolume[pair]?.last {
            features["bybit_volume"] = bybitVolume
        }
        
        // Sentiment features
        features["sentiment"] = sentimentScores[pair] ?? 0.0
        
        return features
    }

    static func calculateProfitProbability(pair: String, strategy: String) -> Double {
        let metrics = tradeMetrics[pair] ?? (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)
        let totalTrades = metrics.wins + metrics.losses
        
        guard totalTrades > 0 else { return 0.5 } // Default 50% if no history
        
        return Double(metrics.wins) / Double(totalTrades)
    }

    static func optimizeStrategyAllocation() {
        Task { @MainActor in
            var totalScore = 0.0
            var strategyScores: [String: Double] = [:]
            
            // Calculate performance scores for each strategy
            for pair in tradingPairs {
                let arbitrageScore = calculateProfitProbability(pair: pair, strategy: "arbitrage")
                let scalpingScore = calculateProfitProbability(pair: pair, strategy: "scalping")
                let marketMakingScore = calculateProfitProbability(pair: pair, strategy: "market_making")
                
                strategyScores["arbitrage"] = (strategyScores["arbitrage"] ?? 0.0) + arbitrageScore
                strategyScores["scalping"] = (strategyScores["scalping"] ?? 0.0) + scalpingScore
                strategyScores["market_making"] = (strategyScores["market_making"] ?? 0.0) + marketMakingScore
            }
            
            totalScore = strategyScores.values.reduce(0, +)
            
            // Normalize to percentages
            if totalScore > 0 {
                for (strategy, score) in strategyScores {
                    strategyAllocations[strategy] = score / totalScore
                }
            }
            
            print("üìä Strategy allocations updated: \(strategyAllocations)")
            logAlert(event: "üìä Strategy allocations updated: \(strategyAllocations)")
        }
    }

    // Enhanced WebSocket Connection Functions

    static func connectKucoinWebSocket(completion: @escaping () -> Void) {
        guard !kucoinIsConnected else {
            print("KuCoin WebSocket already connected")
            completion()
            return
        }

        guard let socket = kucoinSocket else {
            print("KuCoin WebSocket not initialized")
            Task { @MainActor in
                logAlert(event: "KuCoin WebSocket not initialized")
            }
            completion()
            return
        }

        socket.connect()
        
        // Monitor connection status
        Task {
            var connectionAttempts = 0
            while connectionAttempts < 10 && !kucoinIsConnected {
                try? await Task.sleep(nanoseconds: 1_000_000_000) // 1 second
                connectionAttempts += 1
            }
            
            if kucoinIsConnected {
                print("‚úÖ KuCoin WebSocket connected successfully")
                completion()
            } else {
                print("‚ùå KuCoin WebSocket connection failed after 10 attempts")
                await MainActor.run {
                    logAlert(event: "‚ùå KuCoin WebSocket connection failed after 10 attempts")
                }
                completion()
            }
        }
    }

    static func connectBybitWebSocket(completion: @escaping () -> Void) {
        guard !bybitIsConnected else {
            print("Bybit WebSocket already connected")
            completion()
            return
        }

        let url = URL(string: "wss://stream.bybit.com/v5/public/linear")!
        var request = URLRequest(url: url)
        request.timeoutInterval = Double(websocketTimeoutSeconds)
        bybitSocket = WebSocket(request: request)
        
        bybitSocket?.onEvent = { event in
            switch event {
            case .connected(_):
                Task { @MainActor in
                    bybitIsConnected = true
                    bybitReconnectAttempts = 0
                    print("‚úÖ Bybit WebSocket connected")
                    logAlert(event: "‚úÖ Bybit WebSocket connected")
                    
                    // Subscribe to all trading pairs
                    let tickerTopics = tradingPairs.map { "tickers.\($0.replacingOccurrences(of: "-USDT", with: "USDT"))" }
                    let orderBookTopics = tradingPairs.map { "orderbook.50.\($0.replacingOccurrences(of: "-USDT", with: "USDT"))" }
                    
                    let subscribeMessage: [String: Any] = [
                        "op": "subscribe",
                        "args": tickerTopics + orderBookTopics
                    ]
                    
                    do {
                        let jsonData = try JSONSerialization.data(withJSONObject: subscribeMessage)
                        bybitSocket?.write(data: jsonData)
                        print("üì° Subscribed to Bybit topics: \(tickerTopics.count + orderBookTopics.count) total")
                        logAlert(event: "üì° Subscribed to Bybit topics: \(tickerTopics.count + orderBookTopics.count) total")
                    } catch {
                        print("Failed to send Bybit subscription: \(error)")
                        logAlert(event: "Failed to send Bybit subscription: \(error)")
                    }
                }
                completion()
                
            case .disconnected(let reason, let code):
                Task { @MainActor in
                    bybitIsConnected = false
                    print("‚ùå Bybit WebSocket disconnected: \(reason), code: \(code)")
                    logAlert(event: "‚ùå Bybit WebSocket disconnected: \(reason), code: \(code)")
                    
                    if bybitReconnectAttempts < maxReconnectAttempts {
                        bybitReconnectAttempts += 1
                        DispatchQueue.main.asyncAfter(deadline: .now() + 5.0) {
                            connectBybitWebSocket(completion: completion)
                        }
                    }
                }
                
            case .text(let string):
                Task {
                    do {
                        if let json = try JSONSerialization.jsonObject(with: string.data(using: .utf8)!) as? [String: Any] {
                            await handleWebSocketMessage(socket: bybitSocket!, message: json, exchange: "bybit")
                        }
                    } catch {
                        await MainActor.run {
                            logAlert(event: "Failed to parse Bybit WebSocket message: \(error)")
                        }
                    }
                }
                
            case .error(let error):
                Task { @MainActor in
                    print("‚ùå Bybit WebSocket error: \(error?.localizedDescription ?? "Unknown")")
                    logAlert(event: "‚ùå Bybit WebSocket error: \(error?.localizedDescription ?? "Unknown")")
                }
                
            default:
                break
            }
        }
        
        bybitSocket?.connect()
    }
}

