// Block 1: Imports and Class Declaration

import Starscream
import Foundation
import CryptoKit

@MainActor
final class ExchangeWebSocket {
    // Starscream WebSockets (not URLSessionWebSocket)
    static var kucoinSocket: WebSocket?
    static var kucoinFuturesSocket: WebSocket?
    static var bybitSocket: WebSocket?
    static var bybitSpotSocket: WebSocket?
    
    // Connection States
    static var kucoinIsConnected = false
    static var kucoinFuturesIsConnected = false
    static var bybitIsConnected = false
    
    // WebSocket Tokens
    static var kucoinToken: String?
    static var kucoinFuturesToken: String?
    
    // Price Storage
    static var kucoinPrices: [String: [Double]] = [:] // Spot prices
    static var kucoinFuturesPrices: [String: [Double]] = [:] // Futures prices
    static var bybitPrices: [String: [Double]] = [:] // Spot prices
    static var bybitFuturesPrices: [String: [Double]] = [:] // Futures prices
    
    // Current Prices
    static var kucoinCurrentPrice: [String: Double] = [:]
    static var kucoinCurrentFuturesPrice: [String: Double] = [:]
    static var bybitCurrentPrice: [String: Double] = [:]
    static var bybitCurrentFuturesPrice: [String: Double] = [:]
    
    // Volume Storage
    static var kucoinSpotVolume: [String: [Double]] = [:]
    static var kucoinFuturesVolume: [String: [Double]] = [:]
    static var bybitSpotVolume: [String: [Double]] = [:]
    static var bybitFuturesVolume: [String: [Double]] = [:]
    
    // Order Book Storage
    static var kucoinFuturesOrderBook: [String: [(price: Double, volume: Double, side: String)]] = [:]
    static var bybitFuturesOrderBook: [String: [(price: Double, volume: Double, side: String)]] = [:]
    
    // ATR Storage
    static var kucoinFuturesATR: [String: Double] = [:]
    static var bybitFuturesATR: [String: Double] = [:]
    
    // Trading States
    static var kucoinInSpotTrade: [String: Bool] = [:]
    static var bybitInSpotTrade: [String: Bool] = [:]
    static var kucoinSpotEntryPrice: [String: Double] = [:]
    static var bybitSpotEntryPrice: [String: Double] = [:]
    static var kucoinFuturesEntryPrice: [String: Double] = [:]
    static var bybitFuturesEntryPrice: [String: Double] = [:]
    static var kucoinSpotTrailingStop: [String: Double] = [:]
    static var bybitSpotTrailingStop: [String: Double] = [:]
    static var activeSpotTrades: [String: Int] = [:]
    
    // Arbitrage States
    static var arbitrageExecuted: [String: (Bool, Date)] = [:]
    static var crossExchangeArbitrageExecuted: [String: (Bool, Date)] = [:]
    
    // Funding Rates
    static var bybitFundingRates: [String: Double] = [:]
    static var kucoinFundingRates: [String: Double] = [:]
    
    // Balances
    static var kucoinBalance: Double = 0.0
    static var bybitBalance: Double = 0.0
    static var kucoinBalances: [String: Double] = [:]
    static var bybitBalances: [String: Double] = [:]
    
    // Daily Loss Tracking
    static var dailyLoss: [String: Double] = ["bybit": 0.0, "kucoin": 0.0]
    static var lastDailyReset: Date = Date()
    
    // Environment for loading .env variables
    static let environment = ProcessInfo.processInfo.environment
    
    // Parameters loaded from .env
    static var tradingPairs: [String] = []
    static var kucoinFuturesSymbols: [String: String] = [:]
    static var liquidityDepthMultiplier: Double = 0.0
    static var liquidityPriceImpactThreshold: Double = 0.0
    static var orderBookPriceRange: Double = 0.0
    static var orderBookImbalanceThreshold: Double = 0.0
    static var futuresTradeAmount: Double = 0.0
    static var futuresMinProfitPercentage: Double = 0.0
    static var futuresStopLossPercentage: Double = 0.0
    static var futuresTrailingStopPercentage: Double = 0.0
    static var futuresSpikeTrailingStopPercentage: Double = 0.0
    static var maxActiveFuturesTrades: Int = 0
    static var dailyLossLimitPercentage: Double = 0.0
    static var atrMultiplier: Double = 0.0
    static var arbitrageMinBalance: Double = 0.0
    static var arbitrageTradeAmount: Double = 0.0
    static var arbitrageMinSpreadThreshold: Double = 0.0
    static var arbitrageHighSpreadThreshold: Double = 0.0
    static var crossExchangeMinSpreadThreshold: Double = 0.0
    static var crossExchangeMinBalance: Double = 0.0
    static var crossExchangeTradeAmount: Double = 0.0
    static var crossExchangeMinFundingRateThreshold: Double = 0.0
    static var crossExchangeCooldownSeconds: Double = 0.0
    static var volatilityPauseSeconds: Double = 0.0
    static var spotTradeAmount: Double = 0.0
    static var spotFeeRate: Double = 0.0
    static var spotMinProfitPercentage: Double = 0.0
    static var spotStopLossPercentage: Double = 0.0
    static var spotTrailingStopPercentage: Double = 0.0
    static var spotEmaShortPeriod: Int = 0
    static var spotEmaMediumPeriod: Int = 0
    static var spotEmaLongPeriod: Int = 0
    static var spotRsiPeriod: Int = 0
    static var spotRsiUpperThreshold: Double = 0.0
    static var spotRsiLowerThreshold: Double = 0.0
    static var maxActiveSpotTrades: Int = 0
    static var futuresEmaShortPeriod: Int = 0
    static var futuresEmaMediumPeriod: Int = 0
    static var futuresEmaLongPeriod: Int = 0
    static var bybitFuturesFeeRate: Double = 0.0
    static var kucoinFuturesFeeRate: Double = 0.0
    static var bybitFallbackBalance: Double = 0.0
    static var kucoinFallbackBalance: Double = 0.0
    static var bybitRecvWindow: String = ""
    static var kucoinLeverage: String = ""
    static var priceHistoryRetention: Int = 0
    static var volatilitySpikeThreshold: Double = 0.0
    static var volatilitySpikeWindowMinutes: Int = 0
    static var volatilitySpikeCooldownSeconds: Int = 0
    static var volumeAnomalyMultiplier: Double = 0.0
    static var volumeAnomalyWindowHours: Int = 0
    static var volumeAnomalyCooldownSeconds: Int = 0
    static var minLiquidityThreshold: Double = 0.0
    static var maxOrderBookImbalance: Double = 0.0
    static var websocketTimeoutSeconds: Int = 0
    static var balanceFetchTimeout: Int = 0
    static var arbitrageThreshold: Double = 0.001
    static var maxFundingRate: Double = 0.0
    static var crossExchangeArbitrageThreshold: Double = 0.002

    // Added variables for trading strategy and arbitrage
    static var shortSMAPeriod: Int = 10
    static var longSMAPeriod: Int = 20
    static var bybitPositions: [String: Double] = [:]
    static var kucoinPositions: [String: Double] = [:]
    static var tradeAmountPercentage: Double = 0.1
    static var stopLossPercentage: Double = 0.02
    static var bybitEntryPrices: [String: Double] = [:]
    static var kucoinEntryPrices: [String: Double] = [:]
    static var takeProfitPercentage: Double = 0.05
    static var fundingRateAdjustmentFactor: Double = 0.01

    static func initializeParameters() {
        // Load pairs from environment and ensure proper formatting
        let rawPairs = environment["ACTIVE_PAIRS"] ?? "BTC-USDT,ETH-USDT"
        tradingPairs = rawPairs.split(separator: ",").map { String($0).trimmingCharacters(in: .whitespaces) }
        print("Loaded ACTIVE_PAIRS: \(tradingPairs)")
        print("Number of pairs loaded: \(tradingPairs.count)")

        kucoinFuturesSymbols = [:]
        for pair in tradingPairs {
            let components = pair.components(separatedBy: "-")
            if components.count == 2 {
                let base = components[0]
                let quote = components[1]
                kucoinFuturesSymbols[pair] = "\(base)\(quote)M" // e.g., "BTCUSDTM" for BTC-USDT
            } else {
                print("Invalid trading pair format: \(pair)")
            }
        }
        print("Initialized kucoinFuturesSymbols: \(kucoinFuturesSymbols)")
        
        liquidityDepthMultiplier = Double(environment["LIQUIDITY_DEPTH_MULTIPLIER"] ?? "7.0") ?? 7.0
        liquidityPriceImpactThreshold = Double(environment["LIQUIDITY_PRICE_IMPACT_THRESHOLD"] ?? "0.005") ?? 0.005
        orderBookPriceRange = Double(environment["ORDER_BOOK_PRICE_RANGE"] ?? "0.005") ?? 0.005
        orderBookImbalanceThreshold = Double(environment["ORDER_BOOK_IMBALANCE_THRESHOLD"] ?? "1.5") ?? 1.5
        minLiquidityThreshold = Double(environment["MIN_LIQUIDITY_THRESHOLD"] ?? "500.0") ?? 500.0
        maxOrderBookImbalance = Double(environment["MAX_ORDER_BOOK_IMBALANCE"] ?? "3.0") ?? 3.0
        volatilitySpikeThreshold = Double(environment["VOLATILITY_SPIKE_THRESHOLD"] ?? "0.05") ?? 0.05
        volatilitySpikeWindowMinutes = Int(environment["VOLATILITY_SPIKE_WINDOW_MINUTES"] ?? "5") ?? 5
        volatilitySpikeCooldownSeconds = Int(environment["VOLATILITY_SPIKE_COOLDOWN_SECONDS"] ?? "900") ?? 900
        volumeAnomalyMultiplier = Double(environment["VOLUME_ANOMALY_MULTIPLIER"] ?? "5.0") ?? 5.0
        volumeAnomalyWindowHours = Int(environment["VOLUME_ANOMALY_WINDOW_HOURS"] ?? "1") ?? 1
        volumeAnomalyCooldownSeconds = Int(environment["VOLUME_ANOMALY_COOLDOWN_SECONDS"] ?? "1800") ?? 1800
        futuresTradeAmount = Double(environment["FUTURES_TRADE_AMOUNT"] ?? "150.0") ?? 150.0
        futuresMinProfitPercentage = Double(environment["FUTURES_MIN_PROFIT_PERCENTAGE"] ?? "0.01") ?? 0.01
        futuresStopLossPercentage = Double(environment["FUTURES_STOP_LOSS_PERCENTAGE"] ?? "0.02") ?? 0.02
        futuresTrailingStopPercentage = Double(environment["FUTURES_TRAILING_STOP_PERCENTAGE"] ?? "0.01") ?? 0.01
        futuresSpikeTrailingStopPercentage = Double(environment["FUTURES_SPIKE_TRAILING_STOP_PERCENTAGE"] ?? "0.02") ?? 0.02
        maxActiveFuturesTrades = Int(environment["MAX_ACTIVE_FUTURES_TRADES"] ?? "5") ?? 5
        dailyLossLimitPercentage = Double(environment["DAILY_LOSS_LIMIT_PERCENTAGE"] ?? "0.1") ?? 0.1
        atrMultiplier = Double(environment["ATR_MULTIPLIER"] ?? "1.5") ?? 1.5
        arbitrageMinBalance = Double(environment["ARBITRAGE_MIN_BALANCE"] ?? "300.0") ?? 300.0
        arbitrageTradeAmount = Double(environment["ARBITRAGE_TRADE_AMOUNT"] ?? "500.0") ?? 500.0
        arbitrageMinSpreadThreshold = Double(environment["ARBITRAGE_MIN_SPREAD_THRESHOLD"] ?? "0.001") ?? 0.001
        arbitrageHighSpreadThreshold = Double(environment["ARBITRAGE_HIGH_SPREAD_THRESHOLD"] ?? "0.005") ?? 0.005
        crossExchangeMinBalance = Double(environment["CROSS_EXCHANGE_MIN_BALANCE"] ?? "500.0") ?? 500.0
        crossExchangeTradeAmount = Double(environment["CROSS_EXCHANGE_TRADE_AMOUNT"] ?? "150.0") ?? 150.0
        crossExchangeMinSpreadThreshold = Double(environment["CROSS_EXCHANGE_MIN_SPREAD_THRESHOLD"] ?? "0.021162") ?? 0.021162
        crossExchangeMinFundingRateThreshold = Double(environment["CROSS_EXCHANGE_MIN_FUNDING_RATE_THRESHOLD"] ?? "0.00005") ?? 0.00005
        crossExchangeCooldownSeconds = Double(environment["CROSS_EXCHANGE_COOLDOWN_SECONDS"] ?? "300") ?? 300
        volatilityPauseSeconds = Double(environment["VOLATILITY_PAUSE_SECONDS"] ?? "300") ?? 300
        spotTradeAmount = Double(environment["SPOT_TRADE_AMOUNT"] ?? "30.0") ?? 30.0
        spotFeeRate = Double(environment["SPOT_FEE_RATE"] ?? "0.001") ?? 0.001
        spotMinProfitPercentage = Double(environment["SPOT_MIN_PROFIT_PERCENTAGE"] ?? "0.004") ?? 0.004
        spotStopLossPercentage = Double(environment["SPOT_STOP_LOSS_PERCENTAGE"] ?? "0.02") ?? 0.02
        spotTrailingStopPercentage = Double(environment["SPOT_TRAILING_STOP_PERCENTAGE"] ?? "0.003") ?? 0.003
        spotEmaShortPeriod = Int(environment["SPOT_EMA_SHORT_PERIOD"] ?? "3") ?? 3
        spotEmaMediumPeriod = Int(environment["SPOT_EMA_MEDIUM_PERIOD"] ?? "6") ?? 6
        spotEmaLongPeriod = Int(environment["SPOT_EMA_LONG_PERIOD"] ?? "20") ?? 20
        spotRsiPeriod = Int(environment["SPOT_RSI_PERIOD"] ?? "14") ?? 14
        spotRsiUpperThreshold = Double(environment["SPOT_RSI_UPPER_THRESHOLD"] ?? "70.0") ?? 70.0
        spotRsiLowerThreshold = Double(environment["SPOT_RSI_LOWER_THRESHOLD"] ?? "50.0") ?? 50.0
        maxActiveSpotTrades = Int(environment["MAX_ACTIVE_SPOT_TRADES"] ?? "2") ?? 2
        futuresEmaShortPeriod = Int(environment["FUTURES_EMA_SHORT_PERIOD"] ?? "3") ?? 3
        futuresEmaMediumPeriod = Int(environment["FUTURES_EMA_MEDIUM_PERIOD"] ?? "6") ?? 6
        futuresEmaLongPeriod = Int(environment["FUTURES_EMA_LONG_PERIOD"] ?? "20") ?? 20
        bybitFuturesFeeRate = Double(environment["BYBIT_FUTURES_FEE_RATE"] ?? "0.0004") ?? 0.0004
        kucoinFuturesFeeRate = Double(environment["KUCOIN_FUTURES_FEE_RATE"] ?? "0.0005") ?? 0.0005
        bybitFallbackBalance = Double(environment["BYBIT_FALLBACK_BALANCE"] ?? "500.0") ?? 500.0
        kucoinFallbackBalance = Double(environment["KUCOIN_FALLBACK_BALANCE"] ?? "500.0") ?? 0.0
        bybitRecvWindow = environment["BYBIT_RECV_WINDOW"] ?? "5000"
        kucoinLeverage = environment["KUCOIN_LEVERAGE"] ?? "1"
        priceHistoryRetention = Int(environment["PRICE_HISTORY_RETENTION"] ?? "1440") ?? 1440
        websocketTimeoutSeconds = Int(environment["WEBSOCKET_TIMEOUT_SECONDS"] ?? "15") ?? 15
        balanceFetchTimeout = Int(environment["BALANCE_FETCH_TIMEOUT"] ?? "20") ?? 20
        maxFundingRate = Double(environment["MAX_FUNDING_RATE"] ?? "0.001") ?? 0.001
        
        kucoinBalance = kucoinFallbackBalance
        bybitBalance = bybitFallbackBalance
        print("Initialized kucoinBalance: \(kucoinBalance), bybitBalance: \(bybitBalance)")

        // Initialize additional state for trading pairs
        tradingPairs.forEach { pair in
            kucoinPrices[pair] = []
            kucoinFuturesPrices[pair] = []
            bybitPrices[pair] = []
            bybitFuturesPrices[pair] = []
            bybitPositions[pair] = 0.0
            kucoinPositions[pair] = 0.0
            kucoinSpotVolume[pair] = []
            kucoinFuturesVolume[pair] = []
            bybitSpotVolume[pair] = []
            bybitFuturesVolume[pair] = []
            kucoinFuturesOrderBook[pair] = []
            bybitFuturesOrderBook[pair] = []
            kucoinInSpotTrade[pair] = false
            bybitInSpotTrade[pair] = false
            activeSpotTrades[pair] = 0
            arbitrageExecuted[pair] = (false, Date.distantPast)
            crossExchangeArbitrageExecuted[pair] = (false, Date.distantPast)
        }
    }
}

//------------------------------------------------------------Block 2.1: Global Variables and Structs

struct OrderBookEntry {
    let price: Double
    let volume: Double
    let side: String
}

// Dedicated struct to hold environment variables
struct AppConfig {
    static let environment: [String: String] = {
        let env = loadEnv()
        // Debug print to confirm loaded keys
        print("DEBUG: Loaded environment keys: \(env.keys)")
        return env
    }()
}

func findProjectRoot(from directory: URL) -> URL? {
    var currentDirectory = directory
    while currentDirectory.path != "/" {
        let packageFile = currentDirectory.appendingPathComponent("Package.swift")
        if FileManager.default.fileExists(atPath: packageFile.path) {
            return currentDirectory
        }
        currentDirectory = currentDirectory.deletingLastPathComponent()
    }
    return nil
}

func loadEnv() -> [String: String] {
    var env: [String: String] = [:]
    let fileManager = FileManager.default
    
    // Check current working directory first (project root when using `swift run`)
    let currentDirectory = fileManager.currentDirectoryPath
    let currentEnvPath = URL(fileURLWithPath: currentDirectory).appendingPathComponent(".env").path
    
    // Debug: Print the current directory and .env path
    print("Current working directory: \(currentDirectory)")
    print("Looking for .env file at: \(currentEnvPath)")
    
    if fileManager.fileExists(atPath: currentEnvPath) {
        do {
            let contents = try String(contentsOfFile: currentEnvPath, encoding: .utf8)
            print("Successfully read .env file contents: \(contents)")
            let lines = contents.components(separatedBy: .newlines)
            for line in lines {
                let trimmed = line.trimmingCharacters(in: .whitespacesAndNewlines)
                print("Processing line: '\(trimmed)'")
                if trimmed.isEmpty || trimmed.hasPrefix("#") { continue }
                let parts = trimmed.components(separatedBy: "=")
                if parts.count >= 2 {
                    let key = parts[0].trimmingCharacters(in: .whitespaces)
                    let value = parts.dropFirst().joined(separator: "=").trimmingCharacters(in: .whitespaces)
                    print("Parsed key: '\(key)', value: '\(value)'")
                    env[key] = value
                } else {
                    print("Skipping invalid line (expected key=value format): '\(trimmed)'")
                }
            }
        } catch {
            print("Error loading .env file: \(error)")
        }
    } else {
        print("Could not find .env file at path: \(currentEnvPath)")
        
        // Fallback: Search for project root from binary's directory
        let binaryURL = URL(fileURLWithPath: CommandLine.arguments[0])
        if let projectRoot = findProjectRoot(from: binaryURL.deletingLastPathComponent()) {
            let rootEnvPath = projectRoot.appendingPathComponent(".env").path
            print("Falling back to project root: \(projectRoot.path)")
            print("Looking for .env file at: \(rootEnvPath)")
            if fileManager.fileExists(atPath: rootEnvPath) {
                do {
                    let contents = try String(contentsOfFile: rootEnvPath, encoding: .utf8)
                    print("Successfully read .env file contents: \(contents)")
                    let lines = contents.components(separatedBy: .newlines)
                    for line in lines {
                        let trimmed = line.trimmingCharacters(in: .whitespacesAndNewlines)
                        print("Processing line: '\(trimmed)'")
                        if trimmed.isEmpty || trimmed.hasPrefix("#") { continue }
                        let parts = trimmed.components(separatedBy: "=")
                        if parts.count >= 2 {
                            let key = parts[0].trimmingCharacters(in: .whitespaces)
                            let value = parts.dropFirst().joined(separator: "=").trimmingCharacters(in: .whitespaces)
                            print("Parsed key: '\(key)', value: '\(value)'")
                            env[key] = value
                        } else {
                            print("Skipping invalid line (expected key=value format): '\(trimmed)'")
                        }
                    }
                } catch {
                    print("Error loading .env file: \(error)")
                }
            } else {
                print("Could not find .env file at fallback path: \(rootEnvPath)")
            }
        } else {
            print("Could not locate project root for fallback .env loading")
        }
    }
    
    // Debug: Print the final loaded environment variables
    print("DEBUG: Final loaded environment variables: \(env)")
    return env
}

//------------------------------------------------------------Block 3.1: Class Declaration and Static Properties
// Removed - Duplicate declaration moved to Block 1

//------------------------------------------------------------Block 3.2: Liquidity and Order Book Functions

extension ExchangeWebSocket {
    static func fetchOrderBookDepth(exchange: String, pair: String, marketType: String, completion: @escaping (Double?) -> Void) {
        var url: URL?

        if exchange == "bybit" {
            let symbol = pair.replacingOccurrences(of: "-USDT", with: "USDT")
            let category = marketType == "spot" ? "spot" : "linear"
            url = URL(string: "https://api.bybit.com/v5/market/orderbook?category=\(category)&symbol=\(symbol)&limit=50")
        } else {
            let symbol = pair.replacingOccurrences(of: "-USDT", with: "USDT")
            let endpoint = marketType == "spot" ? "/api/v1/market/orderbook/level2_50?symbol=\(symbol)" : "/api/v1/contractMarket/level2?symbol=\(symbol)M"
            url = URL(string: "https://api\(marketType == "spot" ? "" : "-futures").kucoin.com\(endpoint)")
        }

        guard let requestUrl = url else {
            print("Invalid order book URL for \(exchange)-\(pair)-\(marketType)")
            completion(nil)
            return
        }

        var request = URLRequest(url: requestUrl)
        request.httpMethod = "GET"
        request.timeoutInterval = 5.0

        URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                print("Failed to fetch order book for \(exchange)-\(pair)-\(marketType): \(error.localizedDescription)")
                completion(nil)
                return
            }

            guard let data = data,
                  let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] else {
                print("Invalid order book response for \(exchange)-\(pair)-\(marketType)")
                completion(nil)
                return
            }

            if exchange == "bybit" {
                guard let result = json["result"] as? [String: Any],
                      let bids = result["b"] as? [[String]],
                      let asks = result["a"] as? [[String]] else {
                    print("Failed to parse Bybit order book data: \(json)")
                    completion(nil)
                    return
                }

                var bidDepth: Double = 0.0
                var askDepth: Double = 0.0

                for bid in bids {
                    if let priceStr = bid.first, let qtyStr = bid.last,
                       let price = Double(priceStr), let qty = Double(qtyStr) {
                        bidDepth += price * qty
                    }
                }

                for ask in asks {
                    if let priceStr = ask.first, let qtyStr = ask.last,
                       let price = Double(priceStr), let qty = Double(qtyStr) {
                        askDepth += price * qty
                    }
                }

                let totalDepth = bidDepth + askDepth
                completion(totalDepth)
            } else {
                if marketType == "spot" {
                    guard let dataDict = json["data"] as? [String: Any],
                          let bids = dataDict["bids"] as? [[String]],
                          let asks = dataDict["asks"] as? [[String]] else {
                        print("Failed to parse KuCoin spot order book data: \(json)")
                        completion(nil)
                        return
                    }

                    var bidDepth: Double = 0.0
                    var askDepth: Double = 0.0

                    for bid in bids {
                        if let priceStr = bid.first, let qtyStr = bid.last,
                           let price = Double(priceStr), let qty = Double(qtyStr) {
                            bidDepth += price * qty
                        }
                    }

                    for ask in asks {
                        if let priceStr = ask.first, let qtyStr = ask.last,
                           let price = Double(priceStr), let qty = Double(qtyStr) {
                            askDepth += price * qty
                        }
                    }

                    let totalDepth = bidDepth + askDepth
                    completion(totalDepth)
                } else {
                    guard let dataDict = json["data"] as? [String: Any],
                          let bids = dataDict["bids"] as? [[String]],
                          let asks = dataDict["asks"] as? [[String]] else {
                        print("Failed to parse KuCoin futures order book data: \(json)")
                        completion(nil)
                        return
                    }

                    var bidDepth: Double = 0.0
                    var askDepth: Double = 0.0

                    for bid in bids {
                        if let priceStr = bid.first, let qtyStr = bid.last,
                           let price = Double(priceStr), let qty = Double(qtyStr) {
                            bidDepth += price * qty
                        }
                    }

                    for ask in asks {
                        if let priceStr = ask.first, let qtyStr = ask.last,
                           let price = Double(priceStr), let qty = Double(qtyStr) {
                            askDepth += price * qty
                        }
                    }

                    let totalDepth = bidDepth + askDepth
                    completion(totalDepth)
                }
            }
        }.resume()
    }

    static func checkLiquidity(exchange: String, pair: String, marketType: String, tradeAmount: Double, currentPrice: Double) -> Bool {
        let orderBook = exchange == "bybit" ? bybitFuturesOrderBook[pair] ?? [] : kucoinFuturesOrderBook[pair] ?? []
        guard !orderBook.isEmpty else {
            print("No order book data available for \(exchange)-\(pair)-\(marketType)")
            return false
        }

        let priceRange = currentPrice * orderBookPriceRange
        let minPrice = currentPrice - priceRange
        let maxPrice = currentPrice + priceRange

        var availableVolume: Double = 0.0
        for entry in orderBook {
            let price = entry.price
            if price >= minPrice && price <= maxPrice {
                availableVolume += entry.volume
            }
        }

        let requiredVolume = tradeAmount / currentPrice
        let hasEnoughLiquidity = availableVolume >= requiredVolume * liquidityDepthMultiplier

        if !hasEnoughLiquidity {
            print("Insufficient liquidity for \(exchange)-\(pair)-\(marketType): Available volume \(availableVolume), required \(requiredVolume * liquidityDepthMultiplier)")
        }

        let buyVolume = orderBook.filter { $0.side == "buy" && $0.price >= minPrice && $0.price <= maxPrice }.reduce(0.0) { $0 + $1.volume }
        let sellVolume = orderBook.filter { $0.side == "sell" && $0.price >= minPrice && $0.price <= maxPrice }.reduce(0.0) { $0 + $1.volume }
        let imbalance = max(buyVolume, sellVolume) / max(min(buyVolume, sellVolume), 0.0001)
        let isBalanced = imbalance <= orderBookImbalanceThreshold

        if !isBalanced {
            print("Order book imbalance for \(exchange)-\(pair)-\(marketType): Buy volume \(buyVolume), Sell volume \(sellVolume), Imbalance \(imbalance)")
        }

        return hasEnoughLiquidity && isBalanced
    }
}

//---------------------------------------------------------------------------------------------------------------------Block 3.3: WebSocket Connections
//removed
// Removed - Moved to Block 4.8 to resolve visibility issue
//------------------------------------------------------------Block 4.1: Extension Declaration and Static Variables
//------------------------------------------------------------Block 4.1: Technical Indicators

extension ExchangeWebSocket {
    // Calculate Exponential Moving Average (EMA)
    static func calculateEMA(prices: [Double], period: Int) -> Double? {
        guard prices.count >= period else { return nil }
        let k = 2.0 / Double(period + 1)
        var ema = prices[0]
        for i in 1..<prices.count {
            ema = prices[i] * k + ema * (1 - k)
        }
        return ema
    }

    // Calculate Relative Strength Index (RSI)
    static func calculateRSI(prices: [Double], period: Int) -> Double? {
        guard prices.count >= period + 1 else { return nil }
        var gains: [Double] = []
        var losses: [Double] = []
        for i in 1..<prices.count {
            let diff = prices[i] - prices[i - 1]
            if diff > 0 {
                gains.append(diff)
                losses.append(0)
            } else {
                gains.append(0)
                losses.append(abs(diff))
            }
        }
        guard gains.count >= period else { return nil }
        let avgGain = gains.suffix(period).reduce(0, +) / Double(period)
        let avgLoss = losses.suffix(period).reduce(0, +) / Double(period)
        guard avgLoss != 0 else { return 100 }
        let rs = avgGain / avgLoss
        return 100 - (100 / (1 + rs))
    }

    // Calculate Average True Range (ATR)
    static func calculateATR(prices: [Double]) -> Double? {
        guard prices.count > 1 else { return nil }
        var trs: [Double] = []
        for i in 1..<prices.count {
            let highLow = abs(prices[i] - prices[i - 1])
            trs.append(highLow)
        }
        guard !trs.isEmpty else { return nil }
        return trs.reduce(0, +) / Double(trs.count)
    }

    // Check Volatility using ATR
    static func checkVolatility(exchange: String, pair: String, atr: Double) -> Bool {
        let currentPrice = exchange == "bybit" ? bybitCurrentFuturesPrice[pair] ?? 0.0 : kucoinCurrentFuturesPrice[pair] ?? 0.0
        guard currentPrice > 0 else { return false }
        let atrPercentage = atr / currentPrice
        return atrPercentage >= atrMultiplier
    }

    // Detect Volatility Spike
    static func detectVolatilitySpike(exchange: String, pair: String) -> Bool {
        let prices = exchange == "bybit" ? bybitFuturesPrices[pair] ?? [] : kucoinFuturesPrices[pair] ?? []
        guard prices.count >= volatilitySpikeWindowMinutes else { return false }
        let recentPrices = prices.suffix(volatilitySpikeWindowMinutes)
        guard let minPrice = recentPrices.min(), let maxPrice = recentPrices.max() else { return false }
        let priceRange = (maxPrice - minPrice) / minPrice
        return priceRange >= volatilitySpikeThreshold
    }

    // Check Volume Anomaly
    static func checkVolumeAnomaly(exchange: String, pair: String, marketType: String) -> Bool {
        let volumes: [Double]
        switch (exchange, marketType) {
        case ("kucoin", "spot"):
            volumes = kucoinSpotVolume[pair] ?? []
        case ("kucoin", "futures"):
            volumes = kucoinFuturesVolume[pair] ?? []
        case ("bybit", "spot"):
            volumes = bybitSpotVolume[pair] ?? []
        case ("bybit", "futures"):
            volumes = bybitFuturesVolume[pair] ?? []
        default:
            return false
        }
        guard volumes.count >= volumeAnomalyWindowHours * 60 else { return false }
        let recentVolumes = volumes.suffix(volumeAnomalyWindowHours * 60)
        let avgVolume = recentVolumes.reduce(0, +) / Double(recentVolumes.count)
        guard let maxVolume = recentVolumes.max() else { return false }
        return maxVolume >= avgVolume * volumeAnomalyMultiplier
    }
}


//------------------------------------------------------------Block 4.2: Helper Functions (Part 1)

extension ExchangeWebSocket {
    static func fetchKuCoinFuturesSymbols(completion: @escaping () -> Void) {
        var req = URLRequest(url: URL(string: "https://api-futures.kucoin.com/api/v1/contracts/active")!)
        req.httpMethod = "GET"
        URLSession.shared.dataTask(with: req) { data, _, error in
            if let data = data, let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
               let code = json["code"] as? String, code == "200000",
               let dataArray = json["data"] as? [[String: Any]] {
                Task { @MainActor in
                    for contract in dataArray {
                        if let symbol = contract["symbol"] as? String,
                           let baseCurrency = contract["baseCurrency"] as? String,
                           let quoteCurrency = contract["quoteCurrency"] as? String {
                            let spotPair = "\(baseCurrency)-\(quoteCurrency)"
                            kucoinFuturesSymbols[spotPair] = symbol
                        }
                    }
                    completion()
                }
            } else {
                completion()
            }
        }.resume()
    }

    static func calculateATR(prices: [Double], period: Int = 14) -> Double? {
        guard prices.count >= period + 1 else { return nil }
        var trueRanges: [Double] = []
        for i in 1..<prices.count {
            let high = prices[i]
            let low = prices[i]
            let prevClose = prices[i - 1]
            let tr1 = abs(high - low)
            let tr2 = abs(high - prevClose)
            let tr3 = abs(low - prevClose)
            let trueRange = max(tr1, tr2, tr3)
            trueRanges.append(trueRange)
        }
        guard trueRanges.count >= period else { return nil }
        return trueRanges.suffix(period).reduce(0, +) / Double(period)
    }
}

//------------------------------------------------------------Block 4.3: Safeguard Functions

extension ExchangeWebSocket {
    static func fetchKucionWsToken(completion: @escaping (String?) -> Void) {
        let url = URL(string: "https://api.kucoin.com/api/v1/bullet-public")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.timeoutInterval = 10.0

        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                print("DEBUG: Failed to fetch KuCoin WebSocket token: \(error.localizedDescription)")
                completion(nil)
                return
            }
            guard let data = data,
                  let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let dataDict = json["data"] as? [String: Any],
                  let token = dataDict["token"] as? String else {
                print("DEBUG: Failed to fetch KuCoin WebSocket token: Invalid response")
                completion(nil)
                return
            }
            completion(token)
        }
        task.resume()
    }

    static func fetchKucoinFuturesWsToken(completion: @escaping (String?) -> Void) {
        let url = URL(string: "https://api-futures.kucoin.com/api/v1/bullet-public")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.timeoutInterval = 10.0

        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                print("DEBUG: Failed to fetch KuCoin Futures WebSocket token: \(error.localizedDescription)")
                completion(nil)
                return
            }
            guard let data = data,
                  let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let dataDict = json["data"] as? [String: Any],
                  let token = dataDict["token"] as? String else {
                print("DEBUG: Failed to fetch KuCoin Futures WebSocket token: Invalid response")
                completion(nil)
                return
            }
            completion(token)
        }
        task.resume()
    }

    static func fetchBybitBalance(completion: @escaping (Double?) -> Void) {
        let maxRetries = 3
        var retryCount = 0

        func attemptFetch() {
            let timestamp = String(Int(Date().timeIntervalSince1970 * 1000))
            let apiKey = environment["BYBIT_API_KEY"] ?? ""
            let apiSecret = environment["BYBIT_API_SECRET"] ?? ""
            let endpoint = "/v5/account/wallet-balance"
            let recvWindow = bybitRecvWindow
            let queryParams = "accountType=UNIFIED&coin=USDT"
            let signStr = timestamp + apiKey + recvWindow + queryParams

            guard !apiKey.isEmpty, !apiSecret.isEmpty else {
                print("DEBUG: Bybit API key or secret missing in .env, using fallback: \(bybitFallbackBalance)")
                completion(bybitFallbackBalance)
                return
            }

            guard let secretData = apiSecret.data(using: .utf8),
                  let signStrData = signStr.data(using: .utf8) else {
                print("DEBUG: Failed to encode API secret or sign string for Bybit balance")
                completion(nil)
                return
            }

            let key = SymmetricKey(data: secretData)
            let signature = HMAC<SHA256>.authenticationCode(for: signStrData, using: key)
            let signatureHex = Data(signature).map { String(format: "%02hhx", $0) }.joined()

            let urlString = "https://api.bybit.com\(endpoint)?\(queryParams)"
            guard let url = URL(string: urlString) else {
                print("DEBUG: Invalid Bybit balance URL: \(urlString)")
                completion(nil)
                return
            }

            var request = URLRequest(url: url)
            request.httpMethod = "GET"
            request.addValue(apiKey, forHTTPHeaderField: "X-BAPI-API-KEY")
            request.addValue(timestamp, forHTTPHeaderField: "X-BAPI-TIMESTAMP")
            request.addValue(recvWindow, forHTTPHeaderField: "X-BAPI-RECV-WINDOW")
            request.addValue(signatureHex, forHTTPHeaderField: "X-BAPI-SIGN")
            request.addValue("application/json", forHTTPHeaderField: "Content-Type")
            request.timeoutInterval = 10.0

            URLSession.shared.dataTask(with: request) { data, response, error in
                if let error = error {
                    print("DEBUG: Bybit balance fetch failed with error: \(error.localizedDescription)")
                    retryCount += 1
                    if retryCount < maxRetries {
                        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2, Double(retryCount))) {
                            attemptFetch()
                        }
                    } else {
                        print("DEBUG: Bybit balance fetch failed after \(maxRetries) retries")
                        completion(nil)
                    }
                    return
                }
                guard let data = data else {
                    print("DEBUG: Bybit balance fetch failed: No data received")
                    retryCount += 1
                    if retryCount < maxRetries {
                        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2, Double(retryCount))) {
                            attemptFetch()
                        }
                    } else {
                        print("DEBUG: Bybit balance fetch failed after \(maxRetries) retries: No data")
                        completion(nil)
                    }
                    return
                }
                if let rawResponse = String(data: data, encoding: .utf8) {
                    print("DEBUG: Bybit balance raw response: \(rawResponse)")
                } else {
                    print("DEBUG: Failed to decode Bybit balance response as UTF-8")
                }
                guard let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] else {
                    print("DEBUG: Bybit balance fetch failed: Invalid JSON response")
                    retryCount += 1
                    if retryCount < maxRetries {
                        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2, Double(retryCount))) {
                            attemptFetch()
                        }
                    } else {
                        print("DEBUG: Bybit balance fetch failed after \(maxRetries) retries: Invalid JSON")
                        completion(nil)
                    }
                    return
                }
                if let retCode = json["retCode"] as? Int, retCode != 0 {
                    print("DEBUG: Bybit balance fetch failed with retCode: \(retCode), retMsg: \(json["retMsg"] as? String ?? "Unknown error")")
                    retryCount += 1
                    if retryCount < maxRetries {
                        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2, Double(retryCount))) {
                            attemptFetch()
                        }
                    } else {
                        print("DEBUG: Bybit balance fetch failed after \(maxRetries) retries: Error code \(retCode)")
                        completion(nil)
                    }
                    return
                }
                if let result = json["result"] as? [String: Any],
                   let list = result["list"] as? [[String: Any]],
                   let account = list.first,
                   let coinArray = account["coin"] as? [[String: Any]] {
                    let usdtCoin = coinArray.first { $0["coin"] as? String == "USDT" }
                    if let usdtBalanceStr = usdtCoin?["walletBalance"] as? String,
                       let usdtBalance = Double(usdtBalanceStr) {
                        print("DEBUG: Bybit Balance Fetch Successful: \(usdtBalance) USDT")
                        completion(usdtBalance)
                    } else {
                        print("DEBUG: No USDT balance found in Bybit response")
                        completion(0.0)
                    }
                } else {
                    print("DEBUG: Bybit balance fetch failed: Could not parse wallet balance, response: \(json)")
                    retryCount += 1
                    if retryCount < maxRetries {
                        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2, Double(retryCount))) {
                            attemptFetch()
                        }
                    } else {
                        print("DEBUG: Bybit balance fetch failed after \(maxRetries) retries: Parsing error")
                        completion(nil)
                    }
                }
            }.resume()
        }
        attemptFetch()
    }

    static func fetchKucoinBalance(completion: @escaping (Double?) -> Void) {
        let maxRetries = 3
        var retryCount = 0

        func attemptFetch() {
            let timestamp = String(Int(Date().timeIntervalSince1970 * 1000))
            let apiKey = environment["KUCOIN_API_KEY"] ?? ""
            let apiSecret = environment["KUCOIN_API_SECRET"] ?? ""
            let apiPassphrase = environment["KUCOIN_PASSPHRASE"] ?? ""
            let endpoint = "/api/v1/accounts"
            let method = "GET"
            let strToSign = timestamp + method + endpoint

            guard !apiKey.isEmpty, !apiSecret.isEmpty, !apiPassphrase.isEmpty else {
                print("DEBUG: KuCoin API key, secret, or passphrase missing in .env")
                completion(nil)
                return
            }

            guard let secretData = apiSecret.data(using: .utf8),
                  let strToSignData = strToSign.data(using: .utf8),
                  let passphraseData = apiPassphrase.data(using: .utf8) else {
                print("DEBUG: Failed to encode API secret, sign string, or passphrase for KuCoin balance")
                completion(nil)
                return
            }
            let key = SymmetricKey(data: secretData)
            let signature = HMAC<SHA256>.authenticationCode(for: strToSignData, using: key)
            let signatureBase64 = Data(signature).base64EncodedString()
            let passphraseSignature = HMAC<SHA256>.authenticationCode(for: passphraseData, using: key)
            let passphraseBase64 = Data(passphraseSignature).base64EncodedString()

            let url = URL(string: "https://api.kucoin.com\(endpoint)")!
            var request = URLRequest(url: url)
            request.httpMethod = "GET"
            request.addValue(apiKey, forHTTPHeaderField: "KC-API-KEY")
            request.addValue(timestamp, forHTTPHeaderField: "KC-API-TIMESTAMP")
            request.addValue(signatureBase64, forHTTPHeaderField: "KC-API-SIGN")
            request.addValue(passphraseBase64, forHTTPHeaderField: "KC-API-PASSPHRASE")
            request.addValue("2", forHTTPHeaderField: "KC-API-KEY-VERSION")
            request.addValue("application/json", forHTTPHeaderField: "Content-Type")
            request.timeoutInterval = 10.0

            URLSession.shared.dataTask(with: request) { data, response, error in
                if let error = error {
                    print("DEBUG: KuCoin balance fetch failed with error: \(error.localizedDescription)")
                    retryCount += 1
                    if retryCount < maxRetries {
                        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2, Double(retryCount))) {
                            attemptFetch()
                        }
                    } else {
                        print("DEBUG: KuCoin balance fetch failed after \(maxRetries) retries")
                        completion(nil)
                    }
                    return
                }
                guard let data = data else {
                    print("DEBUG: KuCoin balance fetch failed: No data received")
                    retryCount += 1
                    if retryCount < maxRetries {
                        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2, Double(retryCount))) {
                            attemptFetch()
                        }
                    } else {
                        print("DEBUG: KuCoin balance fetch failed after \(maxRetries) retries: No data")
                        completion(nil)
                    }
                    return
                }
                if let rawResponse = String(data: data, encoding: .utf8) {
                    print("DEBUG: KuCoin balance raw response: \(rawResponse)")
                } else {
                    print("DEBUG: Failed to decode KuCoin balance response as UTF-8")
                }
                guard let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] else {
                    print("DEBUG: KuCoin balance fetch failed: Invalid JSON response")
                    retryCount += 1
                    if retryCount < maxRetries {
                        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2, Double(retryCount))) {
                            attemptFetch()
                        }
                    } else {
                        print("DEBUG: KuCoin balance fetch failed after \(maxRetries) retries: Invalid JSON")
                        completion(nil)
                    }
                    return
                }
                if let code = json["code"] as? String, code != "200000" {
                    print("DEBUG: KuCoin balance fetch failed with code: \(code), msg: \(json["msg"] as? String ?? "Unknown error")")
                    retryCount += 1
                    if retryCount < maxRetries {
                        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2, Double(retryCount))) {
                            attemptFetch()
                        }
                    } else {
                        print("DEBUG: KuCoin balance fetch failed after \(maxRetries) retries: Error code \(code)")
                        completion(nil)
                    }
                    return
                }
                if let dataArray = json["data"] as? [[String: Any]] {
                    let usdtAccounts = dataArray.filter { $0["currency"] as? String == "USDT" }
                    if usdtAccounts.isEmpty {
                        print("DEBUG: No USDT accounts found")
                        completion(0.0)
                        return
                    }
                    var totalUsdtBalance: Double = 0.0
                    for account in usdtAccounts {
                        if let balanceStr = account["balance"] as? String,
                           let balance = Double(balanceStr) {
                            totalUsdtBalance += balance
                        }
                    }
                    print("DEBUG: KuCoin Balance Fetch Successful: \(totalUsdtBalance) USDT")
                    completion(totalUsdtBalance)
                } else {
                    print("DEBUG: KuCoin balance fetch failed: Could not parse accounts data, response: \(json)")
                    retryCount += 1
                    if retryCount < maxRetries {
                        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2, Double(retryCount))) {
                            attemptFetch()
                        }
                    } else {
                        print("DEBUG: KuCoin balance fetch failed after \(maxRetries) retries: Parsing error")
                        completion(nil)
                    }
                }
            }.resume()
        }
        attemptFetch()
    }
}



//------------------------------------------------------------Block 4.4: Balance Fetching

extension ExchangeWebSocket {
    static func fetchKuCoinWsToken(completion: @escaping (String?) -> Void) {
        let url = URL(string: "https://api.kucoin.com/api/v1/bullet-public")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.timeoutInterval = 10.0

        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                print("DEBUG: Failed to fetch KuCoin WebSocket token: \(error.localizedDescription)")
                completion(nil)
                return
            }
            guard let data = data,
                  let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let dataDict = json["data"] as? [String: Any],
                  let token = dataDict["token"] as? String else {
                print("DEBUG: Failed to fetch KuCoin WebSocket token: Invalid response")
                completion(nil)
                return
            }
            completion(token)
        }
        task.resume()
    }

    static func fetchBybitServerTime(completion: @escaping (String?) -> Void) {
        let maxRetries = 3
        var retryCount = 0

        func attemptFetch() {
            let serverTimeUrl = URL(string: "https://api.bybit.com/v5/market/time")!
            var request = URLRequest(url: serverTimeUrl)
            request.timeoutInterval = 5.0

            URLSession.shared.dataTask(with: request) { data, response, error in
                if let error = error {
                    print("DEBUG: Failed to fetch Bybit server time: \(error.localizedDescription)")
                    retryCount += 1
                    if retryCount < maxRetries {
                        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2, Double(retryCount))) {
                            attemptFetch()
                        }
                    } else {
                        completion(nil)
                    }
                    return
                }
                guard let data = data else {
                    print("DEBUG: Failed to fetch Bybit server time: No data received")
                    retryCount += 1
                    if retryCount < maxRetries {
                        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2, Double(retryCount))) {
                            attemptFetch()
                        }
                    } else {
                        completion(nil)
                    }
                    return
                }
                guard let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                      let result = json["result"] as? [String: Any],
                      let serverTimestamp = result["timeNano"] as? String else {
                    print("DEBUG: Failed to parse Bybit server time response: Invalid JSON")
                    retryCount += 1
                    if retryCount < maxRetries {
                        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2, Double(retryCount))) {
                            attemptFetch()
                        }
                    } else {
                        completion(nil)
                    }
                    return
                }
                // Convert nanoseconds to milliseconds
                if let nano = Int64(serverTimestamp), nano > 0 {
                    let milli = String(nano / 1_000_000)
                    completion(milli)
                } else {
                    print("DEBUG: Invalid Bybit server timestamp: \(serverTimestamp)")
                    completion(nil)
                }
            }.resume()
        }
        attemptFetch()
    }

    static func fetchKucoinBalance(completion: @escaping () -> Void) {
        let maxRetries = 3
        var retryCount = 0

        func attemptFetch() {
            let timestamp = String(Int(Date().timeIntervalSince1970 * 1000))
            let apiKey = AppConfig.environment["KUCOIN_API_KEY"] ?? ""
            let apiSecret = AppConfig.environment["KUCOIN_API_SECRET"] ?? ""
            let apiPassphrase = AppConfig.environment["KUCOIN_PASSPHRASE"] ?? ""
            let endpoint = "/api/v1/accounts"
            let method = "GET"
            let strToSign = timestamp + method + endpoint

            guard !apiKey.isEmpty, !apiSecret.isEmpty, !apiPassphrase.isEmpty else {
                print("DEBUG: KuCoin API credentials missing - Key: \(apiKey.isEmpty ? "MISSING" : "FOUND"), Secret: \(apiSecret.isEmpty ? "MISSING" : "FOUND"), Passphrase: \(apiPassphrase.isEmpty ? "MISSING" : "FOUND")")
                completion()
                return
            }

            guard let secretData = apiSecret.data(using: .utf8),
                  let strToSignData = strToSign.data(using: .utf8),
                  let passphraseData = apiPassphrase.data(using: .utf8) else {
                print("DEBUG: Failed to encode KuCoin signature data")
                completion()
                return
            }
            let key = SymmetricKey(data: secretData)
            let signature = HMAC<SHA256>.authenticationCode(for: strToSignData, using: key)
            let signatureBase64 = Data(signature).base64EncodedString()
            let passphraseSignature = HMAC<SHA256>.authenticationCode(for: passphraseData, using: key)
            let passphraseBase64 = Data(passphraseSignature).base64EncodedString()

            let url = URL(string: "https://api.kucoin.com/api/v1/accounts")!
            var request = URLRequest(url: url)
            request.httpMethod = "GET"
            request.addValue(apiKey, forHTTPHeaderField: "KC-API-KEY")
            request.addValue(timestamp, forHTTPHeaderField: "KC-API-TIMESTAMP")
            request.addValue(signatureBase64, forHTTPHeaderField: "KC-API-SIGN")
            request.addValue(passphraseBase64, forHTTPHeaderField: "KC-API-PASSPHRASE")
            request.addValue("2", forHTTPHeaderField: "KC-API-KEY-VERSION")
            request.addValue("application/json", forHTTPHeaderField: "Content-Type")
            request.timeoutInterval = 10.0

            print("DEBUG: Sending KuCoin balance request with timestamp: \(timestamp)")

            URLSession.shared.dataTask(with: request) { data, response, error in
                if let error = error {
                    print("DEBUG: KuCoin balance fetch failed: \(error.localizedDescription)")
                    retryCount += 1
                    if retryCount < maxRetries {
                        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2, Double(retryCount))) {
                            attemptFetch()
                        }
                    } else {
                        print("DEBUG: KuCoin balance fetch failed after \(maxRetries) retries")
                        completion()
                    }
                    return
                }
                guard let httpResponse = response as? HTTPURLResponse else {
                    print("DEBUG: KuCoin balance fetch failed: Invalid HTTP response")
                    retryCount += 1
                    if retryCount < maxRetries {
                        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2, Double(retryCount))) {
                            attemptFetch()
                        }
                    } else {
                        completion()
                    }
                    return
                }
                print("DEBUG: KuCoin balance response status: \(httpResponse.statusCode)")
                guard httpResponse.statusCode == 200 else {
                    print("DEBUG: KuCoin balance fetch failed: HTTP status code \(httpResponse.statusCode)")
                    retryCount += 1
                    if retryCount < maxRetries {
                        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2, Double(retryCount))) {
                            attemptFetch()
                        }
                    } else {
                        completion()
                    }
                    return
                }
                guard let data = data,
                      let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                      let code = json["code"] as? String, code == "200000",
                      let dataArray = json["data"] as? [[String: Any]] else {
                    print("DEBUG: KuCoin balance fetch failed: Invalid response - \(String(data: data ?? Data(), encoding: .utf8) ?? "No data")")
                    retryCount += 1
                    if retryCount < maxRetries {
                        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2, Double(retryCount))) {
                            attemptFetch()
                        }
                    } else {
                        completion()
                    }
                    return
                }
                var balances = [String: Double]()
                var totalUsdtBalance: Double = 0.0
                for account in dataArray {
                    if let currency = account["currency"] as? String,
                       let balanceStr = account["balance"] as? String,
                       let balance = Double(balanceStr) {
                        balances[currency] = balance
                        if currency == "USDT" {
                            totalUsdtBalance += balance
                        }
                    }
                }
                DispatchQueue.main.async {
                    ExchangeWebSocket.kucoinBalances = balances
                    ExchangeWebSocket.kucoinBalance = totalUsdtBalance
                    print("DEBUG: Updated KuCoin balances: \(balances)")
                    completion()
                }
            }.resume()
        }
        attemptFetch()
    }

    static func fetchBybitBalance(completion: @escaping () -> Void) {
        fetchBybitServerTime { serverTimestamp in
            guard let serverTimestamp = serverTimestamp else {
                print("DEBUG: Failed to fetch Bybit server time, falling back to local timestamp")
                let localTimestamp = String(Int(Date().timeIntervalSince1970 * 1000))
                makeRequest(with: localTimestamp, completion: completion)
                return
            }
            makeRequest(with: serverTimestamp, completion: completion)
        }
    }

    private static func makeRequest(with timestamp: String, completion: @escaping () -> Void) {
        let maxRetries = 3
        var retryCount = 0

        func attemptFetch() {
            let apiKey = AppConfig.environment["BYBIT_API_KEY"] ?? ""
            let apiSecret = AppConfig.environment["BYBIT_API_SECRET"] ?? ""
            let recvWindow = "5000"
            let endpoint = "/v5/account/wallet-balance"

            guard !apiKey.isEmpty, !apiSecret.isEmpty else {
                print("DEBUG: Bybit API credentials missing - Key: \(apiKey.isEmpty ? "MISSING" : "FOUND"), Secret: \(apiSecret.isEmpty ? "MISSING" : "FOUND")")
                completion()
                return
            }

            // Construct query parameters
            let queryParamsDict = [
                "accountType": "UNIFIED",
                "timestamp": timestamp,
                "recvWindow": recvWindow
            ]
            let sortedKeys = queryParamsDict.keys.sorted()
            let queryParams = sortedKeys.map { "\($0)=\(queryParamsDict[$0]!)" }.joined(separator: "&")

            // Build signature message: timestamp + API key + recvWindow + queryParams
            let signatureMessage = "\(timestamp)\(apiKey)\(recvWindow)\(queryParams)"
            print("DEBUG: Bybit signature message: \(signatureMessage)")

            guard let messageData = signatureMessage.data(using: .utf8),
                  let keyData = apiSecret.data(using: .utf8) else {
                print("DEBUG: Failed to encode Bybit signature data")
                completion()
                return
            }
            let key = SymmetricKey(data: keyData)
            let signature = HMAC<SHA256>.authenticationCode(for: messageData, using: key)
            let signatureHex = signature.map { String(format: "%02x", $0) }.joined()

            // Build URL without `sign` parameter
            let urlString = "https://api.bybit.com\(endpoint)?\(queryParams)"
            guard let url = URL(string: urlString) else {
                print("DEBUG: Invalid Bybit URL: \(urlString)")
                completion()
                return
            }

            // Add signature to headers
            var request = URLRequest(url: url)
            request.httpMethod = "GET"
            request.addValue(apiKey, forHTTPHeaderField: "X-BAPI-API-KEY")
            request.addValue(timestamp, forHTTPHeaderField: "X-BAPI-TIMESTAMP")
            request.addValue(recvWindow, forHTTPHeaderField: "X-BAPI-RECV-WINDOW")
            request.addValue(signatureHex, forHTTPHeaderField: "X-BAPI-SIGN")
            request.addValue("application/json", forHTTPHeaderField: "Content-Type")
            request.addValue("application/json", forHTTPHeaderField: "Accept")
            request.timeoutInterval = 10.0

            print("DEBUG: Sending Bybit balance request - URL: \(urlString), Headers: X-BAPI-API-KEY=\(apiKey.prefix(8))..., X-BAPI-TIMESTAMP=\(timestamp), X-BAPI-RECV-WINDOW=\(recvWindow), X-BAPI-SIGN=\(signatureHex)")

            URLSession.shared.dataTask(with: request) { data, response, error in
                if let error = error {
                    print("DEBUG: Bybit balance fetch failed: \(error.localizedDescription)")
                    retryCount += 1
                    if retryCount < maxRetries {
                        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2, Double(retryCount))) {
                            attemptFetch()
                        }
                    } else {
                        print("DEBUG: Bybit balance fetch failed after \(maxRetries) retries")
                        completion()
                    }
                    return
                }
                guard let httpResponse = response as? HTTPURLResponse else {
                    print("DEBUG: Bybit balance fetch failed: Invalid HTTP response")
                    retryCount += 1
                    if retryCount < maxRetries {
                        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2, Double(retryCount))) {
                            attemptFetch()
                        }
                    } else {
                        completion()
                    }
                    return
                }
                print("DEBUG: Bybit balance response status: \(httpResponse.statusCode)")
                guard httpResponse.statusCode == 200 else {
                    print("DEBUG: Bybit balance fetch failed: HTTP status code \(httpResponse.statusCode)")
                    retryCount += 1
                    if retryCount < maxRetries {
                        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2, Double(retryCount))) {
                            attemptFetch()
                        }
                    } else {
                        completion()
                    }
                    return
                }
                guard let data = data,
                      let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] else {
                    print("DEBUG: Bybit balance fetch failed: Invalid response - \(String(data: data ?? Data(), encoding: .utf8) ?? "No data")")
                    retryCount += 1
                    if retryCount < maxRetries {
                        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2, Double(retryCount))) {
                            attemptFetch()
                        }
                    } else {
                        completion()
                    }
                    return
                }
                guard let retCode = json["retCode"] as? Int else {
                    print("DEBUG: Bybit balance fetch failed: Missing retCode in response - \(json)")
                    retryCount += 1
                    if retryCount < maxRetries {
                        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2, Double(retryCount))) {
                            attemptFetch()
                        }
                    } else {
                        completion()
                    }
                    return
                }
                if retCode != 0 {
                    if let retMsg = json["retMsg"] as? String, retMsg.contains("apiKey") || retMsg.contains("apiTimestamp") {
                        print("DEBUG: Bybit balance fetch failed: API key or timestamp issue - \(json)")
                        print("ACTION REQUIRED: Verify Bybit API key permissions (needs 'Wallet' read access) and ensure API key/secret are correct in .env")
                        print("ACTION REQUIRED: Ensure system clock is synchronized with an NTP server (e.g., on macOS: System Settings > Date & Time > 'Set date and time automatically')")
                    } else {
                        print("DEBUG: Bybit balance fetch failed: Invalid response - \(json)")
                    }
                    retryCount += 1
                    if retryCount < maxRetries {
                        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2, Double(retryCount))) {
                            attemptFetch()
                        }
                    } else {
                        completion()
                    }
                    return
                }
                guard let result = json["result"] as? [String: Any],
                      let list = result["list"] as? [[String: Any]] else {
                    print("DEBUG: Bybit balance fetch failed: Missing result/list in response - \(json)")
                    retryCount += 1
                    if retryCount < maxRetries {
                        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2, Double(retryCount))) {
                            attemptFetch()
                        }
                    } else {
                        completion()
                    }
                    return
                }
                var balances = [String: Double]()
                var totalUsdtBalance: Double = 0.0
                for account in list {
                    guard let coinList = account["coin"] as? [[String: Any]] else { continue }
                    for coinDict in coinList {
                        if let coin = coinDict["coin"] as? String,
                           let walletBalanceStr = coinDict["walletBalance"] as? String,
                           let walletBalance = Double(walletBalanceStr) {
                            balances[coin] = walletBalance
                            if coin == "USDT" {
                                totalUsdtBalance += walletBalance
                            }
                        }
                    }
                }
                DispatchQueue.main.async {
                    ExchangeWebSocket.bybitBalances = balances
                    ExchangeWebSocket.bybitBalance = totalUsdtBalance
                    print("DEBUG: Updated Bybit balances: \(balances)")
                    completion()
                }
            }.resume()
        }
        attemptFetch()
    }

    static func placeBybitSpotOrder(symbol: String, side: String, qty: Double, price: Double, completion: @escaping (Bool) -> Void) {
        print("Simulating Bybit spot order: \(side) \(qty) \(symbol) at \(price)")
        completion(true)
    }

    static func placeKucoinSpotOrder(symbol: String, side: String, qty: Double, price: Double, completion: @escaping (Bool) -> Void) {
        print("Simulating KuCoin spot order: \(side) \(qty) \(symbol) at \(price)")
        completion(true)
    }

    static func placeBybitFuturesOrder(symbol: String, side: String, qty: Double, price: Double, completion: @escaping (Bool) -> Void) {
        print("Simulating Bybit futures order: \(side) \(qty) \(symbol) at \(price)")
        completion(true)
    }

    static func placeKucoinFuturesOrder(symbol: String, side: String, qty: Double, price: Double, completion: @escaping (Bool) -> Void) {
        print("Simulating KuCoin futures order: \(side) \(qty) \(symbol) at \(price)")
        completion(true)
    }

    static func checkDailyLossLimit(exchange: String, potentialLoss: Double) -> Bool {
        let calendar = Calendar.current
        let now = Date()
        if let resetDate = calendar.date(byAdding: .day, value: 1, to: ExchangeWebSocket.lastDailyReset),
           now >= resetDate {
            ExchangeWebSocket.dailyLoss["bybit"] = 0.0
            ExchangeWebSocket.dailyLoss["kucoin"] = 0.0
            ExchangeWebSocket.lastDailyReset = now
            print("Daily loss reset for \(exchange)")
        }

        let currentBalance = exchange == "bybit" ? ExchangeWebSocket.bybitBalance : ExchangeWebSocket.kucoinBalance
        let currentLoss = ExchangeWebSocket.dailyLoss[exchange] ?? 0.0
        let newLoss = currentLoss + potentialLoss
        let lossPercentage = newLoss / currentBalance

        if lossPercentage > ExchangeWebSocket.dailyLossLimitPercentage {
            print("\(exchange) daily loss limit exceeded: \(lossPercentage * 100)% > \(ExchangeWebSocket.dailyLossLimitPercentage * 100)%")
            return false
        }

        ExchangeWebSocket.dailyLoss[exchange] = newLoss
        print("\(exchange) updated daily loss: \(newLoss), percentage: \(lossPercentage * 100)%")
        return true
    }

    static func executeSpotTrade(exchange: String, pair: String, side: String, amount: Double, price: Double, completion: @escaping (Bool) -> Void) {
        let balances = exchange == "bybit" ? bybitBalances : kucoinBalances
        let asset = pair.components(separatedBy: "-")[0] // e.g., "BTC" from "BTC-USDT"

        // Balance checks
        if side == "buy" {
            guard let usdtBalance = balances["USDT"], usdtBalance >= amount * price else {
                print("\(exchange) insufficient USDT balance for spot buy: \(balances["USDT"] ?? 0) < \(amount * price)")
                completion(false)
                return
            }
        } else { // sell
            guard let assetBalance = balances[asset], assetBalance >= amount else {
                print("\(exchange) insufficient \(asset) balance for spot sell: \(balances[asset] ?? 0) < \(amount)")
                completion(false)
                return
            }
        }

        if exchange == "bybit" {
            placeBybitSpotOrder(symbol: pair, side: side, qty: amount, price: price) { success in
                if success {
                    print("\(exchange) spot \(side) order executed for \(pair) at \(price)")
                    if side == "buy" {
                        bybitInSpotTrade[pair] = true
                        bybitSpotEntryPrice[pair] = price
                        activeSpotTrades[pair, default: 0] += 1
                    } else {
                        bybitInSpotTrade[pair] = false
                        bybitSpotEntryPrice[pair] = nil
                        activeSpotTrades[pair, default: 0] -= 1
                    }
                }
                completion(success)
            }
        } else {
            placeKucoinSpotOrder(symbol: pair, side: side, qty: amount, price: price) { success in
                if success {
                    print("\(exchange) spot \(side) order executed for \(pair) at \(price)")
                    if side == "buy" {
                        kucoinInSpotTrade[pair] = true
                        kucoinSpotEntryPrice[pair] = price
                        activeSpotTrades[pair, default: 0] += 1
                    } else {
                        kucoinInSpotTrade[pair] = false
                        kucoinSpotEntryPrice[pair] = nil
                        activeSpotTrades[pair, default: 0] -= 1
                    }
                }
                completion(success)
            }
        }
    }

    static func executeFuturesTrade(exchange: String, pair: String, side: String, amount: Double, price: Double, completion: @escaping (Bool) -> Void) {
        let balances = exchange == "bybit" ? bybitBalances : kucoinBalances

        // For futures, assume sufficient USDT margin in simulation mode
        guard let usdtBalance = balances["USDT"], usdtBalance >= amount else {
            print("\(exchange) insufficient USDT balance for futures \(side): \(balances["USDT"] ?? 0) < \(amount)")
            completion(false)
            return
        }

        if exchange == "bybit" {
            let futuresSymbol = pair.replacingOccurrences(of: "-USDT", with: "USDT")
            placeBybitFuturesOrder(symbol: futuresSymbol, side: side, qty: amount, price: price) { success in
                if success {
                    print("\(exchange) futures \(side) order executed for \(pair) at \(price)")
                    if side == "buy" {
                        bybitFuturesEntryPrice[pair] = price
                    } else {
                        bybitFuturesEntryPrice[pair] = nil
                    }
                }
                completion(success)
            }
        } else {
            let futuresSymbol = kucoinFuturesSymbols[pair] ?? (pair + "M")
            placeKucoinFuturesOrder(symbol: futuresSymbol, side: side, qty: amount, price: price) { success in
                if success {
                    print("\(exchange) futures \(side) order executed for \(pair) at \(price)")
                    if side == "buy" {
                        kucoinFuturesEntryPrice[pair] = price
                    } else {
                        kucoinFuturesEntryPrice[pair] = nil
                    }
                }
                completion(success)
            }
        }
    }
}


//------------------------------------------------------------Block 4.5.2: Spot and Futures Trade Management

extension ExchangeWebSocket {
    static func manageSpotTrades() {
        for pair in tradingPairs {
            let kucoinPrice = kucoinCurrentPrice[pair] ?? 0.0
            let bybitPrice = bybitCurrentPrice[pair] ?? 0.0
            guard kucoinPrice > 0, bybitPrice > 0 else { continue }

            // KuCoin Spot Trade Management
            if let entryPrice = kucoinSpotEntryPrice[pair], kucoinInSpotTrade[pair] == true {
                let profitPercentage = (kucoinPrice - entryPrice) / entryPrice
                let stopLossPrice = entryPrice * (1 - spotStopLossPercentage)
                let trailingStopPrice = kucoinSpotTrailingStop[pair] ?? (entryPrice * (1 + spotTrailingStopPercentage))

                if kucoinPrice <= stopLossPrice {
                    executeSpotTrade(exchange: "kucoin", pair: pair, side: "sell", amount: spotTradeAmount, price: kucoinPrice) { success in
                        if success {
                            print("KuCoin spot stop loss triggered for \(pair) at \(kucoinPrice)")
                        }
                    }
                } else if profitPercentage >= spotMinProfitPercentage || kucoinPrice >= trailingStopPrice {
                    executeSpotTrade(exchange: "kucoin", pair: pair, side: "sell", amount: spotTradeAmount, price: kucoinPrice) { success in
                        if success {
                            print("KuCoin spot profit taken for \(pair) at \(kucoinPrice), profit: \(profitPercentage * 100)%")
                        }
                    }
                } else {
                    kucoinSpotTrailingStop[pair] = max(trailingStopPrice, kucoinPrice * (1 - spotTrailingStopPercentage))
                }
            } else if activeSpotTrades[pair, default: 0] < maxActiveSpotTrades {
                let prices = kucoinPrices[pair] ?? []
                guard prices.count >= spotEmaLongPeriod else { continue }
                let shortEMA = calculateEMA(prices: prices.suffix(spotEmaShortPeriod), period: spotEmaShortPeriod)
                let mediumEMA = calculateEMA(prices: prices.suffix(spotEmaMediumPeriod), period: spotEmaMediumPeriod)
                let rsi = calculateRSI(prices: prices, period: spotRsiPeriod)
                if let shortEMA = shortEMA, let mediumEMA = mediumEMA, let rsi = rsi,
                   shortEMA > mediumEMA, rsi < spotRsiLowerThreshold {
                    executeSpotTrade(exchange: "kucoin", pair: pair, side: "buy", amount: spotTradeAmount, price: kucoinPrice) { success in
                        if success {
                            print("KuCoin spot buy signal for \(pair) at \(kucoinPrice)")
                        }
                    }
                }
            }

            // Bybit Spot Trade Management
            if let entryPrice = bybitSpotEntryPrice[pair], bybitInSpotTrade[pair] == true {
                let profitPercentage = (bybitPrice - entryPrice) / entryPrice
                let stopLossPrice = entryPrice * (1 - spotStopLossPercentage)
                let trailingStopPrice = bybitSpotTrailingStop[pair] ?? (entryPrice * (1 + spotTrailingStopPercentage))

                if bybitPrice <= stopLossPrice {
                    executeSpotTrade(exchange: "bybit", pair: pair, side: "sell", amount: spotTradeAmount, price: bybitPrice) { success in
                        if success {
                            print("Bybit spot stop loss triggered for \(pair) at \(bybitPrice)")
                        }
                    }
                } else if profitPercentage >= spotMinProfitPercentage || bybitPrice >= trailingStopPrice {
                    executeSpotTrade(exchange: "bybit", pair: pair, side: "sell", amount: spotTradeAmount, price: bybitPrice) { success in
                        if success {
                            print("Bybit spot profit taken for \(pair) at \(bybitPrice), profit: \(profitPercentage * 100)%")
                        }
                    }
                } else {
                    bybitSpotTrailingStop[pair] = max(trailingStopPrice, bybitPrice * (1 - spotTrailingStopPercentage))
                }
            } else if activeSpotTrades[pair, default: 0] < maxActiveSpotTrades {
                let prices = bybitPrices[pair] ?? []
                guard prices.count >= spotEmaLongPeriod else { continue }
                let shortEMA = calculateEMA(prices: prices.suffix(spotEmaShortPeriod), period: spotEmaShortPeriod)
                let mediumEMA = calculateEMA(prices: prices.suffix(spotEmaMediumPeriod), period: spotEmaMediumPeriod)
                let rsi = calculateRSI(prices: prices, period: spotRsiPeriod)
                if let shortEMA = shortEMA, let mediumEMA = mediumEMA, let rsi = rsi,
                   shortEMA > mediumEMA, rsi < spotRsiLowerThreshold {
                    executeSpotTrade(exchange: "bybit", pair: pair, side: "buy", amount: spotTradeAmount, price: bybitPrice) { success in
                        if success {
                            print("Bybit spot buy signal for \(pair) at \(bybitPrice)")
                        }
                    }
                }
            }
        }
    }

    static func manageFuturesTrades() {
        for pair in tradingPairs {
            let kucoinPrice = kucoinCurrentFuturesPrice[pair] ?? 0.0
            let bybitPrice = bybitCurrentFuturesPrice[pair] ?? 0.0
            guard kucoinPrice > 0, bybitPrice > 0 else { continue }

            // KuCoin Futures Trade Management
            if let entryPrice = kucoinFuturesEntryPrice[pair] {
                let profitPercentage = (kucoinPrice - entryPrice) / entryPrice
                let stopLossPrice = entryPrice * (1 - futuresStopLossPercentage)
                if kucoinPrice <= stopLossPrice {
                    executeFuturesTrade(exchange: "kucoin", pair: pair, side: "sell", amount: futuresTradeAmount, price: kucoinPrice) { success in
                        if success {
                            print("KuCoin futures stop loss triggered for \(pair) at \(kucoinPrice)")
                        }
                    }
                } else if profitPercentage >= futuresMinProfitPercentage {
                    executeFuturesTrade(exchange: "kucoin", pair: pair, side: "sell", amount: futuresTradeAmount, price: kucoinPrice) { success in
                        if success {
                            print("KuCoin futures profit taken for \(pair) at \(kucoinPrice), profit: \(profitPercentage * 100)%")
                        }
                    }
                }
            } else {
                let prices = kucoinFuturesPrices[pair] ?? []
                guard prices.count >= futuresEmaLongPeriod else { continue }
                let shortEMA = calculateEMA(prices: prices.suffix(futuresEmaShortPeriod), period: futuresEmaShortPeriod)
                let mediumEMA = calculateEMA(prices: prices.suffix(futuresEmaMediumPeriod), period: futuresEmaMediumPeriod)
                if let shortEMA = shortEMA, let mediumEMA = mediumEMA, shortEMA > mediumEMA {
                    executeFuturesTrade(exchange: "kucoin", pair: pair, side: "buy", amount: futuresTradeAmount, price: kucoinPrice) { success in
                        if success {
                            print("KuCoin futures buy signal for \(pair) at \(kucoinPrice)")
                        }
                    }
                }
            }

            // Bybit Futures Trade Management
            if let entryPrice = bybitFuturesEntryPrice[pair] {
                let profitPercentage = (bybitPrice - entryPrice) / entryPrice
                let stopLossPrice = entryPrice * (1 - futuresStopLossPercentage)
                if bybitPrice <= stopLossPrice {
                    executeFuturesTrade(exchange: "bybit", pair: pair, side: "sell", amount: futuresTradeAmount, price: bybitPrice) { success in
                        if success {
                            print("Bybit futures stop loss triggered for \(pair) at \(bybitPrice)")
                        }
                    }
                } else if profitPercentage >= futuresMinProfitPercentage {
                    executeFuturesTrade(exchange: "bybit", pair: pair, side: "sell", amount: futuresTradeAmount, price: bybitPrice) { success in
                        if success {
                            print("Bybit futures profit taken for \(pair) at \(bybitPrice), profit: \(profitPercentage * 100)%")
                        }
                    }
                }
            } else {
                let prices = bybitFuturesPrices[pair] ?? []
                guard prices.count >= futuresEmaLongPeriod else { continue }
                let shortEMA = calculateEMA(prices: prices.suffix(futuresEmaShortPeriod), period: futuresEmaShortPeriod)
                let mediumEMA = calculateEMA(prices: prices.suffix(futuresEmaMediumPeriod), period: futuresEmaMediumPeriod)
                if let shortEMA = shortEMA, let mediumEMA = mediumEMA, shortEMA > mediumEMA {
                    executeFuturesTrade(exchange: "bybit", pair: pair, side: "buy", amount: futuresTradeAmount, price: bybitPrice) { success in
                        if success {
                            print("Bybit futures buy signal for \(pair) at \(bybitPrice)")
                        }
                    }
                }
            }
        }
    }
}



//------------------------------------------------------------Block 4.6: Arbitrage Functions
extension ExchangeWebSocket {
    static func checkArbitrageCooldown(pair: String) -> Bool {
        if let (executed, date) = arbitrageExecuted[pair], executed {
            let elapsed = Date().timeIntervalSince(date)
            if elapsed < volatilityPauseSeconds {
                print("Arbitrage cooldown active for \(pair), \(volatilityPauseSeconds - elapsed) seconds remaining")
                return false
            }
        }
        return true
    }

    static func checkCrossExchangeArbitrageCooldown(pair: String) -> Bool {
        if let (executed, date) = crossExchangeArbitrageExecuted[pair], executed {
            let elapsed = Date().timeIntervalSince(date)
            if elapsed < crossExchangeCooldownSeconds {
                print("Cross-exchange arbitrage cooldown active for \(pair), \(crossExchangeCooldownSeconds - elapsed) seconds remaining")
                return false
            }
        }
        return true
    }

    static func checkLiquidity(exchange: String, pair: String, amount: Double, side: String) -> Bool {
        let orderBook = exchange == "bybit" ? bybitFuturesOrderBook[pair] ?? [] : kucoinFuturesOrderBook[pair] ?? []
        let currentPrice = exchange == "bybit" ? bybitCurrentFuturesPrice[pair] ?? 0.0 : kucoinCurrentFuturesPrice[pair] ?? 0.0
        guard !orderBook.isEmpty, currentPrice > 0 else {
            print("No order book data or invalid price for \(exchange)-\(pair)")
            return false
        }

        let priceRange = currentPrice * orderBookPriceRange
        let minPrice = currentPrice - priceRange
        let maxPrice = currentPrice + priceRange

        var availableVolume: Double = 0.0
        for entry in orderBook {
            let price = entry.price
            if price >= minPrice && price <= maxPrice && entry.side == (side == "buy" ? "sell" : "buy") {
                availableVolume += entry.volume
            }
        }

        let requiredVolume = amount / currentPrice
        let hasEnoughLiquidity = availableVolume >= requiredVolume * liquidityDepthMultiplier

        if !hasEnoughLiquidity {
            print("Insufficient liquidity for \(exchange)-\(pair): Available volume \(availableVolume), required \(requiredVolume * liquidityDepthMultiplier)")
        }

        let buyVolume = orderBook.filter { $0.side == "buy" && $0.price >= minPrice && $0.price <= maxPrice }.reduce(0.0) { $0 + $1.volume }
        let sellVolume = orderBook.filter { $0.side == "sell" && $0.price >= minPrice && $0.price <= maxPrice }.reduce(0.0) { $0 + $1.volume }
        let imbalance = max(buyVolume, sellVolume) / max(min(buyVolume, sellVolume), 0.0001)
        let isBalanced = imbalance <= orderBookImbalanceThreshold

        if !isBalanced {
            print("Order book imbalance for \(exchange)-\(pair): Buy volume \(buyVolume), Sell volume \(sellVolume), Imbalance \(imbalance)")
        }

        return hasEnoughLiquidity && isBalanced
    }

    static func executeFuturesTrade(exchange: String, pair: String, side: String, amount: Double) -> Bool {
        guard checkLiquidity(exchange: exchange, pair: pair, amount: amount, side: side) else {
            print("\(exchange): Liquidity check failed for futures \(pair) \(side)")
            return false
        }

        guard !detectVolatilitySpike(exchange: exchange, pair: pair) else {
            print("\(exchange): Volatility spike detected for futures \(pair), skipping trade")
            return false
        }

        guard !checkVolumeAnomaly(exchange: exchange, pair: pair, marketType: "futures") else {
            print("\(exchange): Volume anomaly detected for futures \(pair), skipping trade")
            return false
        }

        let balance = exchange == "kucoin" ? kucoinBalance : bybitBalance
        guard balance >= amount else {
            print("\(exchange): Insufficient balance for futures \(pair): \(balance) < \(amount)")
            return false
        }

        let currentPrice = exchange == "kucoin" ? kucoinCurrentFuturesPrice[pair] ?? 0.0 : bybitCurrentFuturesPrice[pair] ?? 0.0
        guard currentPrice > 0 else {
            print("\(exchange): Invalid current futures price for \(pair)")
            return false
        }

        let potentialLoss = amount * futuresStopLossPercentage
        guard checkDailyLossLimit(exchange: exchange, potentialLoss: potentialLoss) else {
            print("\(exchange): Daily loss limit reached, cannot trade futures \(pair)")
            return false
        }

        print("\(exchange): [SIMULATION] Executing \(side) futures trade for \(pair) of \(amount) at \(currentPrice)")
        if exchange == "kucoin" {
            if side == "buy" {
                kucoinPositions[pair] = (kucoinPositions[pair] ?? 0.0) + amount
                kucoinFuturesEntryPrice[pair] = currentPrice
                kucoinBalance -= amount
            } else {
                kucoinPositions[pair] = (kucoinPositions[pair] ?? 0.0) - amount
                kucoinFuturesEntryPrice[pair] = nil
                kucoinBalance += amount * currentPrice * (1.0 - kucoinFuturesFeeRate)
            }
        } else {
            if side == "buy" {
                bybitPositions[pair] = (bybitPositions[pair] ?? 0.0) + amount
                bybitFuturesEntryPrice[pair] = currentPrice
                bybitBalance -= amount
            } else {
                bybitPositions[pair] = (bybitPositions[pair] ?? 0.0) - amount
                bybitFuturesEntryPrice[pair] = nil
                bybitBalance += amount * currentPrice * (1.0 - bybitFuturesFeeRate)
            }
        }

        print("\(exchange): [SIMULATION] \(side.capitalized) futures trade executed for \(pair), balance updated to \(exchange == "kucoin" ? kucoinBalance : bybitBalance)")
        return true
    }

    static func checkArbitrageOpportunity(pair: String) -> Bool {
        guard checkArbitrageCooldown(pair: pair),
              checkCrossExchangeArbitrageCooldown(pair: pair) else {
            return false
        }

        let kucoinSpotPrice = kucoinCurrentPrice[pair] ?? 0.0
        let kucoinFuturesPrice = kucoinCurrentFuturesPrice[pair] ?? 0.0
        let bybitSpotPrice = bybitCurrentPrice[pair] ?? 0.0
        let bybitFuturesPrice = bybitCurrentFuturesPrice[pair] ?? 0.0

        guard kucoinSpotPrice > 0, kucoinFuturesPrice > 0,
              bybitSpotPrice > 0, bybitFuturesPrice > 0 else {
            print("Invalid prices for arbitrage check on \(pair): KuCoin Spot=\(kucoinSpotPrice), Futures=\(kucoinFuturesPrice), Bybit Spot=\(bybitSpotPrice), Futures=\(bybitFuturesPrice)")
            return false
        }

        let kucoinFundingRate = kucoinFundingRates[pair] ?? 0.0
        let bybitFundingRate = bybitFundingRates[pair] ?? 0.0

        guard kucoinBalance >= arbitrageMinBalance,
              bybitBalance >= arbitrageMinBalance else {
            print("Insufficient balance for arbitrage: KuCoin \(kucoinBalance), Bybit \(bybitBalance)")
            return false
        }

        let kucoinSpread = abs(kucoinSpotPrice - kucoinFuturesPrice) / min(kucoinSpotPrice, kucoinFuturesPrice)
        let bybitSpread = abs(bybitSpotPrice - bybitFuturesPrice) / min(bybitSpotPrice, bybitFuturesPrice)

        let spotSpread = abs(kucoinSpotPrice - bybitSpotPrice) / min(kucoinSpotPrice, bybitSpotPrice)
        let futuresSpread = abs(kucoinFuturesPrice - bybitFuturesPrice) / min(kucoinFuturesPrice, bybitFuturesPrice)

        var executed = false

        if kucoinSpread >= arbitrageMinSpreadThreshold && kucoinFundingRate < maxFundingRate {
            let sideSpot = kucoinSpotPrice > kucoinFuturesPrice ? "sell" : "buy"
            let sideFutures = kucoinSpotPrice > kucoinFuturesPrice ? "buy" : "sell"

            executeSpotTrade(exchange: "kucoin", pair: pair, side: sideSpot, amount: arbitrageTradeAmount, price: kucoinSpotPrice) { spotSuccess in
                if spotSuccess {
                    let futuresSuccess = executeFuturesTrade(exchange: "kucoin", pair: pair, side: sideFutures, amount: arbitrageTradeAmount)
                    if futuresSuccess {
                        arbitrageExecuted[pair] = (true, Date())
                        print("[SIMULATION] KuCoin arbitrage executed for \(pair): \(sideSpot) spot at \(kucoinSpotPrice), \(sideFutures) futures at \(kucoinFuturesPrice), spread: \(kucoinSpread * 100)%")
                        executed = true
                    }
                }
            }
        }

        if bybitSpread >= arbitrageMinSpreadThreshold && bybitFundingRate < maxFundingRate {
            let sideSpot = bybitSpotPrice > bybitFuturesPrice ? "sell" : "buy"
            let sideFutures = bybitSpotPrice > bybitFuturesPrice ? "buy" : "sell"

            executeSpotTrade(exchange: "bybit", pair: pair, side: sideSpot, amount: arbitrageTradeAmount, price: bybitSpotPrice) { spotSuccess in
                if spotSuccess {
                    let futuresSuccess = executeFuturesTrade(exchange: "bybit", pair: pair, side: sideFutures, amount: arbitrageTradeAmount)
                    if futuresSuccess {
                        arbitrageExecuted[pair] = (true, Date())
                        print("[SIMULATION] Bybit arbitrage executed for \(pair): \(sideSpot) spot at \(bybitSpotPrice), \(sideFutures) futures at \(bybitFuturesPrice), spread: \(bybitSpread * 100)%")
                        executed = true
                    }
                }
            }
        }

        if (spotSpread >= crossExchangeMinSpreadThreshold || futuresSpread >= crossExchangeMinSpreadThreshold) && abs(kucoinFundingRate - bybitFundingRate) >= crossExchangeMinFundingRateThreshold {
            let spotExchange = kucoinSpotPrice > bybitSpotPrice ? "kucoin" : "bybit"
            let futuresExchange = kucoinFuturesPrice < bybitFuturesPrice ? "kucoin" : "bybit"

            let spotSide = spotExchange == "kucoin" ? "sell" : "buy"
            let futuresSide = futuresExchange == "kucoin" ? "buy" : "sell"

            executeSpotTrade(exchange: spotExchange, pair: pair, side: spotSide, amount: crossExchangeTradeAmount, price: spotExchange == "kucoin" ? kucoinSpotPrice : bybitSpotPrice) { spotSuccess in
                if spotSuccess {
                    let futuresSuccess = executeFuturesTrade(exchange: futuresExchange, pair: pair, side: futuresSide, amount: crossExchangeTradeAmount)
                    if futuresSuccess {
                        crossExchangeArbitrageExecuted[pair] = (true, Date())
                        print("[SIMULATION] Cross-exchange arbitrage executed for \(pair): \(spotSide) spot on \(spotExchange) at \(spotExchange == "kucoin" ? kucoinSpotPrice : bybitSpotPrice), \(futuresSide) futures on \(futuresExchange) at \(futuresExchange == "kucoin" ? kucoinFuturesPrice : bybitFuturesPrice)")
                        executed = true
                    }
                }
            }
        }

        return executed
    }

    static func executeSingleExchangeArbitrage() {
        for pair in tradingPairs {
            let _ = checkArbitrageOpportunity(pair: pair)
        }
    }

    static func executeCrossExchangeArbitrage() {
        for pair in tradingPairs {
            let _ = checkArbitrageOpportunity(pair: pair)
        }
    }
}

//------------------------------------------------------------Block 4.9: WebSocket Delegates
// Block 4.9: WebSocket Delegates
class KucoinWebSocketDelegate: WebSocketDelegate {
    func didReceive(event: WebSocketEvent, client: WebSocketClient) {
        Task { @MainActor in
            switch event {
            case .connected(let headers):
                print("KuCoin WebSocket connected with headers: \(headers)")
                ExchangeWebSocket.kucoinIsConnected = true
            case .disconnected(let reason, let code):
                print("KuCoin WebSocket disconnected: \(reason), code: \(code)")
                ExchangeWebSocket.kucoinIsConnected = false
            case .text(let string):
                print("Received from KuCoin WS: \(string)")
                if let data = string.data(using: .utf8),
                   let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                    if let type = json["type"] as? String, type == "message",
                       let topic = json["topic"] as? String,
                       let dataDict = json["data"] as? [String: Any] {
                        // Try multiple price fields: price, bestAsk, last
                        let priceStr = dataDict["price"] as? String ?? dataDict["bestAsk"] as? String ?? dataDict["last"] as? String
                        guard let priceStr = priceStr, let price = Double(priceStr) else {
                            print("Failed to parse price from KuCoin Spot message: \(dataDict)")
                            return
                        }
                        let pair = topic.components(separatedBy: ":").last ?? ""
                        ExchangeWebSocket.kucoinCurrentPrice[pair] = price
                        ExchangeWebSocket.kucoinPrices[pair, default: []].append(price)
                        if ExchangeWebSocket.kucoinPrices[pair]!.count > ExchangeWebSocket.priceHistoryRetention {
                            ExchangeWebSocket.kucoinPrices[pair]!.removeFirst()
                        }
                        let volStr = dataDict["vol"] as? String ?? dataDict["volume"] as? String
                        if let volStr = volStr, let vol = Double(volStr) {
                            ExchangeWebSocket.kucoinSpotVolume[pair, default: []].append(vol)
                            if ExchangeWebSocket.kucoinSpotVolume[pair]!.count > ExchangeWebSocket.priceHistoryRetention {
                                ExchangeWebSocket.kucoinSpotVolume[pair]!.removeFirst()
                            }
                        }
                        print("Updated KuCoin spot price for \(pair): \(price)")
                    }
                }
            case .error(let error):
                print("KuCoin WebSocket error: \(error?.localizedDescription ?? "Unknown error")")
                ExchangeWebSocket.kucoinIsConnected = false
            case .pong(_):
                print("DEBUG: KuCoin WebSocket received pong")
            default:
                break
            }
        }
    }
}

class KucoinFuturesWebSocketDelegate: WebSocketDelegate {
    func didReceive(event: WebSocketEvent, client: WebSocketClient) {
        Task { @MainActor in
            switch event {
            case .connected(let headers):
                print("KuCoin Futures WebSocket connected with headers: \(headers)")
                ExchangeWebSocket.kucoinFuturesIsConnected = true
            case .disconnected(let reason, let code):
                print("KuCoin Futures WebSocket disconnected: \(reason), code: \(code)")
                ExchangeWebSocket.kucoinFuturesIsConnected = false
            case .text(let string):
                print("Received from KuCoin Futures WS: \(string)")
                if let data = string.data(using: .utf8),
                   let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                    if let type = json["type"] as? String, type == "message",
                       let topic = json["topic"] as? String {
                        if topic.hasPrefix("/contractMarket/tickerV2:"),
                           let dataDict = json["data"] as? [String: Any] {
                            // Try multiple price fields: bestAskPrice, price, lastPrice
                            let priceStr = dataDict["bestAskPrice"] as? String ?? dataDict["price"] as? String ?? dataDict["lastPrice"] as? String
                            guard let priceStr = priceStr, let price = Double(priceStr) else {
                                print("Failed to parse price from KuCoin Futures message: \(dataDict)")
                                return
                            }
                            let futuresSymbol = topic.components(separatedBy: ":").last ?? ""
                            guard let pair = ExchangeWebSocket.kucoinFuturesSymbols.first(where: { $0.value == futuresSymbol })?.key else {
                                print("No pair found for futures symbol: \(futuresSymbol)")
                                return
                            }
                            ExchangeWebSocket.kucoinCurrentFuturesPrice[pair] = price
                            ExchangeWebSocket.kucoinFuturesPrices[pair, default: []].append(price)
                            if ExchangeWebSocket.kucoinFuturesPrices[pair]!.count > ExchangeWebSocket.priceHistoryRetention {
                                ExchangeWebSocket.kucoinFuturesPrices[pair]!.removeFirst()
                            }
                            let volStr = dataDict["vol"] as? String ?? dataDict["volume"] as? String
                            if let volStr = volStr, let vol = Double(volStr) {
                                ExchangeWebSocket.kucoinFuturesVolume[pair, default: []].append(vol)
                                if ExchangeWebSocket.kucoinFuturesVolume[pair]!.count > ExchangeWebSocket.priceHistoryRetention {
                                    ExchangeWebSocket.kucoinFuturesVolume[pair]!.removeFirst()
                                }
                            }
                            print("Updated KuCoin futures price for \(pair): \(price)")
                        } else if topic.hasPrefix("/contractMarket/level2:"),
                                  let dataDict = json["data"] as? [String: Any],
                                  let asks = dataDict["asks"] as? [[String]],
                                  let bids = dataDict["bids"] as? [[String]],
                                  let futuresSymbol = topic.components(separatedBy: ":").last,
                                  let pair = ExchangeWebSocket.kucoinFuturesSymbols.first(where: { $0.value == futuresSymbol })?.key {
                            var orderBook: [(price: Double, volume: Double, side: String)] = []
                            for ask in asks {
                                if let priceStr = ask.first, let volStr = ask.last,
                                   let price = Double(priceStr), let vol = Double(volStr) {
                                    orderBook.append((price: price, volume: vol, side: "sell"))
                                }
                            }
                            for bid in bids {
                                if let priceStr = bid.first, let volStr = bid.last,
                                   let price = Double(priceStr), let vol = Double(volStr) {
                                    orderBook.append((price: price, volume: vol, side: "buy"))
                                }
                            }
                            ExchangeWebSocket.kucoinFuturesOrderBook[pair] = orderBook
                            print("Updated KuCoin futures order book for \(pair)")
                        } else if topic.hasPrefix("/contract/instrument:"),
                                  let dataDict = json["data"] as? [String: Any],
                                  let fundingRateStr = dataDict["fundingRate"] as? String,
                                  let fundingRate = Double(fundingRateStr),
                                  let futuresSymbol = topic.components(separatedBy: ":").last,
                                  let pair = ExchangeWebSocket.kucoinFuturesSymbols.first(where: { $0.value == futuresSymbol })?.key {
                            ExchangeWebSocket.kucoinFundingRates[pair] = fundingRate
                            print("Updated KuCoin funding rate for \(pair): \(fundingRate)")
                        }
                    }
                }
            case .error(let error):
                print("KuCoin Futures WebSocket error: \(error?.localizedDescription ?? "Unknown error")")
                ExchangeWebSocket.kucoinFuturesIsConnected = false
            case .pong(_):
                print("DEBUG: KuCoin Futures WebSocket received pong")
            default:
                break
            }
        }
    }
}

class BybitWebSocketDelegate: WebSocketDelegate {
    func didReceive(event: WebSocketEvent, client: WebSocketClient) {
        Task { @MainActor in
            switch event {
            case .connected(let headers):
                print("Bybit Spot WebSocket connected with headers: \(headers)")
                ExchangeWebSocket.bybitIsConnected = true
            case .disconnected(let reason, let code):
                print("Bybit Spot WebSocket disconnected: \(reason), code: \(code)")
                ExchangeWebSocket.bybitIsConnected = false
            case .text(let string):
                print("Received from Bybit Spot WS: \(string)")
                if let data = string.data(using: .utf8),
                   let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                    if let success = json["success"] as? Bool {
                        if success, let retMsg = json["ret_msg"] as? String, retMsg == "subscribe" {
                            print("Bybit Spot subscription confirmed")
                        } else if !success {
                            print("Bybit Spot WebSocket error: \(json)")
                        }
                    } else if let topic = json["topic"] as? String {
                        if topic.hasPrefix("tickers."),
                           let dataDict = json["data"] as? [String: Any],
                           let symbol = dataDict["symbol"] as? String {
                            // Try multiple price fields: lastPrice, last_price
                            let priceStr = dataDict["lastPrice"] as? String ?? dataDict["last_price"] as? String
                            guard let priceStr = priceStr, let price = Double(priceStr) else {
                                print("Failed to parse price from Bybit Spot message: \(dataDict)")
                                return
                            }
                            let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
                            ExchangeWebSocket.bybitCurrentPrice[pair] = price
                            ExchangeWebSocket.bybitPrices[pair, default: []].append(price)
                            if ExchangeWebSocket.bybitPrices[pair]!.count > ExchangeWebSocket.priceHistoryRetention {
                                ExchangeWebSocket.bybitPrices[pair]!.removeFirst()
                            }
                            let volStr = dataDict["volume24h"] as? String ?? dataDict["volume_24h"] as? String
                            if let volStr = volStr, let vol = Double(volStr) {
                                ExchangeWebSocket.bybitSpotVolume[pair, default: []].append(vol)
                                if ExchangeWebSocket.bybitSpotVolume[pair]!.count > ExchangeWebSocket.priceHistoryRetention {
                                    ExchangeWebSocket.bybitSpotVolume[pair]!.removeFirst()
                                }
                            }
                            print("Updated Bybit spot price for \(pair): \(price)")
                        } else if topic.hasPrefix("orderbook.50."),
                                  let dataDict = json["data"] as? [String: Any],
                                  let symbol = dataDict["s"] as? String,
                                  let asks = dataDict["a"] as? [[String]],
                                  let bids = dataDict["b"] as? [[String]] {
                            let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
                            var orderBook: [(price: Double, volume: Double, side: String)] = []
                            for ask in asks {
                                if let priceStr = ask.first, let volStr = ask.last,
                                   let price = Double(priceStr), let vol = Double(volStr) {
                                    orderBook.append((price: price, volume: vol, side: "sell"))
                                }
                            }
                            for bid in bids {
                                if let priceStr = bid.first, let volStr = bid.last,
                                   let price = Double(priceStr), let vol = Double(volStr) {
                                    orderBook.append((price: price, volume: vol, side: "buy"))
                                }
                            }
                            ExchangeWebSocket.bybitFuturesOrderBook[pair] = orderBook
                            print("Updated Bybit spot order book for \(pair)")
                        } else if topic.hasPrefix("publicTrade."),
                                  let dataArray = json["data"] as? [[String: Any]],
                                  let firstTrade = dataArray.first,
                                  let priceStr = firstTrade["p"] as? String,
                                  let price = Double(priceStr),
                                  let symbol = firstTrade["s"] as? String {
                            let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
                            ExchangeWebSocket.bybitCurrentPrice[pair] = price
                            ExchangeWebSocket.bybitPrices[pair, default: []].append(price)
                            if ExchangeWebSocket.bybitPrices[pair]!.count > ExchangeWebSocket.priceHistoryRetention {
                                ExchangeWebSocket.bybitPrices[pair]!.removeFirst()
                            }
                            print("Updated Bybit spot trade price for \(pair): \(price)")
                        }
                    }
                }
            case .error(let error):
                print("Bybit Spot WebSocket error: \(error?.localizedDescription ?? "Unknown error")")
                ExchangeWebSocket.bybitIsConnected = false
            case .pong(_):
                print("DEBUG: Bybit Spot WebSocket received pong")
            default:
                break
            }
        }
    }
}

class BybitFuturesWebSocketDelegate: WebSocketDelegate {
    func didReceive(event: WebSocketEvent, client: WebSocketClient) {
        Task { @MainActor in
            switch event {
            case .connected(let headers):
                print("Bybit Futures WebSocket connected with headers: \(headers)")
                ExchangeWebSocket.bybitIsConnected = true
            case .disconnected(let reason, let code):
                print("Bybit Futures WebSocket disconnected: \(reason), code: \(code)")
                ExchangeWebSocket.bybitIsConnected = false
            case .text(let string):
                print("Received from Bybit Futures WS: \(string)")
                if let data = string.data(using: .utf8),
                   let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                    if let success = json["success"] as? Bool {
                        if success, let retMsg = json["ret_msg"] as? String, retMsg == "subscribe" {
                            print("Bybit Futures subscription confirmed")
                        } else if !success {
                            print("Bybit Futures WebSocket error: \(json)")
                        }
                    } else if let topic = json["topic"] as? String {
                        if topic.hasPrefix("tickers."),
                           let dataDict = json["data"] as? [String: Any],
                           let symbol = dataDict["symbol"] as? String {
                            // Try multiple price fields: lastPrice, last_price
                            let priceStr = dataDict["lastPrice"] as? String ?? dataDict["last_price"] as? String
                            guard let priceStr = priceStr, let price = Double(priceStr) else {
                                print("Failed to parse price from Bybit Futures message: \(dataDict)")
                                return
                            }
                            let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
                            ExchangeWebSocket.bybitCurrentFuturesPrice[pair] = price
                            ExchangeWebSocket.bybitFuturesPrices[pair, default: []].append(price)
                            if ExchangeWebSocket.bybitFuturesPrices[pair]!.count > ExchangeWebSocket.priceHistoryRetention {
                                ExchangeWebSocket.bybitFuturesPrices[pair]!.removeFirst()
                            }
                            let volStr = dataDict["volume24h"] as? String ?? dataDict["volume_24h"] as? String
                            if let volStr = volStr, let vol = Double(volStr) {
                                ExchangeWebSocket.bybitFuturesVolume[pair, default: []].append(vol)
                                if ExchangeWebSocket.bybitFuturesVolume[pair]!.count > ExchangeWebSocket.priceHistoryRetention {
                                    ExchangeWebSocket.bybitFuturesVolume[pair]!.removeFirst()
                                }
                            }
                            let fundingRateStr = dataDict["fundingRate"] as? String ?? dataDict["funding_rate"] as? String
                            if let fundingRateStr = fundingRateStr, let fundingRate = Double(fundingRateStr) {
                                ExchangeWebSocket.bybitFundingRates[pair] = fundingRate
                                print("Updated Bybit funding rate for \(pair): \(fundingRate)")
                            }
                            print("Updated Bybit futures price for \(pair): \(price)")
                        } else if topic.hasPrefix("orderbook.50."),
                                  let dataDict = json["data"] as? [String: Any],
                                  let symbol = dataDict["s"] as? String,
                                  let asks = dataDict["a"] as? [[String]],
                                  let bids = dataDict["b"] as? [[String]] {
                            let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
                            var orderBook: [(price: Double, volume: Double, side: String)] = []
                            for ask in asks {
                                if let priceStr = ask.first, let volStr = ask.last,
                                   let price = Double(priceStr), let vol = Double(volStr) {
                                    orderBook.append((price: price, volume: vol, side: "sell"))
                                }
                            }
                            for bid in bids {
                                if let priceStr = bid.first, let volStr = bid.last,
                                   let price = Double(priceStr), let vol = Double(volStr) {
                                    orderBook.append((price: price, volume: vol, side: "buy"))
                                }
                            }
                            ExchangeWebSocket.bybitFuturesOrderBook[pair] = orderBook
                            print("Updated Bybit futures order book for \(pair)")
                        } else if topic.hasPrefix("publicTrade."),
                                  let dataArray = json["data"] as? [[String: Any]],
                                  let firstTrade = dataArray.first,
                                  let priceStr = firstTrade["p"] as? String,
                                  let price = Double(priceStr),
                                  let symbol = firstTrade["s"] as? String {
                            let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
                            ExchangeWebSocket.bybitCurrentFuturesPrice[pair] = price
                            ExchangeWebSocket.bybitFuturesPrices[pair, default: []].append(price)
                            if ExchangeWebSocket.bybitFuturesPrices[pair]!.count > ExchangeWebSocket.priceHistoryRetention {
                                ExchangeWebSocket.bybitFuturesPrices[pair]!.removeFirst()
                            }
                            print("Updated Bybit futures trade price for \(pair): \(price)")
                        }
                    }
                }
            case .error(let error):
                print("Bybit Futures WebSocket error: \(error?.localizedDescription ?? "Unknown error")")
                ExchangeWebSocket.bybitIsConnected = false
            case .pong(_):
                print("DEBUG: Bybit Futures WebSocket received pong")
            default:
                break
            }
        }
    }
}
//------------------------------------------------------------Block 4.7: WebSocket Connection Functions
// Block 4.7: WebSocket Connections
extension ExchangeWebSocket {
    @MainActor
    static func connectKucoin() {
        print("DEBUG: Attempting to connect to KuCoin WebSocket...")
        fetchKucionWsToken { token in
            guard let token = token else {
                print("Failed to fetch KuCoin WebSocket token, cannot connect. Retrying in 5 seconds...")
                DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                    connectKucoin()
                }
                return
            }
            kucoinToken = token
            let wsURLString = "wss://ws-api.kucoin.com/endpoint?token=\(token)&acceptUserMessage=true"
            guard let wsURL = URL(string: wsURLString) else {
                print("Invalid KuCoin WebSocket URL: \(wsURLString). Retrying in 5 seconds...")
                DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                    connectKucoin()
                }
                return
            }
            var request = URLRequest(url: wsURL)
            request.timeoutInterval = 10
            kucoinSocket = WebSocket(request: request)
            
            kucoinSocket?.onEvent = { event in
                Task { @MainActor in
                    switch event {
                    case .connected(let headers):
                        print("KuCoin WebSocket connected with headers: \(headers)")
                        kucoinIsConnected = true
                        for (index, pair) in tradingPairs.enumerated() {
                            let spotTopic = "/market/ticker:\(pair)"
                            let spotSubscribeMessage: [String: Any] = [
                                "id": Int(Date().timeIntervalSince1970 * 1000) + index,
                                "type": "subscribe",
                                "topic": spotTopic,
                                "privateChannel": false,
                                "response": true
                            ]
                            if let spotData = try? JSONSerialization.data(withJSONObject: spotSubscribeMessage),
                               let spotMessage = String(data: spotData, encoding: .utf8) {
                                kucoinSocket?.write(string: spotMessage)
                                print("Subscribed to KuCoin spot topic: \(spotTopic)")
                            }
                        }
                        Timer.scheduledTimer(withTimeInterval: 15.0, repeats: true) { _ in
                            Task { @MainActor in
                                let pingMessage = "{\"id\": \"ping_\(Int(Date().timeIntervalSince1970))\", \"type\": \"ping\"}"
                                kucoinSocket?.write(string: pingMessage)
                                print("DEBUG: KuCoin WebSocket sent ping")
                            }
                        }
                    case .disconnected(let reason, let code):
                        print("KuCoin WebSocket disconnected: \(reason), code: \(code)")
                        kucoinIsConnected = false
                        DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                            connectKucoin()
                        }
                    case .text(let string):
                        print("Received from KuCoin WS: \(string)")
                        if let data = string.data(using: .utf8),
                           let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                            if let type = json["type"] as? String, type == "message",
                               let topic = json["topic"] as? String,
                               let dataDict = json["data"] as? [String: Any],
                               let priceStr = dataDict["price"] as? String,
                               let price = Double(priceStr) {
                                let pair = topic.components(separatedBy: ":").last ?? ""
                                kucoinCurrentPrice[pair] = price
                                kucoinPrices[pair, default: []].append(price)
                                if kucoinPrices[pair]!.count > priceHistoryRetention { kucoinPrices[pair]!.removeFirst() }
                                print("Updated KuCoin spot price for \(pair): \(price)")
                            }
                        }
                    case .error(let error):
                        print("KuCoin WebSocket error: \(error?.localizedDescription ?? "Unknown error")")
                        kucoinIsConnected = false
                        DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                            connectKucoin()
                        }
                    case .pong(_):
                        print("DEBUG: KuCoin WebSocket received pong")
                    default:
                        break
                    }
                }
            }
            kucoinSocket?.connect()
        }
    }

    @MainActor
    static func connectKucoinFutures() {
        print("DEBUG: Attempting to connect to KuCoin Futures WebSocket...")
        fetchKucoinFuturesWsToken { token in
            guard let token = token else {
                print("Failed to fetch KuCoin Futures WebSocket token, cannot connect. Retrying in 5 seconds...")
                DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                    connectKucoinFutures()
                }
                return
            }
            kucoinFuturesToken = token
            let connectId = UUID().uuidString
            let wsURLString = "wss://ws-api-futures.kucoin.com/?token=\(token)&connectId=\(connectId)"
            guard let wsURL = URL(string: wsURLString) else {
                print("Invalid KuCoin Futures WebSocket URL: \(wsURLString). Retrying in 5 seconds...")
                DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                    connectKucoinFutures()
                }
                return
            }
            var request = URLRequest(url: wsURL)
            request.timeoutInterval = 10
            kucoinFuturesSocket = WebSocket(request: request)
            
            kucoinFuturesSocket?.onEvent = { event in
                Task { @MainActor in
                    switch event {
                    case .connected(let headers):
                        print("KuCoin Futures WebSocket connected with headers: \(headers)")
                        kucoinFuturesIsConnected = true
                        for (index, pair) in tradingPairs.enumerated() {
                            if let futuresSymbol = kucoinFuturesSymbols[pair] {
                                let priceTopic = "/contractMarket/tickerV2:\(futuresSymbol)"
                                let priceSubscription: [String: Any] = [
                                    "id": Int(Date().timeIntervalSince1970 * 1000) + index,
                                    "type": "subscribe",
                                    "topic": priceTopic,
                                    "privateChannel": false,
                                    "response": true
                                ]
                                if let priceData = try? JSONSerialization.data(withJSONObject: priceSubscription),
                                   let priceMessage = String(data: priceData, encoding: .utf8) {
                                    kucoinFuturesSocket?.write(string: priceMessage)
                                    print("Subscribed to KuCoin Futures price topic: \(priceTopic)")
                                }
                                let orderBookTopic = "/contractMarket/level2:\(futuresSymbol)"
                                let orderBookSubscription: [String: Any] = [
                                    "id": Int(Date().timeIntervalSince1970 * 1000) + index + 2000,
                                    "type": "subscribe",
                                    "topic": orderBookTopic,
                                    "privateChannel": false,
                                    "response": true
                                ]
                                if let orderBookData = try? JSONSerialization.data(withJSONObject: orderBookSubscription),
                                   let orderBookMessage = String(data: orderBookData, encoding: .utf8) {
                                    kucoinFuturesSocket?.write(string: orderBookMessage)
                                    print("Subscribed to KuCoin Futures order book topic: \(orderBookTopic)")
                                }
                                let fundingTopic = "/contract/instrument:\(futuresSymbol)"
                                let fundingSubscription: [String: Any] = [
                                    "id": Int(Date().timeIntervalSince1970 * 1000) + index + 1000,
                                    "type": "subscribe",
                                    "topic": fundingTopic,
                                    "privateChannel": false,
                                    "response": true
                                ]
                                if let fundingData = try? JSONSerialization.data(withJSONObject: fundingSubscription),
                                   let fundingMessage = String(data: fundingData, encoding: .utf8) {
                                    kucoinFuturesSocket?.write(string: fundingMessage)
                                    print("Subscribed to KuCoin Futures funding rate topic: \(fundingTopic)")
                                }
                            } else {
                                print("No futures symbol found for pair: \(pair)")
                            }
                        }
                        Timer.scheduledTimer(withTimeInterval: 15.0, repeats: true) { _ in
                            Task { @MainActor in
                                let pingMessage = "{\"id\": \"ping_\(Int(Date().timeIntervalSince1970))\", \"type\": \"ping\"}"
                                kucoinFuturesSocket?.write(string: pingMessage)
                                print("DEBUG: KuCoin Futures WebSocket sent ping")
                            }
                        }
                    case .disconnected(let reason, let code):
                        print("KuCoin Futures WebSocket disconnected: \(reason), code: \(code)")
                        kucoinFuturesIsConnected = false
                        DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                            connectKucoinFutures()
                        }
                    case .text(_):
                        print("Received KuCoin Futures WS message, handled by delegate")
                    case .error(let error):
                        print("KuCoin Futures WebSocket error: \(error?.localizedDescription ?? "Unknown error")")
                        kucoinFuturesIsConnected = false
                        DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                            connectKucoinFutures()
                        }
                    case .pong(_):
                        print("DEBUG: KuCoin Futures WebSocket received pong")
                    default:
                        break
                    }
                }
            }
            kucoinFuturesSocket?.connect()
        }
    }

    @MainActor
    static func connectBybit() {
        print("DEBUG: Attempting to connect to Bybit Spot WebSocket...")
        bybitSocket = WebSocket(request: URLRequest(url: URL(string: "wss://stream.bybit.com/v5/public/spot")!))
        
        bybitSocket?.onEvent = { event in
            Task { @MainActor in
                switch event {
                case .connected(let headers):
                    print("Bybit Spot WebSocket connected with headers: \(headers)")
                    bybitIsConnected = true
                    for pair in tradingPairs {
                        let symbol = pair.replacingOccurrences(of: "-USDT", with: "USDT")
                        let subscribeMessage: [String: Any] = [
                            "req_id": "bybit_spot_\(Int(Date().timeIntervalSince1970 * 1000))",
                            "op": "subscribe",
                            "args": [
                                "tickers.\(symbol)",
                                "orderbook.50.\(symbol)",
                                "publicTrade.\(symbol)"
                            ]
                        ]
                        if let data = try? JSONSerialization.data(withJSONObject: subscribeMessage),
                           let message = String(data: data, encoding: .utf8) {
                            bybitSocket?.write(string: message)
                            print("Subscribed to Bybit spot topics: tickers.\(symbol), orderbook.50.\(symbol), publicTrade.\(symbol)")
                        }
                    }
                    Timer.scheduledTimer(withTimeInterval: 20.0, repeats: true) { _ in
                        Task { @MainActor in
                            let pingMessage = "{\"op\": \"ping\", \"req_id\": \"bybit_spot_\(Int(Date().timeIntervalSince1970 * 1000))\"}"
                            bybitSocket?.write(string: pingMessage)
                            print("DEBUG: Bybit Spot WebSocket sent ping")
                        }
                    }
                case .disconnected(let reason, let code):
                    print("Bybit Spot WebSocket disconnected: \(reason), code: \(code)")
                    bybitIsConnected = false
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectBybit()
                    }
                case .text(_):
                    print("Received Bybit Spot WS message, handled by delegate")
                case .error(let error):
                    print("Bybit Spot WebSocket error: \(error?.localizedDescription ?? "Unknown error")")
                    bybitIsConnected = false
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectBybit()
                    }
                case .pong(_):
                    print("DEBUG: Bybit Spot WebSocket received pong")
                default:
                    break
                }
            }
        }
        bybitSocket?.connect()
        
        print("DEBUG: Attempting to connect to Bybit Futures WebSocket...")
        bybitSpotSocket = WebSocket(request: URLRequest(url: URL(string: "wss://stream.bybit.com/v5/public/linear")!))
        
        bybitSpotSocket?.onEvent = { event in
            Task { @MainActor in
                switch event {
                case .connected(let headers):
                    print("Bybit Futures WebSocket connected with headers: \(headers)")
                    bybitIsConnected = true
                    for pair in tradingPairs {
                        let symbol = pair.replacingOccurrences(of: "-USDT", with: "USDT")
                        let subscribeMessage: [String: Any] = [
                            "req_id": "bybit_futures_\(Int(Date().timeIntervalSince1970 * 1000))",
                            "op": "subscribe",
                            "args": [
                                "tickers.\(symbol)",
                                "orderbook.50.\(symbol)",
                                "publicTrade.\(symbol)"
                            ]
                        ]
                        if let data = try? JSONSerialization.data(withJSONObject: subscribeMessage),
                           let message = String(data: data, encoding: .utf8) {
                            bybitSpotSocket?.write(string: message)
                            print("Subscribed to Bybit futures topics: tickers.\(symbol), orderbook.50.\(symbol), publicTrade.\(symbol)")
                        }
                    }
                    Timer.scheduledTimer(withTimeInterval: 20.0, repeats: true) { _ in
                        Task { @MainActor in
                            let pingMessage = "{\"op\": \"ping\", \"req_id\": \"bybit_futures_\(Int(Date().timeIntervalSince1970 * 1000))\"}"
                            bybitSpotSocket?.write(string: pingMessage)
                            print("DEBUG: Bybit Futures WebSocket sent ping")
                        }
                    }
                case .disconnected(let reason, let code):
                    print("Bybit Futures WebSocket disconnected: \(reason), code: \(code)")
                    bybitIsConnected = false
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectBybit()
                    }
                case .text(_):
                    print("Received Bybit Futures WS message, handled by delegate")
                case .error(let error):
                    print("Bybit Futures WebSocket error: \(error?.localizedDescription ?? "Unknown error")")
                    bybitIsConnected = false
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        connectBybit()
                    }
                case .pong(_):
                    print("DEBUG: Bybit Futures WebSocket received pong")
                default:
                    break
                }
            }
        }
        bybitSpotSocket?.connect()
    }
}

//------------------------------------------------------------Block 4.8: Main Trading Loop
// Block 4.8: Main Trading Loop
extension ExchangeWebSocket {
    private static func fetchAndLogBalances(isInitial: Bool = false, completion: @escaping () -> Void) {
        print("DEBUG: Starting balance fetch...")
        var kucoinBal: Double?
        var bybitBal: Double?
        fetchKucoinBalance {
            Task { @MainActor in
                kucoinBal = ExchangeWebSocket.kucoinBalance
                if kucoinBal == ExchangeWebSocket.kucoinFallbackBalance {
                    print("DEBUG: KuCoin balance fetch failed, using last known: \(kucoinBal!) USDT")
                } else {
                    print("DEBUG: KuCoin balance fetch succeeded: \(kucoinBal!) USDT")
                }
                fetchBybitBalance {
                    Task { @MainActor in
                        bybitBal = ExchangeWebSocket.bybitBalance
                        if bybitBal == ExchangeWebSocket.bybitFallbackBalance {
                            print("DEBUG: Bybit balance fetch failed, using last known: \(bybitBal!) USDT")
                        } else {
                            print("DEBUG: Bybit balance fetch succeeded: \(bybitBal!) USDT")
                        }
                        let logPrefix = isInitial ? "Initial Balances" : "Updated Balances"
                        print("\(logPrefix) - KuCoin: \(ExchangeWebSocket.kucoinBalance) USDT, Bybit: \(ExchangeWebSocket.bybitBalance) USDT")
                        completion()
                    }
                }
            }
        }
    }

    static func startTrading() {
        initializeParameters()
        DispatchQueue.main.async {
            connectKucoin()
            connectKucoinFutures()
            connectBybit()
            fetchAndLogBalances(isInitial: true) {}
            Timer.scheduledTimer(withTimeInterval: 10, repeats: true) { _ in
                Task { @MainActor in
                    fetchAndLogBalances(isInitial: false) {}
                }
            }
            Timer.scheduledTimer(withTimeInterval: 2, repeats: true) { _ in
                Task { @MainActor in
                    for pair in tradingPairs {
                        // Execute spot trading strategy
                        ["bybit", "kucoin"].forEach { exchange in
                            executeSpotStrategy(exchange: exchange, pair: pair)
                        }
                        // Log current prices for all pairs
                        let kucoinSpot = kucoinCurrentPrice[pair] ?? 0.0
                        let kucoinFutures = kucoinCurrentFuturesPrice[pair] ?? 0.0
                        let bybitSpot = bybitCurrentPrice[pair] ?? 0.0
                        let bybitFutures = bybitCurrentFuturesPrice[pair] ?? 0.0
                        print("Current prices for \(pair) - KuCoin Spot: \(kucoinSpot), KuCoin Futures: \(kucoinFutures), Bybit Spot: \(bybitSpot), Bybit Futures: \(bybitFutures)")
                        // Arbitrage checks with detailed logging
                        let arbitrageExecuted = checkArbitrageOpportunity(pair: pair)
                        if arbitrageExecuted {
                            print("Arbitrage trade executed for \(pair)")
                        }
                    }
                }
            }
        }
    }

    static func executeSpotStrategy(exchange: String, pair: String) {
        print("Executing spot strategy for \(exchange) on \(pair) - Placeholder")
    }
}


//------------------------------------------------------------Block 5 Main Trading Loop

DispatchQueue.main.async {
    ExchangeWebSocket.startTrading()
}

RunLoop.main.run()


