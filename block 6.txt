
//-----------------------------------------------------------------------------------------------------------------------Block 6 - Account Balance and API Initialization


extension ExchangeWebSocket {
    static func monitorFundingRateArbitrage() {
        Task {
            await withTaskGroup(of: Void.self) { group in
                let tradingPairsValue = await MainActor.run(body: { tradingPairs })
                for pair in tradingPairsValue {
                    group.addTask { @MainActor @Sendable in
                        let kucoinFundingRate = kucoinFundingRates[pair] ?? 0.0
                        let bybitFundingRate = bybitFundingRates[pair] ?? 0.0
                        let kucoinSpotPrice = kucoinCurrentPrice[pair] ?? 0.0
                        let bybitSpotPrice = bybitCurrentPrice[pair] ?? 0.0
                        let maxFundingRateValue = maxFundingRate
                        
                        guard kucoinSpotPrice > 0, bybitSpotPrice > 0 else {
                            print("DEBUG: Invalid prices for funding rate arbitrage - \(pair): KuCoin=\(kucoinSpotPrice), Bybit=\(bybitSpotPrice)")
                            return
                        }
                        
                        if kucoinFundingRate > maxFundingRateValue || bybitFundingRate > maxFundingRateValue {
                            print("DEBUG: Funding rate too high for \(pair): KuCoin=\(kucoinFundingRate), Bybit=\(bybitFundingRate)")
                            logAlert(event: "Funding rate too high for \(pair): KuCoin=\(kucoinFundingRate), Bybit=\(bybitFundingRate)")
                            return
                        }
                        
                        let tradeAmount = futuresTradeAmount
                        let kucoinLiquidity = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "futures", tradeAmount: tradeAmount, price: kucoinSpotPrice)
                        let bybitLiquidity = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "futures", tradeAmount: tradeAmount, price: bybitSpotPrice)
                        
                        // Use liquidity variables to validate before proceeding
                        guard let kucoinLiquidity = kucoinLiquidity, let bybitLiquidity = bybitLiquidity, kucoinLiquidity >= minLiquidityThreshold, bybitLiquidity >= minLiquidityThreshold else {
                            print("DEBUG: Insufficient liquidity for funding rate arbitrage - \(pair): KuCoin=\(kucoinLiquidity ?? 0.0), Bybit=\(bybitLiquidity ?? 0.0)")
                            logAlert(event: "Insufficient liquidity for funding rate arbitrage - \(pair): KuCoin=\(kucoinLiquidity ?? 0.0), Bybit=\(bybitLiquidity ?? 0.0)")
                            return
                        }
                        
                        let kucoinTradeAmount = await dynamicTradeAmount(balance: kucoinBalance, riskPercent: tradeAmountPercentage, volatility: 0.01)
                        let bybitTradeAmount = await dynamicTradeAmount(balance: bybitBalance, riskPercent: tradeAmountPercentage, volatility: 0.01)
                        
                        // Use trade amount variables to validate before proceeding
                        guard kucoinTradeAmount > 0, bybitTradeAmount > 0 else {
                            print("DEBUG: Invalid trade amounts for funding rate arbitrage - \(pair): KuCoin=\(kucoinTradeAmount), Bybit=\(bybitTradeAmount)")
                            logAlert(event: "Invalid trade amounts for funding rate arbitrage - \(pair): KuCoin=\(kucoinTradeAmount), Bybit=\(bybitTradeAmount)")
                            return
                        }
                        
                        await evaluateFundingRateMomentum(pair: pair, kucoinFundingRate: kucoinFundingRate, bybitFundingRate: bybitFundingRate)
                    }
                }
            }
            
            // Schedule the next check
            try? await Task.sleep(nanoseconds: UInt64(getDouble("ARBITRAGE_CHECK_INTERVAL_SECONDS", defaultValue: 0.5) * 1_000_000_000))
            monitorFundingRateArbitrage()
        }
    }

    static func fetchKuCoinWsToken(completion: @escaping @Sendable (String?) -> Void) {
        // ENHANCED: Check credentials before attempting WebSocket connection
        guard validateAPICredentials(exchange: "kucoin") else {
            print("Invalid KuCoin credentials, skipping WebSocket token fetch")
            Task { @MainActor in
                logAlert(event: "Invalid KuCoin credentials, skipping WebSocket token fetch")
            }
            completion(nil)
            return
        }
        
        let url = URL(string: "https://api.kucoin.com/api/v1/bullet-public")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.timeoutInterval = getDouble("API_TIMEOUT_SECONDS", defaultValue: 10.0)
        
        let startTime = Date()
        URLSession.shared.dataTask(with: request) { data, response, error in
            let latency = Date().timeIntervalSince(startTime) * 1000
            Task { @MainActor in
                lastLatency["kucoin-ws-token"] = latency
                if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 300.0) {
                    print("High latency detected for KuCoin WebSocket token fetch: \(latency)ms")
                    logAlert(event: "High latency detected for KuCoin WebSocket token fetch: \(latency)ms")
                }
            }
            
            if let error = error {
                print("Failed to fetch KuCoin WebSocket token: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to fetch KuCoin WebSocket token: \(error.localizedDescription)")
                }
                completion(nil)
                return
            }
            
            guard let httpResponse = response as? HTTPURLResponse else {
                print("Invalid KuCoin WebSocket token response: Non-HTTP response")
                Task { @MainActor in
                    logAlert(event: "Invalid KuCoin WebSocket token response: Non-HTTP response")
                }
                completion(nil)
                return
            }
            
            // ENHANCED: Better error handling for different status codes
            if httpResponse.statusCode != 200 {
                let responseBody = data != nil ? String(data: data!, encoding: .utf8) ?? "Invalid data" : "No data"
                print("Invalid KuCoin WebSocket token response: Status \(httpResponse.statusCode)")
                Task { @MainActor in
                    handleAPIError(exchange: "kucoin", statusCode: httpResponse.statusCode, responseBody: responseBody)
                    logAlert(event: "Invalid KuCoin WebSocket token response: Status \(httpResponse.statusCode)")
                }
                completion(nil)
                return
            }
            
            guard let data = data else {
                print("No data received for KuCoin WebSocket token")
                Task { @MainActor in
                    logAlert(event: "No data received for KuCoin WebSocket token")
                }
                completion(nil)
                return
            }
            
            do {
                guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                      let dataDict = json["data"] as? [String: Any],
                      let token = dataDict["token"] as? String else {
                    print("Failed to parse KuCoin WebSocket token")
                    Task { @MainActor in
                        logAlert(event: "Failed to parse KuCoin WebSocket token")
                    }
                    completion(nil)
                    return
                }
                
                // ENHANCED: Validate token format
                if token.isEmpty || token.count < 10 {
                    print("Invalid KuCoin WebSocket token format: \(token)")
                    Task { @MainActor in
                        logAlert(event: "Invalid KuCoin WebSocket token format")
                    }
                    completion(nil)
                    return
                }
                
                Task { @MainActor in
                    kucoinToken = token
                    print("DEBUG: Fetched KuCoin WebSocket token: \(token)")
                    kucoinSocket = WebSocket(request: URLRequest(url: URL(string: "wss://ws-api.kucoin.com/endpoint?token=\(token)")!))
                    kucoinSocket?.delegate = kucoinDelegate
                    kucoinSocket?.connect()
                    print("DEBUG: KuCoin WebSocket connected for token: \(token)")
                }
                completion(token)
            } catch {
                print("Failed to parse JSON for KuCoin WebSocket token: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to parse JSON for KuCoin WebSocket token: \(error.localizedDescription)")
                }
                completion(nil)
            }
        }.resume()
    }

    static func fetchKucoinFuturesWsToken(completion: @escaping @Sendable (String?) -> Void) {
        // ENHANCED: Check credentials before attempting WebSocket connection
        guard validateAPICredentials(exchange: "kucoin") else {
            print("Invalid KuCoin credentials, skipping Futures WebSocket token fetch")
            Task { @MainActor in
                logAlert(event: "Invalid KuCoin credentials, skipping Futures WebSocket token fetch")
            }
            completion(nil)
            return
        }
        
        let url = URL(string: "https://api-futures.kucoin.com/api/v1/bullet-public")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.timeoutInterval = getDouble("API_TIMEOUT_SECONDS", defaultValue: 10.0)
        
        let startTime = Date()
        URLSession.shared.dataTask(with: request) { data, response, error in
            let latency = Date().timeIntervalSince(startTime) * 1000
            Task { @MainActor in
                lastLatency["kucoin-futures-ws-token"] = latency
                if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 300.0) {
                    print("High latency detected for KuCoin Futures WebSocket token fetch: \(latency)ms")
                    logAlert(event: "High latency detected for KuCoin Futures WebSocket token fetch: \(latency)ms")
                }
            }
            
            if let error = error {
                print("Failed to fetch KuCoin Futures WebSocket token: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to fetch KuCoin Futures WebSocket token: \(error.localizedDescription)")
                }
                completion(nil)
                return
            }
            
            guard let httpResponse = response as? HTTPURLResponse else {
                print("Invalid KuCoin Futures WebSocket token response: Non-HTTP response")
                Task { @MainActor in
                    logAlert(event: "Invalid KuCoin Futures WebSocket token response: Non-HTTP response")
                }
                completion(nil)
                return
            }
            
            // ENHANCED: Better error handling for different status codes
            if httpResponse.statusCode != 200 {
                let responseBody = data != nil ? String(data: data!, encoding: .utf8) ?? "Invalid data" : "No data"
                print("Invalid KuCoin Futures WebSocket token response: Status \(httpResponse.statusCode)")
                Task { @MainActor in
                    handleAPIError(exchange: "kucoin", statusCode: httpResponse.statusCode, responseBody: responseBody)
                    logAlert(event: "Invalid KuCoin Futures WebSocket token response: Status \(httpResponse.statusCode)")
                }
                completion(nil)
                return
            }
            
            guard let data = data else {
                print("No data received for KuCoin Futures WebSocket token")
                Task { @MainActor in
                    logAlert(event: "No data received for KuCoin Futures WebSocket token")
                }
                completion(nil)
                return
            }
            
            do {
                guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                      let dataDict = json["data"] as? [String: Any],
                      let token = dataDict["token"] as? String else {
                    print("Failed to parse KuCoin Futures WebSocket token")
                    Task { @MainActor in
                        logAlert(event: "Failed to parse KuCoin Futures WebSocket token")
                    }
                    completion(nil)
                    return
                }
                
                // ENHANCED: Validate token format
                if token.isEmpty || token.count < 10 {
                    print("Invalid KuCoin Futures WebSocket token format: \(token)")
                    Task { @MainActor in
                        logAlert(event: "Invalid KuCoin Futures WebSocket token format")
                    }
                    completion(nil)
                    return
                }
                
                Task { @MainActor in
                    kucoinFuturesToken = token
                    print("DEBUG: Fetched KuCoin Futures WebSocket token: \(token)")
                    kucoinFuturesSocket = WebSocket(request: URLRequest(url: URL(string: "wss://ws-api-futures.kucoin.com/endpoint?token=\(token)")!))
                    kucoinFuturesSocket?.delegate = kucoinFuturesDelegate
                    kucoinFuturesSocket?.connect()
                    print("DEBUG: KuCoin Futures WebSocket connected for token: \(token)")
                }
                completion(token)
            } catch {
                print("Failed to parse JSON for KuCoin Futures WebSocket token: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to parse JSON for KuCoin Futures WebSocket token: \(error.localizedDescription)")
                }
                completion(nil)
            }
        }.resume()
    }

    static func fetchKucoinBalance(completion: @escaping @Sendable (Double?) -> Void) {
        // ENHANCED: Validate credentials before making API call
        guard let apiKey = environment["KUCOIN_API_KEY"],
              let apiSecret = environment["KUCOIN_API_SECRET"],
              let apiPassphrase = environment["KUCOIN_API_PASSPHRASE"] else {
            print("Missing KuCoin API credentials")
            Task { @MainActor in
                logAlert(event: "Missing KuCoin API credentials")
                // FIX: Improved fallback balance handling
                kucoinBalance = kucoinFallbackBalance
                logAlert(event: "Using KuCoin fallback balance: \(kucoinFallbackBalance) USDT")
            }
            completion(kucoinFallbackBalance)
            return
        }
        
        // ENHANCED: Validate credential format
        if apiKey.isEmpty || apiSecret.isEmpty || apiPassphrase.isEmpty {
            print("Empty KuCoin API credentials")
            Task { @MainActor in
                logAlert(event: "Empty KuCoin API credentials")
                kucoinBalance = kucoinFallbackBalance
                logAlert(event: "Using KuCoin fallback balance: \(kucoinFallbackBalance) USDT")
            }
            completion(kucoinFallbackBalance)
            return
        }
        
        let url = URL(string: "https://api.kucoin.com/api/v1/accounts")!
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = getDouble("BALANCE_FETCH_TIMEOUT", defaultValue: 20.0)
        
        let timestamp = String(Int(Date().timeIntervalSince1970 * 1000))
        let strToSign = timestamp + "GET" + "/api/v1/accounts"
        let signature = HMAC<SHA256>.authenticationCode(for: strToSign.data(using: .utf8)!, using: SymmetricKey(data: apiSecret.data(using: .utf8)!)).map { String(format: "%02x", $0) }.joined()
        let passphrase = HMAC<SHA256>.authenticationCode(for: apiPassphrase.data(using: .utf8)!, using: SymmetricKey(data: apiSecret.data(using: .utf8)!)).map { String(format: "%02x", $0) }.joined()
        
        request.addValue(apiKey, forHTTPHeaderField: "KC-API-KEY")
        request.addValue(timestamp, forHTTPHeaderField: "KC-API-TIMESTAMP")
        request.addValue(signature, forHTTPHeaderField: "KC-API-SIGN")
        request.addValue(passphrase, forHTTPHeaderField: "KC-API-PASSPHRASE")
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        
        let startTime = Date()
        URLSession.shared.dataTask(with: request) { data, response, error in
            let latency = Date().timeIntervalSince(startTime) * 1000
            Task { @MainActor in
                lastLatency["kucoin-balance"] = latency
                if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 300.0) {
                    print("High latency detected for KuCoin balance fetch: \(latency)ms")
                    logAlert(event: "High latency detected for KuCoin balance fetch: \(latency)ms")
                }
            }
            
            if let error = error {
                print("Failed to fetch KuCoin balance: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to fetch KuCoin balance: \(error.localizedDescription)")
                    // FIX: Use fallback balance on error
                    kucoinBalance = kucoinFallbackBalance
                    logAlert(event: "Using KuCoin fallback balance due to error: \(kucoinFallbackBalance) USDT")
                }
                completion(kucoinFallbackBalance)
                return
            }
            
            guard let httpResponse = response as? HTTPURLResponse else {
                print("Invalid KuCoin balance response: Non-HTTP response")
                Task { @MainActor in
                    logAlert(event: "Invalid KuCoin balance response: Non-HTTP response")
                    kucoinBalance = kucoinFallbackBalance
                    logAlert(event: "Using KuCoin fallback balance: \(kucoinFallbackBalance) USDT")
                }
                completion(kucoinFallbackBalance)
                return
            }
            
            // ENHANCED: Better error handling for different status codes
            if httpResponse.statusCode != 200 {
                let responseBody = data != nil ? String(data: data!, encoding: .utf8) ?? "Invalid data" : "No data"
                print("Invalid KuCoin balance response: Status \(httpResponse.statusCode)")
                Task { @MainActor in
                    handleAPIError(exchange: "kucoin", statusCode: httpResponse.statusCode, responseBody: responseBody)
                    logAlert(event: "Invalid KuCoin balance response: Status \(httpResponse.statusCode)")
                    kucoinBalance = kucoinFallbackBalance
                    logAlert(event: "Using KuCoin fallback balance: \(kucoinFallbackBalance) USDT")
                }
                completion(kucoinFallbackBalance)
                return
            }
            
            guard let data = data else {
                print("No data received for KuCoin balance")
                Task { @MainActor in
                    logAlert(event: "No data received for KuCoin balance")
                    kucoinBalance = kucoinFallbackBalance
                    logAlert(event: "Using KuCoin fallback balance: \(kucoinFallbackBalance) USDT")
                }
                completion(kucoinFallbackBalance)
                return
            }
            
            do {
                guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
                    print("Failed to parse KuCoin balance JSON")
                    Task { @MainActor in
                        logAlert(event: "Failed to parse KuCoin balance JSON")
                        kucoinBalance = kucoinFallbackBalance
                        logAlert(event: "Using KuCoin fallback balance: \(kucoinFallbackBalance) USDT")
                    }
                    completion(kucoinFallbackBalance)
                    return
                }
                
                // ENHANCED: Better JSON validation and error handling
                guard let code = json["code"] as? String else {
                    print("KuCoin balance response missing code field")
                    Task { @MainActor in
                        logAlert(event: "KuCoin balance response missing code field")
                        kucoinBalance = kucoinFallbackBalance
                        logAlert(event: "Using KuCoin fallback balance: \(kucoinFallbackBalance) USDT")
                    }
                    completion(kucoinFallbackBalance)
                    return
                }
                
                guard code == "200000" else {
                    let errorMsg = json["msg"] as? String ?? "Unknown error"
                    print("KuCoin balance API error - code: \(code), msg: \(errorMsg)")
                    Task { @MainActor in
                        logAlert(event: "KuCoin balance API error - code: \(code), msg: \(errorMsg)")
                        kucoinBalance = kucoinFallbackBalance
                        logAlert(event: "Using KuCoin fallback balance: \(kucoinFallbackBalance) USDT")
                    }
                    completion(kucoinFallbackBalance)
                    return
                }
                
                guard let dataArray = json["data"] as? [[String: Any]] else {
                    print("KuCoin balance response missing data array")
                    Task { @MainActor in
                        logAlert(event: "KuCoin balance response missing data array")
                        kucoinBalance = kucoinFallbackBalance
                        logAlert(event: "Using KuCoin fallback balance: \(kucoinFallbackBalance) USDT")
                    }
                    completion(kucoinFallbackBalance)
                    return
                }
                
                // ENHANCED: Better balance parsing with multiple account types
                var totalBalance = 0.0
                var usdtAccountFound = false
                
                for account in dataArray {
                    if let currency = account["currency"] as? String,
                       currency == "USDT",
                       let balanceStr = account["balance"] as? String,
                       let balance = Double(balanceStr),
                       balance > 0 {
                        totalBalance += balance
                        usdtAccountFound = true
                        
                        let accountType = account["type"] as? String ?? "unknown"
                        print("DEBUG: Found KuCoin USDT account (\(accountType)): \(balance) USDT")
                    }
                }
                
                if !usdtAccountFound {
                    print("No KuCoin USDT accounts found")
                    Task { @MainActor in
                        logAlert(event: "No KuCoin USDT accounts found")
                        kucoinBalance = kucoinFallbackBalance
                        logAlert(event: "Using KuCoin fallback balance: \(kucoinFallbackBalance) USDT")
                    }
                    completion(kucoinFallbackBalance)
                    return
                }
                
                // Use fallback if balance is suspiciously low (might indicate API issue)
                let finalBalance = totalBalance < 1.0 ? kucoinFallbackBalance : totalBalance
                
                Task { @MainActor in
                    kucoinBalance = finalBalance
                    print("DEBUG: Fetched KuCoin balance: \(finalBalance) USDT (total from API: \(totalBalance))")
                    if finalBalance != totalBalance {
                        logAlert(event: "Used KuCoin fallback balance due to low API balance: \(totalBalance) -> \(finalBalance)")
                    }
                }
                completion(finalBalance)
            } catch {
                print("Failed to parse JSON for KuCoin balance: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to parse JSON for KuCoin balance: \(error.localizedDescription)")
                    kucoinBalance = kucoinFallbackBalance
                    logAlert(event: "Using KuCoin fallback balance: \(kucoinFallbackBalance) USDT")
                }
                completion(kucoinFallbackBalance)
            }
        }.resume()
    }

    static func fetchBybitBalance(completion: @escaping @Sendable (Double?) -> Void) {
        // ENHANCED: Validate credentials before making API call
        guard let apiKey = environment["BYBIT_API_KEY"],
              let apiSecret = environment["BYBIT_API_SECRET"] else {
            print("Missing Bybit API credentials")
            Task { @MainActor in
                logAlert(event: "Missing Bybit API credentials")
                // FIX: Improved fallback balance handling
                bybitBalance = bybitFallbackBalance
                logAlert(event: "Using Bybit fallback balance: \(bybitFallbackBalance) USDT")
            }
            completion(bybitFallbackBalance)
            return
        }
        
        // ENHANCED: Validate credential format
        if apiKey.isEmpty || apiSecret.isEmpty {
            print("Empty Bybit API credentials")
            Task { @MainActor in
                logAlert(event: "Empty Bybit API credentials")
                bybitBalance = bybitFallbackBalance
                logAlert(event: "Using Bybit fallback balance: \(bybitFallbackBalance) USDT")
            }
            completion(bybitFallbackBalance)
            return
        }
        
        let url = URL(string: "https://api.bybit.com/v5/account/wallet-balance?accountType=UNIFIED")!
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = getDouble("BALANCE_FETCH_TIMEOUT", defaultValue: 20.0)
        
        let timestamp = String(Int(Date().timeIntervalSince1970 * 1000))
        let recvWindow = bybitRecvWindow
        let queryString = "api_key=\(apiKey)Ã—tamp=\(timestamp)&recv_window=\(recvWindow)"
        let signature = HMAC<SHA256>.authenticationCode(for: queryString.data(using: .utf8)!, using: SymmetricKey(data: apiSecret.data(using: .utf8)!)).map { String(format: "%02x", $0) }.joined()
        
        request.addValue(apiKey, forHTTPHeaderField: "X-BAPI-API-KEY")
        request.addValue(timestamp, forHTTPHeaderField: "X-BAPI-TIMESTAMP")
        request.addValue(signature, forHTTPHeaderField: "X-BAPI-SIGN")
        request.addValue(recvWindow, forHTTPHeaderField: "X-BAPI-RECV-WINDOW")
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        
        let startTime = Date()
        URLSession.shared.dataTask(with: request) { data, response, error in
            let latency = Date().timeIntervalSince(startTime) * 1000
            Task { @MainActor in
                lastLatency["bybit-balance"] = latency
                if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 300.0) {
                    print("High latency detected for Bybit balance fetch: \(latency)ms")
                    logAlert(event: "High latency detected for Bybit balance fetch: \(latency)ms")
                }
            }
            
            if let error = error {
                print("Failed to fetch Bybit balance: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to fetch Bybit balance: \(error.localizedDescription)")
                    // FIX: Use fallback balance on error
                    bybitBalance = bybitFallbackBalance
                    logAlert(event: "Using Bybit fallback balance due to error: \(bybitFallbackBalance) USDT")
                }
                completion(bybitFallbackBalance)
                return
            }
            
            guard let httpResponse = response as? HTTPURLResponse else {
                print("Invalid Bybit balance response: Non-HTTP response")
                Task { @MainActor in
                    logAlert(event: "Invalid Bybit balance response: Non-HTTP response")
                    bybitBalance = bybitFallbackBalance
                    logAlert(event: "Using Bybit fallback balance: \(bybitFallbackBalance) USDT")
                }
                completion(bybitFallbackBalance)
                return
            }
            
            // ENHANCED: Better error handling for different status codes
            if httpResponse.statusCode != 200 {
                let responseBody = data != nil ? String(data: data!, encoding: .utf8) ?? "Invalid data" : "No data"
                print("Invalid Bybit balance response: Status \(httpResponse.statusCode)")
                Task { @MainActor in
                    handleAPIError(exchange: "bybit", statusCode: httpResponse.statusCode, responseBody: responseBody)
                    logAlert(event: "Invalid Bybit balance response: Status \(httpResponse.statusCode)")
                    bybitBalance = bybitFallbackBalance
                    logAlert(event: "Using Bybit fallback balance: \(bybitFallbackBalance) USDT")
                }
                completion(bybitFallbackBalance)
                return
            }
            
            guard let data = data else {
                print("No data received for Bybit balance")
                Task { @MainActor in
                    logAlert(event: "No data received for Bybit balance")
                    bybitBalance = bybitFallbackBalance
                    logAlert(event: "Using Bybit fallback balance: \(bybitFallbackBalance) USDT")
                }
                completion(bybitFallbackBalance)
                return
            }
            
            do {
                guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
                    print("Failed to parse Bybit balance JSON")
                    Task { @MainActor in
                        logAlert(event: "Failed to parse Bybit balance JSON")
                        bybitBalance = bybitFallbackBalance
                        logAlert(event: "Using Bybit fallback balance: \(bybitFallbackBalance) USDT")
                    }
                    completion(bybitFallbackBalance)
                    return
                }
                
                // ENHANCED: Better JSON validation and error handling
                guard let retCode = json["retCode"] as? Int else {
                    print("Bybit balance response missing retCode")
                    Task { @MainActor in
                        logAlert(event: "Bybit balance response missing retCode")
                        bybitBalance = bybitFallbackBalance
                        logAlert(event: "Using Bybit fallback balance: \(bybitFallbackBalance) USDT")
                    }
                    completion(bybitFallbackBalance)
                    return
                }
                
                guard retCode == 0 else {
                    let retMsg = json["retMsg"] as? String ?? "Unknown error"
                    print("Bybit balance API error - retCode: \(retCode), retMsg: \(retMsg)")
                    Task { @MainActor in
                        logAlert(event: "Bybit balance API error - retCode: \(retCode), retMsg: \(retMsg)")
                        bybitBalance = bybitFallbackBalance
                        logAlert(event: "Using Bybit fallback balance: \(bybitFallbackBalance) USDT")
                    }
                    completion(bybitFallbackBalance)
                    return
                }
                
                guard let result = json["result"] as? [String: Any],
                      let list = result["list"] as? [[String: Any]] else {
                    print("Bybit balance response missing result.list")
                    Task { @MainActor in
                        logAlert(event: "Bybit balance response missing result.list")
                        bybitBalance = bybitFallbackBalance
                        logAlert(event: "Using Bybit fallback balance: \(bybitFallbackBalance) USDT")
                    }
                    completion(bybitFallbackBalance)
                    return
                }
                
                // ENHANCED: Better balance parsing with validation
                var totalBalance = 0.0
                var usdtAccountFound = false
                
                for unifiedAccount in list {
                    if let coinArray = unifiedAccount["coin"] as? [[String: Any]] {
                        for coin in coinArray {
                            if let coinName = coin["coin"] as? String,
                               coinName == "USDT",
                               let balanceStr = coin["equity"] as? String,
                               let balance = Double(balanceStr),
                               balance >= 0 {
                                totalBalance += balance
                                usdtAccountFound = true
                                
                                let walletBalance = coin["walletBalance"] as? String ?? "0"
                                print("DEBUG: Found Bybit USDT account - equity: \(balance), wallet: \(walletBalance)")
                            }
                        }
                    }
                }
                
                if !usdtAccountFound {
                    print("No Bybit USDT accounts found")
                    Task { @MainActor in
                        logAlert(event: "No Bybit USDT accounts found")
                        bybitBalance = bybitFallbackBalance
                        logAlert(event: "Using Bybit fallback balance: \(bybitFallbackBalance) USDT")
                    }
                    completion(bybitFallbackBalance)
                    return
                }
                
                // Use fallback if balance is suspiciously low (might indicate API issue)
                let finalBalance = totalBalance < 1.0 ? bybitFallbackBalance : totalBalance
                
                Task { @MainActor in
                    bybitBalance = finalBalance
                    print("DEBUG: Fetched Bybit balance: \(finalBalance) USDT (total from API: \(totalBalance))")
                    if finalBalance != totalBalance {
                        logAlert(event: "Used Bybit fallback balance due to low API balance: \(totalBalance) -> \(finalBalance)")
                    }
                }
                completion(finalBalance)
            } catch {
                print("Failed to parse JSON for Bybit balance: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "Failed to parse JSON for Bybit balance: \(error.localizedDescription)")
                    bybitBalance = bybitFallbackBalance
                    logAlert(event: "Using Bybit fallback balance: \(bybitFallbackBalance) USDT")
                }
                completion(bybitFallbackBalance)
            }
        }.resume()
    }
    
    // ENHANCED: Helper function to evaluate funding rate momentum
    static func evaluateFundingRateMomentum(pair: String, kucoinFundingRate: Double, bybitFundingRate: Double) async {
        let rateThreshold = await MainActor.run { fundingMomentumThreshold }
        let rateDifference = abs(kucoinFundingRate - bybitFundingRate)
        
        if rateDifference > rateThreshold {
            await MainActor.run {
                logAlert(event: "Funding rate momentum detected for \(pair): KuCoin=\(kucoinFundingRate), Bybit=\(bybitFundingRate), Diff=\(rateDifference)")
            }
            
            // Store funding rate history for analysis
            await MainActor.run {
                kucoinFundingRateHistory[pair, default: []].append(kucoinFundingRate)
                bybitFundingRateHistory[pair, default: []].append(bybitFundingRate)
                
                // Keep only recent history
                if kucoinFundingRateHistory[pair]!.count > 100 {
                    kucoinFundingRateHistory[pair]?.removeFirst()
                }
                if bybitFundingRateHistory[pair]!.count > 100 {
                    bybitFundingRateHistory[pair]?.removeFirst()
                }
            }
        }
    }
}
