
extension ExchangeWebSocket {
    
    static var bybitFuturesSocket: WebSocket?
    static var bybitSpotDelegate: BybitSpotWebSocketDelegate?
    static var bybitFuturesDelegate: BybitFuturesWebSocketDelegate?
    
    static func subscribeToBybitFuturesPrices(pairs: [String]) {
        Task { @MainActor in
            guard bybitFuturesIsConnected, let socket = bybitFuturesSocket else {
                print("‚ùå [WebSocket] Bybit Futures not connected, cannot subscribe to prices")
                logAlert(event: "‚ùå Bybit Futures not connected, cannot subscribe to prices")
                return
            }
            
            let symbols = pairs.map { $0.replacingOccurrences(of: "-", with: "") }
            let topics = symbols.map { "tickers.\($0)" }
            
            let subscribeMessage: [String: Any] = [
                "op": "subscribe",
                "args": topics
            ]
            
            do {
                let jsonData = try JSONSerialization.data(withJSONObject: subscribeMessage, options: [])
                if let jsonString = String(data: jsonData, encoding: .utf8) {
                    socket.write(string: jsonString)
                    print("‚úÖ [WebSocket] Subscribed to Bybit Futures prices for \(pairs.count) pairs")
                    logAlert(event: "‚úÖ Subscribed to Bybit Futures prices for \(pairs.count) pairs")
                }
            } catch {
                print("‚ùå [WebSocket] Failed to subscribe to Bybit Futures prices: \(error)")
                logAlert(event: "‚ùå Failed to subscribe to Bybit Futures prices: \(error)")
            }
        }
    }
    static func subscribeToKuCoinFuturesPrices(pairs: [String]) {
            Task { @MainActor in
                guard kucoinFuturesIsConnected, let socket = kucoinFuturesSocket else {
                    print("‚ùå [WebSocket] KuCoin Futures not connected, cannot subscribe to prices")
                    logAlert(event: "‚ùå KuCoin Futures not connected, cannot subscribe to prices")
                    return
                }
                
                let symbols = pairs.compactMap { pair in
                    return kucoinFuturesSymbols[pair]
                }
                
                let subscribeMessage: [String: Any] = [
                    "id": Int.random(in: 1...999999),
                    "type": "subscribe",
                    "topic": "/contractMarket/ticker:\(symbols.joined(separator: ","))",
                    "privateChannel": false,
                    "response": true
                ]
                

                do {
                    let jsonData = try JSONSerialization.data(withJSONObject: subscribeMessage, options: [])
                    if let jsonString = String(data: jsonData, encoding: .utf8) {
                        socket.write(string: jsonString)
                        print("‚úÖ [WebSocket] Subscribed to KuCoin Futures prices for \(pairs.count) pairs")
                        logAlert(event: "‚úÖ Subscribed to KuCoin Futures prices for \(pairs.count) pairs")
                    }
                } catch {
                    print("‚ùå [WebSocket] Failed to subscribe to KuCoin Futures prices: \(error)")
                    logAlert(event: "‚ùå Failed to subscribe to KuCoin Futures prices: \(error)")
                }
            }
        }
    
    // FIXED: Dashboard JSON Generation - Add this function to ExchangeWebSocket class

    static func updateDashboardJSON() {
        Task { @MainActor in
            // FIXED: Write dashboard.json to the correct location where Flask can find it
            let dashboardPath = "/Users/robertsteinegger/Desktop/BevaixBot/dashboard.json"
            
            // Collect LIVE price data from WebSocket feeds
            var livePrices: [String: [String: Double]] = [:]
            
            for pair in tradingPairs {
                var pairPrices: [String: Double] = [:]
                
                // Get current live prices (not fallback values)
                let kucoinSpotPrice = kucoinCurrentPrice[pair] ?? 0.0
                let kucoinFuturesPrice = kucoinCurrentFuturesPrice[pair] ?? 0.0
                let bybitSpotPrice = bybitCurrentPrice[pair] ?? 0.0
                let bybitFuturesPrice = bybitCurrentFuturesPrice[pair] ?? 0.0
                
                // Only include pairs with live data (price > 0)
                if kucoinSpotPrice > 0 || bybitSpotPrice > 0 {
                    pairPrices["kucoin_spot"] = kucoinSpotPrice
                    pairPrices["kucoin_futures"] = kucoinFuturesPrice
                    pairPrices["bybit_spot"] = bybitSpotPrice
                    pairPrices["bybit_futures"] = bybitFuturesPrice
                    livePrices[pair] = pairPrices
                }
            }
            
            // Calculate real metrics from actual data
            let totalTrades = performanceMetrics.values.reduce(0) { $0 + $1.trades }
            let totalProfit = performanceMetrics.values.reduce(0.0) { $0 + $1.profit }
            let totalFees = performanceMetrics.values.reduce(0.0) { $0 + $1.fees }
            let winningTrades = performanceMetrics.values.reduce(0) { $0 + $1.wins }
            let winRate = totalTrades > 0 ? Double(winningTrades) / Double(totalTrades) * 100.0 : 0.0
            
            // Build comprehensive dashboard data
            let dashboardData: [String: Any] = [
                "timestamp": ISO8601DateFormatter().string(from: Date()),
                "kucoinBalance": kucoinBalance,
                "bybitBalance": bybitBalance,
                "kucoinFuturesBalance": kucoinFuturesBalance,
                "bybitFuturesBalance": bybitFuturesBalance,
                "livePrices": livePrices,
                "totalTrades": totalTrades,
                "totalProfit": totalProfit,
                "totalFees": totalFees,
                "winRate": winRate,
                "activePairs": tradingPairs.count,
                "connectedExchanges": [
                    "kucoin": kucoinIsConnected,
                    "kucoin_futures": kucoinFuturesIsConnected,
                    "bybit": bybitIsConnected,
                    "bybit_futures": bybitFuturesIsConnected
                ],
                "tradingActive": tradingActive,
                "dailyLoss": dailyLoss
            ]
            
            // Write JSON file
            do {
                let jsonData = try JSONSerialization.data(withJSONObject: dashboardData, options: .prettyPrinted)
                try jsonData.write(to: URL(fileURLWithPath: dashboardPath))
                
                print("‚úÖ Updated dashboard.json with live data: \(livePrices.count) pairs, \(totalTrades) trades")
                logAlert(event: "‚úÖ Dashboard updated: \(livePrices.count) pairs, $\(String(format: "%.2f", totalProfit)) profit")
                
            } catch {
                print("‚ùå Failed to write dashboard.json: \(error)")
                logAlert(event: "‚ùå Failed to write dashboard.json: \(error)")
            }
        }
    }

    // FIXED: Enhanced dashboard metrics with real-time updates
    static func logDashboardMetrics() {
        Task { @MainActor in
            let timestamp = ISO8601DateFormatter().string(from: Date())
            
            // Count active price feeds
            var activePairCount = 0
            for pair in tradingPairs {
                if (kucoinCurrentPrice[pair] ?? 0.0) > 0 || (bybitCurrentPrice[pair] ?? 0.0) > 0 {
                    activePairCount += 1
                }
            }
            
            let metrics = """
            [\(timestamp)] Dashboard Metrics:
            KuCoin Balance: \(kucoinBalance) USDT
            Bybit Balance: \(bybitBalance) USDT
            KuCoin Futures: \(kucoinFuturesBalance) USDT
            Bybit Futures: \(bybitFuturesBalance) USDT
            Total Trades: \(performanceMetrics.values.reduce(0) { $0 + $1.trades })
            Total Profit: \(performanceMetrics.values.reduce(0.0) { $0 + $1.profit }) USDT
            Total Fees: \(performanceMetrics.values.reduce(0.0) { $0 + $1.fees }) USDT
            Active Price Feeds: \(activePairCount)/\(tradingPairs.count)
            WebSocket Status: KC=\(kucoinIsConnected), KCF=\(kucoinFuturesIsConnected), BB=\(bybitIsConnected), BBF=\(bybitFuturesIsConnected)
            """
            
            print(metrics)
            logAlert(event: metrics)
            
            // FIXED: Update dashboard JSON with every metric update
            updateDashboardJSON()
        }
    }

    static func connectKuCoinSpotWebSocket() {
        print("üö® DEBUG: connectKuCoinSpotWebSocket() CALLED")
        logAlert(event: "üö® DEBUG: connectKuCoinSpotWebSocket() CALLED")
        print("üîÑ [WebSocket] Connecting to KuCoin Spot WebSocket...")
        
        Task { @MainActor in
            logAlert(event: "üîÑ Connecting to KuCoin Spot WebSocket...")
        }
        
        // First get connection token
        fetchKuCoinWebSocketToken { token in
            Task { @MainActor in
                guard let websocketToken = token else {
                    print("‚ùå [WebSocket] Failed to get KuCoin WebSocket token")
                    logAlert(event: "‚ùå Failed to get KuCoin WebSocket token")
                    return
                }
                
                print("üö® DEBUG: Got KuCoin token, creating WebSocket")
                logAlert(event: "üö® DEBUG: Got KuCoin token, creating WebSocket")
                
                kucoinToken = websocketToken
                
                // Connect to WebSocket
                guard let url = URL(string: "wss://ws-api-spot.kucoin.com/?token=\(websocketToken)") else {
                    print("‚ùå [WebSocket] Invalid KuCoin WebSocket URL")
                    logAlert(event: "‚ùå Invalid KuCoin WebSocket URL")
                    return
                }
                
                var request = URLRequest(url: url)
                request.timeoutInterval = TimeInterval(websocketTimeoutSeconds)
                
                let socket = WebSocket(request: request)
                kucoinSocket = socket
                
                print("üö® DEBUG: Setting up onEvent handler")
                logAlert(event: "üö® DEBUG: Setting up onEvent handler")
                
                // FIXED: Use onEvent instead of delegate (delegates aren't working)
                socket.onEvent = { event in
                    switch event {
                    case .connected(_):
                        Task { @MainActor in
                            kucoinIsConnected = true
                            print("‚úÖ KuCoin Spot WebSocket connected via onEvent")
                            logAlert(event: "‚úÖ KuCoin Spot WebSocket connected via onEvent")
                            
                            // Subscribe immediately after connection
                            subscribeToKuCoinSpotPrices(pairs: tradingPairs)
                        }
                    case .text(let string):
                        // DEBUG: Log ALL incoming messages
                        print("üîç KuCoin RAW MESSAGE: \(string)")
                        Task { @MainActor in
                            logAlert(event: "üîç KuCoin RAW: \(String(string.prefix(150)))")
                        }
                        
                        // Handle incoming messages
                        do {
                            guard let json = try JSONSerialization.jsonObject(with: string.data(using: .utf8)!) as? [String: Any],
                                  let type = json["type"] as? String else {
                                print("üîç KuCoin: Failed to parse basic JSON structure")
                                return
                            }
                            
                            print("üîç KuCoin message type: \(type)")
                            
                            if type == "ack" {
                                print("‚úÖ KuCoin subscription confirmed")
                                return
                            }
                            
                            if type == "message", let data = json["data"] as? [String: Any], let topic = json["topic"] as? String {
                                print("üîç KuCoin topic: \(topic)")
                                let components = topic.components(separatedBy: ":")
                                guard components.count > 1 else {
                                    print("üîç KuCoin: Invalid topic format")
                                    return
                                }
                                let symbol = components[1]
                                let pair = symbol.replacingOccurrences(of: "USDT", with: "-USDT")
                                print("üîç KuCoin parsed pair: \(pair)")
                                
                                if topic.contains("/market/ticker") {
                                    print("üîç KuCoin ticker data: \(data)")
                                    if let priceStr = data["price"] as? String, let price = Double(priceStr), price > 0 {
                                        Task { @MainActor in
                                            kucoinCurrentPrice[pair] = price
                                            kucoinPrices[pair, default: []].append(price)
                                            if kucoinPrices[pair]!.count > priceHistoryRetention {
                                                kucoinPrices[pair]!.removeFirst()
                                            }
                                            print("‚úÖ KuCoin \(pair) price updated: \(price)")
                                            updateDashboardJSON()
                                        }
                                    } else {
                                        print("üîç KuCoin: Could not parse price from data")
                                    }
                                }
                            }
                        } catch {
                            print("‚ùå Failed to parse KuCoin message: \(error)")
                        }
                    case .disconnected(let reason, let code):
                        Task { @MainActor in
                            kucoinIsConnected = false
                            print("‚ùå KuCoin disconnected: \(reason), code: \(code)")
                            logAlert(event: "‚ùå KuCoin disconnected: \(reason), code: \(code)")
                        }
                    case .error(let error):
                        print("‚ùå KuCoin WebSocket error: \(error?.localizedDescription ?? "Unknown")")
                        Task { @MainActor in
                            logAlert(event: "‚ùå KuCoin WebSocket error: \(error?.localizedDescription ?? "Unknown")")
                        }
                    default:
                        print("üîç KuCoin OTHER EVENT: \(event)")
                        break
                    }
                }
                
                print("üö® DEBUG: About to call socket.connect()")
                logAlert(event: "üö® DEBUG: About to call socket.connect()")
                
                socket.connect()
                
                print("üîÑ [WebSocket] KuCoin Spot WebSocket connection initiated with onEvent")
                logAlert(event: "üîÑ KuCoin Spot WebSocket connection initiated with onEvent")
            }
        }
    }
    static func fetchKuCoinWebSocketToken(completion: @escaping @Sendable (String?) -> Void) {
        guard let url = URL(string: "https://api.kucoin.com/api/v1/bullet-public") else {
            print("‚ùå [API] Invalid KuCoin token URL")
            completion(nil)
            return
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.timeoutInterval = TimeInterval(balanceFetchTimeout)
        
        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                print("‚ùå [API] Failed to get KuCoin WebSocket token: \(error.localizedDescription)")
                completion(nil)
                return
            }
            
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200,
                  let data = data,
                  let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let responseData = json["data"] as? [String: Any],
                  let token = responseData["token"] as? String else {
                print("‚ùå [API] Invalid KuCoin WebSocket token response")
                completion(nil)
                return
            }
            
            print("‚úÖ [API] Successfully obtained KuCoin WebSocket token")
            completion(token)
        }
        task.resume()
    }

    static func fetchKuCoinFuturesWebSocketToken(completion: @escaping @Sendable (String?) -> Void) {
        guard let url = URL(string: "https://api-futures.kucoin.com/api/v1/bullet-public") else {
            print("‚ùå [API] Invalid KuCoin Futures token URL")
            completion(nil)
            return
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.timeoutInterval = TimeInterval(balanceFetchTimeout)
        
        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                print("‚ùå [API] Failed to get KuCoin Futures WebSocket token: \(error.localizedDescription)")
                completion(nil)
                return
            }
            
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200,
                  let data = data,
                  let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let responseData = json["data"] as? [String: Any],
                  let token = responseData["token"] as? String else {
                print("‚ùå [API] Invalid KuCoin Futures WebSocket token response")
                completion(nil)
                return
            }
            
            print("‚úÖ [API] Successfully obtained KuCoin Futures WebSocket token")
            completion(token)
        }
        task.resume()
    }

    static func connectBybitSpotWebSocket() {
        print("üîÑ [WebSocket] Connecting to Bybit Spot WebSocket...")
        
        Task { @MainActor in
            logAlert(event: "üîÑ Connecting to Bybit Spot WebSocket...")
        }
        
        guard let url = URL(string: "wss://stream.bybit.com/v5/public/spot") else {
            print("‚ùå [WebSocket] Invalid Bybit Spot WebSocket URL")
            Task { @MainActor in
                logAlert(event: "‚ùå Invalid Bybit Spot WebSocket URL")
            }
            return
        }
        
        var request = URLRequest(url: url)
        request.timeoutInterval = TimeInterval(websocketTimeoutSeconds)
        
        let socket = WebSocket(request: request)
        bybitSpotSocket = socket
        
        // FIXED: Assign the delegate to handle incoming messages and resolve type mismatch
        bybitSpotDelegate = BybitSpotWebSocketDelegate()
        socket.delegate = bybitSpotDelegate
        
        socket.connect()
        
        print("üîÑ [WebSocket] Bybit Spot WebSocket connection initiated with delegate")
        Task { @MainActor in
            logAlert(event: "üîÑ Bybit Spot WebSocket connection initiated with delegate")
        }
    }
        
    static func connectKuCoinFuturesWebSocket() {
        print("üîÑ [WebSocket] Connecting to KuCoin Futures WebSocket...")
        
        Task { @MainActor in
            logAlert(event: "üîÑ Connecting to KuCoin Futures WebSocket...")
        }
        
        fetchKuCoinFuturesWebSocketToken { token in
            Task { @MainActor in
                guard let websocketToken = token else {
                    print("‚ùå [WebSocket] Failed to get KuCoin Futures WebSocket token")
                    logAlert(event: "‚ùå Failed to get KuCoin Futures WebSocket token")
                    return
                }
                
                kucoinFuturesToken = websocketToken
                
                guard let url = URL(string: "wss://ws-api-futures.kucoin.com/?token=\(websocketToken)") else {
                    print("‚ùå [WebSocket] Invalid KuCoin Futures WebSocket URL")
                    logAlert(event: "‚ùå Invalid KuCoin Futures WebSocket URL")
                    return
                }
                
                var request = URLRequest(url: url)
                request.timeoutInterval = TimeInterval(websocketTimeoutSeconds)
                
                let socket = WebSocket(request: request)
                kucoinFuturesSocket = socket
                
                // FIXED: Assign the delegate to handle incoming messages
                kucoinFuturesDelegate = KuCoinFuturesWebSocketDelegate()
                socket.delegate = kucoinFuturesDelegate
                
                socket.connect()
                
                print("üîÑ [WebSocket] KuCoin Futures WebSocket connection initiated with delegate")
                logAlert(event: "üîÑ KuCoin Futures WebSocket connection initiated with delegate")
            }
        }
    }

    static func connectBybitFuturesWebSocket() {
        print("üîÑ [WebSocket] Connecting to Bybit Futures WebSocket...")
        
        Task { @MainActor in
            logAlert(event: "üîÑ Connecting to Bybit Futures WebSocket...")
        }
        
        guard let url = URL(string: "wss://stream.bybit.com/v5/public/linear") else {
            print("‚ùå [WebSocket] Invalid Bybit Futures WebSocket URL")
            Task { @MainActor in
                logAlert(event: "‚ùå Invalid Bybit Futures WebSocket URL")
            }
            return
        }
        
        var request = URLRequest(url: url)
        request.timeoutInterval = TimeInterval(websocketTimeoutSeconds)
        
        let socket = WebSocket(request: request)
        bybitFuturesSocket = socket  // FIXED: Use bybitFuturesSocket here
        
        // FIXED: Assign the delegate to handle incoming messages
        bybitFuturesDelegate = BybitFuturesWebSocketDelegate()
        socket.delegate = bybitFuturesDelegate
        
        socket.connect()
        
        print("üîÑ [WebSocket] Bybit Futures WebSocket connection initiated with delegate")
        Task { @MainActor in
            logAlert(event: "üîÑ Bybit Futures WebSocket connection initiated with delegate")
        }
    }

    static func subscribeToAllPriceFeeds() {
        Task { @MainActor in
            let pairs = tradingPairs
            logAlert(event: "üîÑ Subscribing to price feeds for \(pairs.count) pairs: \(pairs.joined(separator: ", "))")
            
            // Subscribe to KuCoin Spot
            subscribeToKuCoinSpotPrices(pairs: pairs)
            
            // Subscribe to KuCoin Futures
            subscribeToKuCoinFuturesPrices(pairs: pairs)
            
            // Subscribe to Bybit Spot
            subscribeToBybitSpotPrices(pairs: pairs)
            
            // Subscribe to Bybit Futures
            subscribeToBybitFuturesPrices(pairs: pairs)
        }
    }

    
    
    
    
    
    static func subscribeToKuCoinSpotPrices(pairs: [String]) {
        Task { @MainActor in
            guard kucoinIsConnected, let socket = kucoinSocket else {
                print("‚ùå [WebSocket] KuCoin Spot not connected, cannot subscribe to prices")
                logAlert(event: "‚ùå KuCoin Spot not connected, cannot subscribe to prices")
                return
            }
            
            let symbols = pairs.map { $0.replacingOccurrences(of: "-", with: "") }
            let subscribeMessage: [String: Any] = [
                "id": Int.random(in: 1...999999),
                "type": "subscribe",
                "topic": "/market/ticker:\(symbols.joined(separator: ","))",
                "privateChannel": false,
                "response": true
            ]
            
            do {
                let jsonData = try JSONSerialization.data(withJSONObject: subscribeMessage, options: [])
                if let jsonString = String(data: jsonData, encoding: .utf8) {
                    socket.write(string: jsonString)
                    print("‚úÖ [WebSocket] Subscribed to KuCoin Spot prices for \(pairs.count) pairs")
                    logAlert(event: "‚úÖ Subscribed to KuCoin Spot prices for \(pairs.count) pairs")
                }
            } catch {
                print("‚ùå [WebSocket] Failed to subscribe to KuCoin Spot prices: \(error)")
                logAlert(event: "‚ùå Failed to subscribe to KuCoin Spot prices: \(error)")
            }
        }
    }

    static func subscribeToBybitSpotPrices(pairs: [String]) {
        Task { @MainActor in
            guard bybitIsConnected, let socket = bybitSpotSocket else {
                print("‚ùå [WebSocket] Bybit Spot not connected, cannot subscribe to prices")
                logAlert(event: "‚ùå Bybit Spot not connected, cannot subscribe to prices")
                return
            }
            
            let symbols = pairs.map { $0.replacingOccurrences(of: "-", with: "") }
            let topics = symbols.map { "tickers.\($0)" }
            
            let subscribeMessage: [String: Any] = [
                "op": "subscribe",
                "args": topics
            ]
            
            do {
                let jsonData = try JSONSerialization.data(withJSONObject: subscribeMessage, options: [])
                if let jsonString = String(data: jsonData, encoding: .utf8) {
                    socket.write(string: jsonString)
                    print("‚úÖ [WebSocket] Subscribed to Bybit Spot prices for \(pairs.count) pairs")
                    logAlert(event: "‚úÖ Subscribed to Bybit Spot prices for \(pairs.count) pairs")
                }
            } catch {
                print("‚ùå [WebSocket] Failed to subscribe to Bybit Spot prices: \(error)")
                logAlert(event: "‚ùå Failed to subscribe to Bybit Spot prices: \(error)")
            }
        }
    }

    static func initializeAllWebSocketConnections() {
        Task { @MainActor in
            logAlert(event: "üöÄ Initializing all WebSocket connections...")
            
            // Connect to all exchanges
            connectKuCoinSpotWebSocket()
            connectBybitSpotWebSocket()
            connectKuCoinFuturesWebSocket()
            connectBybitFuturesWebSocket()
            
            // Wait for connections to establish
            DispatchQueue.main.asyncAfter(deadline: .now() + 5.0) {
                subscribeToAllPriceFeeds()
                
                // Start periodic dashboard updates
                Timer.scheduledTimer(withTimeInterval: 5.0, repeats: true) { _ in
                    Task { @MainActor in
                        updateDashboardJSON()
                    }
                }
                
                Task { @MainActor in
                    logAlert(event: "‚úÖ All WebSocket connections and subscriptions initialized")
                }
            }
        }
    }
}
