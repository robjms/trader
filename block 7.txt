//-------------------------------------------------------------------------------------------------------------------Block 7 - WebSocket Connection Handling



extension ExchangeWebSocket {
    
        
        static func subscribeToKuCoinFuturesPrices(pairs: [String]) {
            guard kucoinFuturesIsConnected, let socket = kucoinFuturesSocket else {
                print("‚ùå [WebSocket] KuCoin Futures not connected, cannot subscribe to prices")
                Task { @MainActor in
                    logAlert(event: "‚ùå KuCoin Futures not connected, cannot subscribe to prices")
                }
                return
            }
            
            let symbols = pairs.compactMap { pair in
                return kucoinFuturesSymbols[pair]
            }
            
            let subscribeMessage: [String: Any] = [
                "id": Int.random(in: 1...999999),
                "type": "subscribe",
                "topic": "/contractMarket/ticker:\(symbols.joined(separator: ","))",
                "privateChannel": false,
                "response": true
            ]
            
            do {
                let jsonData = try JSONSerialization.data(withJSONObject: subscribeMessage, options: [])
                if let jsonString = String(data: jsonData, encoding: .utf8) {
                    socket.write(string: jsonString)
                    print("‚úÖ [WebSocket] Subscribed to KuCoin Futures prices for \(pairs.count) pairs")
                    Task { @MainActor in
                        logAlert(event: "‚úÖ Subscribed to KuCoin Futures prices for \(pairs.count) pairs")
                    }
                }
            } catch {
                print("‚ùå [WebSocket] Failed to subscribe to KuCoin Futures prices: \(error)")
                Task { @MainActor in
                    logAlert(event: "‚ùå Failed to subscribe to KuCoin Futures prices: \(error)")
                }
            }
        }
        
        static func subscribeToBybitFuturesPrices(pairs: [String]) {
            guard bybitIsConnected, let socket = bybitSocket else {
                print("‚ùå [WebSocket] Bybit Futures not connected, cannot subscribe to prices")
                Task { @MainActor in
                    logAlert(event: "‚ùå Bybit Futures not connected, cannot subscribe to prices")
                }
                return
            }
            
            let symbols = pairs.map { $0.replacingOccurrences(of: "-", with: "") }
            let topics = symbols.map { "tickers.\($0)" }
            
            let subscribeMessage: [String: Any] = [
                "op": "subscribe",
                "args": topics
            ]
            
            do {
                let jsonData = try JSONSerialization.data(withJSONObject: subscribeMessage, options: [])
                if let jsonString = String(data: jsonData, encoding: .utf8) {
                    socket.write(string: jsonString)
                    print("‚úÖ [WebSocket] Subscribed to Bybit Futures prices for \(pairs.count) pairs")
                    Task { @MainActor in
                        logAlert(event: "‚úÖ Subscribed to Bybit Futures prices for \(pairs.count) pairs")
                    }
                }
            } catch {
                print("‚ùå [WebSocket] Failed to subscribe to Bybit Futures prices: \(error)")
                Task { @MainActor in
                    logAlert(event: "‚ùå Failed to subscribe to Bybit Futures prices: \(error)")
                }
            }
        }
    // ADD THIS FUNCTION (around line 3100)
        static func updateDashboardJSON() {
            let timestamp = ISO8601DateFormatter().string(from: Date())
            
            // Build live prices array for all 22 pairs
            var livePricesArray: [[String: Any]] = []
            
            for pair in tradingPairs {
                let priceEntry: [String: Any] = [
                    "pair": pair,
                    "kucoinSpot": kucoinCurrentPrice[pair] ?? 0.0,
                    "kucoinFutures": kucoinCurrentFuturesPrice[pair] ?? 0.0,
                    "bybitSpot": bybitCurrentPrice[pair] ?? 0.0,
                    "bybitFutures": bybitCurrentFuturesPrice[pair] ?? 0.0
                ]
                livePricesArray.append(priceEntry)
            }
            
            // Build per-pair metrics
            var perPairMetricsArray: [[String: Any]] = []
            for pair in tradingPairs {
                let metrics = tradeMetrics[pair] ?? (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)
                let totalTrades = metrics.wins + metrics.losses
                let winRate = totalTrades > 0 ? Double(metrics.wins) / Double(totalTrades) * 100 : 0.0
                
                let pairMetric: [String: Any] = [
                    "pair": pair,
                    "trades": totalTrades,
                    "wins": metrics.wins,
                    "losses": metrics.losses,
                    "profit": metrics.totalProfit,
                    "fees": metrics.totalFees,
                    "winRate": winRate,
                    "sentiment": sentimentScores[pair] ?? 0.0
                ]
                perPairMetricsArray.append(pairMetric)
            }
            
            // Build complete dashboard data
            let dashboardData: [String: Any] = [
                "timestamp": timestamp,
                "kucoinBalance": kucoinBalance,
                "bybitBalance": bybitBalance,
                "totalTrades": tradeMetrics.values.reduce(0) { $0 + $1.wins + $1.losses },
                "totalProfit": tradeMetrics.values.reduce(0.0) { $0 + $1.totalProfit },
                "totalFees": tradeMetrics.values.reduce(0.0) { $0 + $1.totalFees },
                "livePrices": livePricesArray,
                "perPairMetrics": perPairMetricsArray
            ]
            
            // Write to dashboard.json
            do {
                let jsonData = try JSONSerialization.data(withJSONObject: dashboardData, options: .prettyPrinted)
                let dashboardURL = URL(fileURLWithPath: "dashboard.json")
                try jsonData.write(to: dashboardURL)
                
                print("‚úÖ [Dashboard] Updated dashboard.json with live data for \(tradingPairs.count) pairs")
            } catch {
                print("‚ùå [Dashboard] Failed to write dashboard.json: \(error)")
                logAlert(event: "‚ùå Failed to write dashboard.json: \(error)")
            }
        }
    
    
    // ENHANCED: KuCoin Spot WebSocket Connection with Authentication
    static func connectKuCoinSpotWebSocket() {
        print("üîÑ [WebSocket] Connecting to KuCoin Spot WebSocket...")
        
        Task { @MainActor in
            logAlert(event: "üîÑ Connecting to KuCoin Spot WebSocket...")
        }
        
        // First get connection token
        fetchKuCoinWebSocketToken { token in
            guard let websocketToken = token else {
                print("‚ùå [WebSocket] Failed to get KuCoin WebSocket token")
                Task { @MainActor in
                    logAlert(event: "‚ùå Failed to get KuCoin WebSocket token")
                }
                return
            }
            
            kucoinToken = websocketToken
            
            // Connect to WebSocket
            guard let url = URL(string: "wss://ws-api-spot.kucoin.com/?token=\(websocketToken)") else {
                print("‚ùå [WebSocket] Invalid KuCoin WebSocket URL")
                Task { @MainActor in
                    logAlert(event: "‚ùå Invalid KuCoin WebSocket URL")
                }
                return
            }
            
            var request = URLRequest(url: url)
            request.timeoutInterval = TimeInterval(websocketTimeoutSeconds)
            
            let socket = WebSocket(request: request)
            kucoinSocket = socket
            
            socket.delegate = KuCoinSpotWebSocketDelegate()
            socket.connect()
            
            print("üîÑ [WebSocket] KuCoin Spot WebSocket connection initiated")
            Task { @MainActor in
                logAlert(event: "üîÑ KuCoin Spot WebSocket connection initiated")
            }
        }
    }
    // ADD THESE TOKEN FUNCTIONS (around line 3200)
        
        static func fetchKuCoinWebSocketToken(completion: @escaping @Sendable (String?) -> Void) {
            guard let url = URL(string: "https://api.kucoin.com/api/v1/bullet-public") else {
                print("‚ùå [API] Invalid KuCoin token URL")
                completion(nil)
                return
            }
            
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.timeoutInterval = TimeInterval(balanceFetchTimeout)
            
            let task = URLSession.shared.dataTask(with: request) { data, response, error in
                if let error = error {
                    print("‚ùå [API] Failed to get KuCoin WebSocket token: \(error.localizedDescription)")
                    completion(nil)
                    return
                }
                
                guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200,
                      let data = data,
                      let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                      let responseData = json["data"] as? [String: Any],
                      let token = responseData["token"] as? String else {
                    print("‚ùå [API] Invalid KuCoin WebSocket token response")
                    completion(nil)
                    return
                }
                
                print("‚úÖ [API] Successfully obtained KuCoin WebSocket token")
                completion(token)
            }
            task.resume()
        }
        
        static func fetchKuCoinFuturesWebSocketToken(completion: @escaping @Sendable (String?) -> Void) {
            guard let url = URL(string: "https://api-futures.kucoin.com/api/v1/bullet-public") else {
                print("‚ùå [API] Invalid KuCoin Futures token URL")
                completion(nil)
                return
            }
            
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.timeoutInterval = TimeInterval(balanceFetchTimeout)
            
            let task = URLSession.shared.dataTask(with: request) { data, response, error in
                if let error = error {
                    print("‚ùå [API] Failed to get KuCoin Futures WebSocket token: \(error.localizedDescription)")
                    completion(nil)
                    return
                }
                
                guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200,
                      let data = data,
                      let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                      let responseData = json["data"] as? [String: Any],
                      let token = responseData["token"] as? String else {
                    print("‚ùå [API] Invalid KuCoin Futures WebSocket token response")
                    completion(nil)
                    return
                }
                
                print("‚úÖ [API] Successfully obtained KuCoin Futures WebSocket token")
                completion(token)
            }
            task.resume()
        }
    // ENHANCED: Bybit Spot WebSocket Connection
    static func connectBybitSpotWebSocket() {
        print("üîÑ [WebSocket] Connecting to Bybit Spot WebSocket...")
        
        Task { @MainActor in
            logAlert(event: "üîÑ Connecting to Bybit Spot WebSocket...")
        }
        
        guard let url = URL(string: "wss://stream.bybit.com/v5/public/spot") else {
            print("‚ùå [WebSocket] Invalid Bybit Spot WebSocket URL")
            Task { @MainActor in
                logAlert(event: "‚ùå Invalid Bybit Spot WebSocket URL")
            }
            return
        }
        
        var request = URLRequest(url: url)
        request.timeoutInterval = TimeInterval(websocketTimeoutSeconds)
        
        let socket = WebSocket(request: request)
        bybitSpotSocket = socket
        
        socket.delegate = BybitSpotWebSocketDelegate()
        socket.connect()
        
        print("üîÑ [WebSocket] Bybit Spot WebSocket connection initiated")
        Task { @MainActor in
            logAlert(event: "üîÑ Bybit Spot WebSocket connection initiated")
        }
    }
    
    // ENHANCED: KuCoin Futures WebSocket Connection
    static func connectKuCoinFuturesWebSocket() {
        print("üîÑ [WebSocket] Connecting to KuCoin Futures WebSocket...")
        
        Task { @MainActor in
            logAlert(event: "üîÑ Connecting to KuCoin Futures WebSocket...")
        }
        
        fetchKuCoinFuturesWebSocketToken { token in
            guard let websocketToken = token else {
                print("‚ùå [WebSocket] Failed to get KuCoin Futures WebSocket token")
                Task { @MainActor in
                    logAlert(event: "‚ùå Failed to get KuCoin Futures WebSocket token")
                }
                return
            }
            
            kucoinFuturesToken = websocketToken
            
            guard let url = URL(string: "wss://ws-api-futures.kucoin.com/?token=\(websocketToken)") else {
                print("‚ùå [WebSocket] Invalid KuCoin Futures WebSocket URL")
                Task { @MainActor in
                    logAlert(event: "‚ùå Invalid KuCoin Futures WebSocket URL")
                }
                return
            }
            
            var request = URLRequest(url: url)
            request.timeoutInterval = TimeInterval(websocketTimeoutSeconds)
            
            let socket = WebSocket(request: request)
            kucoinFuturesSocket = socket
            
            socket.delegate = KuCoinFuturesWebSocketDelegate()
            socket.connect()
            
            print("üîÑ [WebSocket] KuCoin Futures WebSocket connection initiated")
            Task { @MainActor in
                logAlert(event: "üîÑ KuCoin Futures WebSocket connection initiated")
            }
        }
    }
    
    // ENHANCED: Bybit Linear WebSocket Connection
    static func connectBybitFuturesWebSocket() {
        print("üîÑ [WebSocket] Connecting to Bybit Futures WebSocket...")
        
        Task { @MainActor in
            logAlert(event: "üîÑ Connecting to Bybit Futures WebSocket...")
        }
        
        guard let url = URL(string: "wss://stream.bybit.com/v5/public/linear") else {
            print("‚ùå [WebSocket] Invalid Bybit Futures WebSocket URL")
            Task { @MainActor in
                logAlert(event: "‚ùå Invalid Bybit Futures WebSocket URL")
            }
            return
        }
        
        var request = URLRequest(url: url)
        request.timeoutInterval = TimeInterval(websocketTimeoutSeconds)
        
        let socket = WebSocket(request: request)
        bybitSocket = socket
        
        socket.delegate = BybitFuturesWebSocketDelegate()
        socket.connect()
        
        print("üîÑ [WebSocket] Bybit Futures WebSocket connection initiated")
        Task { @MainActor in
            logAlert(event: "üîÑ Bybit Futures WebSocket connection initiated")
        }
    }
    
    // ENHANCED: Get KuCoin WebSocket Token with Retry Logic
    static func fetchKuCoinWebSocketToken(completion: @escaping @Sendable (String?) -> Void) {
        guard let url = URL(string: "https://api.kucoin.com/api/v1/bullet-public") else {
            print("‚ùå [API] Invalid KuCoin token URL")
            completion(nil)
            return
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.timeoutInterval = TimeInterval(balanceFetchTimeout)
        
        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                print("‚ùå [API] Failed to get KuCoin WebSocket token: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "‚ùå Failed to get KuCoin WebSocket token: \(error.localizedDescription)")
                }
                completion(nil)
                return
            }
            
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200,
                  let data = data,
                  let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let responseData = json["data"] as? [String: Any],
                  let token = responseData["token"] as? String else {
                print("‚ùå [API] Invalid KuCoin WebSocket token response")
                Task { @MainActor in
                    logAlert(event: "‚ùå Invalid KuCoin WebSocket token response")
                }
                completion(nil)
                return
            }
            
            print("‚úÖ [API] Successfully obtained KuCoin WebSocket token")
            Task { @MainActor in
                logAlert(event: "‚úÖ Successfully obtained KuCoin WebSocket token")
            }
            completion(token)
        }
        
        task.resume()
    }
    
    // ENHANCED: Get KuCoin Futures WebSocket Token
    static func fetchKuCoinFuturesWebSocketToken(completion: @escaping @Sendable (String?) -> Void) {
        guard let url = URL(string: "https://api-futures.kucoin.com/api/v1/bullet-public") else {
            print("‚ùå [API] Invalid KuCoin Futures token URL")
            completion(nil)
            return
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.timeoutInterval = TimeInterval(balanceFetchTimeout)
        
        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                print("‚ùå [API] Failed to get KuCoin Futures WebSocket token: \(error.localizedDescription)")
                Task { @MainActor in
                    logAlert(event: "‚ùå Failed to get KuCoin Futures WebSocket token: \(error.localizedDescription)")
                }
                completion(nil)
                return
            }
            
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200,
                  let data = data,
                  let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let responseData = json["data"] as? [String: Any],
                  let token = responseData["token"] as? String else {
                print("‚ùå [API] Invalid KuCoin Futures WebSocket token response")
                Task { @MainActor in
                    logAlert(event: "‚ùå Invalid KuCoin Futures WebSocket token response")
                }
                completion(nil)
                return
            }
            
            print("‚úÖ [API] Successfully obtained KuCoin Futures WebSocket token")
            Task { @MainActor in
                logAlert(event: "‚úÖ Successfully obtained KuCoin Futures WebSocket token")
            }
            completion(token)
        }
        
        task.resume()
    }
    
    // ENHANCED: Subscribe to Price Feeds for All 22 Pairs
    static func subscribeToAllPriceFeeds() {
        Task { @MainActor in
            let pairs = tradingPairs
            logAlert(event: "üîÑ Subscribing to price feeds for \(pairs.count) pairs: \(pairs.joined(separator: ", "))")
            
            // Subscribe to KuCoin Spot
            subscribeToKuCoinSpotPrices(pairs: pairs)
            
            // Subscribe to KuCoin Futures
            subscribeToKuCoinFuturesPrices(pairs: pairs)
            
            // Subscribe to Bybit Spot
            subscribeToBybitSpotPrices(pairs: pairs)
            
            // Subscribe to Bybit Futures
            subscribeToBybitFuturesPrices(pairs: pairs)
        }
    }
    
    // ENHANCED: KuCoin Spot Price Subscription
    static func subscribeToKuCoinSpotPrices(pairs: [String]) {
        guard kucoinIsConnected, let socket = kucoinSocket else {
            print("‚ùå [WebSocket] KuCoin Spot not connected, cannot subscribe to prices")
            Task { @MainActor in
                logAlert(event: "‚ùå KuCoin Spot not connected, cannot subscribe to prices")
            }
            return
        }
        
        let symbols = pairs.map { $0.replacingOccurrences(of: "-", with: "") }
        let subscribeMessage: [String: Any] = [
            "id": Int.random(in: 1...999999),
            "type": "subscribe",
            "topic": "/market/ticker:\(symbols.joined(separator: ","))",
            "privateChannel": false,
            "response": true
        ]
        
        do {
            let jsonData = try JSONSerialization.data(withJSONObject: subscribeMessage, options: [])
            if let jsonString = String(data: jsonData, encoding: .utf8) {
                socket.write(string: jsonString)
                print("‚úÖ [WebSocket] Subscribed to KuCoin Spot prices for \(pairs.count) pairs")
                Task { @MainActor in
                    logAlert(event: "‚úÖ Subscribed to KuCoin Spot prices for \(pairs.count) pairs")
                }
            }
        } catch {
            print("‚ùå [WebSocket] Failed to subscribe to KuCoin Spot prices: \(error)")
            Task { @MainActor in
                logAlert(event: "‚ùå Failed to subscribe to KuCoin Spot prices: \(error)")
            }
        }
    }
    
    // ENHANCED: Bybit Spot Price Subscription
    static func subscribeToBybitSpotPrices(pairs: [String]) {
        guard bybitFuturesIsConnected, let socket = bybitSpotSocket else {
            print("‚ùå [WebSocket] Bybit Spot not connected, cannot subscribe to prices")
            Task { @MainActor in
                logAlert(event: "‚ùå Bybit Spot not connected, cannot subscribe to prices")
            }
            return
        }
        
        let symbols = pairs.map { $0.replacingOccurrences(of: "-", with: "") }
        let topics = symbols.map { "tickers.\($0)" }
        
        let subscribeMessage: [String: Any] = [
            "op": "subscribe",
            "args": topics
        ]
        
        do {
            let jsonData = try JSONSerialization.data(withJSONObject: subscribeMessage, options: [])
            if let jsonString = String(data: jsonData, encoding: .utf8) {
                socket.write(string: jsonString)
                print("‚úÖ [WebSocket] Subscribed to Bybit Spot prices for \(pairs.count) pairs")
                Task { @MainActor in
                    logAlert(event: "‚úÖ Subscribed to Bybit Spot prices for \(pairs.count) pairs")
                }
            }
        } catch {
            print("‚ùå [WebSocket] Failed to subscribe to Bybit Spot prices: \(error)")
            Task { @MainActor in
                logAlert(event: "‚ùå Failed to subscribe to Bybit Spot prices: \(error)")
            }
        }
    }
    
    // ENHANCED: Dashboard Update Function
    static func updateDashboardJSON() {
        Task { @MainActor in
            let timestamp = ISO8601DateFormatter().string(from: Date())
            
            // Build live prices array for all 22 pairs
            var livePricesArray: [[String: Any]] = []
            
            for pair in tradingPairs {
                let priceEntry: [String: Any] = [
                    "pair": pair,
                    "kucoinSpot": kucoinCurrentPrice[pair] ?? 0.0,
                    "kucoinFutures": kucoinCurrentFuturesPrice[pair] ?? 0.0,
                    "bybitSpot": bybitCurrentPrice[pair] ?? 0.0,
                    "bybitFutures": bybitCurrentFuturesPrice[pair] ?? 0.0
                ]
                livePricesArray.append(priceEntry)
            }
            
            // Build per-pair metrics
            var perPairMetricsArray: [[String: Any]] = []
            
            for pair in tradingPairs {
                let metrics = tradeMetrics[pair] ?? (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)
                let totalTrades = metrics.wins + metrics.losses
                let winRate = totalTrades > 0 ? Double(metrics.wins) / Double(totalTrades) * 100 : 0.0
                
                let pairMetric: [String: Any] = [
                    "pair": pair,
                    "trades": totalTrades,
                    "wins": metrics.wins,
                    "losses": metrics.losses,
                    "profit": metrics.totalProfit,
                    "fees": metrics.totalFees,
                    "winRate": winRate,
                    "sentiment": sentimentScores[pair] ?? 0.0
                ]
                perPairMetricsArray.append(pairMetric)
            }
            
            // Build complete dashboard data
            let dashboardData: [String: Any] = [
                "timestamp": timestamp,
                "kucoinBalance": kucoinBalance,
                "bybitBalance": bybitBalance,
                "totalTrades": tradeMetrics.values.reduce(0) { $0 + $1.wins + $1.losses },
                "totalProfit": tradeMetrics.values.reduce(0.0) { $0 + $1.totalProfit },
                "totalFees": tradeMetrics.values.reduce(0.0) { $0 + $1.totalFees },
                "livePrices": livePricesArray,
                "perPairMetrics": perPairMetricsArray
            ]
            
            // Write to dashboard.json
            do {
                let jsonData = try JSONSerialization.data(withJSONObject: dashboardData, options: .prettyPrinted)
                let dashboardURL = URL(fileURLWithPath: "dashboard.json")
                try jsonData.write(to: dashboardURL)
                
                print("‚úÖ [Dashboard] Updated dashboard.json with live data for \(tradingPairs.count) pairs")
                logAlert(event: "‚úÖ Updated dashboard.json with live data for \(tradingPairs.count) pairs")
            } catch {
                print("‚ùå [Dashboard] Failed to write dashboard.json: \(error)")
                logAlert(event: "‚ùå Failed to write dashboard.json: \(error)")
            }
        }
    }
    
    // ENHANCED: Initialize All Connections
    static func initializeAllWebSocketConnections() {
        Task { @MainActor in
            logAlert(event: "üöÄ Initializing all WebSocket connections...")
            
            // Connect to all exchanges
            connectKuCoinSpotWebSocket()
            connectBybitSpotWebSocket()
            connectKuCoinFuturesWebSocket()
            connectBybitFuturesWebSocket()
            
            // Wait for connections to establish
            DispatchQueue.main.asyncAfter(deadline: .now() + 5.0) {
                subscribeToAllPriceFeeds()
                
                // Start periodic dashboard updates
                Timer.scheduledTimer(withTimeInterval: 5.0, repeats: true) { _ in
                    Task { @MainActor in
                                      updateDashboardJSON()
                                  }
                }
                
                logAlert(event: "‚úÖ All WebSocket connections and subscriptions initialized")
            }
        }
    }
}
