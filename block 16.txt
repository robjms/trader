//--------------------------------------------------------------------------------------------------------------Block 16 - Spot-Futures Arbitrage Execution

//--------------- Block 16 - Spot-Futures Arbitrage Execution
// VARIABLES TO ADD: None required - uses existing ExchangeWebSocket variables

extension ExchangeWebSocket {
    
    static func fetchBybitFuturesPrice(pair: String, completion: @escaping @Sendable (Double?) -> Void) {
           let symbol = pair.replacingOccurrences(of: "-USDT", with: "USDT")
           let url = URL(string: "https://api.bybit.com/v5/market/tickers?category=linear&symbol=\(symbol)")!
           var request = URLRequest(url: url)
           request.httpMethod = "GET"
           request.timeoutInterval = Double(getInt("BALANCE_FETCH_TIMEOUT", defaultValue: 20))

           let startTime = Date()
           let task = URLSession.shared.dataTask(with: request) { data, response, error in
               let latency = Date().timeIntervalSince(startTime) * 1000
               Task { @MainActor in
                   lastLatency["bybit-futures-\(pair)"] = latency
                   if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 300.0) {
                       logAlert(event: "High latency detected for Bybit futures price fetch for \(pair): \(latency)ms")
                   }
               }

               if let error = error {
                   print("DEBUG: Failed to fetch Bybit futures price for \(pair): \(error.localizedDescription)")
                   Task { @MainActor in
                       logAlert(event: "Failed to fetch Bybit futures price for \(pair): \(error.localizedDescription)")
                   }
                   completion(nil)
                   return
               }

               guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200,
                     let data = data else {
                   print("DEBUG: Invalid Bybit futures price response for \(pair)")
                   Task { @MainActor in
                       logAlert(event: "Invalid Bybit futures price response for \(pair)")
                   }
                   completion(nil)
                   return
               }

               do {
                   if let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                      let result = json["result"] as? [String: Any],
                      let list = result["list"] as? [[String: Any]],
                      let ticker = list.first,
                      let priceString = ticker["lastPrice"] as? String,
                      let price = Double(priceString), price > 0 {
                       
                       Task { @MainActor in
                           bybitCurrentFuturesPrice[pair] = price
                           bybitFuturesPrices[pair, default: []].append(price)
                           if bybitFuturesPrices[pair]!.count > getInt("PRICE_HISTORY_RETENTION", defaultValue: 1440) {
                               bybitFuturesPrices[pair]?.removeFirst()
                           }
                           print("DEBUG: Fetched Bybit futures price for \(pair): \(price)")
                       }
                       completion(price)
                   } else {
                       print("DEBUG: Failed to parse Bybit futures price for \(pair)")
                       Task { @MainActor in
                           logAlert(event: "Failed to parse Bybit futures price for \(pair)")
                       }
                       completion(nil)
                   }
               } catch {
                   print("DEBUG: Error parsing Bybit futures price JSON: \(error.localizedDescription)")
                   Task { @MainActor in
                       logAlert(event: "Error parsing Bybit futures price JSON: \(error.localizedDescription)")
                   }
                   completion(nil)
               }
           }
           task.resume()
       }
   
    
    
    
    
    
    
    
    
    
    static func fetchBybitSpotPrice(pair: String, completion: @escaping @Sendable (Double?) -> Void) {
            let symbol = pair.replacingOccurrences(of: "-USDT", with: "USDT")
            let url = URL(string: "https://api.bybit.com/v5/market/tickers?category=spot&symbol=\(symbol)")!
            var request = URLRequest(url: url)
            request.httpMethod = "GET"
            request.timeoutInterval = Double(getInt("BALANCE_FETCH_TIMEOUT", defaultValue: 20))

            let startTime = Date()
            let task = URLSession.shared.dataTask(with: request) { data, response, error in
                let latency = Date().timeIntervalSince(startTime) * 1000
                Task { @MainActor in
                    lastLatency["bybit-spot-\(pair)"] = latency
                    if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 300.0) {
                        logAlert(event: "High latency detected for Bybit spot price fetch for \(pair): \(latency)ms")
                    }
                }

                if let error = error {
                    print("DEBUG: Failed to fetch Bybit spot price for \(pair): \(error.localizedDescription)")
                    Task { @MainActor in
                        logAlert(event: "Failed to fetch Bybit spot price for \(pair): \(error.localizedDescription)")
                    }
                    completion(nil)
                    return
                }

                guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200,
                      let data = data else {
                    print("DEBUG: Invalid Bybit spot price response for \(pair)")
                    Task { @MainActor in
                        logAlert(event: "Invalid Bybit spot price response for \(pair)")
                    }
                    completion(nil)
                    return
                }

                do {
                    if let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                       let result = json["result"] as? [String: Any],
                       let list = result["list"] as? [[String: Any]],
                       let ticker = list.first,
                       let priceString = ticker["lastPrice"] as? String,
                       let price = Double(priceString), price > 0 {
                        
                        Task { @MainActor in
                            bybitCurrentPrice[pair] = price
                            bybitPrices[pair, default: []].append(price)
                            if bybitPrices[pair]!.count > getInt("PRICE_HISTORY_RETENTION", defaultValue: 1440) {
                                bybitPrices[pair]?.removeFirst()
                            }
                            print("DEBUG: Fetched Bybit spot price for \(pair): \(price)")
                        }
                        completion(price)
                    } else {
                        print("DEBUG: Failed to parse Bybit spot price for \(pair)")
                        Task { @MainActor in
                            logAlert(event: "Failed to parse Bybit spot price for \(pair)")
                        }
                        completion(nil)
                    }
                } catch {
                    print("DEBUG: Error parsing Bybit spot price JSON: \(error.localizedDescription)")
                    Task { @MainActor in
                        logAlert(event: "Error parsing Bybit spot price JSON: \(error.localizedDescription)")
                    }
                    completion(nil)
                }
            }
            task.resume()
        }
    static func fetchKuCoinFuturesPrice(pair: String, completion: @escaping @Sendable (Double?) -> Void) {
           guard hasValidKuCoinCredentials else {
               print("DEBUG: Skipping KuCoin futures price fetch - invalid credentials")
               completion(nil)
               return
           }
           
           let futuresSymbol = kucoinFuturesSymbols[pair] ?? {
               let components = pair.components(separatedBy: "-")
               if components.count == 2 {
                   let base = components[0] == "BTC" ? "XBT" : components[0]
                   return "\(base)\(components[1])M"
               }
               return "\(pair.replacingOccurrences(of: "-", with: ""))M"
           }()
           
           let url = URL(string: "https://api-futures.kucoin.com/api/v1/ticker?symbol=\(futuresSymbol)")!
           var request = URLRequest(url: url)
           request.httpMethod = "GET"
           request.timeoutInterval = Double(getInt("BALANCE_FETCH_TIMEOUT", defaultValue: 20))

           let startTime = Date()
           let task = URLSession.shared.dataTask(with: request) { data, response, error in
               let latency = Date().timeIntervalSince(startTime) * 1000
               Task { @MainActor in
                   lastLatency["kucoin-futures-\(pair)"] = latency
                   if latency > getDouble("LATENCY_SPIKE_THRESHOLD", defaultValue: 300.0) {
                       logAlert(event: "High latency detected for KuCoin futures price fetch for \(pair): \(latency)ms")
                   }
               }

               if let error = error {
                   print("DEBUG: Failed to fetch KuCoin futures price for \(pair): \(error.localizedDescription)")
                   Task { @MainActor in
                       logAlert(event: "Failed to fetch KuCoin futures price for \(pair): \(error.localizedDescription)")
                   }
                   completion(nil)
                   return
               }

               guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200,
                     let data = data else {
                   print("DEBUG: Invalid KuCoin futures price response for \(pair)")
                   Task { @MainActor in
                       logAlert(event: "Invalid KuCoin futures price response for \(pair)")
                   }
                   completion(nil)
                   return
               }

               do {
                   if let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                      let dataDict = json["data"] as? [String: Any],
                      let priceString = dataDict["price"] as? String,
                      let price = Double(priceString), price > 0 {
                       
                       Task { @MainActor in
                           kucoinCurrentFuturesPrice[pair] = price
                           kucoinFuturesPrices[pair, default: []].append(price)
                           if kucoinFuturesPrices[pair]!.count > getInt("PRICE_HISTORY_RETENTION", defaultValue: 1440) {
                               kucoinFuturesPrices[pair]?.removeFirst()
                           }
                           print("DEBUG: Fetched KuCoin futures price for \(pair): \(price)")
                       }
                       completion(price)
                   } else {
                       print("DEBUG: Failed to parse KuCoin futures price for \(pair)")
                       Task { @MainActor in
                           logAlert(event: "Failed to parse KuCoin futures price for \(pair)")
                       }
                       completion(nil)
                   }
               } catch {
                   print("DEBUG: Error parsing KuCoin futures price JSON: \(error.localizedDescription)")
                   Task { @MainActor in
                       logAlert(event: "Error parsing KuCoin futures price JSON: \(error.localizedDescription)")
                   }
                   completion(nil)
               }
           }
           task.resume()
       }
    
    
    
    static func executeSpotFuturesArbitrage(pair: String, kucoinSpotPrice: Double, kucoinFuturesPrice: Double, bybitSpotPrice: Double, bybitFuturesPrice: Double, amount: Double, completion: @escaping (Bool) -> Void) {
        Task {
            let minSpreadThreshold = getDouble("ARBITRAGE_MIN_SPREAD_THRESHOLD", defaultValue: 0.002)
            let kucoinSpread = abs(kucoinSpotPrice - kucoinFuturesPrice) / min(kucoinSpotPrice, kucoinFuturesPrice)
            let bybitSpread = abs(bybitSpotPrice - bybitFuturesPrice) / min(bybitSpotPrice, bybitFuturesPrice)
            
            guard kucoinSpread >= minSpreadThreshold || bybitSpread >= minSpreadThreshold else {
                print("DEBUG: Spread too low for spot-futures arbitrage: KuCoin=\(kucoinSpread), Bybit=\(bybitSpread)")
                await MainActor.run {
                    logAlert(event: "Spread too low for spot-futures arbitrage: KuCoin=\(kucoinSpread), Bybit=\(bybitSpread)")
                }
                completion(false)
                return
            }
            
            let kucoinLiquidity = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "spot", tradeAmount: amount, price: kucoinSpotPrice)
            let kucoinFuturesLiquidity = await checkLiquidityAsync(exchange: "kucoin", pair: pair, marketType: "futures", tradeAmount: amount, price: kucoinFuturesPrice)
            let bybitLiquidity = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "spot", tradeAmount: amount, price: bybitSpotPrice)
            let bybitFuturesLiquidity = await checkLiquidityAsync(exchange: "bybit", pair: pair, marketType: "futures", tradeAmount: amount, price: bybitFuturesPrice)
            
            guard let kucoinLiquidity = kucoinLiquidity, let kucoinFuturesLiquidity = kucoinFuturesLiquidity,
                  let bybitLiquidity = bybitLiquidity, let bybitFuturesLiquidity = bybitFuturesLiquidity else {
                print("DEBUG: Insufficient liquidity for spot-futures arbitrage: \(pair)")
                await MainActor.run {
                    logAlert(event: "Insufficient liquidity for spot-futures arbitrage: \(pair)")
                }
                completion(false)
                return
            }
            
            // Integrate liquidity into weighted trade amount calculation
            let kucoinLiquidityFactor = min(kucoinLiquidity, kucoinFuturesLiquidity) / (kucoinLiquidity + kucoinFuturesLiquidity)
            let bybitLiquidityFactor = min(bybitLiquidity, bybitFuturesLiquidity) / (bybitLiquidity + bybitFuturesLiquidity)
            
            let kucoinFundingRate = await MainActor.run { kucoinFundingRates[pair] ?? 0.0 }
            let bybitFundingRate = await MainActor.run { bybitFundingRates[pair] ?? 0.0 }
            let maxFundingRateValue = await MainActor.run { maxFundingRate }
            
            guard abs(kucoinFundingRate) < maxFundingRateValue && abs(bybitFundingRate) < maxFundingRateValue else {
                print("DEBUG: Funding rate too high for \(pair): KuCoin=\(kucoinFundingRate), Bybit=\(bybitFundingRate)")
                await MainActor.run {
                    logAlert(event: "Funding rate too high for \(pair): KuCoin=\(kucoinFundingRate), Bybit=\(bybitFundingRate)")
                }
                completion(false)
                return
            }
            
            let kucoinTakerFeeValue = await MainActor.run { kucoinTakerFee }
            let kucoinMakerFeeValue = await MainActor.run { kucoinMakerFee }
            let bybitTakerFeeValue = await MainActor.run { bybitTakerFee }
            let bybitMakerFeeValue = await MainActor.run { bybitMakerFee }
            
            let kucoinProfit = kucoinSpread * amount - amount * (kucoinTakerFeeValue + kucoinMakerFeeValue) * 2
            let bybitProfit = bybitSpread * amount - amount * (bybitTakerFeeValue + bybitMakerFeeValue) * 2
            let minProfitThreshold = await MainActor.run { spotMinProfitPercentage }
            
            guard kucoinProfit > minProfitThreshold * amount * min(kucoinSpotPrice, kucoinFuturesPrice) ||
                  bybitProfit > minProfitThreshold * amount * min(bybitSpotPrice, bybitFuturesPrice) else {
                print("DEBUG: Expected profit too low for spot-futures arbitrage: KuCoin=\(kucoinProfit), Bybit=\(bybitProfit)")
                await MainActor.run {
                    logAlert(event: "Expected profit too low for spot-futures arbitrage: KuCoin=\(kucoinProfit), Bybit=\(bybitProfit)")
                }
                completion(false)
                return
            }
            
            let kucoinBalanceValue = await MainActor.run { kucoinBalance }
            let bybitBalanceValue = await MainActor.run { bybitBalance }
            let kucoinTradeAmount = await dynamicTradeAmount(balance: kucoinBalanceValue, riskPercent: 0.3, volatility: 0.5) * kucoinLiquidityFactor
            let bybitTradeAmount = await dynamicTradeAmount(balance: bybitBalanceValue, riskPercent: 0.3, volatility: 0.5) * bybitLiquidityFactor
            let stopLossPercentageValue = await MainActor.run { stopLossPercentage }
            
            if kucoinSpread > bybitSpread && kucoinProfit > bybitProfit {
                let potentialLoss = kucoinTradeAmount * kucoinSpotPrice * stopLossPercentageValue
                if await checkDailyLossLimit(exchange: "kucoin", pair: pair, potentialLoss: potentialLoss) {
                    print("DEBUG: Daily loss limit exceeded for KuCoin-\(pair)")
                    completion(false)
                    return
                }
                
                let kucoinPricesValue = await MainActor.run { kucoinPrices[pair] ?? [] }
                await MainActor.run {
                    executeSingleExchangeArbitrage(
                        exchange: "kucoin",
                        pair: pair,
                        spotPrice: kucoinSpotPrice,
                        futuresPrice: kucoinFuturesPrice,
                        strategy: "Spot-to-Futures",
                        kucoinSpotPrices: kucoinPricesValue,
                        bybitSpotPrices: [],
                        tradeAmount: kucoinTradeAmount
                    )
                    
                    tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].totalProfit += kucoinProfit
                    tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].totalFees += amount * (kucoinTakerFeeValue + kucoinMakerFeeValue) * 2
                    tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].wins += kucoinProfit > 0 ? 1 : 0
                    performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].profit += kucoinProfit
                    performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].fees += amount * (kucoinTakerFeeValue + kucoinMakerFeeValue) * 2
                    performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].trades += 1
                    performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].wins += kucoinProfit > 0 ? 1 : 0
                    kucoinBalance += kucoinProfit - amount * (kucoinTakerFeeValue + kucoinMakerFeeValue) * 2
                    logTradeToCSV(pair: pair, strategy: "Spot-to-Futures", profit: kucoinProfit, fees: amount * (kucoinTakerFeeValue + kucoinMakerFeeValue) * 2, tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/trades.csv"))
                    print("DEBUG: Executed spot-futures arbitrage on KuCoin for \(pair): Profit=\(kucoinProfit)")
                    logAlert(event: "Executed spot-futures arbitrage on KuCoin for \(pair): Profit=\(kucoinProfit)")
                }
                completion(true)
            } else {
                let potentialLoss = bybitTradeAmount * bybitSpotPrice * stopLossPercentageValue
                if await checkDailyLossLimit(exchange: "bybit", pair: pair, potentialLoss: potentialLoss) {
                    print("DEBUG: Daily loss limit exceeded for Bybit-\(pair)")
                    completion(false)
                    return
                }
                
                let bybitPricesValue = await MainActor.run { bybitPrices[pair] ?? [] }
                await MainActor.run {
                    executeSingleExchangeArbitrage(
                        exchange: "bybit",
                        pair: pair,
                        spotPrice: bybitSpotPrice,
                        futuresPrice: bybitFuturesPrice,
                        strategy: "Spot-to-Futures",
                        kucoinSpotPrices: [],
                        bybitSpotPrices: bybitPricesValue,
                        tradeAmount: bybitTradeAmount
                    )
                    
                    tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].totalProfit += bybitProfit
                    tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].totalFees += amount * (bybitTakerFeeValue + bybitMakerFeeValue) * 2
                    tradeMetrics[pair, default: (wins: 0, losses: 0, totalProfit: 0.0, totalFees: 0.0)].wins += bybitProfit > 0 ? 1 : 0
                    performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].profit += bybitProfit
                    performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].fees += amount * (bybitTakerFeeValue + bybitMakerFeeValue) * 2
                    performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].trades += 1
                    performanceMetrics[pair, default: (profit: 0.0, fees: 0.0, trades: 0, wins: 0)].wins += bybitProfit > 0 ? 1 : 0
                    bybitBalance += bybitProfit - amount * (bybitTakerFeeValue + bybitMakerFeeValue) * 2
                    logTradeToCSV(pair: pair, strategy: "Spot-to-Futures", profit: bybitProfit, fees: amount * (bybitTakerFeeValue + bybitMakerFeeValue) * 2, tradesCSVURL: URL(fileURLWithPath: "/Users/robertsteinegger/Desktop/BevaixBot/Output/trades.csv"))
                    print("DEBUG: Executed spot-futures arbitrage on Bybit for \(pair): Profit=\(bybitProfit)")
                    logAlert(event: "Executed spot-futures arbitrage on Bybit for \(pair): Profit=\(bybitProfit)")
                }
                completion(true)
            }
        }
    }
}

